<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/jadepeng/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/jadepeng/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/jadepeng/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/jadepeng/images/logo.svg" color="#222">

<link rel="stylesheet" href="/jadepeng/css/main.css">


<link rel="stylesheet" href="/jadepeng/lib/font-awesome/css/all.min.css">
<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.iflyresearch.com","root":"/jadepeng/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JadePeng的技术笔记本">
<meta property="og:type" content="website">
<meta property="og:title" content="JadePeng的技术笔记本">
<meta property="og:url" content="http://blog.iflyresearch.com/index.html">
<meta property="og:site_name" content="JadePeng的技术笔记本">
<meta property="og:description" content="JadePeng的技术笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="JadePeng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.iflyresearch.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JadePeng的技术笔记本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/jadepeng/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JadePeng的技术笔记本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">爱学习爱分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/jadepeng/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-博客">

    <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" rel="section"><i class="fa fa-th fa-fw"></i>博客</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/jadepeng/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/jadepeng/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/jadepeng/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/07/12/hugegraph-index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/07/12/hugegraph-index/" class="post-title-link" itemprop="url">hugegraph 索引与查询优化分析</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-12 21:00:00 / 修改时间：21:28:27" itemprop="dateCreated datePublished" datetime="2021-07-12T21:00:00+08:00">2021-07-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么要有索引"><a href="#为什么要有索引" class="headerlink" title="为什么要有索引"></a>为什么要有索引</h2><p><code>gremlin</code> 其实是一个逐级过滤的运行机制，比如下面的一个简单的gremlin查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.V().hasLabel(&quot;label&quot;).has(&quot;prop&quot;,&quot;value&quot;)</span><br></pre></td></tr></table></figure>

<p>运行原理就是：</p>
<ul>
<li>找出所有的顶点V</li>
<li>然后过滤出label为label的数据</li>
<li>然后过滤出prop=value的数据</li>
</ul>
<p>当数据量很大时，这个代价非常大，因此需要做查询优化。</p>
<p><code>hugegraph</code> 的优化方案是，<code>HugeGraphStepStrategy</code> 中将has条件提取出来，然后走索引优化，减少读取的数据量。</p>
<p><code>TraversalUtil.extractHasContainer</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extractHasContainer</span><span class="params">(HugeGraphStep&lt;?, ?&gt; newStep,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Traversal.Admin&lt;?, ?&gt; traversal)</span> </span>&#123;</span><br><span class="line">       Step&lt;?, ?&gt; step = newStep;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           step = step.getNextStep();</span><br><span class="line">           <span class="keyword">if</span> (step <span class="keyword">instanceof</span> HasStep) &#123;</span><br><span class="line">               HasContainerHolder holder = (HasContainerHolder) step;</span><br><span class="line">               <span class="keyword">for</span> (HasContainer has : holder.getHasContainers()) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!GraphStep.processHasContainerIds(newStep, has)) &#123;</span><br><span class="line">                       newStep.addHasContainer(has);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               TraversalHelper.copyLabels(step, step.getPreviousStep(), <span class="keyword">false</span>);</span><br><span class="line">               traversal.removeStep(step);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (step <span class="keyword">instanceof</span> HasStep || step <span class="keyword">instanceof</span> NoOpBarrierStep);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h2 id="hugegraph索引介绍"><a href="#hugegraph索引介绍" class="headerlink" title="hugegraph索引介绍"></a>hugegraph索引介绍</h2><p><code>hugegraph</code> 通过<code>IndexLabel</code> 来定义索引类型，描述索引的约束信息。</p>
<ul>
<li><p>indexType: 建立的索引类型，目前支持五种，即 Secondary、Range、Search、Shard 和 Unique。</p>
<ul>
<li><p>Secondary 支持精确匹配的二级索引，允许建立联合索引，联合索引支持索引前缀搜索</p>
<ul>
<li><p>  单个属性，支持相等查询，比如：person顶点的city属性的二级索引，可以用<code>g.V().has(&quot;city&quot;, &quot;北京&quot;)</code>查询”city属性值是北京”的全部顶点</p>
</li>
<li><p>联合索引，支持前缀查询和相等查询，比如：person顶点的city和street属性的联合索引，可以用<code>g.V().has (&quot;city&quot;, &quot;北京&quot;).has(&#39;street&#39;, &#39;中关村街道&#39;)</code>查询”city属性值是北京且street属性值是中关村”的全部顶点，或者<code>g.V() .has(&quot;city&quot;, &quot;北京&quot;)</code>查询”city属性值是北京”的全部顶点</p>
<blockquote>
<p>secondary index的查询都是基于”是”或者”相等”的查询条件，不支持”部分匹配”</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Range 支持数值类型的范围查询</p>
<ul>
<li>  必须是单个数字或者日期属性，比如：person顶点的age属性的范围索引，可以用<code>g.V().has(&quot;age&quot;, P.gt(18))</code>查询”age属性值大于18”的顶点。除了<code>P.gt()</code>以外，还支持<code>P.gte()</code>, <code>P.lte()</code>, <code>P.lt()</code>, <code>P.eq()</code>, <code>P.between()</code>, <code>P.inside()</code>和<code>P.outside()</code>等</li>
</ul>
</li>
<li><p>Search 支持全文检索的索引</p>
<ul>
<li><p>必须是单个文本属性，比如：person顶点的address属性的全文索引，可以用<code>g.V().has(&quot;address&quot;, Text .contains(&#39;大厦&#39;)</code>查询”address属性中包含大厦”的全部顶点</p>
<blockquote>
<p>search index的查询是基于”是”或者”包含”的查询条件</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Shard 支持前缀匹配 + 数字范围查询的索引</p>
<ul>
<li><p>  N个属性的分片索引，支持前缀相等情况下的范围查询，比如：person顶点的city和age属性的分片索引，可以用<code>g.V().has (&quot;city&quot;, &quot;北京&quot;).has(&quot;age&quot;, P.between(18, 30))</code>查询”city属性是北京且年龄大于等于18小于30”的全部顶点</p>
</li>
<li><p>  shard index N个属性全是文本属性时，等价于secondary index</p>
</li>
<li><p>shard index只有单个数字或者日期属性时，等价于range index</p>
<blockquote>
<p>shard index可以有任意数字或者日期属性，但是查询时最多只能提供一个范围查找条件，且该范围查找条件的属性的前缀属性都是相等查询条件</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Unique 支持属性值唯一性约束，即可以限定属性的值不重复，允许联合索引，但不支持查询</p>
<ul>
<li>  单个或者多个属性的唯一性索引，不可用来查询，只可对属性的值进行限定，当出现重复值时将报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>摘录自 <a target="_blank" rel="noopener" href="https://hugegraph.github.io/hugegraph-doc/clients/hugegraph-client.html">https://hugegraph.github.io/hugegraph-doc/clients/hugegraph-client.html</a></p>
</blockquote>
<p><code>Secondary</code> 和 <code>Range</code>是最常用的索引。</p>
<h2 id="索引存储原理"><a href="#索引存储原理" class="headerlink" title="索引存储原理"></a>索引存储原理</h2><p>我们通过源代码来分析索引存储过程。 核心代码在<code>GraphIndexTransaction.updateIndex</code>函数里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Update index(user properties) of vertex or edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ilId      the id of index label</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element   the properties owner</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> removed   remove or add index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateIndex</span><span class="params">(Id ilId, HugeElement element, <span class="keyword">boolean</span> removed)</span> </span>&#123;</span><br><span class="line">        SchemaTransaction schema = <span class="keyword">this</span>.params().schemaTransaction();</span><br><span class="line">        IndexLabel indexLabel = schema.getIndexLabel(ilId);</span><br><span class="line">        E.checkArgument(indexLabel != <span class="keyword">null</span>,</span><br><span class="line">                        <span class="string">&quot;Not exist index label with id &#x27;%s&#x27;&quot;</span>, ilId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect property values of index fields</span></span><br><span class="line">        List&lt;Object&gt; allPropValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> fieldsNum = indexLabel.indexFields().size();</span><br><span class="line">        <span class="keyword">int</span> firstNullField = fieldsNum;</span><br><span class="line">        <span class="keyword">for</span> (Id fieldId : indexLabel.indexFields()) &#123;</span><br><span class="line">            HugeProperty&lt;Object&gt; property = element.getProperty(fieldId);</span><br><span class="line">            <span class="keyword">if</span> (property == <span class="keyword">null</span>) &#123;</span><br><span class="line">                E.checkState(hasNullableProp(element, fieldId),</span><br><span class="line">                             <span class="string">&quot;Non-null property &#x27;%s&#x27; is null for &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                             <span class="keyword">this</span>.graph().propertyKey(fieldId) , element);</span><br><span class="line">                <span class="keyword">if</span> (firstNullField == fieldsNum) &#123;</span><br><span class="line">                    firstNullField = allPropValues.size();</span><br><span class="line">                &#125;</span><br><span class="line">                allPropValues.add(INDEX_SYM_NULL);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                E.checkArgument(!INDEX_SYM_NULL.equals(property.value()),</span><br><span class="line">                                <span class="string">&quot;Illegal value of index property: &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                                INDEX_SYM_NULL);</span><br><span class="line">                allPropValues.add(property.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstNullField == <span class="number">0</span> &amp;&amp; !indexLabel.indexType().isUnique()) &#123;</span><br><span class="line">            <span class="comment">// The property value of first index field is null</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Not build index for record with nullable field (except unique index)</span></span><br><span class="line">        List&lt;Object&gt; propValues = allPropValues.subList(<span class="number">0</span>, firstNullField);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expired time</span></span><br><span class="line">        <span class="keyword">long</span> expiredTime = element.expiredTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update index for each index type</span></span><br><span class="line">        <span class="keyword">switch</span> (indexLabel.indexType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> RANGE_INT:</span><br><span class="line">            <span class="keyword">case</span> RANGE_FLOAT:</span><br><span class="line">            <span class="keyword">case</span> RANGE_LONG:</span><br><span class="line">            <span class="keyword">case</span> RANGE_DOUBLE:</span><br><span class="line">                E.checkState(propValues.size() == <span class="number">1</span>,</span><br><span class="line">                             <span class="string">&quot;Expect only one property in range index&quot;</span>);</span><br><span class="line">                Object value = NumericUtil.convertToNumber(propValues.get(<span class="number">0</span>));</span><br><span class="line">                <span class="keyword">this</span>.updateIndex(indexLabel, value, element.id(),</span><br><span class="line">                                 expiredTime, removed);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SEARCH:</span><br><span class="line">                E.checkState(propValues.size() == <span class="number">1</span>,</span><br><span class="line">                             <span class="string">&quot;Expect only one property in search index&quot;</span>);</span><br><span class="line">                value = propValues.get(<span class="number">0</span>);</span><br><span class="line">                Set&lt;String&gt; words = <span class="keyword">this</span>.segmentWords(value.toString());</span><br><span class="line">                <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.updateIndex(indexLabel, word, element.id(),</span><br><span class="line">                                     expiredTime, removed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SECONDARY:</span><br><span class="line">                <span class="comment">// Secondary index maybe include multi prefix index</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = propValues.size(); i &lt; n; i++) &#123;</span><br><span class="line">                    List&lt;Object&gt; prefixValues = propValues.subList(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// prefixValues is list or set , should create index for</span></span><br><span class="line">                    <span class="comment">// each item</span></span><br><span class="line">                    <span class="keyword">if</span>(prefixValues.get(<span class="number">0</span>) <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Object propValue :</span><br><span class="line">                                (Collection&lt;Object&gt;) prefixValues.get(<span class="number">0</span>)) &#123;</span><br><span class="line">                            value = escapeIndexValueIfNeeded(propValue.toString());</span><br><span class="line">                            <span class="keyword">this</span>.updateIndex(indexLabel, value, element.id(),</span><br><span class="line">                                             expiredTime, removed);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        value = ConditionQuery.concatValues(prefixValues);</span><br><span class="line">                        value = escapeIndexValueIfNeeded((String) value);</span><br><span class="line">                        <span class="keyword">this</span>.updateIndex(indexLabel, value, element.id(),</span><br><span class="line">                                         expiredTime, removed);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHARD:</span><br><span class="line">                value = ConditionQuery.concatValues(propValues);</span><br><span class="line">                value = escapeIndexValueIfNeeded((String) value);</span><br><span class="line">                <span class="keyword">this</span>.updateIndex(indexLabel, value, element.id(),</span><br><span class="line">                                 expiredTime, removed);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UNIQUE:</span><br><span class="line">                value = ConditionQuery.concatValues(allPropValues);</span><br><span class="line">                <span class="keyword">assert</span> !value.equals(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                Id id = element.id();</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> add lock for updating unique index</span></span><br><span class="line">                <span class="keyword">if</span> (!removed &amp;&amp; <span class="keyword">this</span>.existUniqueValue(indexLabel, value, id)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                              <span class="string">&quot;Unique constraint %s conflict is found for %s&quot;</span>,</span><br><span class="line">                              indexLabel, element));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.updateIndex(indexLabel, value, element.id(),</span><br><span class="line">                                 expiredTime, removed);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(String.format(</span><br><span class="line">                          <span class="string">&quot;Unknown index type &#x27;%s&#x27;&quot;</span>, indexLabel.indexType()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数是索引id，数据HugeElement</li>
<li>先schema.getIndexLabel(ilId)，根据索引id获取到indexlabel</li>
<li>然后根据indexlabel中的字段获取element中的属性值</li>
<li>然后根据switch索引类型，来处理索引。</li>
</ul>
<p>当用户的查询语义是：某属性值大于、小于、大于等于、小于等于、等于某个界限，或者属性值属于某个区间时，适合使用范围索引。比如：“年龄”、“价格”、“得分”等取值比较连续的属性。</p>
<p>范围索引处理方式如下：</p>
<ul>
<li>先检查属性值个数是否为1，范围索引不支持组合索引。</li>
<li>然后updateIndex，保存索引</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E.checkState(propValues.size() == <span class="number">1</span>,</span><br><span class="line">                      <span class="string">&quot;Expect only one property in range index&quot;</span>);</span><br><span class="line">         Object value = NumericUtil.convertToNumber(propValues.get(<span class="number">0</span>));</span><br><span class="line">         <span class="keyword">this</span>.updateIndex(indexLabel, value, element.id(),</span><br><span class="line">                          expiredTime, removed);</span><br></pre></td></tr></table></figure>
<p>updateIndex 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateIndex</span><span class="params">(IndexLabel indexLabel, Object propValue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Id elementId, <span class="keyword">long</span> expiredTime, <span class="keyword">boolean</span> removed)</span> </span>&#123;</span><br><span class="line">        HugeIndex index = <span class="keyword">new</span> HugeIndex(<span class="keyword">this</span>.graph(), indexLabel);</span><br><span class="line">        index.fieldValues(propValue);</span><br><span class="line">        index.elementIds(elementId, expiredTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doEliminate(<span class="keyword">this</span>.serializer.writeIndex(index));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.doAppend(<span class="keyword">this</span>.serializer.writeIndex(index));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造索引，根据removed来决定是append还是删除。</li>
<li>通过GraphSerializer序列化索引</li>
</ul>
<p>这里我们来探索Serializer是如何做的，比如Binary:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Id id = index.id();</span><br><span class="line">      HugeType type = index.type();</span><br><span class="line">      <span class="keyword">byte</span>[] value = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!type.isNumericIndex() &amp;&amp; indexIdLengthExceedLimit(id)) &#123;</span><br><span class="line">          id = index.hashId();</span><br><span class="line">          <span class="comment">// Save field-values as column value if the key is a hash string</span></span><br><span class="line">          value = StringEncoding.encode(index.fieldValues().toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      entry = newBackendEntry(type, id);</span><br><span class="line">      entry.column(<span class="keyword">this</span>.formatIndexName(index), value);</span><br><span class="line">      entry.subId(index.elementId());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index.hasTtl()) &#123;</span><br><span class="line">          entry.ttl(index.ttl());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成一个BackendEntry，id为索引id</li>
<li>column name 通过formatIndexName生成， value 一般为null</li>
<li>subId为elementid</li>
</ul>
<p>索引的id：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Id <span class="title">formatIndexId</span><span class="params">(HugeType type, Id indexLabelId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Object fieldValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isStringIndex()) &#123;</span><br><span class="line">            String value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (fieldValues <span class="keyword">instanceof</span> Id) &#123;</span><br><span class="line">                value = IdGenerator.asStoredString((Id) fieldValues);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fieldValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">                value = fieldValues.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Modify order between index label and field-values to put the</span></span><br><span class="line"><span class="comment">             * index label in front(hugegraph-1317)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String strIndexLabelId = IdGenerator.asStoredString(indexLabelId);</span><br><span class="line">            <span class="keyword">return</span> SplicingIdGenerator.splicing(strIndexLabelId, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> type.isRangeIndex();</span><br><span class="line">            <span class="keyword">int</span> length = type.isRange4Index() ? <span class="number">4</span> : <span class="number">8</span>;</span><br><span class="line">            BytesBuffer buffer = BytesBuffer.allocate(<span class="number">4</span> + length);</span><br><span class="line">            buffer.writeInt(SchemaElement.schemaId(indexLabelId));</span><br><span class="line">            <span class="keyword">if</span> (fieldValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">                E.checkState(fieldValues <span class="keyword">instanceof</span> Number,</span><br><span class="line">                             <span class="string">&quot;Field value of range index must be number:&quot;</span> +</span><br><span class="line">                             <span class="string">&quot; %s&quot;</span>, fieldValues.getClass().getSimpleName());</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = number2bytes((Number) fieldValues);</span><br><span class="line">                buffer.write(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buffer.asId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是rangeindex，id为 SchemaElement.schemaId(indexLabelId) + fieldValues</li>
<li>如果是字符串索引，id为 indexLabelId:fieldValues 拼接为字符串 （SplicingIdGenerator.splicing(）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] formatIndexName(HugeIndex index) &#123;</span><br><span class="line">        BytesBuffer buffer;</span><br><span class="line">        Id elemId = index.elementId();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.indexWithIdPrefix) &#123;</span><br><span class="line">            <span class="keyword">int</span> idLen = <span class="number">1</span> + elemId.length();</span><br><span class="line">            buffer = BytesBuffer.allocate(idLen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Id indexId = index.id();</span><br><span class="line">            HugeType type = index.type();</span><br><span class="line">            <span class="keyword">if</span> (!type.isNumericIndex() &amp;&amp; indexIdLengthExceedLimit(indexId)) &#123;</span><br><span class="line">                indexId = index.hashId();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> idLen = <span class="number">1</span> + elemId.length() + <span class="number">1</span> + indexId.length();</span><br><span class="line">            buffer = BytesBuffer.allocate(idLen);</span><br><span class="line">            <span class="comment">// Write index-id</span></span><br><span class="line">            buffer.writeIndexId(indexId, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Write element-id</span></span><br><span class="line">        buffer.writeId(elemId);</span><br><span class="line">        <span class="comment">// Write expired time if needed</span></span><br><span class="line">        <span class="keyword">if</span> (index.hasTtl()) &#123;</span><br><span class="line">            buffer.writeVLong(index.expiredTime());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buffer.bytes();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>formatIndexName 决定了column name：</p>
<ul>
<li>先写入indexId，也就是上面（formatIndexId）生成的index id</li>
<li>再写入elemId</li>
</ul>
<p>最后写入存储后端时，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Session session, BackendEntry entry)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> !entry.columns().isEmpty();</span><br><span class="line">       <span class="keyword">for</span> (BackendColumn col : entry.columns()) &#123;</span><br><span class="line">           <span class="keyword">assert</span> entry.belongToMe(col) : entry;</span><br><span class="line">           session.put(<span class="keyword">this</span>.table(), col.name, col.value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>对于range 索引，key的前缀是Int的indexLabelId，中间是索引值的bytes，后缀是elementid，因此range索引天然是有序的。</p>
<p>存储结构：</p>
<pre><code>index_label_id | field_values | element_ids
</code></pre>
<p>对于二级索引，也是：</p>
<pre><code> indexLabelId | fieldValues | element_ids
</code></pre>
<ul>
<li>  <code>field_values</code>: 属性的值，可以是单个属性，也可以是多个属性拼接而成</li>
<li>  <code>index_label_id</code>: 索引标签的Id</li>
<li>  <code>element_ids</code>: 顶点或边的Id</li>
</ul>
<h2 id="索引查询过程分析"><a href="#索引查询过程分析" class="headerlink" title="索引查询过程分析"></a>索引查询过程分析</h2><p>查询要从GraphTransaction的query开始分析，针对ConditionQuery条件查询，会调用optimizeQueries优化查询。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> QueryResults&lt;BackendEntry&gt; <span class="title">query</span><span class="params">(Query query)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(query <span class="keyword">instanceof</span> ConditionQuery)) &#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Query&#123;final:&#123;&#125;&#125;&quot;</span>, query);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.query(query);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QueryList&lt;BackendEntry&gt; queries = <span class="keyword">this</span>.optimizeQueries(query,</span><br><span class="line">                                                               <span class="keyword">super</span>::query);</span><br><span class="line">        LOG.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, queries);</span><br><span class="line">        <span class="keyword">return</span> queries.empty() ? QueryResults.empty() :</span><br><span class="line">                                 queries.fetch(<span class="keyword">this</span>.pageSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>optimizeQueries 会将condtion query flatten展开（比如in查询，展开成多个查询），然后针对每个cq做查询。</p>
<p>针对每个cq，会调用indexQuery走索引查询。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;R&gt; <span class="function">QueryList&lt;R&gt; <span class="title">optimizeQueries</span><span class="params">(Query query,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             QueryResults.Fetcher&lt;R&gt; fetcher)</span> </span>&#123;</span><br><span class="line">        QueryList&lt;R&gt; queries = <span class="keyword">new</span> QueryList&lt;&gt;(query, fetcher);</span><br><span class="line">        <span class="keyword">for</span> (ConditionQuery cq: ConditionQueryFlatten.flatten(</span><br><span class="line">                                (ConditionQuery) query)) &#123;</span><br><span class="line">            <span class="comment">// Optimize by sysprop</span></span><br><span class="line">            Query q = <span class="keyword">this</span>.optimizeQuery(cq);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * <span class="doctag">NOTE:</span> There are two possibilities for this query:</span></span><br><span class="line"><span class="comment">             * 1.sysprop-query, which would not be empty.</span></span><br><span class="line"><span class="comment">             * 2.index-query result(ids after optimization), which may be empty.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                queries.add(<span class="keyword">this</span>.indexQuery(cq), <span class="keyword">this</span>.batchSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">                queries.add(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queries;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>索引查询，核心代码在 GraphIndexTransaction.queryIndex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Watched(prefix = &quot;index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IdHolderList <span class="title">queryIndex</span><span class="params">(ConditionQuery query)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Index query must have been flattened in Graph tx</span></span><br><span class="line">        query.checkFlattened();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Currently we can&#x27;t support filter changes in memory</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasUpdate()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HugeException(<span class="string">&quot;Can&#x27;t do index query when &quot;</span> +</span><br><span class="line">                                    <span class="string">&quot;there are changes in transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can&#x27;t query by index and by non-label sysprop at the same time</span></span><br><span class="line">        List&lt;Condition&gt; conds = query.syspropConditions();</span><br><span class="line">        <span class="keyword">if</span> (conds.size() &gt; <span class="number">1</span> ||</span><br><span class="line">            (conds.size() == <span class="number">1</span> &amp;&amp; !query.containsCondition(HugeKeys.LABEL))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HugeException(<span class="string">&quot;Can&#x27;t do index query with %s and %s&quot;</span>,</span><br><span class="line">                                    conds, query.userpropConditions());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Query by index</span></span><br><span class="line">        query.optimized(OptimizedType.INDEX);</span><br><span class="line">        <span class="keyword">if</span> (query.allSysprop() &amp;&amp; conds.size() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            query.containsCondition(HugeKeys.LABEL)) &#123;</span><br><span class="line">            <span class="comment">// Query only by label</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.queryByLabel(query);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Query by userprops (or userprops + label)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.queryByUserprop(query);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>会先做一些检查，然后判断是否有属性条件，如果没有则直接查询对应label，否则走queryByUserprop，根据属性值查询结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Watched(prefix = &quot;index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IdHolderList <span class="title">queryByUserprop</span><span class="params">(ConditionQuery query)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Get user applied label or collect all qualified labels with</span></span><br><span class="line">        <span class="comment">// related index labels</span></span><br><span class="line">        Set&lt;MatchedIndex&gt; indexes = <span class="keyword">this</span>.collectMatchedIndexes(query);</span><br><span class="line">        <span class="keyword">if</span> (indexes.isEmpty()) &#123;</span><br><span class="line">            Id label = query.condition(HugeKeys.LABEL);</span><br><span class="line">            <span class="keyword">throw</span> noIndexException(<span class="keyword">this</span>.graph(), query, label);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Value type of Condition not matched</span></span><br><span class="line">        <span class="keyword">boolean</span> paging = query.paging();</span><br><span class="line">        <span class="keyword">if</span> (!validQueryConditionValues(<span class="keyword">this</span>.graph(), query)) &#123;</span><br><span class="line">            <span class="keyword">return</span> IdHolderList.empty(paging);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do index query</span></span><br><span class="line">        IdHolderList holders = <span class="keyword">new</span> IdHolderList(paging);</span><br><span class="line">        <span class="keyword">for</span> (MatchedIndex index : indexes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IndexLabel il : index.indexLabels()) &#123;</span><br><span class="line">                validateIndexLabel(il);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (paging &amp;&amp; index.indexLabels().size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NotSupportException(<span class="string">&quot;joint index query in paging&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index.containsSearchIndex()) &#123;</span><br><span class="line">                <span class="comment">// Do search-index query</span></span><br><span class="line">                holders.addAll(<span class="keyword">this</span>.doSearchIndex(query, index));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Do secondary-index, range-index or shard-index query</span></span><br><span class="line">                IndexQueries queries = index.constructIndexQueries(query);</span><br><span class="line">                <span class="keyword">assert</span> !paging || queries.size() &lt;= <span class="number">1</span>;</span><br><span class="line">                IdHolder holder = <span class="keyword">this</span>.doSingleOrJointIndex(queries);</span><br><span class="line">                holders.add(holder);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * <span class="doctag">NOTE:</span> need to skip the offset if offset &gt; 0, but can&#x27;t handle</span></span><br><span class="line"><span class="comment">             * it here because the query may a sub-query after flatten,</span></span><br><span class="line"><span class="comment">             * so the offset will be handle in QueryList.IndexQuery</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">TODO:</span> finish early here if records exceeds required limit with</span></span><br><span class="line"><span class="comment">             *       FixedIdHolder.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holders;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>queryByUserprop 会先查询出匹配的索引(collectMatchedIndexes)，如果没匹配到索引，就会报错。</p>
<p>如果匹配到多个索引，依次查询，如果是search索引，走doSearchIndex，反之先constructIndexQueries，然后doSingleOrJointIndex。</p>
<h3 id="搜索索引"><a href="#搜索索引" class="headerlink" title="搜索索引"></a>搜索索引</h3><p>搜索索引，之所以特殊处理，因为要分词：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Watched(prefix = &quot;index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IdHolderList <span class="title">doSearchIndex</span><span class="params">(ConditionQuery query,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       MatchedIndex index)</span> </span>&#123;</span><br><span class="line">        query = <span class="keyword">this</span>.constructSearchQuery(query, index);</span><br><span class="line">        <span class="comment">// Sorted by matched count</span></span><br><span class="line">        IdHolderList holders = <span class="keyword">new</span> SortByCountIdHolderList(query.paging());</span><br><span class="line">        List&lt;ConditionQuery&gt; flatten = ConditionQueryFlatten.flatten(query);</span><br><span class="line">        <span class="keyword">for</span> (ConditionQuery q : flatten) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!q.noLimit() &amp;&amp; flatten.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// Increase limit for union operation</span></span><br><span class="line">                increaseLimit(q);</span><br><span class="line">            &#125;</span><br><span class="line">            IndexQueries queries = index.constructIndexQueries(q);</span><br><span class="line">            <span class="keyword">assert</span> !query.paging() || queries.size() &lt;= <span class="number">1</span>;</span><br><span class="line">            IdHolder holder = <span class="keyword">this</span>.doSingleOrJointIndex(queries);</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> ids will be merged into one IdHolder if not in paging</span></span><br><span class="line">            holders.add(holder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holders;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先构造查询，然后组合结果</li>
<li>重点是如何构造查询的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConditionQuery <span class="title">constructSearchQuery</span><span class="params">(ConditionQuery query,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                MatchedIndex index)</span> </span>&#123;</span><br><span class="line">        ConditionQuery originQuery = query;</span><br><span class="line">        Set&lt;Id&gt; indexFields = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// Convert has(key, text) to has(key, textContainsAny(word1, word2))</span></span><br><span class="line">        <span class="keyword">for</span> (IndexLabel il : index.indexLabels()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (il.indexType() != IndexType.SEARCH) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Id indexField = il.indexField();</span><br><span class="line">            String fieldValue = (String) query.userpropValue(indexField);</span><br><span class="line">            Set&lt;String&gt; words = <span class="keyword">this</span>.segmentWords(fieldValue);</span><br><span class="line">            indexFields.add(indexField);</span><br><span class="line"></span><br><span class="line">            query = query.copy();</span><br><span class="line">            query.unsetCondition(indexField);</span><br><span class="line">            query.query(Condition.textContainsAny(indexField, words));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register results filter to compare property value and search text</span></span><br><span class="line">        query.registerResultsFilter(elem -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (Condition cond : originQuery.conditions()) &#123;</span><br><span class="line">                Object key = cond.isRelation() ? ((Relation) cond).key() : <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (key <span class="keyword">instanceof</span> Id &amp;&amp; indexFields.contains(key)) &#123;</span><br><span class="line">                    <span class="comment">// This is an index field of search index</span></span><br><span class="line">                    Id field = (Id) key;</span><br><span class="line">                    <span class="keyword">assert</span> elem != <span class="keyword">null</span>;</span><br><span class="line">                    HugeProperty&lt;?&gt; property = elem.getProperty(field);</span><br><span class="line">                    String propValue = propertyValueToString(property.value());</span><br><span class="line">                    String fieldValue = (String) originQuery.userpropValue(field);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.matchSearchIndexWords(propValue, fieldValue)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!cond.test(elem)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先分词</li>
<li>然后resetquery，Convert has(key, text) to has(key, textContainsAny(word1, word2))</li>
<li>最后，索引查询可能匹配到多个结果，registerResultsFilter 注册一个结果过滤器，对结果做过滤</li>
</ul>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>普通索引，也是先构造索引查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic IndexQueries <span class="title">constructIndexQueries</span><span class="params">(ConditionQuery query)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Condition query =&gt; Index Queries</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.indexLabels().size() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Query by single index or composite index</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                IndexLabel il = <span class="keyword">this</span>.indexLabels().iterator().next();</span><br><span class="line">                ConditionQuery indexQuery = constructQuery(query, il);</span><br><span class="line">                <span class="keyword">assert</span> indexQuery != <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> IndexQueries.of(il, indexQuery);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Query by joint indexes</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                IndexQueries queries = buildJointIndexesQueries(query, <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">assert</span> !queries.isEmpty();</span><br><span class="line">                <span class="keyword">return</span> queries;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果只匹配到一个索引，直接走这个索引，最简单的情况，</p>
<p>如果匹配到多个索引，这个时候要走联合查询了（buildJointIndexesQueries）</p>
<p>最后，通过doSingleOrJointIndex来获取结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Watched(prefix = &quot;index&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> IdHolder <span class="title">doSingleOrJointIndex</span><span class="params">(IndexQueries queries)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (queries.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doSingleOrCompositeIndex(queries);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doJointIndex(queries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果queries.size &gt; 1，代表要走联合索引。但是一般db一次查询通常直走一个索引，hugegraph也差不多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Watched(prefix = &quot;index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IdHolder <span class="title">doJointIndex</span><span class="params">(IndexQueries queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queries.oomRisk()) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;There is OOM risk if the joint operation is based on a &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;large amount of data, please use single index + filter &quot;</span> +</span><br><span class="line">                     <span class="string">&quot;instead of joint index: &#123;&#125;&quot;</span>, queries.rootQuery());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// All queries are joined with AND</span></span><br><span class="line">        Set&lt;Id&gt; intersectIds = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> filtering = <span class="keyword">false</span>;</span><br><span class="line">        IdHolder resultHolder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;IndexLabel, ConditionQuery&gt; e : queries.entrySet()) &#123;</span><br><span class="line">            IndexLabel indexLabel = e.getKey();</span><br><span class="line">            ConditionQuery query = e.getValue();</span><br><span class="line">            <span class="keyword">assert</span> !query.paging();</span><br><span class="line">            <span class="keyword">if</span> (!query.noLimit() &amp;&amp; queries.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// Unset limit for intersection operation</span></span><br><span class="line">                query.limit(Query.NO_LIMIT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Try to query by joint indexes:</span></span><br><span class="line"><span class="comment">             * 1 If there is any index exceeded the threshold, transform into</span></span><br><span class="line"><span class="comment">             *   partial index query, then filter after back-table.</span></span><br><span class="line"><span class="comment">             * 1.1 Return the holder of the first index that not exceeded the</span></span><br><span class="line"><span class="comment">             *     threshold if there exists one index, this holder will be used</span></span><br><span class="line"><span class="comment">             *     as the only query condition.</span></span><br><span class="line"><span class="comment">             * 1.2 Return the holder of the first index if all indexes exceeded</span></span><br><span class="line"><span class="comment">             *     the threshold.</span></span><br><span class="line"><span class="comment">             * 2 Else intersect holders for all indexes, and return intersection</span></span><br><span class="line"><span class="comment">             *   ids of all indexes.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            IdHolder holder = <span class="keyword">this</span>.doIndexQuery(indexLabel, query);</span><br><span class="line">            <span class="keyword">if</span> (resultHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultHolder = holder;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">this</span>.indexIntersectThresh &gt; <span class="number">0</span>; <span class="comment">// default value is 1000</span></span><br><span class="line">            Set&lt;Id&gt; ids = ((BatchIdHolder) holder).peekNext(</span><br><span class="line">                          <span class="keyword">this</span>.indexIntersectThresh).ids();</span><br><span class="line">            <span class="keyword">if</span> (ids.size() &gt;= <span class="keyword">this</span>.indexIntersectThresh) &#123;</span><br><span class="line">                <span class="comment">// Transform into filtering</span></span><br><span class="line">                filtering = <span class="keyword">true</span>;</span><br><span class="line">                query.optimized(OptimizedType.INDEX_FILTER);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filtering) &#123;</span><br><span class="line">                <span class="keyword">assert</span> ids.size() &lt; <span class="keyword">this</span>.indexIntersectThresh;</span><br><span class="line">                resultHolder = holder;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (intersectIds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    intersectIds = ids;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    CollectionUtil.intersectWithModify(intersectIds, ids);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (intersectIds.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filtering) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultHolder;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> intersectIds != <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FixedIdHolder(queries.asJointQuery(), intersectIds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>依次读取，先读取indexIntersectThresh 个数的匹配索引id，indexIntersectThresh用来控制1次读取索引id的个数，这个默认是1000,</li>
<li>如果地个数》=indexIntersectThresh，这个时候hugegraph认为匹配结果数太多了，不能直接走索引查询到结果，需要走过滤（OptimizedType.INDEX_FILTER），也就是读取可能的候选结果，然后通过查询条件过滤结果。</li>
<li>如果有一个索引较小，resultHolder缓存较小索引的</li>
<li>如果几个索引都小于indexIntersectThresh，这是最理想情况，直接取ids的交集（CollectionUtil.intersectWithModify）</li>
</ul>
<p>读取到id后，就是根据id读取结果，过滤结果了。</p>
<h2 id="如何通过索引读取到匹配的id？"><a href="#如何通过索引读取到匹配的id？" class="headerlink" title="如何通过索引读取到匹配的id？"></a>如何通过索引读取到匹配的id？</h2><p>关键代码在AbstractTransaction：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Watched(prefix = &quot;tx&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryResults&lt;BackendEntry&gt; <span class="title">query</span><span class="params">(Query query)</span> </span>&#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;Transaction query: &#123;&#125;&quot;</span>, query);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * <span class="doctag">NOTE:</span> it&#x27;s dangerous if an IdQuery/ConditionQuery is empty</span></span><br><span class="line"><span class="comment">         * check if the query is empty and its class is not the Query itself</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (query.empty() &amp;&amp; !query.getClass().equals(Query.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BackendException(<span class="string">&quot;Query without any id or condition&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Query squery = <span class="keyword">this</span>.serializer.writeQuery(query);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do rate limit if needed</span></span><br><span class="line">        RateLimiter rateLimiter = <span class="keyword">this</span>.graph.readRateLimiter();</span><br><span class="line">        <span class="keyword">if</span> (rateLimiter != <span class="keyword">null</span> &amp;&amp; query.resultType().isGraph()) &#123;</span><br><span class="line">            <span class="keyword">double</span> time = rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Waited for &#123;&#125;s to query&quot;</span>, time);</span><br><span class="line">            &#125;</span><br><span class="line">            BackendEntryIterator.checkInterrupted();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.beforeRead();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> QueryResults&lt;&gt;(<span class="keyword">this</span>.store.query(squery), query);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.afterRead(); <span class="comment">// <span class="doctag">TODO:</span> not complete the iteration currently</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>逐级往下，核心代码在writeQueryCondition：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected Query <span class="function"><span class="title">writeQueryCondition</span>(<span class="params">Query query</span>)</span> &#123;</span><br><span class="line">       HugeType type = query.resultType();</span><br><span class="line">       <span class="keyword">if</span> (!type.isIndex()) &#123;</span><br><span class="line">           <span class="keyword">return</span> query;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ConditionQuery cq = (ConditionQuery) query;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (type.isNumericIndex()) &#123;</span><br><span class="line">           <span class="comment">// Convert range-index/shard-index query to id range query</span></span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.writeRangeIndexQuery(cq);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           assert type.isSearchIndex() || type.isSecondaryIndex() ||</span><br><span class="line">                  type.isUniqueIndex();</span><br><span class="line">           <span class="comment">// Convert secondary-index or search-index query to id query</span></span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">this</span>.writeStringIndexQuery(cq);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果是rangeindex 索引，会转换为scan <code> indexlabelid:start - indexlabelid:end</code> 的查询</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private Query <span class="function"><span class="title">writeRangeIndexQuery</span>(<span class="params">ConditionQuery query</span>)</span> &#123;</span><br><span class="line">        Id index = query.condition(HugeKeys.INDEX_LABEL_ID);</span><br><span class="line">        E.checkArgument(index != <span class="literal">null</span>, <span class="string">&quot;Please specify the index label&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Condition&gt; fields = query.syspropConditions(HugeKeys.FIELD_VALUES);</span><br><span class="line">        E.checkArgument(!fields.isEmpty(),</span><br><span class="line">                        <span class="string">&quot;Please specify the index field values&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HugeType type = query.resultType();</span><br><span class="line">        Id start = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (query.paging() &amp;&amp; !query.page().isEmpty()) &#123;</span><br><span class="line">            byte[] position = PageState.fromString(query.page()).position();</span><br><span class="line">            start = <span class="keyword">new</span> BinaryId(position, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RangeConditions range = <span class="keyword">new</span> RangeConditions(fields);</span><br><span class="line">        <span class="keyword">if</span> (range.keyEq() != <span class="literal">null</span>) &#123;</span><br><span class="line">            Id id = formatIndexId(type, index, range.keyEq(), <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (start == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> IdPrefixQuery(query, id);</span><br><span class="line">            &#125;</span><br><span class="line">            E.checkArgument(Bytes.compare(start.asBytes(), id.asBytes()) &gt;= <span class="number">0</span>,</span><br><span class="line">                            <span class="string">&quot;Invalid page out of lower bound&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IdPrefixQuery(query, start, id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span> keyMin = range.keyMin();</span><br><span class="line">        <span class="built_in">Object</span> keyMax = range.keyMax();</span><br><span class="line">        boolean keyMinEq = range.keyMinEq();</span><br><span class="line">        boolean keyMaxEq = range.keyMaxEq();</span><br><span class="line">        <span class="keyword">if</span> (keyMin == <span class="literal">null</span>) &#123;</span><br><span class="line">            E.checkArgument(keyMax != <span class="literal">null</span>,</span><br><span class="line">                            <span class="string">&quot;Please specify at least one condition&quot;</span>);</span><br><span class="line">            <span class="comment">// Set keyMin to min value</span></span><br><span class="line">            keyMin = NumericUtil.minValueOf(keyMax.getClass());</span><br><span class="line">            keyMinEq = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Id min = formatIndexId(type, index, keyMin, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!keyMinEq) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Increase 1 to keyMin, index GT query is a scan with GT prefix,</span></span><br><span class="line"><span class="comment">             * inclusiveStart=false will also match index started with keyMin</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            increaseOne(min.asBytes());</span><br><span class="line">            keyMinEq = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start == <span class="literal">null</span>) &#123;</span><br><span class="line">            start = min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            E.checkArgument(Bytes.compare(start.asBytes(), min.asBytes()) &gt;= <span class="number">0</span>,</span><br><span class="line">                            <span class="string">&quot;Invalid page out of lower bound&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyMax == <span class="literal">null</span>) &#123;</span><br><span class="line">            keyMax = NumericUtil.maxValueOf(keyMin.getClass());</span><br><span class="line">            keyMaxEq = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Id max = formatIndexId(type, index, keyMax, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (keyMaxEq) &#123;</span><br><span class="line">            keyMaxEq = <span class="literal">false</span>;</span><br><span class="line">            increaseOne(max.asBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IdRangeQuery(query, start, keyMinEq, max, keyMaxEq);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果是其他索引，则转换为前缀匹配查询:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Query <span class="title">writeStringIndexQuery</span><span class="params">(ConditionQuery query)</span> </span>&#123;</span><br><span class="line">        E.checkArgument(query.allSysprop() &amp;&amp;</span><br><span class="line">                        query.conditions().size() == <span class="number">2</span>,</span><br><span class="line">                        <span class="string">&quot;There should be two conditions: &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;INDEX_LABEL_ID and FIELD_VALUES&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;in secondary index query&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Id index = query.condition(HugeKeys.INDEX_LABEL_ID);</span><br><span class="line">        Object key = query.condition(HugeKeys.FIELD_VALUES);</span><br><span class="line"></span><br><span class="line">        E.checkArgument(index != <span class="keyword">null</span>, <span class="string">&quot;Please specify the index label&quot;</span>);</span><br><span class="line">        E.checkArgument(key != <span class="keyword">null</span>, <span class="string">&quot;Please specify the index key&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Id prefix = formatIndexId(query.resultType(), index, key, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> prefixQuery(query, prefix);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查询到rocksdb后端的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BackendColumnIterator <span class="title">queryBy</span><span class="params">(Session session, Query query)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Query all</span></span><br><span class="line">        <span class="keyword">if</span> (query.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.queryAll(session, query);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Query by prefix</span></span><br><span class="line">        <span class="keyword">if</span> (query <span class="keyword">instanceof</span> IdPrefixQuery) &#123;</span><br><span class="line">            IdPrefixQuery pq = (IdPrefixQuery) query;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.queryByPrefix(session, pq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Query by range</span></span><br><span class="line">        <span class="keyword">if</span> (query <span class="keyword">instanceof</span> IdRangeQuery) &#123;</span><br><span class="line">            IdRangeQuery rq = (IdRangeQuery) query;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.queryByRange(session, rq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Query by id</span></span><br><span class="line">        <span class="keyword">if</span> (query.conditions().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">assert</span> !query.ids().isEmpty();</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> this will lead to lazy create rocksdb iterator</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BackendColumnIteratorWrapper(<span class="keyword">new</span> FlatMapperIterator&lt;&gt;(</span><br><span class="line">                   query.ids().iterator(), id -&gt; <span class="keyword">this</span>.queryById(session, id)</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Query by condition (or condition + id)</span></span><br><span class="line">        ConditionQuery cq = (ConditionQuery) query;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queryByCond(session, cq);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>前缀查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BackendColumnIterator <span class="title">queryByPrefix</span><span class="params">(Session session,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  IdPrefixQuery query)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = query.inclusiveStart() ?</span><br><span class="line">                   Session.SCAN_GTE_BEGIN : Session.SCAN_GT_BEGIN;</span><br><span class="line">        type |= Session.SCAN_PREFIX_END;</span><br><span class="line">        <span class="keyword">return</span> session.scan(<span class="keyword">this</span>.table(), query.start().asBytes(),</span><br><span class="line">                            query.prefix().asBytes(), type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>range查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BackendColumnIterator <span class="title">queryByRange</span><span class="params">(Session session,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 IdRangeQuery query)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] start = query.start().asBytes();</span><br><span class="line">        <span class="keyword">byte</span>[] end = query.end() == <span class="keyword">null</span> ? <span class="keyword">null</span> : query.end().asBytes();</span><br><span class="line">        <span class="keyword">int</span> type = query.inclusiveStart() ?</span><br><span class="line">                   Session.SCAN_GTE_BEGIN : Session.SCAN_GT_BEGIN;</span><br><span class="line">        <span class="keyword">if</span> (end != <span class="keyword">null</span>) &#123;</span><br><span class="line">            type |= query.inclusiveEnd() ?</span><br><span class="line">                    Session.SCAN_LTE_END : Session.SCAN_LT_END;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> session.scan(<span class="keyword">this</span>.table(), start, end, type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查询后，在BinarySerializer中，通过readIndex还原为index：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HugeIndex <span class="title">readIndex</span><span class="params">(HugeGraph graph, ConditionQuery query,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BackendEntry bytesEntry)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (bytesEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       BinaryBackendEntry entry = <span class="keyword">this</span>.convertEntry(bytesEntry);</span><br><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> index id without length prefix</span></span><br><span class="line">       <span class="keyword">byte</span>[] bytes = entry.id().asBytes();</span><br><span class="line">       HugeIndex index = HugeIndex.parseIndexId(graph, entry.type(), bytes);</span><br><span class="line"></span><br><span class="line">       Object fieldValues = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (!index.type().isRangeIndex()) &#123;</span><br><span class="line">           fieldValues = query.condition(HugeKeys.FIELD_VALUES);</span><br><span class="line">           <span class="keyword">if</span> (!index.fieldValues().equals(fieldValues)) &#123;</span><br><span class="line">               <span class="comment">// Update field-values for hashed or encoded index-id</span></span><br><span class="line">               index.fieldValues(fieldValues);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.parseIndexName(graph, query, entry, index, fieldValues);</span><br><span class="line">       <span class="keyword">return</span> index;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>parseIndexId 和parseIndexName 是存储的decode操作，代码类似，一个存，一个读。</p>
<h2 id="索引与全局排序优化"><a href="#索引与全局排序优化" class="headerlink" title="索引与全局排序优化"></a>索引与全局排序优化</h2><p>这里提一个问题，要对符合条件的结果做全局排序怎么优化？</p>
<p>比如，我们需要按更新时间(update_time）排序，当没有其他条件时，可以将排序转换为update_time&gt;0 的查询，因为range索引默认是有序的，从小到大（详见上面的存储结构分析）。</p>
<p>如果要倒序怎么办？</p>
<ul>
<li>业务简单时，可以冗余一个字段，比如update_time_desc，取一个固定值-update_time, 这样最新的的数据在前面。</li>
</ul>
<p>但是，这种查询，在有其他条件时就无效了，详见doJointIndex，这种情况如何优化了？</p>
<p>我们下期再聊。</p>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/04/27/%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/04/27/%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">博客</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-27 11:37:44" itemprop="dateCreated datePublished" datetime="2021-04-27T11:37:44+08:00">2021-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这里放部门规范</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/04/25/jqpeng-chemfig%E5%8C%96%E5%AD%A6%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BApdf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/04/25/jqpeng-chemfig%E5%8C%96%E5%AD%A6%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BApdf/" class="post-title-link" itemprop="url">chemfig化学式转换为pdf</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 19:37:00" itemprop="dateCreated datePublished" datetime="2021-04-25T19:37:00+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/chemfig.html">chemfig化学式转换为pdf</a></p>
<h2 id="SMILES-与-chemfig"><a href="#SMILES-与-chemfig" class="headerlink" title="SMILES 与 chemfig"></a>SMILES 与 chemfig</h2><p>针对化学分子结构，可以用<code>SMILES</code> （用ASCII字符串明确描述分子结构的规范）来定义。</p>
<blockquote>
<p>SMILES（Simplified molecular input line entry specification），简化分子线性输入规范，是一种用ASCII字符串明确描述分子结构的规范。SMILES由Arthur Weininger和David Weininger于20世纪80年代晚期开发，并由其他人，尤其是日光化学信息系统有限公司（Daylight Chemical Information Systems Inc.），修改和扩展</p>
</blockquote>
<p>但是<code>SMILES</code>需要一定的化学基础，而<code>chemfig</code>则是从图形层面定义了一套规范，方便定义和显示化学式。当然，<code>SMILES</code>可以方便的转换到<code>chemfig</code>.</p>
<p>比如:</p>
<pre><code>CN1C=NC2=C1C(=O)N(C(=O)N2C)C
</code></pre>
<p>可通过mol2chemfig进行转换：</p>
<pre><code>mol2chemfig -wz -i direct &#39;CN1C=NC2=C1C(=O)N(C(=O)N2C)C&#39; &gt; caffeine.tex
</code></pre>
<p>转换后：</p>
<pre><code>\chemfig&#123;-[:138]N-[:84]=^[:156]N-[:228]=[:300](-[:240](-[:180]N(-[:240]%
)-[:120](-[:60]N(-[:120])-)=[:180]O)=[:300]O)-[:12]\phantom&#123;N&#125;&#125;
</code></pre>
<h2 id="chemfig-转换为pdf"><a href="#chemfig-转换为pdf" class="headerlink" title="chemfig 转换为pdf"></a>chemfig 转换为pdf</h2><p>我们可以通过pdflatex（textlive的一个工具）来转换tex为pdf：</p>
<p>拉取txtlive镜像：</p>
<pre><code>docker pull listx/texlive:2020
docker run -it --rm -v `pwd`:/app listx/texlive:2020 bash
</code></pre>
<p>然后用pdflatex转换。首先，我们生成一个tex文件<code>test.tex</code>，一个空tex文件，使用<code>mol2chemfig</code>(可从mol2chemfig下载),中间放上<code>\chemfig&#123;H_3C-[:30]N**6(-(=O)-(**5(-N(-CH_3)--N-))--N(-CH_3)-(=O)-)&#125;</code>，</p>
<pre><code>\documentclass&#123;minimal&#125;
\usepackage&#123;xcolor, mol2chemfig&#125;
\usepackage[margin=(margin)spt,papersize=&#123;%(width)spt, %(height)spt&#125;]&#123;geometry&#125;

\usepackage[helvet]&#123;sfmath&#125;
\setcrambond&#123;2.5pt&#125;&#123;0.4pt&#125;&#123;1.0pt&#125;
\setbondoffset&#123;1pt&#125;
\setdoublesep&#123;2pt&#125;
\setatomsep&#123;%(atomsep)spt&#125;
\renewcommand&#123;\printatom&#125;[1]&#123;\fontsize&#123;8pt&#125;&#123;10pt&#125;\selectfont&#123;\ensuremath&#123;\mathsf&#123;#1&#125;&#125;&#125;&#125;

\setlength&#123;\parindent&#125;&#123;0pt&#125;
\setlength&#123;\fboxsep&#125;&#123;0pt&#125;
\begin&#123;document&#125;
\vspace*&#123;\fill&#125;
\vspace&#123;-8pt&#125;
\begin&#123;center&#125;

\chemfig&#123;H_3C-[:30]N**6(-(=O)-(**5(-N(-CH_3)--N-))--N(-CH_3)-(=O)-)&#125;

\end&#123;center&#125;
\vspace*&#123;\fill&#125;
\end&#123;document&#125;
</code></pre>
<p>然后执行转换：</p>
<pre><code>pdflatex -interaction=nonstopmode  test.tex
</code></pre>
<p>等待1~2s，可以看到生成的pdf，打开：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/4/25/1619350402339.png" alt="PDF"></p>
<p>如何返回给前端呢，可以读取文件，然后转换为base64，python代码：</p>
<pre><code>pdfstring = open(&#39;test.pdf&#39;).read()
encoded = base64.encodestring(pdfstring)
pdflink = &quot;data:application/pdf;base64,&#123;&#125;&quot;.format(encoded)
</code></pre>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/04/13/jqpeng-%E4%BB%8Ewav%E5%88%B0Ogg%20Opus%20%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8java%E8%A7%A3%E7%A0%81OPUS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/04/13/jqpeng-%E4%BB%8Ewav%E5%88%B0Ogg%20Opus%20%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8java%E8%A7%A3%E7%A0%81OPUS/" class="post-title-link" itemprop="url">从wav到Ogg Opus 以及使用java解码OPUS</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-13 10:09:00" itemprop="dateCreated datePublished" datetime="2021-04-13T10:09:00+08:00">2021-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/ogg-opus.html">从wav到Ogg Opus 以及使用java解码OPUS</a></p>
<h2 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h2><p>自然界中的声音非常复杂，波形极其复杂，通常我们采用的是脉冲代码调制编码，即PCM编码。PCM通过抽样、量化、编码三个步骤将连续变化的模拟信号转换为数字编码。</p>
<p><strong>采样率</strong></p>
<p>采样频率，也称为采样速度或者采样率，定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。采样频率的倒数是采样周期或者叫作采样时间，它是采样之间的时间间隔。通俗的讲采样频率是指计算机每秒钟采集多少个信号样本。</p>
<p>工业界常用的16K，就是1s有16000个采样点。</p>
<h2 id="WAV"><a href="#WAV" class="headerlink" title="WAV"></a>WAV</h2><p>PCM是原始语音，依据采样率的定义，我们知道要播放PCM，需要知道采样率，因此需要一个文件格式可以封装PCM，<code>wav</code>就是微软公司专门为Windows开发的一种标准数字音频文件，该文件能记录各种单声道或立体声的声音信息。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/4/13/1618277649258.png" alt="WAV格式"></p>
<p>wav文件前44个字节，定义了采样率，channel等参数，播放器通过这个数据就可以播放PCM数据了。</p>
<h2 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h2><p><code>wav</code> 很好的解决了PCM播放的问题，但是PCM实在是太大了，因此出现了<code>mp3</code>等音频格式，通过一定的压缩算法压缩语音，以便于互联网传输分享。</p>
<h2 id="Ogg-与-Opus"><a href="#Ogg-与-Opus" class="headerlink" title="Ogg 与 Opus"></a>Ogg 与 Opus</h2><p>随着音视频应用的越来越广泛，工业界有了越来越多的编解码器，比如<code>Speek</code>,<code>Opus</code></p>
<p>Opus编解码器是专门设计用于互联网的交互式语音和音频传输。它是由IETF的编解码器工作组设计的，合并了Skype的SILK和Xiph. Org的CELT技术。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/4/13/1618278091526.png" alt="OPUS"></p>
<p>OPUS编解码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lostromb/concentus">https://github.com/lostromb/concentus</a> 是一个纯java库，可以编解码OPUS。</p>
<p>OPUS一般是分帧编码，比如一个320采样点（640字节）的数据，编码后为70多个字节，和PCM一样，编码后的OPUS不能直接播放：</p>
<ul>
<li>无法从文件本身获取音频的元数据(采样率,声道数,码率等)</li>
<li>缺少帧分隔标识,无法从连续的文件流中分隔帧(尤其是vbr情况)</li>
</ul>
<p>伴随着HTML5的发展，出现了OGG媒体文件格式，Ogg是一个自由且开放标准的多媒体文件格式，由Xiph.Org基金会所维护。Ogg格式并不受到软件专利的限制，并设计用于有效率地流媒体和处理高质量的数字多媒体。“Ogg”意指一种文件格式，可以纳入各式各样自由和开放源代码的编解码器，包含音效、视频、文字（像字幕）与元数据的处理。</p>
<p>OGG音频</p>
<table>
<thead>
<tr>
<th>压缩类型</th>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>有损</td>
<td>Speek</td>
<td>以低比特率处理语音数据（〜2.1-32 kbit / s /通道）</td>
</tr>
<tr>
<td></td>
<td>Vorbis</td>
<td>处理中高级可变比特率（每通道≈16-500kbit / s）的一般音频数据</td>
</tr>
<tr>
<td></td>
<td>Opus：</td>
<td>以低和高可变比特率处理语音，音乐和通用音频（每通道≈6-510kbit / s）</td>
</tr>
<tr>
<td>无损</td>
<td>FLAC</td>
<td>处理文件和高保真音频数据</td>
</tr>
<tr>
<td>未压缩</td>
<td>OggPCM</td>
<td>处理未压缩的PCM音频,与WAV类似</td>
</tr>
</tbody></table>
<p>参考: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904016254599175">https://juejin.cn/post/6844904016254599175</a></p>
<p>借博主的图:</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/4/13/1618278801473.png" alt="OGG封装"></p>
<h2 id="java-解码OPUS文件"><a href="#java-解码OPUS文件" class="headerlink" title="java 解码OPUS文件"></a>java 解码OPUS文件</h2><p>通过ffmpeg可以轻松的将wav转换为opus文件，本质是一个ogg封装的opus，我们可以通过<code>vorbis-java</code> 来读取opus文件。</p>
<p>通过OpusInfoTool，可以打印OPUS文件信息：</p>
<pre><code>Processing file &quot;C:\Users\jqpeng\Downloads\opus\wav16k.opus&quot;

Opus Headers:
  Version: 1
  Vendor: Lavf58.27.103
  Channels: 1
  Rate: 16000Hz
  Pre-Skip: 104
  Playback Gain: 0dB

User Comments:
  encoder=Lavc58.53.100 libopus

Logical stream 81c1bbc0 (-2118009920) completed

Opus Audio:
  Total Data Packets: 579
  Total Data Length: 41406
  Audio Length Seconds: 11.564333333333334
  Audio Length: 00:00:11.56
  Packet duration:     20.0ms (max),     20.0ms (avg),     20.0ms (min)
  Page duration:     1000.0ms (max),    965.0ms (avg),    580.0ms (min)
  Total data length: 41406 (overhead: 2.34%)
  Playback length: 00:00:11.56
  Average bitrate: 28.70 kb/s, w/o overhead: 27.97 kb/s
</code></pre>
<p>再借助<code>concentus </code>，我们来解码OPUS文件为PCM文件。</p>
<pre><code>public void testDecode() throws IOException, OpusException &#123;
        FileInputStream fs = new FileInputStream(&quot;\\wav16k.opus&quot;);
        OggFile ogg = new OggFile(fs);
        OpusFile of = new OpusFile(ogg);
        OpusAudioData ad = null;

        System.out.println(of.getInfo().getSampleRate());
        System.out.println(of.getInfo().getNumChannels());

        OpusDecoder decoder = new OpusDecoder(of.getInfo().getSampleRate(),
                                              of.getInfo().getNumChannels());
        System.out.println(of.getTags());
        FileOutputStream fileOut = new FileOutputStream(&quot;wav16k.pcm&quot;);
        // 
        byte[] data_packet = new byte[of.getInfo().getSampleRate()];
        int samples = 0;
        while ((ad = of.getNextAudioPacket()) != null) &#123;
            // NOTE: samplesDecoded 是decode出来的short个数，byte需要*2
            int samplesDecoded =
                    decoder.decode(ad.getData(), 0, ad.getData().length
                            , data_packet, 0, of.getInfo().getSampleRate() / 2,
                                   false);

            fileOut.write(data_packet, 0, samplesDecoded * 2);
            samples += samplesDecoded;
        &#125;

        System.out.println(&quot;samples: &quot; + samples);
        System.out.println(&quot;durationSeconds: &quot; + (samples / 16000f));
        fileOut.close();
    &#125;
</code></pre>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/03/15/jqpeng-%E4%BD%BF%E7%94%A8jhipster%20%E5%8A%A0%E9%80%9Fjava%20web%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/03/15/jqpeng-%E4%BD%BF%E7%94%A8jhipster%20%E5%8A%A0%E9%80%9Fjava%20web%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">使用jhipster 加速java web开发</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-15 16:14:00" itemprop="dateCreated datePublished" datetime="2021-03-15T16:14:00+08:00">2021-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/jhipster.html">使用jhipster 加速java web开发</a></p>
<p>jhipster，中文释义： Java 热爱者!</p>
<blockquote>
<p>JHipster is a development platform to quickly generate, develop, &amp; deploy modern web applications &amp; microservice architectures.</p>
</blockquote>
<p>JHipster 可以通过代码生成，让你快速开发web应用和微服务。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>安装<a target="_blank" rel="noopener" href="https://adoptopenjdk.net/">Java</a>,<a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a> <a target="_blank" rel="noopener" href="https://nodejs.org/">Node.js</a></li>
<li>安装 JHipster <code>npm install -g generator-jhipster</code><ul>
<li>建议安装最新的<a target="_blank" rel="noopener" href="https://github.com/jhipster/generator-jhipster/releases/">7.0版本</a>,</li>
</ul>
</li>
<li>创建应用目录 <code>mkdir myApp &amp;&amp; cd myApp</code></li>
<li>运行<code>jhipster</code>命令，根据提示设置应用</li>
<li>可以通过<a target="_blank" rel="noopener" href="https://start.jhipster.tech/jdl-studio/">JDL Studio</a> 来生成<code>jhipster-jdl.jh</code>文件</li>
<li>然后通过<code>jhipster jdl jhipster-jdl.jh</code>来生成代码，<code>JDL</code> 后续会重点介绍</li>
</ol>
<h2 id="JDL-入门"><a href="#JDL-入门" class="headerlink" title="JDL 入门"></a>JDL 入门</h2><p>JDL 是jhipster的数据模型定义文件，通过这个文件我们可以定义数据结构，然后jhipster基于这个JDL，就可以生成实体类、服务类以及前端页面。</p>
<p>例如，我们要开发投诉建议，假如设计的数据表如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>comment</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>record_id</td>
<td>主键</td>
<td>Bigint</td>
<td>自增</td>
</tr>
<tr>
<td>feedback_type</td>
<td>反馈类型</td>
<td>unsigned tinyint</td>
<td>枚举值：[1:意见与建议;5:投诉]</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>varchar(64)</td>
<td></td>
</tr>
<tr>
<td>content</td>
<td>问题描述</td>
<td>varchar(512)</td>
<td></td>
</tr>
<tr>
<td>feedback_status</td>
<td>反馈状态</td>
<td>unsigned tinyint</td>
<td>枚举值：[1:待提交;5:待回复;10:待确认;15:已解决;]</td>
</tr>
<tr>
<td>last_reply_time</td>
<td>最后回复时间</td>
<td>timestamp</td>
<td>与feedback_status联合使用，当状态为2的时候，更新此时间，用于超时判断</td>
</tr>
<tr>
<td>close_type</td>
<td>关闭类型</td>
<td>unsigned tinyint</td>
<td>枚举值：[1:正常关闭;5:超时关闭;]</td>
</tr>
<tr>
<td>created_date</td>
<td>创建时间</td>
<td>timestamp</td>
<td></td>
</tr>
<tr>
<td>created_by</td>
<td>创建者</td>
<td>char(32)</td>
<td></td>
</tr>
</tbody></table>
<p>使用<code>jhipster</code>,我们可以用<code>jdl</code>来定义：</p>
<pre><code>/**
 * 反馈记录表
 */
entity FeedbackRecord &#123;
    /** 反馈类型*/
    feedbackType FeedbackType,
    /** 问题描述 */
    title String,
    /** 反馈状态     */
    feedbackStatus FeedbackStatus,
     /** 是否已完成 */
    lastReplyTime Integer,
     /** 关闭类型     */
    closeType FeedbackCloseType,
     /** 创建时间 */
    createdDate Instant,
    /**     创建者 */
    createdBy String
&#125;
/** 反馈类型 */
enum FeedbackType &#123;
    ADVICE,
    COMPLAINTS
&#125;
/** 反馈状态 */
enum FeedbackStatus &#123;
    TO_BE_SUBMIT, TO_BE_REPLY, TO_BE_CONFIRMED
&#125;
/** 关闭类型 */
enum FeedbackCloseType &#123;
    NORMALLY, TIMEOUT
&#125;

dto * with mapstruct
service all with serviceImpl
paginate all with pagination
</code></pre>
<p>详细讲解：</p>
<h3 id="实体和字段"><a href="#实体和字段" class="headerlink" title="实体和字段"></a>实体和字段</h3><p>entity 表示一个实体，可以增加字段，注意，不用增加id</p>
<p>语法是：</p>
<pre><code>[&lt;entity javadoc&gt;]
[&lt;entity annotation&gt;*]
entity &lt;entity name&gt; [(&lt;table name&gt;)] &#123;
  [&lt;field javadoc&gt;]
  [&lt;field annotation&gt;*]
  &lt;field name&gt; &lt;field type&gt; [&lt;validation&gt;*]
&#125;
</code></pre>
<p>例如：</p>
<pre><code>entity A &#123;
  name String required
  age Integer min(42) max(42)
&#125;
</code></pre>
<p>可以增加<code>required</code>、<code>min</code>、<code>max</code>等验证</p>
<p>字段的注释:</p>
<pre><code>/**
 * This is a comment
 * about a class
 * @author Someone
 */
entity A &#123;
  /** 名称 */
   name String
   age Integer // this is yet another comment
&#125;
</code></pre>
<p>JHipster支持许多字段类型。这种支持取决于您的数据库后端，因此我们使用Java类型来描述它们：Java<code>String</code>将以不同的方式存储在Oracle或Cassandra中，这是JHipster的优势之一，可以为您生成正确的数据库访问代码。</p>
<ul>
<li><code>String</code>: Java字符串。它的默认大小取决于基础后端（如果使用JPA，默认情况下为255），但是您可以使用校验规则进行更改（例如，修改 <code>max</code>大小为1024）。</li>
<li><code>Integer</code>: Java整数。</li>
<li><code>Long</code>: Java长整数。</li>
<li><code>Float</code>: Java浮点数.</li>
<li><code>Double</code>: Java双精度浮点数.</li>
<li><code>BigDecimal</code>: <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">java.math.BigDecimal</a>对象, 当您需要精确的数学计算时使用（通常用于财务操作）。</li>
<li><code>LocalDate</code>: <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">java.time.LocalDate</a>对象, 用于正确管理Java中的日期。</li>
<li><code>Instant</code>: <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html">java.time.Instant</a>对象, 用于表示时间戳，即时间线上的瞬时点。</li>
<li><code>ZonedDateTime</code>: <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html">java.time.ZonedDateTime</a>对象, 用于表示给定时区（通常是日历中会议、约定）中的本地日期时间。请注意，REST和持久层都不支持时区，因此您很可能应该使用<code>Instant</code>。</li>
<li><code>Duration</code>: <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html">java.time.Duration</a>对象, 用于表示时间量。</li>
<li><code>UUID</code>: <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html">java.util.UUID</a>对象.</li>
<li><code>Boolean</code>: Java布尔型.</li>
<li><code>Enumeration</code>:Java枚举对象。选择此类型后，子生成器将询问您要在枚举中使用哪些值，并将创建一个特定的<code>enum</code>类来存储它们。</li>
<li><code>Blob</code>: Blob对象，用于存储一些二进制数据。选择此类型时，子生成器将询问您是否要存储通用二进制数据，图像对象或CLOB（长文本）。图像将专门在Angular侧进行优化处理，因此可以将其正常显示给最终用户。</li>
</ul>
<p>字段的数据类型及数据库支持：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/b8149b95c85096326712cb9228e7245ad86e778ae01e53f8cf59c3541aac229f.png" alt="数据类型"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>对于可枚举的状态，建议采用枚举值：</p>
<pre><code>enum [&lt;enum name&gt;] &#123;
  &lt;ENUM KEY&gt; ([&lt;enum value&gt;])
&#125;
</code></pre>
<p>例如：</p>
<pre><code>/** 反馈类型 */
enum FeedbackType &#123;
    ADVICE,
    COMPLAINTS
&#125;
</code></pre>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>SQL数据库支持表和表的关联：</p>
<ul>
<li><code>OneToOne</code></li>
<li><code>OneToMany</code></li>
<li><code>ManyToOne</code></li>
<li><code>ManyToMany</code></li>
</ul>
<p>如何定义关系呢？</p>
<pre><code>relationship (OneToMany | ManyToOne | OneToOne | ManyToMany) &#123;
  &lt;from entity&gt;[&#123;&lt;relationship name&gt;[(&lt;display field&gt;)]&#125;] to &lt;to entity&gt;[&#123;&lt;relationship name&gt;[(&lt;display field&gt;)]&#125;]+
&#125;
</code></pre>
<p>例如, 下面的例子里，我们定义两个对象，<code>File</code>和<code>Chunk</code>，1个<code>Chunk</code>属于一个<code>File</code>：</p>
<pre><code>/**
 * 文件
 */
entity File &#123;
    /** 文件名 */
    name String,
    /** 文件大小 */
    size Long,
    /** 文件路径 */
    path String,
    /** 分片数 */
    chunks Integer,
     /** 是否已完成 */
    complete Integer
&#125;

/**
 * 文件分片
 */
entity Chunk &#123;
    /** md5值 */
    md5 String,
    /** 分片序号 */
    number Integer,
    /** 分片名称 */
    name String
&#125;

relationship ManyToOne &#123;
    /** 所属文件 */
    Chunk&#123;file&#125; to File
&#125;
</code></pre>
<p>对应的关系图：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/5678aa9b0f1462f73e224f3a075fc3ebf7ebcb54f39f2fab44498e4cba7f0330.png" alt="关系图"></p>
<h3 id="生成代码配置"><a href="#生成代码配置" class="headerlink" title="生成代码配置"></a>生成代码配置</h3><p>JHipster提供了丰富的配置，可以用来指定生成代码时的策略，例如是否要生成<code>DTO对象</code>，是否需要支持分页，是否需要生成service类，如果生成service，是使用<code>serviceClass</code>还是<code>serviceImpl</code>。</p>
<p>示例如下：</p>
<pre><code>entity A &#123;
  name String required
&#125;
entity B
entity C

// 筛选实体
filter *

// 生成dto
dto A, B with mapstruct

// 分页
paginate A with infinite-scroll
paginate B with pagination
paginate C with pager  // pager is only available in AngularJS

// 生成service
service A with serviceClass
service C with serviceImpl
</code></pre>
<h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>首先定义<code>jdl</code>文件：</p>
<pre><code>/**
 * 反馈记录表
 */
entity FeedbackRecord &#123;
    /** 反馈类型*/
    feedbackType FeedbackType,
    /** 问题描述 */
    title String,
    /** 反馈状态     */
    feedbackStatus FeedbackStatus,
     /** 是否已完成 */
    lastReplyTime Integer,
     /** 关闭类型     */
    closeType FeedbackCloseType,
     /** 创建时间 */
    createdDate Instant,
    /**     创建者 */
    createdBy String
&#125;
/** 反馈类型 */
enum FeedbackType &#123;
    ADVICE,
    COMPLAINTS
&#125;
/** 反馈状态 */
enum FeedbackStatus &#123;
    TO_BE_SUBMIT, TO_BE_REPLY, TO_BE_CONFIRMED
&#125;
/** 关闭类型 */
enum FeedbackCloseType &#123;
    NORMALLY, TIMEOUT
&#125;
// 筛选实体
filter *
// 生成DTO
dto * with mapstruct
// 生成带接口和实现的service
service all with serviceImpl
// 支持分页
paginate all with pagination
</code></pre>
<p>然后生成代码：</p>
<pre><code>jhipster jdl feedback.jh --force
</code></pre>
<p>可以看到类似下面的输出</p>
<pre><code>D:\Project\jhipster-7&gt;jhipster jdl feedback.jh --force
INFO! Using JHipster version installed locally in current project&#39;s node_modules
INFO! Executing import-jdl feedback.jh
INFO! The JDL is being parsed.
info: The dto option is set for FeedbackRecord, the &#39;serviceClass&#39; value for the &#39;service&#39; is gonna be set for this entity if no other value has been set.
INFO! Found entities: FeedbackRecord.
INFO! The JDL has been successfully parsed
INFO! Generating 0 applications.
INFO! Generating 1 entity.
INFO! Generating entities for application undefined in a new parallel process

Found the D:\Project\jhipster-7\.jhipster\File.json configuration file, entity can be automatically generated!


Found the D:\Project\jhipster-7\.jhipster\Chunk.json configuration file, entity can be automatically generated!


Found the D:\Project\jhipster-7\.jhipster\FeedbackRecord.json configuration file, entity can be automatically generated!

     info Creating changelog for entities File,Chunk,FeedbackRecord
    force .yo-rc.json
    force .jhipster\FeedbackRecord.json
    force .jhipster\File.json
    force .jhipster\Chunk.json
    force src\main\java\com\company\blog\domain\File.java
    force src\main\java\com\company\blog\web\rest\FileResource.java
    force src\main\java\com\company\blog\repository\FileRepository.java
    force src\main\java\com\company\blog\service\FileService.java
    force src\main\java\com\company\blog\service\impl\FileServiceImpl.java
    force src\main\java\com\company\blog\service\dto\FileDTO.java
    force src\main\java\com\company\blog\service\mapper\EntityMapper.java
    force src\main\java\com\company\blog\service\mapper\FileMapper.java
    force src\test\java\com\company\blog\web\rest\FileResourceIT.java
    force src\test\java\com\company\blog\domain\FileTest.java
    force src\test\java\com\company\blog\service\dto\FileDTOTest.java
    force src\test\java\com\company\blog\service\mapper\FileMapperTest.java
    force src\main\webapp\app\shared\model\file.model.ts
    force src\main\webapp\app\entities\file\file-details.vue
    force src\main\webapp\app\entities\file\file-details.component.ts
    force src\main\webapp\app\entities\file\file.vue
    force src\main\webapp\app\entities\file\file.component.ts
    force src\main\webapp\app\entities\file\file.service.ts
    force src\main\webapp\app\entities\file\file-update.vue
    force src\main\webapp\app\entities\file\file-update.component.ts
    force src\test\javascript\spec\app\entities\file\file.component.spec.ts
    force src\test\javascript\spec\app\entities\file\file-details.component.spec.ts
    force src\test\javascript\spec\app\entities\file\file.service.spec.ts
    force src\test\javascript\spec\app\entities\file\file-update.component.spec.ts
    force src\main\webapp\app\router\entities.ts
    force src\main\webapp\app\main.ts
    force src\main\webapp\app\core\jhi-navbar\jhi-navbar.vue
    force src\main\webapp\i18n\zh-cn\file.json
    force src\main\webapp\i18n\zh-cn\global.json
    force src\main\webapp\i18n\en\file.json
    force src\main\webapp\i18n\en\global.json
    force src\main\java\com\company\blog\domain\Chunk.java
    force src\main\java\com\company\blog\web\rest\ChunkResource.java
    force src\main\java\com\company\blog\repository\ChunkRepository.java
    force src\main\java\com\company\blog\service\ChunkService.java
    force src\main\java\com\company\blog\service\impl\ChunkServiceImpl.java
    force src\main\java\com\company\blog\service\dto\ChunkDTO.java
    force src\main\java\com\company\blog\service\mapper\ChunkMapper.java
    force src\test\java\com\company\blog\web\rest\ChunkResourceIT.java
    force src\test\java\com\company\blog\domain\ChunkTest.java
    force src\test\java\com\company\blog\service\dto\ChunkDTOTest.java
    force src\test\java\com\company\blog\service\mapper\ChunkMapperTest.java
    force src\main\webapp\app\shared\model\chunk.model.ts
    force src\main\webapp\app\entities\chunk\chunk-details.vue
    force src\main\webapp\app\entities\chunk\chunk-details.component.ts
    force src\main\webapp\app\entities\chunk\chunk.vue
    force src\main\webapp\app\entities\chunk\chunk.component.ts
    force src\main\webapp\app\entities\chunk\chunk.service.ts
    force src\main\webapp\app\entities\chunk\chunk-update.vue
    force src\main\webapp\app\entities\chunk\chunk-update.component.ts
    force src\test\javascript\spec\app\entities\chunk\chunk.component.spec.ts
    force src\test\javascript\spec\app\entities\chunk\chunk-details.component.spec.ts
    force src\test\javascript\spec\app\entities\chunk\chunk.service.spec.ts
    force src\test\javascript\spec\app\entities\chunk\chunk-update.component.spec.ts
    force src\main\webapp\i18n\zh-cn\chunk.json
    force src\main\webapp\i18n\en\chunk.json
   create src\main\java\com\company\blog\domain\FeedbackRecord.java
   create src\main\java\com\company\blog\web\rest\FeedbackRecordResource.java
   create src\main\java\com\company\blog\repository\FeedbackRecordRepository.java
   create src\main\java\com\company\blog\service\FeedbackRecordService.java
   create src\main\java\com\company\blog\service\impl\FeedbackRecordServiceImpl.java
   create src\main\java\com\company\blog\service\dto\FeedbackRecordDTO.java
   create src\main\java\com\company\blog\service\mapper\FeedbackRecordMapper.java
   create src\test\java\com\company\blog\web\rest\FeedbackRecordResourceIT.java
   create src\test\java\com\company\blog\domain\FeedbackRecordTest.java
   create src\test\java\com\company\blog\service\dto\FeedbackRecordDTOTest.java
   create src\test\java\com\company\blog\service\mapper\FeedbackRecordMapperTest.java
   create src\main\java\com\company\blog\domain\enumeration\FeedbackType.java
   create src\main\java\com\company\blog\domain\enumeration\FeedbackStatus.java
   create src\main\java\com\company\blog\domain\enumeration\FeedbackCloseType.java
   create src\main\webapp\app\shared\model\feedback-record.model.ts
   create src\main\webapp\app\entities\feedback-record\feedback-record-details.vue
   create src\main\webapp\app\entities\feedback-record\feedback-record-details.component.ts
   create src\main\webapp\app\entities\feedback-record\feedback-record.vue
   create src\main\webapp\app\entities\feedback-record\feedback-record.component.ts
   create src\main\webapp\app\entities\feedback-record\feedback-record.service.ts
    force src\main\resources\config\liquibase\changelog\20210312045459_added_entity_File.xml
    force src\main\resources\config\liquibase\fake-data\file.csv
   create src\main\webapp\app\entities\feedback-record\feedback-record-update.vue
    force src\main\resources\config\liquibase\master.xml
    force src\main\resources\config\liquibase\changelog\20210312045500_added_entity_Chunk.xml
    force src\main\resources\config\liquibase\changelog\20210312045500_added_entity_constraints_Chunk.xml
    force src\main\resources\config\liquibase\fake-data\chunk.csv
   create src\main\resources\config\liquibase\changelog\20210312072243_added_entity_FeedbackRecord.xml
   create src\main\resources\config\liquibase\fake-data\feedback_record.csv
   create src\main\webapp\app\entities\feedback-record\feedback-record-update.component.ts
   create src\test\javascript\spec\app\entities\feedback-record\feedback-record.component.spec.ts
   create src\test\javascript\spec\app\entities\feedback-record\feedback-record-details.component.spec.ts
   create src\test\javascript\spec\app\entities\feedback-record\feedback-record.service.spec.ts
   create src\test\javascript\spec\app\entities\feedback-record\feedback-record-update.component.spec.ts
   create src\main\webapp\app\shared\model\enumerations\feedback-type.model.ts
   create src\main\webapp\app\shared\model\enumerations\feedback-status.model.ts
   create src\main\webapp\app\shared\model\enumerations\feedback-close-type.model.ts
   create src\main\webapp\i18n\zh-cn\feedbackType.json
   create src\main\webapp\i18n\en\feedbackType.json
   create src\main\webapp\i18n\zh-cn\feedbackStatus.json
   create src\main\webapp\i18n\en\feedbackStatus.json
   create src\main\webapp\i18n\zh-cn\feedbackCloseType.json
   create src\main\webapp\i18n\en\feedbackCloseType.json
   create src\main\webapp\i18n\zh-cn\feedbackRecord.json
   create src\main\webapp\i18n\en\feedbackRecord.json
Entity File generated successfully.
Entity Chunk generated successfully.
Entity FeedbackRecord generated successfully.

Running `webapp:build` to update client app
</code></pre>
<p>包含domain、service、controller等都有生成：</p>
<h2 id="测试生成程序"><a href="#测试生成程序" class="headerlink" title="测试生成程序"></a>测试生成程序</h2><p>运行程序，</p>
<p>列表页面：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/dfb9592f5a57bfd645ff822113534f78480cb8d52cd59b915f6dd8d017f22a46.png" alt="列表页面"></p>
<p>编辑页面：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/0dc5aa933e3186e0b3daf6c44637601204cecd894a66acfc38142fdda7713243.png" alt="编辑页面"></p>
<h2 id="生成代码介绍"><a href="#生成代码介绍" class="headerlink" title="生成代码介绍"></a>生成代码介绍</h2><h3 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h3><pre><code>package com.company.blog.domain;

import com.company.blog.domain.enumeration.FeedbackCloseType;
import com.company.blog.domain.enumeration.FeedbackStatus;
import com.company.blog.domain.enumeration.FeedbackType;
import java.io.Serializable;
import java.time.Instant;
import javax.persistence.*;

/**
 * 反馈记录表
 */
@Entity
@Table(name = &quot;feedback_record&quot;)
public class FeedbackRecord implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 反馈类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = &quot;feedback_type&quot;)
    private FeedbackType feedbackType;

    /**
     * 问题描述
     */
    @Column(name = &quot;title&quot;)
    private String title;

    /**
     * 反馈状态
     */
    @Enumerated(EnumType.STRING)
    @Column(name = &quot;feedback_status&quot;)
    private FeedbackStatus feedbackStatus;

    /**
     * 是否已完成
     */
    @Column(name = &quot;last_reply_time&quot;)
    private Integer lastReplyTime;

    /**
     * 关闭类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = &quot;close_type&quot;)
    private FeedbackCloseType closeType;

    /**
     * 创建时间
     */
    @Column(name = &quot;created_date&quot;)
    private Instant createdDate;

    /**
     * 创建者
     */
    @Column(name = &quot;created_by&quot;)
    private String createdBy;

    // jhipster-needle-entity-add-field - JHipster will add fields here
    public Long getId() &#123;
        return id;
    &#125;

    public void setId(Long id) &#123;
        this.id = id;
    &#125;

    public FeedbackRecord id(Long id) &#123;
        this.id = id;
        return this;
    &#125;

    public FeedbackType getFeedbackType() &#123;
        return this.feedbackType;
    &#125;

    public FeedbackRecord feedbackType(FeedbackType feedbackType) &#123;
        this.feedbackType = feedbackType;
        return this;
    &#125;

    public void setFeedbackType(FeedbackType feedbackType) &#123;
        this.feedbackType = feedbackType;
    &#125;

    public String getTitle() &#123;
        return this.title;
    &#125;

    public FeedbackRecord title(String title) &#123;
        this.title = title;
        return this;
    &#125;

    public void setTitle(String title) &#123;
        this.title = title;
    &#125;

    public FeedbackStatus getFeedbackStatus() &#123;
        return this.feedbackStatus;
    &#125;

    public FeedbackRecord feedbackStatus(FeedbackStatus feedbackStatus) &#123;
        this.feedbackStatus = feedbackStatus;
        return this;
    &#125;

    public void setFeedbackStatus(FeedbackStatus feedbackStatus) &#123;
        this.feedbackStatus = feedbackStatus;
    &#125;

    public Integer getLastReplyTime() &#123;
        return this.lastReplyTime;
    &#125;

    public FeedbackRecord lastReplyTime(Integer lastReplyTime) &#123;
        this.lastReplyTime = lastReplyTime;
        return this;
    &#125;

    public void setLastReplyTime(Integer lastReplyTime) &#123;
        this.lastReplyTime = lastReplyTime;
    &#125;

    public FeedbackCloseType getCloseType() &#123;
        return this.closeType;
    &#125;

    public FeedbackRecord closeType(FeedbackCloseType closeType) &#123;
        this.closeType = closeType;
        return this;
    &#125;

    public void setCloseType(FeedbackCloseType closeType) &#123;
        this.closeType = closeType;
    &#125;

    public Instant getCreatedDate() &#123;
        return this.createdDate;
    &#125;

    public FeedbackRecord createdDate(Instant createdDate) &#123;
        this.createdDate = createdDate;
        return this;
    &#125;

    public void setCreatedDate(Instant createdDate) &#123;
        this.createdDate = createdDate;
    &#125;

    public String getCreatedBy() &#123;
        return this.createdBy;
    &#125;

    public FeedbackRecord createdBy(String createdBy) &#123;
        this.createdBy = createdBy;
        return this;
    &#125;

    public void setCreatedBy(String createdBy) &#123;
        this.createdBy = createdBy;
    &#125;

    // jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) &#123;
            return true;
        &#125;
        if (!(o instanceof FeedbackRecord)) &#123;
            return false;
        &#125;
        return id != null &amp;&amp; id.equals(((FeedbackRecord) o).id);
    &#125;

    @Override
    public int hashCode() &#123;
        // see https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/
        return getClass().hashCode();
    &#125;

    // prettier-ignore
    @Override
    public String toString() &#123;
        return &quot;FeedbackRecord&#123;&quot; +
            &quot;id=&quot; + getId() +
            &quot;, feedbackType=&#39;&quot; + getFeedbackType() + &quot;&#39;&quot; +
            &quot;, title=&#39;&quot; + getTitle() + &quot;&#39;&quot; +
            &quot;, feedbackStatus=&#39;&quot; + getFeedbackStatus() + &quot;&#39;&quot; +
            &quot;, lastReplyTime=&quot; + getLastReplyTime() +
            &quot;, closeType=&#39;&quot; + getCloseType() + &quot;&#39;&quot; +
            &quot;, createdDate=&#39;&quot; + getCreatedDate() + &quot;&#39;&quot; +
            &quot;, createdBy=&#39;&quot; + getCreatedBy() + &quot;&#39;&quot; +
            &quot;&#125;&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><pre><code>@SuppressWarnings(&quot;unused&quot;)
@Repository
public interface FeedbackRecordRepository extends JpaRepository&lt;FeedbackRecord, Long&gt;, JpaSpecificationExecutor&lt;FeedbackRecord&gt; &#123;&#125;
</code></pre>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><pre><code>/**
 * Service Interface for managing &#123;@link com.company.blog.domain.FeedbackRecord&#125;.
 */
public interface FeedbackRecordService &#123;
    /**
     * Save a feedbackRecord.
     *
     * @param feedbackRecordDTO the entity to save.
     * @return the persisted entity.
     */
    FeedbackRecordDTO save(FeedbackRecordDTO feedbackRecordDTO);

    /**
     * Partially updates a feedbackRecord.
     *
     * @param feedbackRecordDTO the entity to update partially.
     * @return the persisted entity.
     */
    Optional&lt;FeedbackRecordDTO&gt; partialUpdate(FeedbackRecordDTO feedbackRecordDTO);

    /**
     * Get all the feedbackRecords.
     *
     * @param pageable the pagination information.
     * @return the list of entities.
     */
    Page&lt;FeedbackRecordDTO&gt; findAll(Pageable pageable);

    /**
     * Get the &quot;id&quot; feedbackRecord.
     *
     * @param id the id of the entity.
     * @return the entity.
     */
    Optional&lt;FeedbackRecordDTO&gt; findOne(Long id);

    /**
     * Delete the &quot;id&quot; feedbackRecord.
     *
     * @param id the id of the entity.
     */
    void delete(Long id);
&#125;
</code></pre>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><pre><code>/**
 * REST controller for managing &#123;@link com.company.blog.domain.FeedbackRecord&#125;.
 */
@RestController
@RequestMapping(&quot;/api&quot;)
public class FeedbackRecordResource &#123;

    private final Logger log = LoggerFactory.getLogger(FeedbackRecordResource.class);

    private static final String ENTITY_NAME = &quot;feedbackRecord&quot;;

    @Value(&quot;$&#123;jhipster.clientApp.name&#125;&quot;)
    private String applicationName;

    private final FeedbackRecordService feedbackRecordService;

    private final FeedbackRecordQueryService feedbackRecordQueryService;

    public FeedbackRecordResource(FeedbackRecordService feedbackRecordService, FeedbackRecordQueryService feedbackRecordQueryService) &#123;
        this.feedbackRecordService = feedbackRecordService;
        this.feedbackRecordQueryService = feedbackRecordQueryService;
    &#125;

    /**
     * &#123;@code POST  /feedback-records&#125; : Create a new feedbackRecord.
     *
     * @param feedbackRecordDTO the feedbackRecordDTO to create.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 201 (Created)&#125; and with body the new feedbackRecordDTO, or with status &#123;@code 400 (Bad Request)&#125; if the feedbackRecord has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping(&quot;/feedback-records&quot;)
    public ResponseEntity&lt;FeedbackRecordDTO&gt; createFeedbackRecord(@RequestBody FeedbackRecordDTO feedbackRecordDTO)
        throws URISyntaxException &#123;
        log.debug(&quot;REST request to save FeedbackRecord : &#123;&#125;&quot;, feedbackRecordDTO);
        if (feedbackRecordDTO.getId() != null) &#123;
            throw new BadRequestAlertException(&quot;A new feedbackRecord cannot already have an ID&quot;, ENTITY_NAME, &quot;idexists&quot;);
        &#125;
        FeedbackRecordDTO result = feedbackRecordService.save(feedbackRecordDTO);
        return ResponseEntity
            .created(new URI(&quot;/api/feedback-records/&quot; + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getId().toString()))
            .body(result);
    &#125;

    /**
     * &#123;@code PUT  /feedback-records&#125; : Updates an existing feedbackRecord.
     *
     * @param feedbackRecordDTO the feedbackRecordDTO to update.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and with body the updated feedbackRecordDTO,
     * or with status &#123;@code 400 (Bad Request)&#125; if the feedbackRecordDTO is not valid,
     * or with status &#123;@code 500 (Internal Server Error)&#125; if the feedbackRecordDTO couldn&#39;t be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PutMapping(&quot;/feedback-records&quot;)
    public ResponseEntity&lt;FeedbackRecordDTO&gt; updateFeedbackRecord(@RequestBody FeedbackRecordDTO feedbackRecordDTO)
        throws URISyntaxException &#123;
        log.debug(&quot;REST request to update FeedbackRecord : &#123;&#125;&quot;, feedbackRecordDTO);
        if (feedbackRecordDTO.getId() == null) &#123;
            throw new BadRequestAlertException(&quot;Invalid id&quot;, ENTITY_NAME, &quot;idnull&quot;);
        &#125;
        FeedbackRecordDTO result = feedbackRecordService.save(feedbackRecordDTO);
        return ResponseEntity
            .ok()
            .headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, feedbackRecordDTO.getId().toString()))
            .body(result);
    &#125;

    /**
     * &#123;@code PATCH  /feedback-records&#125; : Updates given fields of an existing feedbackRecord.
     *
     * @param feedbackRecordDTO the feedbackRecordDTO to update.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and with body the updated feedbackRecordDTO,
     * or with status &#123;@code 400 (Bad Request)&#125; if the feedbackRecordDTO is not valid,
     * or with status &#123;@code 404 (Not Found)&#125; if the feedbackRecordDTO is not found,
     * or with status &#123;@code 500 (Internal Server Error)&#125; if the feedbackRecordDTO couldn&#39;t be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PatchMapping(value = &quot;/feedback-records&quot;, consumes = &quot;application/merge-patch+json&quot;)
    public ResponseEntity&lt;FeedbackRecordDTO&gt; partialUpdateFeedbackRecord(@RequestBody FeedbackRecordDTO feedbackRecordDTO)
        throws URISyntaxException &#123;
        log.debug(&quot;REST request to update FeedbackRecord partially : &#123;&#125;&quot;, feedbackRecordDTO);
        if (feedbackRecordDTO.getId() == null) &#123;
            throw new BadRequestAlertException(&quot;Invalid id&quot;, ENTITY_NAME, &quot;idnull&quot;);
        &#125;

        Optional&lt;FeedbackRecordDTO&gt; result = feedbackRecordService.partialUpdate(feedbackRecordDTO);

        return ResponseUtil.wrapOrNotFound(
            result,
            HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, feedbackRecordDTO.getId().toString())
        );
    &#125;

    /**
     * &#123;@code GET  /feedback-records&#125; : get all the feedbackRecords.
     *
     * @param pageable the pagination information.
     * @param criteria the criteria which the requested entities should match.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and the list of feedbackRecords in body.
     */
    @GetMapping(&quot;/feedback-records&quot;)
    public ResponseEntity&lt;List&lt;FeedbackRecordDTO&gt;&gt; getAllFeedbackRecords(FeedbackRecordCriteria criteria, Pageable pageable) &#123;
        log.debug(&quot;REST request to get FeedbackRecords by criteria: &#123;&#125;&quot;, criteria);
        Page&lt;FeedbackRecordDTO&gt; page = feedbackRecordQueryService.findByCriteria(criteria, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return ResponseEntity.ok().headers(headers).body(page.getContent());
    &#125;

    /**
     * &#123;@code GET  /feedback-records/count&#125; : count all the feedbackRecords.
     *
     * @param criteria the criteria which the requested entities should match.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and the count in body.
     */
    @GetMapping(&quot;/feedback-records/count&quot;)
    public ResponseEntity&lt;Long&gt; countFeedbackRecords(FeedbackRecordCriteria criteria) &#123;
        log.debug(&quot;REST request to count FeedbackRecords by criteria: &#123;&#125;&quot;, criteria);
        return ResponseEntity.ok().body(feedbackRecordQueryService.countByCriteria(criteria));
    &#125;

    /**
     * &#123;@code GET  /feedback-records/:id&#125; : get the &quot;id&quot; feedbackRecord.
     *
     * @param id the id of the feedbackRecordDTO to retrieve.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and with body the feedbackRecordDTO, or with status &#123;@code 404 (Not Found)&#125;.
     */
    @GetMapping(&quot;/feedback-records/&#123;id&#125;&quot;)
    public ResponseEntity&lt;FeedbackRecordDTO&gt; getFeedbackRecord(@PathVariable Long id) &#123;
        log.debug(&quot;REST request to get FeedbackRecord : &#123;&#125;&quot;, id);
        Optional&lt;FeedbackRecordDTO&gt; feedbackRecordDTO = feedbackRecordService.findOne(id);
        return ResponseUtil.wrapOrNotFound(feedbackRecordDTO);
    &#125;

    /**
     * &#123;@code DELETE  /feedback-records/:id&#125; : delete the &quot;id&quot; feedbackRecord.
     *
     * @param id the id of the feedbackRecordDTO to delete.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 204 (NO_CONTENT)&#125;.
     */
    @DeleteMapping(&quot;/feedback-records/&#123;id&#125;&quot;)
    public ResponseEntity&lt;Void&gt; deleteFeedbackRecord(@PathVariable Long id) &#123;
        log.debug(&quot;REST request to delete FeedbackRecord : &#123;&#125;&quot;, id);
        feedbackRecordService.delete(id);
        return ResponseEntity
            .noContent()
            .headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, ENTITY_NAME, id.toString()))
            .build();
    &#125;
&#125;
</code></pre>
<h3 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h3><p>获取数据</p>
<pre><code>    @GetMapping(&quot;/feedback-records&quot;)
    public ResponseEntity&lt;List&lt;FeedbackRecordDTO&gt;&gt; getAllFeedbackRecords(FeedbackRecordCriteria criteria, Pageable pageable) &#123;
        log.debug(&quot;REST request to get FeedbackRecords by criteria: &#123;&#125;&quot;, criteria);
        Page&lt;FeedbackRecordDTO&gt; page = feedbackRecordQueryService.findByCriteria(criteria, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return ResponseEntity.ok().headers(headers).body(page.getContent());
    &#125;
</code></pre>
<p>这里有意思的是<code>FeedbackRecordCriteria</code>，可以针对实体中的每个字段进行过滤，不用单独写业务代码去过滤：</p>
<p>比如<code>feedbackStatus</code>是一个枚举，那么可以使用<code>equals</code>，<code>in</code> 等过过滤器。</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/1d9808d0eda2d85271774a65f23b896fccad85c64dd2809615ced2118f3cad4b.png" alt="feedbackStatus"></p>
<p>关于过滤器：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/d8bb64214258bdc59187a085495f9a07e5b94ae8de47490d23c8969a4a3fb43f.png" alt="过滤器"></p>
<p>我们测试下，比如查询<code>feedbackStatus</code> 为 <code>TO_BE_REPLY</code>的，那么可以使用<code>feedbackStatus.equals=TO_BE_REPLY</code></p>
<pre><code>GET http://localhost:8080/api/feedback-records?sort=id,asc&amp;page=0&amp;size=20&amp;feedbackStatus.equals=TO_BE_REPLY




[
    &#123;
        &quot;id&quot;: 1,
        &quot;feedbackType&quot;: &quot;COMPLAINTS&quot;,
        &quot;title&quot;: &quot;SMTP lavender Table&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 9391,
        &quot;closeType&quot;: &quot;NORMALLY&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T21:38:31Z&quot;,
        &quot;createdBy&quot;: &quot;新疆 Central Soft&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;上海市 haptic&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 53521,
        &quot;closeType&quot;: &quot;NORMALLY&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T18:04:14Z&quot;,
        &quot;createdBy&quot;: &quot;Rubber connect 桥&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 4,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;Senior index&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 67874,
        &quot;closeType&quot;: &quot;TIMEOUT&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T14:53:15Z&quot;,
        &quot;createdBy&quot;: &quot;Uganda&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 6,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;Expanded Sports compelling&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 8032,
        &quot;closeType&quot;: &quot;TIMEOUT&quot;,
        &quot;createdDate&quot;: &quot;2021-03-12T03:53:46Z&quot;,
        &quot;createdBy&quot;: &quot;deposit Chicken mesh&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 7,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;Division overriding&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 38000,
        &quot;closeType&quot;: &quot;NORMALLY&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T07:57:51Z&quot;,
        &quot;createdBy&quot;: &quot;Account stable&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 9,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;Loan&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 99908,
        &quot;closeType&quot;: &quot;TIMEOUT&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T09:47:44Z&quot;,
        &quot;createdBy&quot;: &quot;Re-engineered&quot;
    &#125;
]
</code></pre>
<h2 id="JHipster-管理界面介绍"><a href="#JHipster-管理界面介绍" class="headerlink" title="JHipster 管理界面介绍"></a>JHipster 管理界面介绍</h2><p>JHipster 自动生成的前端代码里，包含了一些管理界面：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/1ae0597aba92bc958635fce65666676237a007614ad17227a6bb84a46af2f3ef.png" alt="管理界面"></p>
<p>资源监控：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/cd050dc19d39a0a3171ea4e8d883e921a76b0bb768cd51c2535f0124dcbcff26.png" alt="资源监控"></p>
<h2 id="开发实践"><a href="#开发实践" class="headerlink" title="开发实践"></a>开发实践</h2><h3 id="更新实体增加字段"><a href="#更新实体增加字段" class="headerlink" title="更新实体增加字段"></a>更新实体增加字段</h3><p>在项目的工程目录下，有一个<code>.jhipster</code>文件夹，里面包含了已有的实体。</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/ad9cdc11084c56f5f78ff6aed3647038a94199516d87c59bf5aac780d928f1cd.png" alt="已有实体"></p>
<p>要为实体增加字段，可以打开json文件，在fields里新增即可，比如我们增加一个content字段。</p>
<pre><code>&#123;
  &quot;name&quot;: &quot;FeedbackRecord&quot;,
  &quot;fields&quot;: [
    &#123;
      &quot;fieldName&quot;: &quot;feedbackType&quot;,
      &quot;fieldType&quot;: &quot;FeedbackType&quot;,
      &quot;javadoc&quot;: &quot;反馈类型&quot;,
      &quot;fieldValues&quot;: &quot;ADVICE,COMPLAINTS&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;title&quot;,
      &quot;fieldType&quot;: &quot;String&quot;,
      &quot;javadoc&quot;: &quot;问题描述&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;content&quot;,
      &quot;fieldType&quot;: &quot;String&quot;,
      &quot;javadoc&quot;: &quot;问题详情&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;feedbackStatus&quot;,
      &quot;fieldType&quot;: &quot;FeedbackStatus&quot;,
      &quot;javadoc&quot;: &quot;反馈状态&quot;,
      &quot;fieldValues&quot;: &quot;TO_BE_SUBMIT,TO_BE_REPLY,TO_BE_CONFIRMED&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;lastReplyTime&quot;,
      &quot;fieldType&quot;: &quot;Integer&quot;,
      &quot;javadoc&quot;: &quot;是否已完成&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;closeType&quot;,
      &quot;fieldType&quot;: &quot;FeedbackCloseType&quot;,
      &quot;javadoc&quot;: &quot;关闭类型&quot;,
      &quot;fieldValues&quot;: &quot;NORMALLY,TIMEOUT&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;createdDate&quot;,
      &quot;fieldType&quot;: &quot;Instant&quot;,
      &quot;javadoc&quot;: &quot;创建时间&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;createdBy&quot;,
      &quot;fieldType&quot;: &quot;String&quot;,
      &quot;javadoc&quot;: &quot;创建者&quot;
    &#125;
  ],
  &quot;relationships&quot;: [],
  &quot;javadoc&quot;: &quot;反馈记录表&quot;,
  &quot;entityTableName&quot;: &quot;feedback_record&quot;,
  &quot;dto&quot;: &quot;mapstruct&quot;,
  &quot;pagination&quot;: &quot;pagination&quot;,
  &quot;service&quot;: &quot;serviceImpl&quot;,
  &quot;jpaMetamodelFiltering&quot;: true,
  &quot;fluentMethods&quot;: true,
  &quot;readOnly&quot;: false,
  &quot;embedded&quot;: false,
  &quot;applications&quot;: &quot;*&quot;,
  &quot;changelogDate&quot;: &quot;20210312072243&quot;
&#125;
</code></pre>
<p>再次运行实体生成器：</p>
<pre><code>jhipster entity FeedbackRecord
</code></pre>
<p>当您为现有实体运行实体子生成器时，系统会询问您“Do you want to update the entity? This will replace the existing files for this entity, all your custom code will be overwritten”(您确定需要更新实体吗？这将替换该实体的现有文件，所有自定义代码将被覆盖)，并具有以下选项：</p>
<ul>
<li><code>Yes, re generate the entity</code> - 这将重新生成您的实体。提示：这可以通过在运行子生成器时传递<code>--regenerate</code>标志来强制执行</li>
<li><code>Yes, add more fields and relationships</code> - 这将需要您回答一些问题，以添加更多字段和关系</li>
<li><code>Yes, remove fields and relationships</code> - 这将需要您回答一些问题，以便从实体中删除现有字段和关系</li>
<li><code>No, exit</code> - 这将存在子生成器而无需更改任何内容</li>
</ul>
<p>您可能由于以下原因而要更新您的实体：</p>
<p>提示：要立即重新生成所有实体，可以使用以下命令（不提供<code>--force</code>标识会在文件更改时询问覆盖选项）。</p>
<ul>
<li>Linux &amp; Mac: <code>for f in</code>ls .jhipster<code>; do jhipster entity $&#123;f%.*&#125; --force ; done</code></li>
<li>Windows: <code>for %f in (.jhipster/*) do jhipster entity %~nf --force</code></li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/02/08/jqpeng-%E4%BB%8ESpring%E6%A1%86%E6%9E%B6%E7%9C%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/02/08/jqpeng-%E4%BB%8ESpring%E6%A1%86%E6%9E%B6%E7%9C%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">从Spring框架看设计模式如何灵活使用</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-08 18:05:00" itemprop="dateCreated datePublished" datetime="2021-02-08T18:05:00+08:00">2021-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-design-pattern.html">从Spring框架看设计模式如何灵活使用</a></p>
<h2 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h2><p>单例模式是确保每个应用程序只存在一个实例的机制。默认情况下，Spring将所有bean创建为单例。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/8/1612778162513.png" alt="单例模式"></p>
<p>你用@Autowired获取的bean，全局唯一。</p>
<pre><code>@RestController
public class LibraryController &#123;
    
    @Autowired
    private BookRepository repository;

    @GetMapping(&quot;/count&quot;)
    public Long findCount() &#123;
        System.out.println(repository);
        return repository.count();
    &#125;
&#125;
</code></pre>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>Spring 定义了BeanFactory接口，抽象对象容器：</p>
<pre><code>public interface BeanFactory &#123;

    getBean(Class&lt;T&gt; requiredType);
    getBean(Class&lt;T&gt; requiredType, Object... args);
    getBean(String name);

    // ...
]
</code></pre>
<p>每一个<code>getBean</code> 方法其实就是一个工厂方法。</p>
<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/8/1612778397869.png" alt="代理模式"></p>
<p>在Spring中，对于事务，我们可以加一个<code>@Transactional</code>注解，</p>
<pre><code>@Service
public class BookManager &#123;
    
    @Autowired
    private BookRepository repository;

    @Transactional
    public Book create(String author) &#123;
        System.out.println(repository.getClass().getName());
        return repository.create(author);
    &#125;
&#125;
</code></pre>
<p>Spring框架，通过AOP做Proxy。</p>
<h2 id="Decorator装饰器模式"><a href="#Decorator装饰器模式" class="headerlink" title="Decorator装饰器模式"></a>Decorator装饰器模式</h2><p><code>Spring</code> 中的<code>TransactionAwareCacheDecorator</code> 就做了对<code>Cache</code> 的包装：</p>
<pre><code>public interface Cache &#123;
    String getName();

    Object getNativeCache();

    @Nullable
    Cache.ValueWrapper get(Object var1);

    @Nullable
    &lt;T&gt; T get(Object var1, @Nullable Class&lt;T&gt; var2);

    @Nullable
    &lt;T&gt; T get(Object var1, Callable&lt;T&gt; var2);

    void put(Object var1, @Nullable Object var2);
&#125;
</code></pre>
<p><code>TransactionAwareCacheDecorator</code> 实现了<code>Cache</code>接口，构造时传入一个<code>targetCache</code>，在调用<code>put</code>等方法时，增加了自己装饰逻辑在里面。</p>
<pre><code>public class TransactionAwareCacheDecorator implements Cache &#123;
    private final Cache targetCache;

    public TransactionAwareCacheDecorator(Cache targetCache) &#123;
        Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);
        this.targetCache = targetCache;
    &#125;

    public void put(final Object key, @Nullable final Object value) &#123;
        if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;
                public void afterCommit() &#123;
                    TransactionAwareCacheDecorator.this.targetCache.put(key, value);
                &#125;
            &#125;);
        &#125; else &#123;
            this.targetCache.put(key, value);
        &#125;

    &#125;
</code></pre>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li>装饰模式是继承的有力补充。相比于继承，装饰模式可以增加代码的可维护性、扩展性、复用性。在一些情况下装饰模式可以替代继承，解决类膨胀问题。</li>
<li>装饰模式有利于程序的可扩展性。在一个项目中，有很多因素考虑不周，特别是业务的变更。通过装饰模式重新封装一个装饰类，可以避免修改继承体系中的中间类，而是使用装饰类修饰中间类，这样原有的程序没有变更，通过扩展完成了这次变更。</li>
</ul>
<h2 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式(Composite)"></a>组合模式(Composite)</h2><p>Spring actuate 提供<code>HealthIndicator</code>, 用于监控服务健康状态。</p>
<pre><code>@FunctionalInterface
public interface HealthIndicator &#123;

    /**
     * Return an indication of health.
     * @return the health for
     */
    Health health();

&#125;
</code></pre>
<p>实现类里，有一个<code>CompositeHealthIndicator</code>, 可以<code>add</code>多个<code>HealthIndicator</code>,放入<code>indicators</code>里，最后返回<code>health</code>时，聚合所有<code>indicators</code>的<code>Health</code>。</p>
<pre><code>public class CompositeHealthIndicator implements HealthIndicator &#123;

    private final Map&lt;String, HealthIndicator&gt; indicators;

    private final HealthAggregator healthAggregator;

    /**
     * Create a new &#123;@link CompositeHealthIndicator&#125;.
     * @param healthAggregator the health aggregator
     */
    public CompositeHealthIndicator(HealthAggregator healthAggregator) &#123;
        this(healthAggregator, new LinkedHashMap&lt;&gt;());
    &#125;

    /**
     * Create a new &#123;@link CompositeHealthIndicator&#125; from the specified indicators.
     * @param healthAggregator the health aggregator
     * @param indicators a map of &#123;@link HealthIndicator&#125;s with the key being used as an
     * indicator name.
     */
    public CompositeHealthIndicator(HealthAggregator healthAggregator,
            Map&lt;String, HealthIndicator&gt; indicators) &#123;
        Assert.notNull(healthAggregator, &quot;HealthAggregator must not be null&quot;);
        Assert.notNull(indicators, &quot;Indicators must not be null&quot;);
        this.indicators = new LinkedHashMap&lt;&gt;(indicators);
        this.healthAggregator = healthAggregator;
    &#125;

    public void addHealthIndicator(String name, HealthIndicator indicator) &#123;
        this.indicators.put(name, indicator);
    &#125;

    @Override
    public Health health() &#123;
        Map&lt;String, Health&gt; healths = new LinkedHashMap&lt;&gt;();
        for (Map.Entry&lt;String, HealthIndicator&gt; entry : this.indicators.entrySet()) &#123;
            healths.put(entry.getKey(), entry.getValue().health());
        &#125;
        return this.healthAggregator.aggregate(healths);
    &#125;

&#125;
</code></pre>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/02/04/jqpeng-%E6%8F%90%E5%8D%87NginxTLSSSL%20HTTPS%20%E6%80%A7%E8%83%BD%E7%9A%847%E6%9D%A1%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/02/04/jqpeng-%E6%8F%90%E5%8D%87NginxTLSSSL%20HTTPS%20%E6%80%A7%E8%83%BD%E7%9A%847%E6%9D%A1%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/" class="post-title-link" itemprop="url">提升NginxTLSSSL HTTPS 性能的7条优化建议</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-04 21:27:00" itemprop="dateCreated datePublished" datetime="2021-02-04T21:27:00+08:00">2021-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/nginx-tls.html">提升NginxTLSSSL HTTPS 性能的7条优化建议</a></p>
<p>自2018年7月起，谷歌浏览器开始将“ HTTP”网站标记为“不安全”。在过去的几年中，互联网已经迅速过渡到HTTPS，Chrome浏览器的流量超过70％，并且Web排名前100位的网站中有80多个现在默认使用HTTPS 当前Nginx作为最常见的服务器，广泛用于负载均衡（LB)、网关、反向代理。考虑到这一点，让我们看一下Nginx调优技巧，改善Nginx + HTTPS的性能以获得更好的TTFB和更少的延迟。</p>
<p><img src="https://p3-tt.byteimg.com/origin/dfic-imagehandler/0f5b86a5-a1d0-4d4e-a386-43fa9dbda992?from=pc" alt="提升Nginx SSL/HTTPS性能的7条建议"></p>
<p>HTTPS 优化</p>
<h1 id="1-开启-HTTP-2"><a href="#1-开启-HTTP-2" class="headerlink" title="1. 开启 HTTP/2"></a>1. 开启 HTTP/2</h1><p>HTTP/2最初是在Nginx版本1.9.5中实现的，以取代spdy。在Nginx上启用HTTP/2模块很简单。</p>
<p>原先的配置：</p>
<pre><code>listen 443 ssl;
</code></pre>
<p>修改为：</p>
<pre><code>listen 443 ssl http2;
</code></pre>
<p>可以通过curl来验证：</p>
<pre><code>curl --http2 -I https://domain.com/
</code></pre>
<h1 id="2-开启-SSL-session-缓存"><a href="#2-开启-SSL-session-缓存" class="headerlink" title="2. 开启 SSL session 缓存"></a>2. 开启 SSL session 缓存</h1><p>启用 SSL Session 缓存可以减少 TLS 的反复验证，减少 TLS 握手。 1M 的内存就可以缓存 4000 个连接，非常划算，现在内存便宜，尽量开启。</p>
<pre><code>ssl_session_cache shared:SSL:50m; # 1m 4000个，
ssl_session_timeout 1h; # 1小时过期 1 hour during which sessions can be re-used.
</code></pre>
<h1 id="3-禁用-SSL-session-tickets"><a href="#3-禁用-SSL-session-tickets" class="headerlink" title="3. 禁用 SSL session tickets"></a>3. 禁用 SSL session tickets</h1><p>由于Nginx中尚未实现SSL session tickets，可以关闭。</p>
<pre><code>ssl_session_tickets off;
</code></pre>
<h1 id="4-禁用-TLS-version-1-0"><a href="#4-禁用-TLS-version-1-0" class="headerlink" title="4. 禁用 TLS version 1.0"></a>4. 禁用 TLS version 1.0</h1><p>1.3已经出来。1.0可以丢进历史垃圾堆</p>
<pre><code>ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
</code></pre>
<p>修改为</p>
<pre><code>ssl_protocols TLSv1.2 TLSv1.3;
</code></pre>
<h1 id="5-启用OCSP-Stapling"><a href="#5-启用OCSP-Stapling" class="headerlink" title="5. 启用OCSP Stapling"></a>5. 启用OCSP Stapling</h1><p>如果不启用 OCSP Stapling 的话，在用户连接你的服务器的时候，需要去验证证书，这个验证证书的时间不可控，我们开启OCSP Stapling后，可以省掉这一步。</p>
<pre><code>ssl_stapling on;
ssl_stapling_verify on;
ssl_trusted_certificate /path/to/full_chain.pem;
resolver 8.8.8.8 8.8.4.4 valid=300s;
resolver_timeout 5s;
</code></pre>
<h1 id="6-减小ssl-buffer-size"><a href="#6-减小ssl-buffer-size" class="headerlink" title="6. 减小ssl buffer size"></a>6. 减小ssl buffer size</h1><p>ssl_buffer_size 控制在发送数据时的 buffer 大小，默认情况下，缓冲区设置为16k，为了最大程度地减少TTFB（至第一个字节的时间），最好使用较小的值，这样TTFB可以节省大约30 – 50ms。</p>
<pre><code>ssl_buffer_size 4k;
</code></pre>
<h1 id="7-调整-Cipher-优先级"><a href="#7-调整-Cipher-优先级" class="headerlink" title="7. 调整 Cipher 优先级"></a>7. 调整 Cipher 优先级</h1><p>更新更快的 Cipher放前面，这样延迟更小。</p>
<pre><code># 手动启用 cipher 列表
ssl_prefer_server_ciphers on;  # prefer a list of ciphers to prevent old and slow ciphers
ssl_ciphers &#39;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#39;;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/02/02/jqpeng-%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E7%9A%84gitlab%20flow%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/02/02/jqpeng-%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E7%9A%84gitlab%20flow%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">高效团队的gitlab flow最佳实践</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-02 20:38:00" itemprop="dateCreated datePublished" datetime="2021-02-02T20:38:00+08:00">2021-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/gitlab-flow.html">高效团队的gitlab flow最佳实践</a></p>
<p>当前git是大部分开发团队的首选版本管理工具，一个好的流程规范可以让大家有效地合作，像流水线一样有条不紊地进行团队协作。</p>
<p>业界包含三种flow：</p>
<ul>
<li>Git flow</li>
<li>Github flow</li>
<li>Gitlab flow</li>
</ul>
<p>下面我们先来分析，然后再基于gitlab flow来设计一个适合我们团队的git规范。</p>
<h2 id="从git-flow到gitlab-flow"><a href="#从git-flow到gitlab-flow" class="headerlink" title="从git flow到gitlab flow"></a>从git flow到gitlab flow</h2><h3 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h3><p>先说git flow，大概是这样的。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612267487337.png" alt="gitflow"></p>
<p>然后，我们老的git规范是参考git flow实现的。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612267545738.png" alt="当前git流程"></p>
<p>综合考虑了开发、测试、新功能开发、临时需求、热修复，理想很丰满，现实很骨干，这一套运行起来实在是太复杂了。那么如何精简流程呢？</p>
<p>我们来看业界的做法，首先是github flow。</p>
<h3 id="github-flow"><a href="#github-flow" class="headerlink" title="github flow"></a>github flow</h3><p>Github flow 是Git flow的简化版，专门配合”持续发布”。它是 Github.com 使用的工作流程。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612267831741.png" alt="github flow"></p>
<p>整个流程：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612267888369.png" alt="流程"></p>
<ul>
<li>第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。</li>
<li>第二步：新分支开发完成后，或者需要讨论的时候，就向master发起一个pull request（简称PR）。</li>
<li>第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。</li>
<li>第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</li>
</ul>
<p>github flow这种方式，要保证高质量，对于贡献者的素质要求很高，换句话说，如果代码贡献者素质不那么高，质量就无法得到保证。</p>
<blockquote>
<p>github flow这一套对于库、框架、工具这样并非最终应用的产品来说，没问题，但是，如果如果一个产品是“最终应用”，github flow可能就不合适了。</p>
</blockquote>
<h3 id="gitlab-flow"><a href="#gitlab-flow" class="headerlink" title="gitlab flow"></a>gitlab flow</h3><p>Gitlab flow 是 Git flow 与 Github flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。</p>
<p>Gitlab flow 的最大原则叫做”上游优先”（upsteam first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。</p>
<p>对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612268052916.png" alt="gitlab flow"></p>
<p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p>
<p>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612268111739.png" alt="版本发布"></p>
<p>gitlab flow 如何处理hotfix？ git flow之所以这么复杂，一大半原因就是把hotfix考虑得太周全了。hotfix的意思是，当代码部署到产品环境之后发现的问题，需要火速fix。gitlab flow 可以基于后续分支，修改后上线。</p>
<h2 id="团队git规范"><a href="#团队git规范" class="headerlink" title="团队git规范"></a>团队git规范</h2><p>综合上面的介绍，我们决定采用gitlab flow，按照版本发布的模式实施，具体来说：</p>
<ol>
<li>新的迭代开始，所有开发人员从主干master拉个人分支开发特性, 分支命名规范 feature-name</li>
<li>开发完成后，在迭代结束前，合入master分支</li>
<li>master分支合并后，自动cicd到dev环境</li>
<li>开发自测通过后，从master拉取要发布的分支，release-$version，将这个分支部署到测试环境进行测试</li>
<li>测出的bug，通过从release-$versio拉出分支进行修复，修复完成后，再合入release-$versio</li>
<li>正式发布版本，如果上线后，又有bug，根据5的方式处理</li>
<li>等发布版本稳定后，将release-$versio反合入主干</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="开发feature功能"><a href="#开发feature功能" class="headerlink" title="开发feature功能"></a>开发feature功能</h3><p>新建分支，比如<code>feat-test</code></p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612263756008.png" alt="新分支"></p>
<p>开发代码，增加新功能，提交：</p>
<pre><code>@GetMapping(path = &quot;/test&quot;, produces = &quot;application/json&quot;)@ResponseBodypublic Map&lt;String, Object&gt; test() &#123;    return singletonMap(&quot;test&quot;, &quot;test&quot;);&#125;



git commit -m &quot;feat: add test code&quot;
git push origin feat-test
</code></pre>
<h3 id="提交MR"><a href="#提交MR" class="headerlink" title="提交MR"></a>提交MR</h3><p>提交代码后，可以提交<code>mr</code>到<code>master</code>，申请合并代码</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612264109605.png" alt="mr"></p>
<p><strong>Note</strong>：</p>
<ul>
<li>这里可以增加自动代码审查,</li>
</ul>
<h3 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h3><p>研发组长，打开mr，review代码，可以添加建议：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612264544465.png" alt="添加评论"></p>
<p>开发同学根据建议修复代码，或者线下修改后commit代码。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612264598028.png" alt="应用建议"></p>
<p>研发组长确认没有问题后，可以合并到master。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612264745987.png" alt="合并"></p>
<p>合并完成，可以删除feat分支。</p>
<p>新功能开发好，可以进行提测。</p>
<h3 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h3><h4 id="语义化版本号"><a href="#语义化版本号" class="headerlink" title="语义化版本号"></a>语义化版本号</h4><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>
<p>主版本号：当你做了不兼容的 API 修改，<br> 次版本号：当你做了向下兼容的功能性新增，<br> 修订号：当你做了向下兼容的问题修正。<br> 先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>
<p>主版本号为0，代表还未发布正式版本。</p>
<h4 id="测试发布"><a href="#测试发布" class="headerlink" title="测试发布"></a>测试发布</h4><p>master分支，自动部署到开发环境（dev）</p>
<p>功能开发完成，并自测通过后，代码合并到待发布版本，</p>
<p>分支规则：</p>
<pre><code>release-version
</code></pre>
<p>版本规则</p>
<pre><code>主版本号.次版本号
</code></pre>
<p>构建时，自动增加修订号：</p>
<pre><code>主版本号.次版本号.修订号
</code></pre>
<p>从最新的master新拉一个分支<code>release-$version</code>，比如<code>release-0.1</code></p>
<pre><code>git checkout -b release-0.1
</code></pre>
<p><code>release-$version</code>会自动构建，版本号为<code>$version.$buildNumber</code></p>
<p>设定<code>release-$version</code> 分支为保护分支，不允许直接推送，只能通过merge不允许直接提交代码，接受<code>MR</code>。</p>
<h4 id="bug修复"><a href="#bug修复" class="headerlink" title="bug修复"></a>bug修复</h4><p>需要修改bug时，从<code>release-$version</code>新拉分支，修改完成后再合并到<code>release-$version</code>分支.</p>
<ul>
<li>Q: 从<code>release-$version</code>拉的分支，如何测试？</li>
<li>A:  这个节点定义为bug修复节点，建议开发同学优先本地测试验证，严重通过再合并到release分支。</li>
<li>Q: <code>release-$version</code>太多怎么办？</li>
<li>A:  可以保留最近的10个版本。历史的打tag后，删除分支。</li>
</ul>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2021/01/14/jqpeng-Spring%E4%B8%AD%E7%9A%84@Valid%20%E5%92%8C%20@Validated%E6%B3%A8%E8%A7%A3%E4%BD%A0%E7%94%A8%E5%AF%B9%E4%BA%86%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2021/01/14/jqpeng-Spring%E4%B8%AD%E7%9A%84@Valid%20%E5%92%8C%20@Validated%E6%B3%A8%E8%A7%A3%E4%BD%A0%E7%94%A8%E5%AF%B9%E4%BA%86%E5%90%97/" class="post-title-link" itemprop="url">Spring中的@Valid 和 @Validated注解你用对了吗</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-14 18:24:00" itemprop="dateCreated datePublished" datetime="2021-01-14T18:24:00+08:00">2021-01-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-valid.html">Spring中的@Valid 和 @Validated注解你用对了吗</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>本文我们将重点介绍Spring中 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/validation/Valid.html">@Valid</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/annotation/Validated.html">@Validated</a>注解的区别 。</p>
<p>验证用户输入是否正确是我们应用程序中的常见功能。Spring提供了<code>@Valid</code>和@<code>Validated</code>两个注解来实现验证功能，下面我们来详细介绍它们。</p>
<h2 id="2-Valid和-Validate注解"><a href="#2-Valid和-Validate注解" class="headerlink" title="2. @Valid和@Validate注解"></a>2. @Valid和@Validate注解</h2><p>在Spring中，我们使用<code>@Valid</code> 注解进行方法级别验证，同时还能用它来标记成员属性以进行验证。</p>
<p>但是，此注释不支持分组验证。<code>@Validated</code>则支持分组验证。</p>
<h2 id="3-例子"><a href="#3-例子" class="headerlink" title="3.例子"></a>3.例子</h2><p>让我们考虑一个使用Spring Boot开发的简单用户注册表单。首先，我们只有<code>名称</code>和<code>密码</code>属性：</p>
<pre><code>public class UserAccount &#123;

    @NotNull
    @Size(min = 4, max = 15)
    private String password;

    @NotBlank
    private String name;

    // standard constructors / setters / getters / toString

&#125;
</code></pre>
<p>接下来，让我们看一下控制器。在这里，我们将使用带有<code>@Valid</code>批注的<code>saveBasicInfo</code>方法来验证用户输入：</p>
<pre><code>@RequestMapping(value = &quot;/saveBasicInfo&quot;, method = RequestMethod.POST)
public String saveBasicInfo(
  @Valid @ModelAttribute(&quot;useraccount&quot;) UserAccount useraccount, 
  BindingResult result, 
  ModelMap model) &#123;
    if (result.hasErrors()) &#123;
        return &quot;error&quot;;
    &#125;
    return &quot;success&quot;;
&#125;
</code></pre>
<p>现在让我们测试一下这个方法：</p>
<pre><code>@Test
public void givenSaveBasicInfo_whenCorrectInput`thenSuccess() throws Exception &#123;
    this.mockMvc.perform(MockMvcRequestBuilders.post(&quot;/saveBasicInfo&quot;)
      .accept(MediaType.TEXT_HTML)
      .param(&quot;name&quot;, &quot;test123&quot;)
      .param(&quot;password&quot;, &quot;pass&quot;))
      .andExpect(view().name(&quot;success&quot;))
      .andExpect(status().isOk())
      .andDo(print());
&#125;
</code></pre>
<p>在确认测试成功运行之后，现在让我们扩展功能。下一步的逻辑步骤是将其转换为多步骤注册表格，就像大多数向导一样。第一步，<code>名称</code>和<code>密码</code>保持不变。在第二步中，我们将获取其他信息，例如<code>age</code> 和 <code>phone</code>。因此，我们将使用以下其他字段更新域对象：</p>
<pre><code>public class UserAccount &#123;

    @NotNull
    @Size(min = 4, max = 15)
    private String password;

    @NotBlank
    private String name;

    @Min(value = 18, message = &quot;Age should not be less than 18&quot;)
    private int age;

    @NotBlank
    private String phone;

    // standard constructors / setters / getters / toString   

&#125;
</code></pre>
<p>但是，这一次，我们将注意到先前的测试失败。这是因为我们没有传递<code>年龄</code>和<code>电话</code>字段。</p>
<p>为了支持此行为，我们引入支持分组验证的<code>@Validated</code>批注。</p>
<p><code>分组验证</code>,就是将字段分组，分别验证，比如我们将用户信息分为两组：<code>BasicInfo</code>和<code>AdvanceInfo</code></p>
<p>可以建立两个空接口：</p>
<pre><code>public interface BasicInfo &#123;
&#125;



public interface AdvanceInfo &#123;
&#125;
</code></pre>
<p>第一步将具有<code>BasicInfo</code>接口，第二步 将具有<code>AdvanceInfo</code>  。此外，我们将更新<code>UserAccount</code>类以使用这些标记接口，如下所示：</p>
<pre><code>public class UserAccount &#123;

    @NotNull(groups = BasicInfo.class)
    @Size(min = 4, max = 15, groups = BasicInfo.class)
    private String password;

    @NotBlank(groups = BasicInfo.class)
    private String name;

    @Min(value = 18, message = &quot;Age should not be less than 18&quot;, groups = AdvanceInfo.class)
    private int age;

    @NotBlank(groups = AdvanceInfo.class)
    private String phone;

    // standard constructors / setters / getters / toString   

&#125;
</code></pre>
<p>另外，我们现在将更新控制器以使用<code>@Validated</code>注释而不是<code>@Valid</code>：</p>
<pre><code>@RequestMapping(value = &quot;/saveBasicInfoStep1&quot;, method = RequestMethod.POST)
public String saveBasicInfoStep1(
  @Validated(BasicInfo.class) 
  @ModelAttribute(&quot;useraccount&quot;) UserAccount useraccount, 
  BindingResult result, ModelMap model) &#123;
    if (result.hasErrors()) &#123;
        return &quot;error&quot;;
    &#125;
    return &quot;success&quot;;
&#125;
</code></pre>
<p>更新后，再次执行测试，现在可以成功运行。现在，我们还要测试这个新方法：</p>
<pre><code>@Test
public void givenSaveBasicInfoStep1`whenCorrectInput`thenSuccess() throws Exception &#123;
    this.mockMvc.perform(MockMvcRequestBuilders.post(&quot;/saveBasicInfoStep1&quot;)
      .accept(MediaType.TEXT_HTML)
      .param(&quot;name&quot;, &quot;test123&quot;)
      .param(&quot;password&quot;, &quot;pass&quot;))
      .andExpect(view().name(&quot;success&quot;))
      .andExpect(status().isOk())
      .andDo(print());
&#125;
</code></pre>
<p>也成功运行！</p>
<p>接下来，让我们看看<code>@Valid</code>对于触发嵌套属性验证是必不可少的。</p>
<h2 id="4-使用-Valid批注标记嵌套对象"><a href="#4-使用-Valid批注标记嵌套对象" class="headerlink" title="4.使用@Valid批注标记嵌套对象"></a>4.使用<code>@Valid</code>批注标记嵌套对象</h2><p>@Valid 可以用于嵌套对象。例如，在我们当前的场景中，让我们创建一个 <code>UserAddress </code>对象：</p>
<pre><code>public class UserAddress &#123;

    @NotBlank
    private String countryCode;

    // standard constructors / setters / getters / toString
&#125;
</code></pre>
<p>为了确保验证此嵌套对象，我们将使用<code>@Valid</code>批注装饰属性：</p>
<pre><code>public class UserAccount &#123;

    //...

    @Valid
    @NotNull(groups = AdvanceInfo.class)
    private UserAddress useraddress;

    // standard constructors / setters / getters / toString 
&#125;
</code></pre>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><code>@Valid</code>保证了整个对象的验证, 但是它是对整个对象进行验证，当仅需要部分验证的时候就会出现问题。 这时候，可以使用<code>@Validated</code> 进行分组验证。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-valid-vs-validated">https://www.baeldung.com/spring-valid-vs-validated</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2020/12/09/jqpeng-hugegraph%20%E5%AD%98%E5%8F%96%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2020/12/09/jqpeng-hugegraph%20%E5%AD%98%E5%8F%96%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">hugegraph 存取数据解析</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-09 11:58:00" itemprop="dateCreated datePublished" datetime="2020-12-09T11:58:00+08:00">2020-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/hugegraph-storage.html">hugegraph 存取数据解析</a></p>
<p>hugegraph 是百度开源的图数据库，支持hbase，mysql，rocksdb等作为存储后端。本文以EDGE 存储，hbase为存储后端，来探索hugegraph是如何存取数据的。</p>
<h2 id="存数据"><a href="#存数据" class="headerlink" title="存数据"></a>存数据</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/12/9/1607480289186.png" alt="Edge"></p>
<p>首先需要序列化，<code>hbase</code> 使用BinarySerializer:</p>
<ul>
<li>keyWithIdPrefix 和indexWithIdPrefix都是false</li>
</ul>
<p>这个后面会用到。</p>
<pre><code>public class HbaseSerializer extends BinarySerializer &#123;

    public HbaseSerializer() &#123;
        super(false, true);
    &#125;
&#125;
</code></pre>
<p>要存到db，首先需要序列化为BackendEntry，<code>BackendEntry</code> 是图数据库和后端存储的传输对象，Hbase对应的是<code>BinaryBackendEntry</code>:</p>
<pre><code>public class BinaryBackendEntry implements BackendEntry &#123;

    private static final byte[] EMPTY_BYTES = new byte[]&#123;&#125;;

    private final HugeType type;
    private final BinaryId id;
    private Id subId;
    private final List&lt;BackendColumn&gt; columns;
    private long ttl;

    public BinaryBackendEntry(HugeType type, byte[] bytes) &#123;
        this(type, BytesBuffer.wrap(bytes).parseId(type));
    &#125;

    public BinaryBackendEntry(HugeType type, BinaryId id) &#123;
        this.type = type;
        this.id = id;
        this.subId = null;
        this.columns = new ArrayList&lt;&gt;();
        this.ttl = 0L;
    &#125;
</code></pre>
<p>我们来看序列化，序列化，其实就是要将数据放到entry的column列里。</p>
<ul>
<li><code>hbase</code> 的<code>keyWithIdPrefix</code>是false，因此<code>name</code>不包含ownerVertexId（参考下面的EdgeId，去掉ownerVertexId）</li>
</ul>
<pre><code> public BackendEntry writeEdge(HugeEdge edge) &#123;
        BinaryBackendEntry entry = newBackendEntry(edge);
        byte[] name = this.keyWithIdPrefix ?
                      this.formatEdgeName(edge) : EMPTY_BYTES;
        byte[] value = this.formatEdgeValue(edge);
        entry.column(name, value);

        if (edge.hasTtl()) &#123;
            entry.ttl(edge.ttl());
        &#125;

        return entry;
    &#125;
</code></pre>
<p>EdgeId：</p>
<pre><code>    private final Id ownerVertexId;
    private final Directions direction;
    private final Id edgeLabelId;
    private final String sortValues;
    private final Id otherVertexId;

    private final boolean directed;
    private String cache;
</code></pre>
<h3 id="backend-存储"><a href="#backend-存储" class="headerlink" title="backend 存储"></a>backend 存储</h3><p>生成BackendEntry后，通过store机制，交给后端的backend存储。</p>
<p>EDGE的保存，对应HbaseTables.Edge:</p>
<pre><code>public static class Edge extends HbaseTable &#123;

        @Override
        public void insert(Session session, BackendEntry entry) &#123;
            long ttl = entry.ttl();
            if (ttl == 0L) &#123;
                session.put(this.table(), CF, entry.id().asBytes(),
                            entry.columns());
            &#125; else &#123;
                session.put(this.table(), CF, entry.id().asBytes(),
                            entry.columns(), ttl);
            &#125;
        &#125;
&#125;
</code></pre>
<p>CF 是固定的f：</p>
<pre><code>    protected static final byte[] CF = &quot;f&quot;.getBytes();
</code></pre>
<p><code>session.put</code> 对应：</p>
<pre><code> @Override
        public void put(String table, byte[] family, byte[] rowkey,
                        Collection&lt;BackendColumn&gt; columns) &#123;
            Put put = new Put(rowkey);
            for (BackendColumn column : columns) &#123;
                put.addColumn(family, column.name, column.value);
            &#125;
            this.batch(table, put);
        &#125;
</code></pre>
<p>可以看出，存储时，edgeid作为<code>rowkey</code>，然后把去除<code>ownerVertexId</code>后的<code>edgeid</code>作为<code>column.name</code></p>
<h2 id="EDGE-读取"><a href="#EDGE-读取" class="headerlink" title="EDGE 读取"></a>EDGE 读取</h2><h3 id="从backend读取BackendEntry"><a href="#从backend读取BackendEntry" class="headerlink" title="从backend读取BackendEntry"></a>从backend读取BackendEntry</h3><p>读取就是从hbase读取result，转换为BinaryBackendEntry，再转成Edge。</p>
<p>读取，是scan的过程：</p>
<pre><code> /**
         * Inner scan: send scan request to HBase and get iterator
         */
        @Override
        public RowIterator scan(String table, Scan scan) &#123;
            assert !this.hasChanges();

            try (Table htable = table(table)) &#123;
                return new RowIterator(htable.getScanner(scan));
            &#125; catch (IOException e) &#123;
                throw new BackendException(e);
            &#125;
        &#125;
</code></pre>
<p>scan后，返回<code>BackendEntryIterator</code></p>
<pre><code>protected BackendEntryIterator newEntryIterator(Query query,
                                                    RowIterator rows) &#123;
        return new BinaryEntryIterator&lt;&gt;(rows, query, (entry, row) -&gt; &#123;
            E.checkState(!row.isEmpty(), &quot;Can&#39;t parse empty HBase result&quot;);
            byte[] id = row.getRow();
            if (entry == null || !Bytes.prefixWith(id, entry.id().asBytes())) &#123;
                HugeType type = query.resultType();
                // NOTE: only support BinaryBackendEntry currently
                entry = new BinaryBackendEntry(type, id);
            &#125;
            try &#123;
                this.parseRowColumns(row, entry, query);
            &#125; catch (IOException e) &#123;
                throw new BackendException(&quot;Failed to read HBase columns&quot;, e);
            &#125;
            return entry;
        &#125;);
    &#125;
</code></pre>
<p>注意，<code>new BinaryBackendEntry(type, id)</code> 时，BinaryBackendEntry的id并不是<code>rowkey</code>，而是对rowkey做了处理：</p>
<pre><code>public BinaryId parseId(HugeType type) &#123;
        if (type.isIndex()) &#123;
            return this.readIndexId(type);
        &#125;
        // Parse id from bytes
        int start = this.buffer.position();
        /*
         * Since edge id in edges table doesn&#39;t prefix with leading 0x7e,
         * so readId() will return the source vertex id instead of edge id,
         * can&#39;t call: type.isEdge() ? this.readEdgeId() : this.readId();
         */
        Id id = this.readId();
        int end = this.buffer.position();
        int len = end - start;
        byte[] bytes = new byte[len];
        System.arraycopy(this.array(), start, bytes, 0, len);
        return new BinaryId(bytes, id);
    &#125;
</code></pre>
<p>这里是先读取ownervertexId作为Id部分, 然后将剩余的直接放入bytes，组合成BinaryId，和序列化的时候有差别，为什么这么设计呢？原来不管是vertex还是edge，都是当成Vertex来读取的。</p>
<pre><code>protected final BinaryBackendEntry newBackendEntry(HugeEdge edge) &#123;
        BinaryId id = new BinaryId(formatEdgeName(edge),
                                   edge.idWithDirection());
        return newBackendEntry(edge.type(), id);
    &#125;

public EdgeId directed(boolean directed) &#123;
    return new EdgeId(this.ownerVertexId, this.direction, this.edgeLabelId,
                      this.sortValues, this.otherVertexId, directed);
&#125;
</code></pre>
<p>序列化的时候是<code>EdgeId</code>。</p>
<p><code>BackendEntryIterator</code>迭代器支持对结果进行merge, 上面代码里的<code>!Bytes.prefixWith(id, entry.id().asBytes()))</code> 就是对比是否是同一个ownervertex，如果是同一个，则放到同一个BackendEntry的Columns里。</p>
<pre><code>     public BinaryEntryIterator(BackendIterator&lt;Elem&gt; results, Query query,
                               BiFunction&lt;BackendEntry, Elem, BackendEntry&gt; m)

    @Override
    protected final boolean fetch() &#123;
        assert this.current == null;
        if (this.next != null) &#123;
            this.current = this.next;
            this.next = null;
        &#125;

        while (this.results.hasNext()) &#123;
            Elem elem = this.results.next();
            BackendEntry merged = this.merger.apply(this.current, elem);
            E.checkState(merged != null, &quot;Error when merging entry&quot;);
            if (this.current == null) &#123;
                // The first time to read
                this.current = merged;
            &#125; else if (merged == this.current) &#123;
                // The next entry belongs to the current entry
                assert this.current != null;
                if (this.sizeOf(this.current) &gt;= INLINE_BATCH_SIZE) &#123;
                    break;
                &#125;
            &#125; else &#123;
                // New entry
                assert this.next == null;
                this.next = merged;
                break;
            &#125;

            // When limit exceed, stop fetching
            if (this.reachLimit(this.fetched() - 1)) &#123;
                // Need remove last one because fetched limit + 1 records
                this.removeLastRecord();
                this.results.close();
                break;
            &#125;
        &#125;

        return this.current != null;
    &#125;
</code></pre>
<h3 id="从BackendEntry转换为edge"><a href="#从BackendEntry转换为edge" class="headerlink" title="从BackendEntry转换为edge"></a>从BackendEntry转换为edge</h3><p>然后再来看读取数据<code>readVertex</code>，前面说了，就算是edge，其实也是当vertex来读取的：</p>
<pre><code> @Override
    public HugeVertex readVertex(HugeGraph graph, BackendEntry bytesEntry) &#123;
        if (bytesEntry == null) &#123;
            return null;
        &#125;
        BinaryBackendEntry entry = this.convertEntry(bytesEntry);

        // Parse id
        Id id = entry.id().origin();
        Id vid = id.edge() ? ((EdgeId) id).ownerVertexId() : id;
        HugeVertex vertex = new HugeVertex(graph, vid, VertexLabel.NONE);

        // Parse all properties and edges of a Vertex
        for (BackendColumn col : entry.columns()) &#123;
            if (entry.type().isEdge()) &#123;
                // NOTE: the entry id type is vertex even if entry type is edge
                // Parse vertex edges
                this.parseColumn(col, vertex);
            &#125; else &#123;
                assert entry.type().isVertex();
                // Parse vertex properties
                assert entry.columnsSize() == 1 : entry.columnsSize();
                this.parseVertex(col.value, vertex);
            &#125;
        &#125;

        return vertex;
    &#125;
</code></pre>
<p>逻辑：</p>
<ul>
<li>先读取ownervertexid，生成HugeVertex，这个时候只知道id，不知道vertexlabel，所以设置为VertexLabel.NONE</li>
<li>然后，读取BackendColumn，一个edge，一个Column（name是edgeid去除ownervertexid后的部分，value是边数据）</li>
</ul>
<p>读取是在<code>parseColumn</code>:</p>
<pre><code>protected void parseColumn(BackendColumn col, HugeVertex vertex) &#123;
        BytesBuffer buffer = BytesBuffer.wrap(col.name);
        Id id = this.keyWithIdPrefix ? buffer.readId() : vertex.id();
        E.checkState(buffer.remaining() &gt; 0, &quot;Missing column type&quot;);
        byte type = buffer.read();
        // Parse property
        if (type == HugeType.PROPERTY.code()) &#123;
            Id pkeyId = buffer.readId();
            this.parseProperty(pkeyId, BytesBuffer.wrap(col.value), vertex);
        &#125;
        // Parse edge
        else if (type == HugeType.EDGE_IN.code() ||
                 type == HugeType.EDGE_OUT.code()) &#123;
            this.parseEdge(col, vertex, vertex.graph());
        &#125;
        // Parse system property
        else if (type == HugeType.SYS_PROPERTY.code()) &#123;
            // pass
        &#125;
        // Invalid entry
        else &#123;
            E.checkState(false, &quot;Invalid entry(%s) with unknown type(%s): 0x%s&quot;,
                         id, type &amp; 0xff, Bytes.toHex(col.name));
        &#125;
    &#125;
</code></pre>
<p>从``col.name`读取type，如果是edge，则parseEdge:</p>
<pre><code>protected void parseEdge(BackendColumn col, HugeVertex vertex,
                             HugeGraph graph) &#123;
        // owner-vertex + dir + edge-label + sort-values + other-vertex

        BytesBuffer buffer = BytesBuffer.wrap(col.name);
        if (this.keyWithIdPrefix) &#123;
            // Consume owner-vertex id
            buffer.readId();
        &#125;
        byte type = buffer.read();
        Id labelId = buffer.readId();
        String sortValues = buffer.readStringWithEnding();
        Id otherVertexId = buffer.readId();

        boolean direction = EdgeId.isOutDirectionFromCode(type);
        EdgeLabel edgeLabel = graph.edgeLabelOrNone(labelId);

        // Construct edge
        HugeEdge edge = HugeEdge.constructEdge(vertex, direction, edgeLabel,
                                               sortValues, otherVertexId);

        // Parse edge-id + edge-properties
        buffer = BytesBuffer.wrap(col.value);

        //Id id = buffer.readId();

        // Parse edge properties
        this.parseProperties(buffer, edge);

        // Parse edge expired time if needed
        if (edge.hasTtl()) &#123;
            this.parseExpiredTime(buffer, edge);
        &#125;
    &#125;
</code></pre>
<p>从col.name依次读取出type,labelId,sortValues和otherVertexId：</p>
<pre><code>        byte type = buffer.read();
        Id labelId = buffer.readId();
        String sortValues = buffer.readStringWithEnding();
        Id otherVertexId = buffer.readId();
</code></pre>
<p>然后根据labelid找到  <code>EdgeLabel edgeLabel = graph.edgeLabelOrNone(labelId);</code></p>
<p>创建<code>edge</code>, 解析边属性<code>parseProperties</code></p>
<p>最后读取<code>Ttl</code>, 处理结果的时候，会过滤过期数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/jadepeng/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/jadepeng/page/10/">10</a><a class="extend next" rel="next" href="/jadepeng/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JadePeng"
      src="/jadepeng/images/avatar.gif">
  <p class="site-author-name" itemprop="name">JadePeng</p>
  <div class="site-description" itemprop="description">JadePeng的技术笔记本</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/jadepeng/archives/">
        
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/jadepeng/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/jadepeng/tags/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JadePeng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">668k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/jadepeng/lib/anime.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.ui.min.js"></script>

<script src="/jadepeng/js/utils.js"></script>

<script src="/jadepeng/js/motion.js"></script>


<script src="/jadepeng/js/schemes/muse.js"></script>


<script src="/jadepeng/js/next-boot.js"></script>




  




  
<script src="/jadepeng/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/jadepeng/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
