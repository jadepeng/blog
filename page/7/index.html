<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/jadepeng/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/jadepeng/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/jadepeng/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/jadepeng/images/logo.svg" color="#222">

<link rel="stylesheet" href="/jadepeng/css/main.css">


<link rel="stylesheet" href="/jadepeng/lib/font-awesome/css/all.min.css">
<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.iflyresearch.com","root":"/jadepeng/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JadePeng的技术笔记本">
<meta property="og:type" content="website">
<meta property="og:title" content="JadePeng的技术笔记本">
<meta property="og:url" content="http://blog.iflyresearch.com/page/7/index.html">
<meta property="og:site_name" content="JadePeng的技术笔记本">
<meta property="og:description" content="JadePeng的技术笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="JadePeng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.iflyresearch.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JadePeng的技术笔记本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/jadepeng/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JadePeng的技术笔记本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">爱学习爱分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/jadepeng/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-博客">

    <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" rel="section"><i class="fa fa-th fa-fw"></i>博客</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/jadepeng/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/jadepeng/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/jadepeng/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/08/27/jqpeng-APM%20%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/08/27/jqpeng-APM%20%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/" class="post-title-link" itemprop="url">APM 原理与框架选型</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-27 15:59:00" itemprop="dateCreated datePublished" datetime="2018-08-27T15:59:00+08:00">2018-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/apm.html">APM 原理与框架选型</a></p>
<p>发些存稿:)</p>
<h2 id="0-APM简介"><a href="#0-APM简介" class="headerlink" title="0. APM简介"></a>0. APM简介</h2><p>随着微服务架构的流行，一次请求往往需要涉及到多个服务，因此服务性能监控和排查就变得更复杂：</p>
<ul>
<li>不同的服务可能由不同的团队开发、甚至可能使用不同的编程语言来实现</li>
<li>服务有可能布在了几千台服务器，横跨多个不同的数据中心</li>
</ul>
<p>因此，就需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题，这就是APM系统，全称是（<strong>A</strong>pplication <strong>P</strong>erformance <strong>M</strong>onitor，当然也有叫 <strong>A</strong>pplication <strong>P</strong>erformance <strong>M</strong>anagement tools）</p>
<p>AMP最早是谷歌公开的论文提到的 <a target="_blank" rel="noopener" href="http://bigbully.github.io/Dapper-translation">Google Dapper</a>。Dapper是Google生产环境下的分布式跟踪系统，自从Dapper发展成为一流的监控系统之后，给google的开发者和运维团队帮了大忙，所以谷歌公开论文分享了Dapper。</p>
<h2 id="1-谷歌Dapper介绍"><a href="#1-谷歌Dapper介绍" class="headerlink" title="1. 谷歌Dapper介绍"></a>1. 谷歌Dapper介绍</h2><h3 id="1-1-Dapper的挑战"><a href="#1-1-Dapper的挑战" class="headerlink" title="1.1 Dapper的挑战"></a>1.1 <strong>Dapper的挑战</strong></h3><p>在google的首页页面，提交一个查询请求后，会经历什么：</p>
<ul>
<li>可能对上百台查询服务器发起了一个Web查询，每一个查询都有自己的Index</li>
<li>这个查询可能会被发送到多个的子系统，这些子系统分别用来处理广告、进行拼写检查或是查找一些像图片、视频或新闻这样的特殊结果</li>
<li>根据每个子系统的查询结果进行筛选，得到最终结果，最后汇总到页面上</li>
</ul>
<p>总结一下：</p>
<ul>
<li>一次全局搜索有可能调用上千台服务器，涉及各种服务。</li>
<li>用户对搜索的耗时是很敏感的，而任何一个子系统的低效都导致导致最终的搜索耗时</li>
</ul>
<p>如果一次查询耗时不正常，工程师怎么来排查到底是由哪个服务调用造成的？</p>
<ul>
<li>首先，这个工程师可能无法准确的定位到这次全局搜索是调用了哪些服务，因为新的服务、乃至服务上的某个片段，都有可能在任何时间上过线或修改过，有可能是面向用户功能，也有可能是一些例如针对性能或安全认证方面的功能改进</li>
<li>其次，你不能苛求这个工程师对所有参与这次全局搜索的服务都了如指掌，每一个服务都有可能是由不同的团队开发或维护的</li>
<li>再次，这些暴露出来的服务或服务器有可能同时还被其他客户端使用着，所以这次全局搜索的性能问题甚至有可能是由其他应用造成的</li>
</ul>
<p>从上面可以看出Dapper需要：</p>
<ul>
<li>无所不在的部署，无所不在的重要性不言而喻，因为在使用跟踪系统的进行监控时，即便只有一小部分没被监控到，那么人们对这个系统是不是值得信任都会产生巨大的质疑</li>
<li>持续的监控</li>
</ul>
<h3 id="1-2-Dapper的三个具体设计目标"><a href="#1-2-Dapper的三个具体设计目标" class="headerlink" title="1.2 Dapper的三个具体设计目标"></a>1.2 Dapper的三个具体设计目标</h3><ol>
<li><strong>性能消耗低</strong><br> APM组件服务的影响应该做到足够小。<strong>服务调用埋点本身会带来性能损耗，这就需要调用跟踪的低损耗，实际中还会通过配置采样率的方式，选择一部分请求去分析请求路径</strong>。在一些高度优化过的服务，即使一点点损耗也会很容易察觉到，而且有可能迫使在线服务的部署团队不得不将跟踪系统关停。</li>
<li><strong>应用透明</strong>，也就是<strong>代码的侵入性小</strong><br> <strong>即也作为业务组件，应当尽可能少入侵或者无入侵其他业务系统，对于使用方透明，减少开发人员的负担</strong>。<br> 对于应用的程序员来说，是不需要知道有跟踪系统这回事的。如果一个跟踪系统想生效，就必须需要依赖应用的开发者主动配合，那么这个跟踪系统也太脆弱了，往往由于跟踪系统在应用中植入代码的bug或疏忽导致应用出问题，这样才是无法满足对跟踪系统“无所不在的部署”这个需求。</li>
<li><strong>可扩展性</strong><br> <strong>一个优秀的调用跟踪系统必须支持分布式部署，具备良好的可扩展性。能够支持的组件越多当然越好</strong>。或者提供便捷的插件开发API，对于一些没有监控到的组件，应用开发者也可以自行扩展。</li>
<li><strong>数据的分析</strong><br> <strong>数据的分析要快 ，分析的维度尽可能多</strong>。跟踪系统能提供足够快的信息反馈，就可以对生产环境下的异常状况做出快速反应。<strong>分析的全面，能够避免二次开发</strong>。</li>
</ol>
<h3 id="1-3-Dapper的分布式跟踪原理"><a href="#1-3-Dapper的分布式跟踪原理" class="headerlink" title="1.3 Dapper的分布式跟踪原理"></a>1.3 Dapper的分布式跟踪原理</h3><p>先来看一次请求调用示例：</p>
<ol>
<li>包括：前端（A），两个中间层（B和C），以及两个后端（D和E）</li>
<li>当用户发起一个请求时，首先到达前端A服务，然后分别对B服务和C服务进行RPC调用；</li>
<li>B服务处理完给A做出响应，但是C服务还需要和后端的D服务和E服务交互之后再返还给A服务，最后由A服务来响应用户的请求；</li>
</ol>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535337727679.png" alt="Dapper的分布式跟踪"></p>
<p>Dapper是如何来跟踪记录这次请求呢？</p>
<h4 id="1-3-1-跟踪树和span"><a href="#1-3-1-跟踪树和span" class="headerlink" title="1.3.1  跟踪树和span"></a>1.3.1  <strong>跟踪树和span</strong></h4><p>Span是dapper的<strong>基本工作单元</strong>，一次链路调用（可以是RPC，DB等没有特定的限制）创建一个span，通过一个64位ID标识它；同时附加（Annotation）作为payload负载信息，用于记录性能等数据。</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535338174615.png" alt="5个span在Dapper跟踪树种短暂的关联关系"></p>
<p>上图说明了span在一次大的跟踪过程中是什么样的。<strong>Dapper记录了span名称，以及每个span的ID和父ID，以重建在一次追踪过程中不同span之间的关系</strong>。如果一个span没有父ID被称为root span。<strong>所有span都挂在一个特定的跟踪上，也共用一个跟踪id</strong>。</p>
<p>再来看下<strong>Span的细节</strong>：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535338251754.png" alt="一个单独的span的细节图"></p>
<p><strong>Span数据结构</strong>：</p>
<pre><code>type Span struct &#123;
    TraceID    int64 // 用于标示一次完整的请求id
    Name       string
    ID         int64 // 当前这次调用span_id
    ParentID   int64 // 上层服务的调用span_id  最上层服务parent_id为null
    Annotation []Annotation // 用于标记的时间戳
    Debug      bool
&#125;
</code></pre>
<h4 id="1-3-2-TraceID"><a href="#1-3-2-TraceID" class="headerlink" title="1.3.2 TraceID"></a>1.3.2 TraceID</h4><p>类似于 <strong>树结构的Span集合</strong>，表示一次完整的跟踪，从请求到服务器开始，服务器返回response结束，跟踪每次rpc调用的耗时，存在唯一标识trace_id。比如：你运行的分布式大数据存储一次Trace就由你的一次请求组成。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/4/163c9bee3a9d029a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Trace"></p>
<p>每种颜色的note标注了一个span，一条链路通过TraceId唯一标识，Span标识发起的请求信息。<strong>树节点是整个架构的基本单元，而每一个节点又是对span的引用</strong>。节点之间的连线表示的span和它的父span直接的关系。虽然span在日志文件中只是简单的代表span的开始和结束时间，他们在整个树形结构中却是相对独立的。</p>
<h4 id="1-3-3-Annotation"><a href="#1-3-3-Annotation" class="headerlink" title="1.3.3 Annotation"></a>1.3.3 Annotation</h4><p>Dapper允许应用程序开发人员在Dapper跟踪的过程中添加额外的信息，以监控更高级别的系统行为，或帮助调试问题。这就是Annotation：</p>
<p><strong>Annotation</strong>，用来记录请求特定事件相关信息（例如时间），<strong>一个span中会有多个annotation注解描述</strong>。通常包含四个注解信息：</p>
<blockquote>
<p>(1) <strong>cs</strong>：Client Start，表示客户端发起请求<br> (2) <strong>sr</strong>：Server Receive，表示服务端收到请求<br> (3) <strong>ss</strong>：Server Send，表示服务端完成处理，并将结果发送给客户端<br> (4) <strong>cr</strong>：Client Received，表示客户端获取到服务端返回信息</p>
</blockquote>
<p><strong>Annotation数据结构</strong>：</p>
<pre><code>type Annotation struct &#123;
    Timestamp int64
    Value     string
    Host      Endpoint
    Duration  int32
&#125;
</code></pre>
<h4 id="1-3-4-采样率"><a href="#1-3-4-采样率" class="headerlink" title="1.3.4 采样率"></a>1.3.4 采样率</h4><p>低损耗的是Dapper的一个关键的设计目标，因为如果这个工具价值未被证实但又对性能有影响的话，你可以理解服务运营人员为什么不愿意部署它。</p>
<p>另外，某些类型的Web服务对植入带来的性能损耗确实非常敏感。</p>
<p>因此，除了把Dapper的收集工作对基本组件的性能损耗限制的尽可能小之外，Dapper支持设置采样率来减少性能损耗，同时支持<strong>可变采样</strong>。</p>
<h2 id="2-APM组件选型"><a href="#2-APM组件选型" class="headerlink" title="2. APM组件选型"></a>2. APM组件选型</h2><p>市面上的全链路监控理论模型大多都是借鉴Google Dapper论文，重点关注以下三种APM组件：</p>
<blockquote>
<ol>
<li>**<a href="https://link.juejin.im/?target=http://zipkin.io/">Zipkin</a>**：由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微服务架构中的延迟问题，包括：数据的收集、存储、查找和展现。</li>
<li>**<a href="https://link.juejin.im/?target=https://github.com/naver/pinpoint">Pinpoint</a>**：一款对Java编写的大规模分布式系统的APM工具，由韩国人开源的分布式跟踪组件。</li>
<li>**<a href="https://link.juejin.im/?target=http://skywalking.org/">Skywalking</a>**：国产的优秀APM组件，是一个对JAVA分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统。</li>
</ol>
</blockquote>
<h3 id="2-1-对比项"><a href="#2-1-对比项" class="headerlink" title="2.1 对比项"></a>2.1 对比项</h3><p>主要对比项：</p>
<ol>
<li><strong>探针的性能</strong><br> 主要是agent对服务的吞吐量、CPU和内存的影响。微服务的规模和动态性使得数据收集的成本大幅度提高。</li>
<li><strong>collector的可扩展性</strong><br> 能够水平扩展以便支持大规模服务器集群。</li>
<li><strong>全面的调用链路数据分析</strong><br> 提供代码级别的可见性以便轻松定位失败点和瓶颈。</li>
<li><strong>对于开发透明，容易开关</strong><br> 添加新功能而无需修改代码，容易启用或者禁用。</li>
<li><strong>完整的调用链应用拓扑</strong><br> 自动检测应用拓扑，帮助你搞清楚应用的架构</li>
</ol>
<h3 id="2-2-探针的性能"><a href="#2-2-探针的性能" class="headerlink" title="2.2 探针的性能"></a>2.2 探针的性能</h3><p>比较关注探针的性能，毕竟APM定位还是工具，如果启用了链路监控组建后，直接导致吞吐量降低过半，那也是不能接受的。对skywalking、zipkin、pinpoint进行了压测，并与基线（未使用探针）的情况进行了对比。</p>
<p>选用了一个常见的基于Spring的应用程序，他包含Spring Boot, Spring MVC，redis客户端，mysql。 监控这个应用程序，每个trace，探针会抓取5个span(1 Tomcat, 1 SpringMVC, 2 Jedis, 1 Mysql)。这边基本和 <a href="https://link.juejin.im/?target=https://link.juejin.im?target=https%253A%252F%252Fskywalkingtest.github.io%252FAgent-Benchmarks%252FREADME_zh.html">skywalkingtest</a> 的测试应用差不多。</p>
<p>模拟了三种并发用户：500，750，1000。使用jmeter测试，每个线程发送30个请求，设置思考时间为10ms。使用的采样率为1，即100%，这边与生产可能有差别。pinpoint默认的采样率为20，即50%，通过设置agent的配置文件改为100%。zipkin默认也是1。组合起来，一共有12种。下面看下汇总表：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339573733.png" alt="探针性能"></p>
<p>从上表可以看出，在三种链路监控组件中，<strong>skywalking的探针对吞吐量的影响最小，zipkin的吞吐量居中。pinpoint的探针对吞吐量的影响较为明显</strong>，在500并发用户时，测试服务的吞吐量从1385降低到774，影响很大。然后再看下CPU和memory的影响，在内部服务器进行的压测，对CPU和memory的影响都差不多在10%之内。</p>
<h3 id="2-3-collector的可扩展性"><a href="#2-3-collector的可扩展性" class="headerlink" title="2.3 collector的可扩展性"></a>2.3 collector的可扩展性</h3><p>collector的可扩展性，使得能够水平扩展以便支持大规模服务器集群。</p>
<ol>
<li><strong>zipkin</strong><br> 开发zipkin-Server（其实就是提供的开箱即用包），zipkin-agent与zipkin-Server通过http或者mq进行通信，<strong>http通信会对正常的访问造成影响，所以还是推荐基于mq异步方式通信</strong>，zipkin-Server通过订阅具体的topic进行消费。这个当然是可以扩展的，<strong>多个zipkin-Server实例进行异步消费mq中的监控信息</strong>。</li>
<li><strong>skywalking</strong><br> skywalking的collector支持两种部署方式：<strong>单机和集群模式。collector与agent之间的通信使用了gRPC</strong>。</li>
<li><strong>pinpoint</strong><br> 同样，pinpoint也是支持集群和单机部署的。<strong>pinpoint agent通过thrift通信框架，发送链路信息到collector</strong>。</li>
</ol>
<h3 id="2-4-全面的调用链路数据分析"><a href="#2-4-全面的调用链路数据分析" class="headerlink" title="2.4 全面的调用链路数据分析"></a>2.4 全面的调用链路数据分析</h3><p>全面的调用链路数据分析，提供代码级别的可见性以便轻松定位失败点和瓶颈。</p>
<p><strong>zipkin</strong></p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339676013.png" alt="zipkin"><br><strong>zipkin的链路监控粒度相对没有那么细</strong>，从上图可以看到调用链中具体到接口级别，再进一步的调用信息并未涉及。</p>
<p><strong>skywalking</strong></p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339690665.png" alt="skywalking"></p>
<pre><code>**skywalking 还支持20+的中间件、框架、类库**，比如：主流的dubbo、Okhttp，还有DB和消息中间件。上图skywalking链路调用分析截取的比较简单，网关调用user服务，**由于支持众多的中间件，所以skywalking链路调用分析比zipkin完备些**。
</code></pre>
<p><strong>pinpoint</strong></p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339702378.png" alt="pinpoint"><br> pinpoint应该是这三种APM组件中，<strong>数据分析最为完备的组件</strong>。提供代码级别的可见性以便轻松定位失败点和瓶颈，上图可以看到对于执行的sql语句，都进行了记录。还可以配置报警规则等，设置每个应用对应的负责人，根据配置的规则报警，支持的中间件和框架也比较完备。</p>
<h3 id="2-5-对于开发透明，容易开关"><a href="#2-5-对于开发透明，容易开关" class="headerlink" title="2.5  对于开发透明，容易开关"></a>2.5  对于开发透明，容易开关</h3><p>对于开发透明，容易开关，添加新功能而无需修改代码，容易启用或者禁用。我们期望功能可以不修改代码就工作并希望得到代码级别的可见性。</p>
<p>对于这一点，<strong>Zipkin 使用修改过的类库和它自己的容器(Finagle)来提供分布式事务跟踪的功能</strong>。但是，它要求在需要时修改代码。<strong>skywalking和pinpoint都是基于字节码增强的方式，开发人员不需要修改代码，并且可以收集到更多精确的数据因为有字节码中的更多信息</strong>。</p>
<h3 id="2-6-完整的调用链应用拓扑"><a href="#2-6-完整的调用链应用拓扑" class="headerlink" title="2.6  完整的调用链应用拓扑"></a>2.6  完整的调用链应用拓扑</h3><p>自动检测应用拓扑，帮助你搞清楚应用的架构。</p>
<p>zipkin链路拓扑：<br><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339925728.png" alt="zipkin链路拓扑"></p>
<p>skywalking链路拓扑：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339959895.png" alt="skywalking链路拓扑"></p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339973274.png" alt="pinpoint"></p>
<p>三个组件都能实现完整的调用链应用拓扑。相对来说：</p>
<ul>
<li>pinpoint界面显示的更加丰富，具体到调用的DB名</li>
<li>zipkin的拓扑局限于服务于服务之间</li>
</ul>
<h3 id="2-7-社区支持"><a href="#2-7-社区支持" class="headerlink" title="2.7  社区支持"></a>2.7  社区支持</h3><p>Zipkin 由 Twitter 开发，可以算得上是明星团队，而 pinpoint的Naver 的团队只是一个默默无闻的小团队，skywalking是国内的明星项目，目前属于apache孵化项目，社区活跃。</p>
<h3 id="2-8-总结"><a href="#2-8-总结" class="headerlink" title="2.8  总结"></a>2.8  总结</h3><table>
<thead>
<tr>
<th></th>
<th>zipkin</th>
<th>pinpoint</th>
<th>skywalking</th>
</tr>
</thead>
<tbody><tr>
<td>探针性能</td>
<td>中</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>collector扩展性</td>
<td><strong>高</strong></td>
<td>中</td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>调用链路数据分析</td>
<td>低</td>
<td><strong>高</strong></td>
<td>中</td>
</tr>
<tr>
<td>对开发透明性</td>
<td>中</td>
<td><strong>高</strong></td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>调用链应用拓扑</td>
<td>中</td>
<td><strong>高</strong></td>
<td>中</td>
</tr>
<tr>
<td>社区支持</td>
<td><strong>高</strong></td>
<td>中</td>
<td><strong>高</strong></td>
</tr>
</tbody></table>
<p>相对来说，skywalking更占优，因此团队采用skywalking作为APM工具。</p>
<h2 id="3-参考内容"><a href="#3-参考内容" class="headerlink" title="3. 参考内容"></a>3. 参考内容</h2><p>本文主要内容参考下文：<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5a7a9e0af265da4e914b46f1">https://juejin.im/post/5a7a9e0af265da4e914b46f1</a><br><a target="_blank" rel="noopener" href="http://bigbully.github.io/Dapper-translation/">http://bigbully.github.io/Dapper-translation/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/08/24/jqpeng-%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/08/24/jqpeng-%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">统一配置中心选型对比</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-24 11:03:00" itemprop="dateCreated datePublished" datetime="2018-08-24T11:03:00+08:00">2018-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/configserver-compair.html">统一配置中心选型对比</a></p>
<p>整理笔记时发现之前整理的一些东西，分享给大家。</p>
<h2 id="为什么需要集中配置"><a href="#为什么需要集中配置" class="headerlink" title="为什么需要集中配置"></a>为什么需要集中配置</h2><p><strong>程序的发展，需要引入集中配置</strong>：</p>
<ul>
<li>随着程序功能的日益复杂，程序的配置日益增多：各种功能的开关、参数的配置、服务器的地址……</li>
<li>并且对配置的期望也越来越高，配置修改后实时生效，灰度发布，分环境、分集群管理配置，完善的权限、审核机制……</li>
<li>并且随着采用分布式的开发模式，项目之间的相互引用随着服务的不断增多，相互之间的调用复杂度成指数升高，每次投产或者上线新的项目时苦不堪言，因此需要引用配置中心治理。</li>
</ul>
<p><strong>已有zookeeper、etcd还需要引入吗</strong>？</p>
<ul>
<li>之前的音乐服务项目，通过etcd实现了服务的注册与发现，且一些业务配置也存储到etcd中，通过实践我们收获了集中配置带来的优势</li>
<li>但是etcd并没有方便的UI管理工具，且缺乏权限、审核等机制</li>
<li>最重要的是，etcd和zookeeper通常定义为<strong>服务注册中心</strong>，统一配置中心的事情交给专业的工具去解决。</li>
</ul>
<h2 id="有哪些开源配置中心"><a href="#有哪些开源配置中心" class="headerlink" title="有哪些开源配置中心"></a>有哪些开源配置中心</h2><ol>
<li>spring-cloud/spring-cloud-config<br><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a><br>spring出品，可以和spring cloud无缝配合</li>
<li>淘宝 diamond<br><a target="_blank" rel="noopener" href="https://github.com/takeseem/diamond">https://github.com/takeseem/diamond</a><br>已经不维护</li>
<li>disconf<br><a target="_blank" rel="noopener" href="https://github.com/knightliao/disconf">https://github.com/knightliao/disconf</a><br>java开发，蚂蚁金服技术专家发起，业界使用广泛</li>
<li>ctrip apollo<br><a target="_blank" rel="noopener" href="https://github.com/ctripcorp/apollo/">https://github.com/ctripcorp/apollo/</a><br>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。</li>
</ol>
<h2 id="配置中心对别"><a href="#配置中心对别" class="headerlink" title="配置中心对别"></a>配置中心对别</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p>我们先从功能层面来对别</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>静态配置管理</td>
<td>高</td>
<td>基于file</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>动态配置管理</td>
<td>高</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>统一管理</td>
<td>高</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>多环境</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>本地配置缓存</td>
<td>高</td>
<td>无</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置锁</td>
<td>中</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不允许动态及远程更新</td>
</tr>
<tr>
<td>配置校验</td>
<td>中</td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>如：ip地址校验，配置</td>
</tr>
<tr>
<td>配置生效时间</td>
<td></td>
<td>重启生效，或手动refresh生效</td>
<td>实时</td>
<td>实时</td>
<td>需要结合热加载管理， springcloudconfig需要 git webhook+rabbitmq 实时生效</td>
</tr>
<tr>
<td>配置更新推送</td>
<td>高</td>
<td>需要手工触发</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置定时拉取</td>
<td>高</td>
<td>无</td>
<td>支持</td>
<td>配置更新目前依赖事件驱动， client重启或者server端推送操作</td>
<td></td>
</tr>
<tr>
<td>用户权限管理</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>授权、审核、审计</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>无</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>配置版本管理</td>
<td>高</td>
<td>Git做版本管理</td>
<td>界面上直接提供发布历史和回滚按钮</td>
<td>操作记录有落数据库，但无查询接口</td>
<td></td>
</tr>
<tr>
<td>配置合规检测</td>
<td>高</td>
<td>不支持</td>
<td>支持（但还需完善）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>实例配置监控</td>
<td>高</td>
<td>需要结合springadmin</td>
<td>支持</td>
<td>支持，可以查看每个配置在哪些机器上加载</td>
<td></td>
</tr>
<tr>
<td>灰度发布</td>
<td>中</td>
<td>不支持</td>
<td>支持</td>
<td>不支持部分更新</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>告警通知</td>
<td>中</td>
<td>不支持</td>
<td>支持，邮件方式告警</td>
<td>支持，邮件方式告警</td>
<td></td>
</tr>
<tr>
<td>依赖关系</td>
<td>高</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>配置与系统版本的依赖系统运行时的依赖关系</td>
</tr>
</tbody></table>
<h3 id="技术路线兼容性"><a href="#技术路线兼容性" class="headerlink" title="技术路线兼容性"></a>技术路线兼容性</h3><p>引入配置中心，需要考虑和现有项目的兼容性，以及是否引入额外的第三方组件。我们的java项目以SpringBoot为主，需要重点关注springboot支持性。</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SpringBoot支持</td>
<td>高</td>
<td>原生支持</td>
<td>支持</td>
<td>与spring boot无相关</td>
<td></td>
</tr>
<tr>
<td>SpringCloud支持</td>
<td>高</td>
<td>原生支持</td>
<td>支持</td>
<td>与spring cloud无相关</td>
<td></td>
</tr>
<tr>
<td>客户端支持</td>
<td>低</td>
<td>Java</td>
<td>Java、.Net</td>
<td>java</td>
<td></td>
</tr>
<tr>
<td>业务系统侵入性</td>
<td>高</td>
<td>侵入性弱</td>
<td>侵入性弱</td>
<td>侵入性弱，支持注解及xml方式</td>
<td></td>
</tr>
<tr>
<td>依赖组件</td>
<td>高</td>
<td>Eureka</td>
<td>Eureka</td>
<td>zookeeper</td>
<td></td>
</tr>
</tbody></table>
<h3 id="可用性与易用性"><a href="#可用性与易用性" class="headerlink" title="可用性与易用性"></a>可用性与易用性</h3><p>引入配置中心后，所有的应用都需要依赖配置中心，因此可用性需要重点关注，另外管理的易用性也需要关注。</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>单点故障（SPOF）</td>
<td>高</td>
<td>支持HA部署</td>
<td>支持HA部署</td>
<td>支持HA部署，高可用由zookeeper保证</td>
<td></td>
</tr>
<tr>
<td>多数据中心部署</td>
<td>高</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置获取性能</td>
<td>高</td>
<td>unkown</td>
<td>unkown（官方说比spring快）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>配置界面</td>
<td>中</td>
<td>无，需要通过git操作</td>
<td>统一界面（ng编写）</td>
<td>统一界面</td>
<td></td>
</tr>
</tbody></table>
<h2 id="最终选择"><a href="#最终选择" class="headerlink" title="最终选择"></a>最终选择</h2><p>综上，ctrip applo是较好的选择方案，最终选择applo。</p>
<ul>
<li>支持不同环境（开发、测试、生产）、不同集群</li>
<li>完善的管理系统，权限管理、发布审核、操作审计</li>
<li>SpringBoot集成友好 ，较小的迁移成本</li>
<li>配置修改实时生效（热发布）</li>
<li>版本发布管理</li>
</ul>
<h3 id="部署情况"><a href="#部署情况" class="headerlink" title="部署情况"></a>部署情况</h3><ul>
<li>管理Web：<a target="_blank" rel="noopener" href="http://config/">http://config</a>.***.com/</li>
<li>三个环境MetaServer：<ul>
<li>Dev： config.devmeta.***.com</li>
<li>Test： config.testmeta.***.com</li>
<li>PRO: config.prometa.***.com</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/08/19/jqpeng-Spring%20boot%E5%9B%BD%E9%99%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/08/19/jqpeng-Spring%20boot%E5%9B%BD%E9%99%85%E5%8C%96/" class="post-title-link" itemprop="url">Spring boot国际化</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-19 13:27:00" itemprop="dateCreated datePublished" datetime="2018-08-19T13:27:00+08:00">2018-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-boot-i18n.html">Spring boot国际化</a></p>
<p>国际化主要是引入了MessageSource，我们简单看下如何使用，以及其原理。</p>
<h2 id="1-1-设置资源文件"><a href="#1-1-设置资源文件" class="headerlink" title="1.1 设置资源文件"></a>1.1 设置资源文件</h2><p>在 properties新建i18n目录</p>
<p>新建message文件：</p>
<p>messages.properties</p>
<pre><code>error.title=Your request cannot be processed
</code></pre>
<p>messages_zh_CN.properties</p>
<pre><code>error.title=您的请求无法处理
</code></pre>
<h2 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h2><p>修改properties文件的目录：在application.yml或者application.properties中配置 spring.message.basename</p>
<pre><code>spring:
    application:
        name: test-worklog
    messages:
        basename: i18n/messages
        encoding: UTF-8
</code></pre>
<h2 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h2><p>引用自动注解的MessageSource,调用<code>messageSource.getMessage</code>即可，注意，需要通过<code> LocaleContextHolder.getLocale()</code>获取当前的地区。</p>
<pre><code>@Autowired
private MessageSource messageSource;
/**
 * 国际化
 *
 * @param result
 * @return
 */
public String getMessage(String result, Object[] params) &#123;
    String message = &quot;&quot;;
    try &#123;
        Locale locale = LocaleContextHolder.getLocale();
        message = messageSource.getMessage(result, params, locale);
    &#125; catch (Exception e) &#123;
        LOGGER.error(&quot;parse message error! &quot;, e);
    &#125;
    return message;
&#125;
</code></pre>
<p>如何设置个性化的地区呢? <code>forLanguageTag</code> 即可</p>
<pre><code> Locale locale = Locale.forLanguageTag(user.getLangKey());
</code></pre>
<h2 id="1-4-原理分析"><a href="#1-4-原理分析" class="headerlink" title="1.4 原理分析"></a>1.4 原理分析</h2><p><code>MessageSourceAutoConfiguration</code>中，实现了autoconfig</p>
<pre><code>@Configuration
@ConditionalOnMissingBean(value = MessageSource.class, search = SearchStrategy.CURRENT)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Conditional(ResourceBundleCondition.class)
@EnableConfigurationProperties
@ConfigurationProperties(prefix = &quot;spring.messages&quot;)
public class MessageSourceAutoConfiguration &#123;
</code></pre>
<p>该类一方面读取配置文件，一方面创建了MessageSource的实例:</p>
<pre><code>@Beanpublic MessageSource messageSource() &#123;    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();    if (StringUtils.hasText(this.basename)) &#123;        messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(                StringUtils.trimAllWhitespace(this.basename)));    &#125;    if (this.encoding != null) &#123;        messageSource.setDefaultEncoding(this.encoding.name());    &#125;    messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);    messageSource.setCacheSeconds(this.cacheSeconds);    messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);    return messageSource;&#125;
</code></pre>
<p>因此，默认是加载的<code>ResourceBundleMessageSource</code>，该类派生与于AbstractResourceBasedMessageSource</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532590285975.jpg" alt="enter description here" title="1532590285975"></p>
<pre><code>@Overridepublic final String getMessage(String code, Object[] args, String defaultMessage, Locale locale) &#123;    String msg = getMessageInternal(code, args, locale);    if (msg != null) &#123;        return msg;    &#125;    if (defaultMessage == null) &#123;        String fallback = getDefaultMessage(code);        if (fallback != null) &#123;            return fallback;        &#125;    &#125;    return renderDefaultMessage(defaultMessage, args, locale);&#125;
</code></pre>
<p>最终是调用resolveCode来获取message，通过ResourceBundle来获取message</p>
<pre><code>    @Overrideprotected MessageFormat resolveCode(String code, Locale locale) &#123;    // 遍历语言文件路径    Set&lt;String&gt; basenames = getBasenameSet();    for (String basename : basenames) &#123;        ResourceBundle bundle = getResourceBundle(basename, locale);        if (bundle != null) &#123;            MessageFormat messageFormat = getMessageFormat(bundle, code, locale);            if (messageFormat != null) &#123;                return messageFormat;            &#125;        &#125;    &#125;    return null;&#125;
// 获取ResourceBundle    
protected ResourceBundle getResourceBundle(String basename, Locale locale) &#123;    if (getCacheMillis() &gt;= 0) &#123;        // Fresh ResourceBundle.getBundle call in order to let ResourceBundle        // do its native caching, at the expense of more extensive lookup steps.        return doGetBundle(basename, locale);    &#125;    else &#123;        // Cache forever: prefer locale cache over repeated getBundle calls.        synchronized (this.cachedResourceBundles) &#123;            Map&lt;Locale, ResourceBundle&gt; localeMap = this.cachedResourceBundles.get(basename);            if (localeMap != null) &#123;                ResourceBundle bundle = localeMap.get(locale);                if (bundle != null) &#123;                    return bundle;                &#125;            &#125;            try &#123;                ResourceBundle bundle = doGetBundle(basename, locale);                if (localeMap == null) &#123;                    localeMap = new HashMap&lt;Locale, ResourceBundle&gt;();                    this.cachedResourceBundles.put(basename, localeMap);                &#125;                localeMap.put(locale, bundle);                return bundle;            &#125;            catch (MissingResourceException ex) &#123;                if (logger.isWarnEnabled()) &#123;                    logger.warn(&quot;ResourceBundle [&quot; + basename + &quot;] not found for MessageSource: &quot; + ex.getMessage());                &#125;                // Assume bundle not found                // -&gt; do NOT throw the exception to allow for checking parent message source.                return null;            &#125;        &#125;    &#125;&#125;

//  ResourceBundle    
protected ResourceBundle doGetBundle(String basename, Locale locale) throws MissingResourceException &#123;    return ResourceBundle.getBundle(basename, locale, getBundleClassLoader(), new MessageSourceControl());
&#125;
</code></pre>
<p>最后来看getMessageFormat：</p>
<pre><code>/** * Return a MessageFormat for the given bundle and code, * fetching already generated MessageFormats from the cache. * @param bundle the ResourceBundle to work on * @param code the message code to retrieve * @param locale the Locale to use to build the MessageFormat * @return the resulting MessageFormat, or &#123;@code null&#125; if no message * defined for the given code * @throws MissingResourceException if thrown by the ResourceBundle */protected MessageFormat getMessageFormat(ResourceBundle bundle, String code, Locale locale)        throws MissingResourceException &#123;
    synchronized (this.cachedBundleMessageFormats) &#123;        // 从缓存读取        Map&lt;String, Map&lt;Locale, MessageFormat&gt;&gt; codeMap = this.cachedBundleMessageFormats.get(bundle);        Map&lt;Locale, MessageFormat&gt; localeMap = null;        if (codeMap != null) &#123;            localeMap = codeMap.get(code);            if (localeMap != null) &#123;                MessageFormat result = localeMap.get(locale);                if (result != null) &#123;                    return result;                &#125;            &#125;        &#125;        // 缓存miss，从bundle读取        String msg = getStringOrNull(bundle, code);        if (msg != null) &#123;            if (codeMap == null) &#123;                codeMap = new HashMap&lt;String, Map&lt;Locale, MessageFormat&gt;&gt;();                this.cachedBundleMessageFormats.put(bundle, codeMap);            &#125;            if (localeMap == null) &#123;                localeMap = new HashMap&lt;Locale, MessageFormat&gt;();                codeMap.put(code, localeMap);            &#125;            MessageFormat result = createMessageFormat(msg, locale);            localeMap.put(locale, result);            return result;        &#125;
        return null;    &#125;&#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/08/09/jqpeng-%E7%AE%A1%E7%90%86%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/08/09/jqpeng-%E7%AE%A1%E7%90%86%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">管理培训笔记</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 10:41:00" itemprop="dateCreated datePublished" datetime="2018-08-09T10:41:00+08:00">2018-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/9447480.html">管理培训笔记</a></p>
<h2 id="开启-领导之路"><a href="#开启-领导之路" class="headerlink" title="开启 领导之路"></a>开启 领导之路</h2><h3 id="建立团队"><a href="#建立团队" class="headerlink" title="建立团队"></a>建立团队</h3><h4 id="什么是团队？"><a href="#什么是团队？" class="headerlink" title="什么是团队？"></a>什么是团队？</h4><ol>
<li>一群人为了共同目的而奋斗，惟有通过成员间有效合作共事才能达成目标</li>
<li>团队具有共同的目的：使命、职责、目标</li>
</ol>
<h4 id="使命"><a href="#使命" class="headerlink" title="使命"></a>使命</h4><p>包含三个方面：</p>
<ol>
<li>团队是谁</li>
<li>团队存在的理由</li>
<li>团队支持何种组织目标的实现</li>
</ol>
<h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h4><p>团队所负责的具体职责，是具体的可落地工作：</p>
<p>对于一个IT团队，可能的职责是：</p>
<ol>
<li>推动公司内部管理信息化， 负责内部网络信息系统的建设</li>
<li>负责公司电子商务 的应用推广工作</li>
<li>负责公司员工 电子商务系统应用的培训</li>
</ol>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>目标是短期、中长期具体工作规划。制定目标需要符合SMART原则。</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672418534.jpg" alt="SMART原则" title="SMART原则"></p>
<p>建立团队规范：<br> 沟通、会议、决策、冲突</p>
<h2 id="保障-运营卓越"><a href="#保障-运营卓越" class="headerlink" title="保障 运营卓越"></a>保障 运营卓越</h2><p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672674475.jpg" alt=" 任务规划与执行的步骤" title="1532672674475"></p>
<h3 id="1-明确需求"><a href="#1-明确需求" class="headerlink" title="1. 明确需求"></a>1. 明确需求</h3><h4 id="什么是计划"><a href="#什么是计划" class="headerlink" title="什么是计划"></a>什么是计划</h4><p>为实现目标，而规划自己与他人的行动</p>
<h4 id="什么是“执行力”？"><a href="#什么是“执行力”？" class="headerlink" title="什么是“执行力”？"></a>什么是“执行力”？</h4><p>有效运用资源，达成目标的能力</p>
<h4 id="任务规划与执行的步骤"><a href="#任务规划与执行的步骤" class="headerlink" title="任务规划与执行的步骤"></a>任务规划与执行的步骤</h4><ul>
<li>建立信息基础，分析整理已知信息，计划需要收集的信息</li>
<li>信息基础：假设、准则/条件、资源、行动</li>
<li>考虑个人特质： 客观、远见、主动</li>
</ul>
<h3 id="2-定计划"><a href="#2-定计划" class="headerlink" title="2. 定计划"></a>2. 定计划</h3><ul>
<li><p>任务和行动：</p>
<ul>
<li>任务并非单一的行动，而是若干个单一行动组成的</li>
<li>行动是可执行的步骤，是能够推进任务完成的、具体的、可实施的行动</li>
<li>行动需要为任务服务</li>
</ul>
</li>
<li><p>注意行动排序</p>
<ul>
<li>识别任务清单中各项行动的相互关联与依赖关系</li>
<li>并据各项行动的先后顺序，安排和确定工作</li>
</ul>
</li>
<li><p>评估风险、机会 四象限</p>
<ul>
<li>从影响大小、概率高低</li>
</ul>
<p>  <img src="http://oyqmmpkcm.bkt.clouddn.com/1532672842584.jpg" alt="评估风险/机会" title="1532672842584"></p>
</li>
</ul>
<h3 id="3-分职责"><a href="#3-分职责" class="headerlink" title="3. 分职责"></a>3. 分职责</h3><ul>
<li>团队分工：RACI<ul>
<li>Responsible 负责人</li>
<li>Accountable 当责人</li>
<li>Consult 被咨询人</li>
<li>Inform 知情者</li>
</ul>
</li>
</ul>
<p>需要注意，负责人和当责人之间的三不管地带：</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672894561.jpg" alt="团队分工:RACI" title="1532672894561"></p>
<p>任务分配时，需要明确期待的结果，方便跟踪和评价。</p>
<p>同时注意，选择合适人员  </p>
<ul>
<li>客观条件  </li>
<li>人员意愿  </li>
</ul>
<ul>
<li>不会做  </li>
<li>不能做  </li>
<li>不想做</li>
</ul>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532673100397.jpg" alt="enter description here" title="1532673100397"></p>
<h3 id="4-做追踪"><a href="#4-做追踪" class="headerlink" title="4. 做追踪"></a>4. 做追踪</h3><blockquote>
<p>郭士纳说：人们不会做你希望的，只会做你检查的；如果你强调什么，你就检查什么，你不检查就等于不重视</p>
</blockquote>
<p>因此，你强调什么，就一定要检查什么！</p>
<p>追踪流程：  </p>
<ul>
<li> 收集资料  </li>
<li> 对标找差  </li>
<li> 纠偏强化</li>
</ul>
<p>追踪需要重点关注结果和行为。</p>
<p>常见的追踪方法：  </p>
<ul>
<li> 召集 会议  </li>
<li> 观察 检查  </li>
<li> 定期反馈 及报告</li>
</ul>
<p>如何有效追踪：</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532673452477.jpg" alt="如何有效追踪" title="如何有效追踪"></p>
<h2 id="确保-沟通有效"><a href="#确保-沟通有效" class="headerlink" title="确保 沟通有效"></a>确保 沟通有效</h2><h3 id="破除沟通障碍"><a href="#破除沟通障碍" class="headerlink" title="破除沟通障碍"></a>破除沟通障碍</h3><h4 id="常见沟通障碍"><a href="#常见沟通障碍" class="headerlink" title="常见沟通障碍"></a>常见沟通障碍</h4><p>认知偏差、听不到位 无效表达、缺乏参与</p>
<h4 id="破除沟通障碍三法宝：-听、问、说"><a href="#破除沟通障碍三法宝：-听、问、说" class="headerlink" title="破除沟通障碍三法宝： 听、问、说"></a>破除沟通障碍三法宝： 听、问、说</h4><p>提高沟通效能</p>
<p>互动五流程：</p>
<ol>
<li>定方向</li>
<li>理情况</li>
<li>想方法</li>
<li>明作法</li>
<li>做总结</li>
</ol>
<h4 id="观人沟通术"><a href="#观人沟通术" class="headerlink" title="观人沟通术"></a>观人沟通术</h4><p>人际矩阵</p>
<p>理解自己，理解他人-PDP</p>
<p>利用PDP与风格不同的人更 好合作</p>
<h2 id="辅导员工"><a href="#辅导员工" class="headerlink" title="辅导员工"></a>辅导员工</h2><h3 id="主管，你是教练"><a href="#主管，你是教练" class="headerlink" title="主管，你是教练"></a>主管，你是教练</h3><p>常见辅导议题</p>
<h3 id="发现辅导机会"><a href="#发现辅导机会" class="headerlink" title="发现辅导机会"></a>发现辅导机会</h3><p>发现征兆、收集信息</p>
<p>检验原因、做出判断</p>
<h3 id="进行有效辅导"><a href="#进行有效辅导" class="headerlink" title="进行有效辅导"></a>进行有效辅导</h3><p>利用沟通三法宝和互动五流 程进行有效辅导</p>
<h3 id="辅导反馈与跟进"><a href="#辅导反馈与跟进" class="headerlink" title="辅导反馈与跟进"></a>辅导反馈与跟进</h3><p>有效反馈要诀： 及时、平衡、具体<br> 两种反馈工具： 正面反馈(STAR) 改进型反馈(STAR/AR)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/07/05/jqpeng-Jhipster%20Registry%EF%BC%88Eureka%20Server%EF%BC%89%20Docker%E5%8F%8C%E5%90%91%E8%81%94%E9%80%9A%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/07/05/jqpeng-Jhipster%20Registry%EF%BC%88Eureka%20Server%EF%BC%89%20Docker%E5%8F%8C%E5%90%91%E8%81%94%E9%80%9A%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">Jhipster Registry（Eureka Server） Docker双向联通与高可用部署</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 09:56:00" itemprop="dateCreated datePublished" datetime="2018-07-05T09:56:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/9266722.html">Jhipster Registry（Eureka Server） Docker双向联通与高可用部署</a></p>
<p>使用Compose来编排这个Eureka Server集群：</p>
<h2 id="peer1配置："><a href="#peer1配置：" class="headerlink" title="peer1配置："></a>peer1配置：</h2><pre><code>server:
    port: 8761

eureka:
    instance:
        hostname: eureka-peer-1
    server:
        # see discussion about enable-self-preservation:
        # https://github.com/jhipster/generator-jhipster/issues/3654
        enable-self-preservation: false
        registry-sync-retry-wait-ms: 500
        a-sgcache-expiry-timeout-ms: 60000
        eviction-interval-timer-in-ms: 30000
        peer-eureka-nodes-update-interval-ms: 30000
        renewal-threshold-update-interval-ms: 15000
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
            defaultZone: http://admin:$&#123;spring.security.user.password:admin&#125;@eureka-peer-2:8762/eureka/
</code></pre>
<h2 id="peer2配置："><a href="#peer2配置：" class="headerlink" title="peer2配置："></a>peer2配置：</h2><pre><code>server:
    port: 8762

eureka:
    instance:
        hostname: eureka-peer-2
    server:
        # see discussion about enable-self-preservation:
        # https://github.com/jhipster/generator-jhipster/issues/3654
        enable-self-preservation: false
        registry-sync-retry-wait-ms: 500
        a-sgcache-expiry-timeout-ms: 60000
        eviction-interval-timer-in-ms: 30000
        peer-eureka-nodes-update-interval-ms: 30000
        renewal-threshold-update-interval-ms: 15000
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
            defaultZone: http://admin:$&#123;spring.security.user.password:admin&#125;@eureka-peer-1:8761/eureka/
</code></pre>
<h2 id="构建Image"><a href="#构建Image" class="headerlink" title="构建Image"></a>构建Image</h2><p>使用官方的DockerFile：</p>
<pre><code>FROM openjdk:8-jre-alpine

ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \
    JAVA_OPTS=&quot;&quot; \
    JHIPSTER_SLEEP=0

VOLUME /tmp
EXPOSE 8761
CMD echo &quot;The application will start in $&#123;JHIPSTER_SLEEP&#125;s...&quot; &amp;&amp; \
    sleep $&#123;JHIPSTER_SLEEP&#125; &amp;&amp; \
    java $&#123;JAVA_OPTS&#125; -Djava.security.egd=file:/dev/./urandom -jar /app.war

# add directly the war
ADD *.war /app.war
</code></pre>
<p>构建Image并push到registry，这里是192.168.86.8:5000/registry-dev</p>
<h2 id="编写compose文件："><a href="#编写compose文件：" class="headerlink" title="编写compose文件："></a>编写compose文件：</h2><pre><code>version: &quot;3&quot; 
services:
  eureka-peer-1 :
    image: 192.168.86.8:5000/registry-dev:latest
    links:
      - eureka-peer-2
    ports:
      - &quot;8761:8761&quot;
    environment:
      spring.profiles.active: oauth2,peer1,swagger
    entrypoint:
      - java
      - -Dspring.profiles.active=oauth2,peer1,swagger
      - -Djava.security.egd=file:/dev/./urandom
      - -jar
      - /app.war
  eureka-peer-2:
    image: 192.168.86.8:5000/registry-dev:latest
    links:
      - eureka-peer-1
    expose:
      - &quot;8762&quot;
    ports:
      - &quot;8762:8762&quot;
    environment:
      spring.profiles.active: oauth2,peer2,swagger
    entrypoint:
      - java
      - -Dspring.profiles.active=oauth2,peer2,swagger
      - -Djava.security.egd=file:/dev/./urandom
      - -jar
      - /app.war
</code></pre>
<p>启动即可。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/06/29/jqpeng-%EF%BC%88%E8%BD%AC%E9%98%AE%E4%B8%80%E5%B3%B0%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OAuth%202.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/06/29/jqpeng-%EF%BC%88%E8%BD%AC%E9%98%AE%E4%B8%80%E5%B3%B0%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OAuth%202.0/" class="post-title-link" itemprop="url">（转阮一峰）深入理解OAuth 2.0</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-29 08:51:00" itemprop="dateCreated datePublished" datetime="2018-06-29T08:51:00+08:00">2018-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/9241712.html">（转阮一峰）深入理解OAuth 2.0</a></p>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/OAuth">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。</p>
<p>本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a target="_blank" rel="noopener" href="http://www.rfcreader.com/#rfc6749">RFC 6749</a>。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051201.png" alt="OAuth Logo"></p>
<h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p>
<p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051202.png" alt="云冲印"></p>
<p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p>
<p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p>
<blockquote>
<p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。</p>
<p>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</p>
<p>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。</p>
<p>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</p>
<p>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p>
</blockquote>
<p>OAuth就是为了解决上面这些问题而诞生的。</p>
<h2 id="二、名词定义"><a href="#二、名词定义" class="headerlink" title="二、名词定义"></a>二、名词定义</h2><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p>
<blockquote>
<p>（1） <strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</p>
<p>（2）<strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。</p>
<p>（3）<strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。</p>
<p>（4）<strong>User Agent</strong>：用户代理，本文中就是指浏览器。</p>
<p>（5）<strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</p>
<p>（6）<strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
</blockquote>
<p>知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p>
<h2 id="三、OAuth的思路"><a href="#三、OAuth的思路" class="headerlink" title="三、OAuth的思路"></a>三、OAuth的思路</h2><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<h2 id="四、运行流程"><a href="#四、运行流程" class="headerlink" title="四、运行流程"></a>四、运行流程</h2><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png" alt="OAuth运行流程"></p>
<blockquote>
<p>（A）用户打开客户端以后，客户端要求用户给予授权。</p>
<p>（B）用户同意给予客户端授权。</p>
<p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p>
<p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p>
<p>（E）客户端使用令牌，向资源服务器申请获取资源。</p>
<p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
</blockquote>
<p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<p>下面一一讲解客户端获取授权的四种模式。</p>
<h2 id="五、客户端的授权模式"><a href="#五、客户端的授权模式" class="headerlink" title="五、客户端的授权模式"></a>五、客户端的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h2 id="六、授权码模式"><a href="#六、授权码模式" class="headerlink" title="六、授权码模式"></a>六、授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051204.png" alt="授权码模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A步骤中，客户端申请认证的URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1<br>    Host: server.example.com</p>
</blockquote>
<p>C步骤中，服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 302 Found<br>    Location: <a target="_blank" rel="noopener" href="https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA">https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</a><br>              &amp;state=xyz</p>
</blockquote>
<p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>    Host: server.example.com<br>    Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>    Content-Type: application/x-www-form-urlencoded</p>
<pre><code>grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
</code></pre>
</blockquote>
<p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p>
<h2 id="七、简化模式"><a href="#七、简化模式" class="headerlink" title="七、简化模式"></a>七、简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051205.png" alt="简化模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端将用户导向认证服务器。</p>
<p>（B）用户决定是否给于客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p>
<p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p>
<p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p>
<p>（G）浏览器将令牌发给客户端。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，此处的值固定为”token”，必选项。</li>
<li>client_id：表示客户端的ID，必选项。</li>
<li>redirect_uri：表示重定向的URI，可选项。</li>
<li>scope：表示权限范围，可选项。</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1<br>        Host: server.example.com</p>
</blockquote>
<p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 302 Found<br>         Location: <a target="_blank" rel="noopener" href="http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA">http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</a><br>                   &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</p>
</blockquote>
<p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p>
<p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p>
<h2 id="八、密码模式"><a href="#八、密码模式" class="headerlink" title="八、密码模式"></a>八、密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051206.png" alt="密码模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户向客户端提供用户名和密码。</p>
<p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p>
<p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=password&amp;username=johndoe&amp;password=A3ddj3w
</code></pre>
</blockquote>
<p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<p>整个过程中，客户端不得保存用户的密码。</p>
<h2 id="九、客户端模式"><a href="#九、客户端模式" class="headerlink" title="九、客户端模式"></a>九、客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051207.png" alt="客户端模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p>
<p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”client_credentials”，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=client_credentials
</code></pre>
</blockquote>
<p>认证服务器必须以某种方式，验证客户端身份。</p>
<p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<h2 id="十、更新令牌"><a href="#十、更新令牌" class="headerlink" title="十、更新令牌"></a>十、更新令牌</h2><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，此处的值固定为”refresh_token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
</code></pre>
</blockquote>
<p>（完）</p>
<hr>
<p>出处：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/2014/05/oauth_2_0.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/06/14/jqpeng-%E5%9F%BA%E4%BA%8Espring%20security%20%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/06/14/jqpeng-%E5%9F%BA%E4%BA%8Espring%20security%20%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">基于spring security 实现前后端分离项目权限控制</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-14 09:04:00" itemprop="dateCreated datePublished" datetime="2018-06-14T09:04:00+08:00">2018-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security-usage.html">基于spring security 实现前后端分离项目权限控制</a></p>
<p>前后端分离的项目，前端有菜单（menu），后端有API（backendApi），一个menu对应的页面有N个API接口来支持，本文介绍如何基于spring security实现前后端的同步权限控制。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>还是基于Role来实现，具体的思路是，一个Role拥有多个Menu，一个menu有多个backendApi，其中Role和menu，以及menu和backendApi都是ManyToMany关系。</p>
<p>验证授权也很简单，用户登陆系统时，获取Role关联的Menu，页面访问后端API时，再验证下用户是否有访问API的权限。</p>
<h3 id="domain定义"><a href="#domain定义" class="headerlink" title="domain定义"></a>domain定义</h3><p>我们用JPA来实现，先来定义Role</p>
<pre><code>public class Role implements Serializable &#123;


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 名称
     */
    @NotNull
    @ApiModelProperty(value = &quot;名称&quot;, required = true)
    @Column(name = &quot;name&quot;, nullable = false)
    private String name;

    /**
     * 备注
     */
    @ApiModelProperty(value = &quot;备注&quot;)
    @Column(name = &quot;remark&quot;)
    private String remark;

    @JsonIgnore
    @ManyToMany
    @JoinTable(
        name = &quot;role_menus&quot;,
        joinColumns = &#123;@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)&#125;,
        inverseJoinColumns = &#123;@JoinColumn(name = &quot;menu_id&quot;, referencedColumnName = &quot;id&quot;)&#125;)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    @BatchSize(size = 100)
    private Set&lt;Menu&gt; menus = new HashSet&lt;&gt;();&#125;
</code></pre>
<p>以及Menu：</p>
<pre><code>public class Menu implements Serializable &#123;


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = &quot;parent_id&quot;)
    private Integer parentId;

    /**
     * 文本
     */
    @ApiModelProperty(value = &quot;文本&quot;)
    @Column(name = &quot;text&quot;)
    private String text;@ApiModelProperty(value = &quot;angular路由&quot;)
    @Column(name = &quot;link&quot;)
    private String link;
    @ManyToMany
    @JsonIgnore
    @JoinTable(name = &quot;backend_api_menus&quot;,
        joinColumns = @JoinColumn(name=&quot;menus_id&quot;, referencedColumnName=&quot;id&quot;),
        inverseJoinColumns = @JoinColumn(name=&quot;backend_apis_id&quot;, referencedColumnName=&quot;id&quot;))
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set&lt;BackendApi&gt; backendApis = new HashSet&lt;&gt;();

    @ManyToMany(mappedBy = &quot;menus&quot;)
    @JsonIgnore
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();&#125;
</code></pre>
<p>最后是BackendApi，区分method（HTTP请求方法）、tag（哪一个Controller）和path（API请求路径）：</p>
<pre><code>public class BackendApi implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = &quot;tag&quot;)
    private String tag;

    @Column(name = &quot;path&quot;)
    private String path;

    @Column(name = &quot;method&quot;)
    private String method;

    @Column(name = &quot;summary&quot;)
    private String summary;

    @Column(name = &quot;operation_id&quot;)
    private String operationId;

    @ManyToMany(mappedBy = &quot;backendApis&quot;)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set&lt;Menu&gt; menus = new HashSet&lt;&gt;();&#125;
</code></pre>
<h2 id="管理页面实现"><a href="#管理页面实现" class="headerlink" title="管理页面实现"></a>管理页面实现</h2><p>Menu菜单是业务需求确定的，因此提供CRUD编辑即可。<br> BackendAPI，可以通过swagger来获取。<br> 前端选择ng-algin，参见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/angular-ng-alain.html">Angular 中后台前端解决方案 - Ng Alain 介绍</a></p>
<h3 id="通过swagger获取BackendAPI"><a href="#通过swagger获取BackendAPI" class="headerlink" title="通过swagger获取BackendAPI"></a>通过swagger获取BackendAPI</h3><p>获取swagger api有多种方法，最简单的就是访问http接口获取json，然后解析，这很简单，这里不赘述，还有一种就是直接调用相关API获取Swagger对象。</p>
<p>查看官方的web代码，可以看到获取数据大概是这样的：</p>
<pre><code>        String groupName = Optional.fromNullable(swaggerGroup).or(Docket.DEFAULT_GROUP_NAME);
        Documentation documentation = documentationCache.documentationByGroup(groupName);
        if (documentation == null) &#123;
            return new ResponseEntity&lt;Json&gt;(HttpStatus.NOT_FOUND);
        &#125;
        Swagger swagger = mapper.mapDocumentation(documentation);
        UriComponents uriComponents = componentsFrom(servletRequest, swagger.getBasePath());
        swagger.basePath(Strings.isNullOrEmpty(uriComponents.getPath()) ? &quot;/&quot; : uriComponents.getPath());
        if (isNullOrEmpty(swagger.getHost())) &#123;
            swagger.host(hostName(uriComponents));
        &#125;
        return new ResponseEntity&lt;Json&gt;(jsonSerializer.toJson(swagger), HttpStatus.OK);
</code></pre>
<p>其中的documentationCache、environment、mapper等可以直接Autowired获得：</p>
<pre><code>@Autowired
    public SwaggerResource(
        Environment environment,
        DocumentationCache documentationCache,
        ServiceModelToSwagger2Mapper mapper,
        BackendApiRepository backendApiRepository,
        JsonSerializer jsonSerializer) &#123;

        this.hostNameOverride = environment.getProperty(&quot;springfox.documentation.swagger.v2.host&quot;, &quot;DEFAULT&quot;);
        this.documentationCache = documentationCache;
        this.mapper = mapper;
        this.jsonSerializer = jsonSerializer;

        this.backendApiRepository = backendApiRepository;

    &#125;
</code></pre>
<p>然后我们自动加载就简单了，写一个updateApi接口，读取swagger对象，然后解析成BackendAPI，存储到数据库：</p>
<pre><code>@RequestMapping(
        value = &quot;/api/updateApi&quot;,
        method = RequestMethod.GET,
        produces = &#123; APPLICATION_JSON_VALUE, HAL_MEDIA_TYPE &#125;)
    @PropertySourcedMapping(
        value = &quot;$&#123;springfox.documentation.swagger.v2.path&#125;&quot;,
        propertyKey = &quot;springfox.documentation.swagger.v2.path&quot;)
    @ResponseBody
    public ResponseEntity&lt;Json&gt; updateApi(
        @RequestParam(value = &quot;group&quot;, required = false) String swaggerGroup) &#123;

        // 加载已有的api
        Map&lt;String,Boolean&gt; apiMap = Maps.newHashMap();
        List&lt;BackendApi&gt; apis = backendApiRepository.findAll();
        apis.stream().forEach(api-&gt;apiMap.put(api.getPath()+api.getMethod(),true));

        // 获取swagger
        String groupName = Optional.fromNullable(swaggerGroup).or(Docket.DEFAULT_GROUP_NAME);
        Documentation documentation = documentationCache.documentationByGroup(groupName);
        if (documentation == null) &#123;
            return new ResponseEntity&lt;Json&gt;(HttpStatus.NOT_FOUND);
        &#125;
        Swagger swagger = mapper.mapDocumentation(documentation);

        // 加载到数据库
        for(Map.Entry&lt;String, Path&gt; item : swagger.getPaths().entrySet())&#123;
            String path = item.getKey();
            Path pathInfo = item.getValue();
            createApiIfNeeded(apiMap, path,  pathInfo.getGet(), HttpMethod.GET.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getPost(), HttpMethod.POST.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getDelete(), HttpMethod.DELETE.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getPut(), HttpMethod.PUT.name());
        &#125;
        return new ResponseEntity&lt;Json&gt;(HttpStatus.OK);
    &#125;
</code></pre>
<p>其中createApiIfNeeded，先判断下是否存在，不存在的则新增：</p>
<pre><code> private void createApiIfNeeded(Map&lt;String, Boolean&gt; apiMap, String path, Operation operation, String method) &#123;
        if(operation==null) &#123;
            return;
        &#125;
        if(!apiMap.containsKey(path+ method))&#123;
            apiMap.put(path+ method,true);

            BackendApi api = new BackendApi();
            api.setMethod( method);
            api.setOperationId(operation.getOperationId());
            api.setPath(path);
            api.setTag(operation.getTags().get(0));
            api.setSummary(operation.getSummary());

            // 保存
            this.backendApiRepository.save(api);
        &#125;
    &#125;
</code></pre>
<p>最后，做一个简单页面展示即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886480360.jpg" alt="enter description here" title="1528886480360"></p>
<h3 id="菜单管理"><a href="#菜单管理" class="headerlink" title="菜单管理"></a>菜单管理</h3><p>新增和修改页面，可以选择上级菜单，后台API做成按tag分组，可多选即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886647893.jpg" alt="enter description here" title="1528886647893"></p>
<p>列表页面</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886586348.jpg" alt="enter description here" title="1528886586348"></p>
<h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><p>普通的CRUD，最主要的增加一个菜单授权页面，菜单按层级显示即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886692091.jpg" alt="enter description here" title="1528886692091"></p>
<h2 id="认证实现"><a href="#认证实现" class="headerlink" title="认证实现"></a>认证实现</h2><p>管理页面可以做成千奇百样，最核心的还是如何实现认证。</p>
<p>在上一篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a>里我们说了，可以自定义<code>FilterInvocationSecurityMetadataSource</code>来实现。</p>
<p>实现<code>FilterInvocationSecurityMetadataSource</code>接口即可，核心是根据FilterInvocation的Request的method和path，获取对应的Role，然后交给RoleVoter去判断是否有权限。</p>
<h3 id="自定义FilterInvocationSecurityMetadataSource"><a href="#自定义FilterInvocationSecurityMetadataSource" class="headerlink" title="自定义FilterInvocationSecurityMetadataSource"></a>自定义FilterInvocationSecurityMetadataSource</h3><p>我们新建一个DaoSecurityMetadataSource实现FilterInvocationSecurityMetadataSource接口，主要看getAttributes方法：</p>
<pre><code>     @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;
        FilterInvocation fi = (FilterInvocation) object;

        List&lt;Role&gt; neededRoles = this.getRequestNeededRoles(fi.getRequest().getMethod(), fi.getRequestUrl());

        if (neededRoles != null) &#123;
            return SecurityConfig.createList(neededRoles.stream().map(role -&gt; role.getName()).collect(Collectors.toList()).toArray(new String[]&#123;&#125;));
        &#125;

        //  返回默认配置
        return superMetadataSource.getAttributes(object);
    &#125;
</code></pre>
<p>核心是getRequestNeededRoles怎么实现，获取到干净的RequestUrl（去掉参数）,然后看是否有对应的backendAPI，如果没有，则有可能该API有path参数，我们可以去掉最后的path，去库里模糊匹配，直到找到。</p>
<pre><code> public List&lt;Role&gt; getRequestNeededRoles(String method, String path) &#123;
        String rawPath = path;
        //  remove parameters
        if(path.indexOf(&quot;?&quot;)&gt;-1)&#123;
            path = path.substring(0,path.indexOf(&quot;?&quot;));
        &#125;
        // /menus/&#123;id&#125;
        BackendApi api = backendApiRepository.findByPathAndMethod(path, method);
        if (api == null)&#123;
            // try fetch by remove last path
            api = loadFromSimilarApi(method, path, rawPath);
        &#125;

        if (api != null &amp;&amp; api.getMenus().size() &gt; 0) &#123;
            return api.getMenus()
                .stream()
                .flatMap(menu -&gt; menuRepository.findOneWithRolesById(menu.getId()).getRoles().stream())
                .collect(Collectors.toList());
        &#125;
        return null;
    &#125;

    private BackendApi loadFromSimilarApi(String method, String path, String rawPath) &#123;
        if(path.lastIndexOf(&quot;/&quot;)&gt;-1)&#123;
            path = path.substring(0,path.lastIndexOf(&quot;/&quot;));
            List&lt;BackendApi&gt; apis = backendApiRepository.findByPathStartsWithAndMethod(path, method);

            // 如果为空，再去掉一层path
            while(apis==null)&#123;
                if(path.lastIndexOf(&quot;/&quot;)&gt;-1) &#123;
                    path = path.substring(0, path.lastIndexOf(&quot;/&quot;));
                    apis = backendApiRepository.findByPathStartsWithAndMethod(path, method);
                &#125;else&#123;
                    break;
                &#125;
            &#125;

            if(apis!=null)&#123;
                for(BackendApi backendApi : apis)&#123;
                    if (antPathMatcher.match(backendApi.getPath(), rawPath)) &#123;
                        return backendApi;
                    &#125;
                &#125;
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<p>其中，BackendApiRepository：</p>
<pre><code>    @EntityGraph(attributePaths = &quot;menus&quot;)
    BackendApi findByPathAndMethod(String path,String method);

    @EntityGraph(attributePaths = &quot;menus&quot;)
    List&lt;BackendApi&gt; findByPathStartsWithAndMethod(String path,String method);
</code></pre>
<p>以及MenuRepository</p>
<pre><code>    @EntityGraph(attributePaths = &quot;roles&quot;)
    Menu findOneWithRolesById(long id);
</code></pre>
<h3 id="使用DaoSecurityMetadataSource"><a href="#使用DaoSecurityMetadataSource" class="headerlink" title="使用DaoSecurityMetadataSource"></a>使用DaoSecurityMetadataSource</h3><p>需要注意的是，在DaoSecurityMetadataSource里，不能直接注入Repository，我们可以给DaoSecurityMetadataSource添加一个方法，方便传入：</p>
<pre><code>   public void init(MenuRepository menuRepository, BackendApiRepository backendApiRepository) &#123;
        this.menuRepository = menuRepository;
        this.backendApiRepository = backendApiRepository;
    &#125;
</code></pre>
<p>然后建立一个容器，存储实例化的DaoSecurityMetadataSource，我们可以建立如下的ApplicationContext来作为对象容器，存取对象：</p>
<pre><code>public class ApplicationContext &#123;
    static Map&lt;Class&lt;?&gt;,Object&gt; beanMap = Maps.newConcurrentMap();

    public static &lt;T&gt; T getBean(Class&lt;T&gt; requireType)&#123;
        return (T) beanMap.get(requireType);
    &#125;

    public static void registerBean(Object item)&#123;
        beanMap.put(item.getClass(),item);
    &#125;
&#125;
</code></pre>
<p>在SecurityConfiguration配置中使用<code>DaoSecurityMetadataSource</code>，并通过<code> ApplicationContext.registerBean</code>将<code>DaoSecurityMetadataSource</code>注册：</p>
<pre><code> @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)        ....
           // .withObjectPostProcessor()
            // 自定义accessDecisionManager
            .accessDecisionManager(accessDecisionManager())
            // 自定义FilterInvocationSecurityMetadataSource
            .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;
                @Override
                public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
                    O fsi) &#123;
                    fsi.setSecurityMetadataSource(daoSecurityMetadataSource(fsi.getSecurityMetadataSource()));
                    return fsi;
                &#125;
            &#125;)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;

    @Bean
    public DaoSecurityMetadataSource daoSecurityMetadataSource(FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource) &#123;
        DaoSecurityMetadataSource securityMetadataSource = new DaoSecurityMetadataSource(filterInvocationSecurityMetadataSource);
        ApplicationContext.registerBean(securityMetadataSource);
        return securityMetadataSource;
    &#125;
</code></pre>
<p>最后，在程序启动后，通过<code>ApplicationContext.getBean</code>获取到daoSecurityMetadataSource，然后调用init注入Repository</p>
<pre><code> public static void postInit()&#123;
        ApplicationContext
            .getBean(DaoSecurityMetadataSource.class)
 .init(applicationContext.getBean(MenuRepository.class),applicationContext.getBean(BackendApiRepository.class));
    &#125;

    static ConfigurableApplicationContext applicationContext;

    public static void main(String[] args) throws UnknownHostException &#123;
        SpringApplication app = new SpringApplication(UserCenterApp.class);
        DefaultProfileUtil.addDefaultProfile(app);
        applicationContext = app.run(args);

        // 后初始化
        postInit();
&#125;
</code></pre>
<p>大功告成！</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/06/07/jqpeng-spring%20security%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AEurl%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/06/07/jqpeng-spring%20security%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AEurl%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">spring security实现动态配置url权限的两种方法</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-07 15:33:00" itemprop="dateCreated datePublished" datetime="2018-06-07T15:33:00+08:00">2018-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a></p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>标准的RABC, 权限需要支持动态配置，spring security默认是在代码里约定好权限，真实的业务场景通常需要可以支持动态配置角色访问权限，即在运行时去配置url对应的访问角色。</p>
<p>基于spring security，如何实现这个需求呢？</p>
<p>最简单的方法就是自定义一个Filter去完成权限判断，但这脱离了spring security框架，如何基于spring security优雅的实现呢？</p>
<h2 id="spring-security-授权回顾"><a href="#spring-security-授权回顾" class="headerlink" title="spring security 授权回顾"></a>spring security 授权回顾</h2><p>spring security 通过FilterChainProxy作为注册到web的filter，FilterChainProxy里面一次包含了内置的多个过滤器，我们首先需要了解spring security内置的各种filter：</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Filter Class</th>
<th>Namespace Element or Attribute</th>
</tr>
</thead>
<tbody><tr>
<td>CHANNEL_FILTER</td>
<td>ChannelProcessingFilter</td>
<td>http/intercept-url@requires-channel</td>
</tr>
<tr>
<td>SECURITY_CONTEXT_FILTER</td>
<td>SecurityContextPersistenceFilter</td>
<td>http</td>
</tr>
<tr>
<td>CONCURRENT_SESSION_FILTER</td>
<td>ConcurrentSessionFilter</td>
<td>session-management/concurrency-control</td>
</tr>
<tr>
<td>HEADERS_FILTER</td>
<td>HeaderWriterFilter</td>
<td>http/headers</td>
</tr>
<tr>
<td>CSRF_FILTER</td>
<td>CsrfFilter</td>
<td>http/csrf</td>
</tr>
<tr>
<td>LOGOUT_FILTER</td>
<td>LogoutFilter</td>
<td>http/logout</td>
</tr>
<tr>
<td>X509_FILTER</td>
<td>X509AuthenticationFilter</td>
<td>http/x509</td>
</tr>
<tr>
<td>PRE_AUTH_FILTER</td>
<td>AbstractPreAuthenticatedProcessingFilter Subclasses</td>
<td>N/A</td>
</tr>
<tr>
<td>CAS_FILTER</td>
<td>CasAuthenticationFilter</td>
<td>N/A</td>
</tr>
<tr>
<td>FORM_LOGIN_FILTER</td>
<td>UsernamePasswordAuthenticationFilter</td>
<td>http/form-login</td>
</tr>
<tr>
<td>BASIC_AUTH_FILTER</td>
<td>BasicAuthenticationFilter</td>
<td>http/http-basic</td>
</tr>
<tr>
<td>SERVLET_API_SUPPORT_FILTER</td>
<td>SecurityContextHolderAwareRequestFilter</td>
<td>http/@servlet-api-provision</td>
</tr>
<tr>
<td>JAAS_API_SUPPORT_FILTER</td>
<td>JaasApiIntegrationFilter</td>
<td>http/@jaas-api-provision</td>
</tr>
<tr>
<td>REMEMBER_ME_FILTER</td>
<td>RememberMeAuthenticationFilter</td>
<td>http/remember-me</td>
</tr>
<tr>
<td>ANONYMOUS_FILTER</td>
<td>AnonymousAuthenticationFilter</td>
<td>http/anonymous</td>
</tr>
<tr>
<td>SESSION_MANAGEMENT_FILTER</td>
<td>SessionManagementFilter</td>
<td>session-management</td>
</tr>
<tr>
<td>EXCEPTION_TRANSLATION_FILTER</td>
<td>ExceptionTranslationFilter</td>
<td>http</td>
</tr>
<tr>
<td>FILTER_SECURITY_INTERCEPTOR</td>
<td>FilterSecurityInterceptor</td>
<td>http</td>
</tr>
<tr>
<td>SWITCH_USER_FILTER</td>
<td>SwitchUserFilter</td>
<td>N/A</td>
</tr>
</tbody></table>
<p>最重要的是<code>FilterSecurityInterceptor</code>，该过滤器实现了主要的鉴权逻辑，最核心的代码在这里：</p>
<pre><code>protected InterceptorStatusToken beforeInvocation(Object object) &#123;    // 获取访问URL所需权限    Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource()            .getAttributes(object);
    Authentication authenticated = authenticateIfRequired();
    // 通过accessDecisionManager鉴权    try &#123;        this.accessDecisionManager.decide(authenticated, object, attributes);    &#125;    catch (AccessDeniedException accessDeniedException) &#123;        publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated,                accessDeniedException));
        throw accessDeniedException;    &#125;
    if (debug) &#123;        logger.debug(&quot;Authorization successful&quot;);    &#125;
    if (publishAuthorizationSuccess) &#123;        publishEvent(new AuthorizedEvent(object, attributes, authenticated));    &#125;
    // Attempt to run as a different user    Authentication runAs = this.runAsManager.buildRunAs(authenticated, object,            attributes);
    if (runAs == null) &#123;        if (debug) &#123;            logger.debug(&quot;RunAsManager did not change Authentication object&quot;);        &#125;
        // no further work post-invocation        return new InterceptorStatusToken(SecurityContextHolder.getContext(), false,                attributes, object);    &#125;    else &#123;        if (debug) &#123;            logger.debug(&quot;Switching to RunAs Authentication: &quot; + runAs);        &#125;
        SecurityContext origCtx = SecurityContextHolder.getContext();        SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());        SecurityContextHolder.getContext().setAuthentication(runAs);
        // need to revert to token.Authenticated post-invocation        return new InterceptorStatusToken(origCtx, true, attributes, object);    &#125;&#125;
</code></pre>
<p>从上面可以看出，要实现动态鉴权，可以从两方面着手：</p>
<ul>
<li>自定义SecurityMetadataSource，实现从数据库加载ConfigAttribute</li>
<li>另外就是可以自定义accessDecisionManager，官方的UnanimousBased其实足够使用，并且他是基于AccessDecisionVoter来实现权限认证的，因此我们只需要自定义一个AccessDecisionVoter就可以了</li>
</ul>
<p>下面来看分别如何实现。</p>
<h2 id="自定义AccessDecisionManager"><a href="#自定义AccessDecisionManager" class="headerlink" title="自定义AccessDecisionManager"></a>自定义AccessDecisionManager</h2><p>官方的三个AccessDecisionManager都是基于AccessDecisionVoter来实现权限认证的，因此我们只需要自定义一个AccessDecisionVoter就可以了。</p>
<p>自定义主要是实现<code>AccessDecisionVoter</code>接口，我们可以仿照官方的RoleVoter实现一个：</p>
<pre><code>public class RoleBasedVoter implements AccessDecisionVoter&lt;Object&gt; &#123;

    @Override
    public boolean supports(ConfigAttribute attribute) &#123;
        return true;
    &#125;

    @Override
    public int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes) &#123;
        if(authentication == null) &#123;
            return ACCESS_DENIED;
        &#125;
        int result = ACCESS_ABSTAIN;
        Collection&lt;? extends GrantedAuthority&gt; authorities = extractAuthorities(authentication);

        for (ConfigAttribute attribute : attributes) &#123;
            if(attribute.getAttribute()==null)&#123;
                continue;
            &#125;
            if (this.supports(attribute)) &#123;
                result = ACCESS_DENIED;

                // Attempt to find a matching granted authority
                for (GrantedAuthority authority : authorities) &#123;
                    if (attribute.getAttribute().equals(authority.getAuthority())) &#123;
                        return ACCESS_GRANTED;
                    &#125;
                &#125;
            &#125;
        &#125;

        return result;
    &#125;

    Collection&lt;? extends GrantedAuthority&gt; extractAuthorities(
        Authentication authentication) &#123;
        return authentication.getAuthorities();
    &#125;

    @Override
    public boolean supports(Class clazz) &#123;
        return true;
    &#125;
&#125;
</code></pre>
<p>如何加入动态权限呢？</p>
<p><code>vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes) </code>里的<code>Object object</code>的类型是<code>FilterInvocation</code>，可以通过<code>getRequestUrl</code>获取当前请求的URL:</p>
<pre><code>  FilterInvocation fi = (FilterInvocation) object;
  String url = fi.getRequestUrl();
</code></pre>
<p>因此这里扩展空间就大了，可以从DB动态加载，然后判断URL的ConfigAttribute就可以了。</p>
<p>如何使用这个RoleBasedVoter呢？在configure里使用accessDecisionManager方法自定义，我们还是使用官方的<code>UnanimousBased</code>，然后将自定义的RoleBasedVoter加入即可。</p>
<pre><code>@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;

 
    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
            // 自定义accessDecisionManager
            .accessDecisionManager(accessDecisionManager())
          
        .and()
            .apply(securityConfigurerAdapter());

    &#125;


    @Bean
    public AccessDecisionManager accessDecisionManager() &#123;
        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters
            = Arrays.asList(
            new WebExpressionVoter(),
            // new RoleVoter(),
            new RoleBasedVoter(),
            new AuthenticatedVoter());
        return new UnanimousBased(decisionVoters);
    &#125;
</code></pre>
<h2 id="自定义SecurityMetadataSource"><a href="#自定义SecurityMetadataSource" class="headerlink" title="自定义SecurityMetadataSource"></a>自定义SecurityMetadataSource</h2><p>自定义FilterInvocationSecurityMetadataSource只要实现接口即可，在接口里从DB动态加载规则。</p>
<p>为了复用代码里的定义，我们可以将代码里生成的SecurityMetadataSource带上，在构造函数里传入默认的FilterInvocationSecurityMetadataSource。</p>
<pre><code>public class AppFilterInvocationSecurityMetadataSource implements org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource &#123;

    private FilterInvocationSecurityMetadataSource  superMetadataSource;

    @Override
    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123;
        return null;
    &#125;

    public AppFilterInvocationSecurityMetadataSource(FilterInvocationSecurityMetadataSource expressionBasedFilterInvocationSecurityMetadataSource)&#123;
         this.superMetadataSource = expressionBasedFilterInvocationSecurityMetadataSource;

         // TODO 从数据库加载权限配置
    &#125;

    private final AntPathMatcher antPathMatcher = new AntPathMatcher();
    // 这里的需要从DB加载
    private final Map&lt;String,String&gt; urlRoleMap = new HashMap&lt;String,String&gt;()&#123;&#123;
            put("/open/**","ROLE_ANONYMOUS");
            put("/health","ROLE_ANONYMOUS");
            put("/restart","ROLE_ADMIN");
            put("/demo","ROLE_USER");
        &#125;&#125;;

    @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;
        FilterInvocation fi = (FilterInvocation) object;
        String url = fi.getRequestUrl();

        for(Map.Entry&lt;String,String&gt; entry:urlRoleMap.entrySet())&#123;
            if(antPathMatcher.match(entry.getKey(),url))&#123;
                return SecurityConfig.createList(entry.getValue());
            &#125;
        &#125;

        //  返回代码定义的默认配置
        return superMetadataSource.getAttributes(object);
    &#125;



    @Override
    public boolean supports(Class&lt;?&gt; clazz) &#123;
        return FilterInvocation.class.isAssignableFrom(clazz);
    &#125;
&#125;
</code></pre>
<p>怎么使用？和<code>accessDecisionManager</code>不一样，<code>ExpressionUrlAuthorizationConfigurer</code> 并没有提供set方法设置<code>FilterSecurityInterceptor</code>的<code>FilterInvocationSecurityMetadataSource</code>，how to do?</p>
<p>发现一个扩展方法<code>withObjectPostProcessor</code>，通过该方法自定义一个处理<code>FilterSecurityInterceptor</code>类型的<code>ObjectPostProcessor</code>就可以修改<code>FilterSecurityInterceptor</code>。</p>
<pre><code>@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;

 
    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
              // 自定义FilterInvocationSecurityMetadataSource
            .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;
                @Override
                public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
                    O fsi) &#123;
                    fsi.setSecurityMetadataSource(mySecurityMetadataSource(fsi.getSecurityMetadataSource()));
                    return fsi;
                &#125;
            &#125;)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;


    @Bean
    public AppFilterInvocationSecurityMetadataSource mySecurityMetadataSource(FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource) &#123;
        AppFilterInvocationSecurityMetadataSource securityMetadataSource = new AppFilterInvocationSecurityMetadataSource(filterInvocationSecurityMetadataSource);
        return securityMetadataSource;
&#125;
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了两种基于spring security实现动态权限的方法，一是自定义accessDecisionManager，二是自定义FilterInvocationSecurityMetadataSource。实际项目里可以根据需要灵活选择。</p>
<p>延伸阅读:</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/06/06/jqpeng-Spring%20Security%20%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/06/06/jqpeng-Spring%20Security%20%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Spring Security 架构与源码分析</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-06 16:03:00" itemprop="dateCreated datePublished" datetime="2018-06-06T16:03:00+08:00">2018-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></p>
<p>Spring Security 主要实现了Authentication（认证，解决who are you? ） 和 Access Control（访问控制，也就是what are you allowed to do？，也称为Authorization）。Spring Security在架构上将认证与授权分离，并提供了扩展点。</p>
<h2 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h2><p>主要代码在<code>spring-security-core</code>包下面。要了解Spring Security，需要先关注里面的核心对象。</p>
<h3 id="SecurityContextHolder-SecurityContext-和-Authentication"><a href="#SecurityContextHolder-SecurityContext-和-Authentication" class="headerlink" title="SecurityContextHolder, SecurityContext 和 Authentication"></a>SecurityContextHolder, SecurityContext 和 Authentication</h3><p>SecurityContextHolder 是 SecurityContext的存放容器，默认使用ThreadLocal 存储，意味SecurityContext在相同线程中的方法都可用。<br> SecurityContext主要是存储应用的principal信息，在Spring Security中用Authentication 来表示。</p>
<p>获取principal：</p>
<pre><code>Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

if (principal instanceof UserDetails) &#123;
String username = ((UserDetails)principal).getUsername();
&#125; else &#123;
String username = principal.toString();
&#125;
</code></pre>
<p>在Spring Security中，可以看一下Authentication定义：</p>
<pre><code>public interface Authentication extends Principal, Serializable &#123;
Collection&lt;? extends GrantedAuthority&gt; getAuthorities();
/** * 通常是密码 */Object getCredentials();
/** * Stores additional details about the authentication request. These might be an IP * address, certificate serial number etc. */Object getDetails();
/** * 用来标识是否已认证，如果使用用户名和密码登录,通常是用户名  */Object getPrincipal();
/** * 是否已认证 */boolean isAuthenticated();
void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
&#125;
</code></pre>
<p>在实际应用中，通常使用<code>UsernamePasswordAuthenticationToken</code>：</p>
<pre><code>public abstract class AbstractAuthenticationToken implements Authentication,    CredentialsContainer &#123;    &#125;
public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken &#123;
&#125;
</code></pre>
<p>一个常见的认证过程通常是这样的，创建一个UsernamePasswordAuthenticationToken，然后交给authenticationManager认证（后面详细说明），认证通过则通过SecurityContextHolder存放Authentication信息。</p>
<pre><code> UsernamePasswordAuthenticationToken authenticationToken =
            new UsernamePasswordAuthenticationToken(loginVM.getUsername(), loginVM.getPassword());

Authentication authentication = this.authenticationManager.authenticate(authenticationToken);
SecurityContextHolder.getContext().setAuthentication(authentication);
</code></pre>
<h3 id="UserDetails与UserDetailsService"><a href="#UserDetails与UserDetailsService" class="headerlink" title="UserDetails与UserDetailsService"></a>UserDetails与UserDetailsService</h3><p>UserDetails 是Spring Security里的一个关键接口，他用来表示一个principal。</p>
<pre><code>public interface UserDetails extends Serializable &#123;/** * 用户的授权信息，可以理解为角色 */Collection&lt;? extends GrantedAuthority&gt; getAuthorities();
/** * 用户密码 * * @return the password */String getPassword();
/** * 用户名  *     */String getUsername();
boolean isAccountNonExpired();
boolean isAccountNonLocked();
boolean isCredentialsNonExpired();
boolean isEnabled();
&#125;
</code></pre>
<p>UserDetails提供了认证所需的必要信息，在实际使用里，可以自己实现UserDetails，并增加额外的信息，比如email、mobile等信息。</p>
<p>在Authentication中的principal通常是用户名，我们可以通过UserDetailsService来通过principal获取UserDetails：</p>
<pre><code>public interface UserDetailsService &#123;UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
&#125;
</code></pre>
<h3 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h3><p>在UserDetails里说了，GrantedAuthority可以理解为角色，例如 <code>ROLE_ADMINISTRATOR</code> or <code>ROLE_HR_SUPERVISOR</code>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>SecurityContextHolder</code>, 用来访问 <code>SecurityContext</code>.</li>
<li><code>SecurityContext</code>, 用来存储<code>Authentication</code> .</li>
<li><code>Authentication</code>, 代表凭证.</li>
<li><code>GrantedAuthority</code>, 代表权限.</li>
<li><code>UserDetails</code>, 用户信息.</li>
<li><code>UserDetailsService</code>,获取用户信息.</li>
</ul>
<h2 id="Authentication认证"><a href="#Authentication认证" class="headerlink" title="Authentication认证"></a>Authentication认证</h2><h3 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h3><p>实现认证主要是通过AuthenticationManager接口，它只包含了一个方法：</p>
<pre><code>public interface AuthenticationManager &#123;
  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
&#125;
</code></pre>
<p>authenticate()方法主要做三件事：</p>
<ol>
<li>如果验证通过，返回Authentication（通常带上authenticated=true）。</li>
<li>认证失败抛出<code>AuthenticationException</code></li>
<li>如果无法确定，则返回null</li>
</ol>
<p><code>AuthenticationException</code>是运行时异常,它通常由应用程序按通用方式处理，用户代码通常不用特意被捕获和处理这个异常。</p>
<p><code>AuthenticationManager</code>的默认实现是<code>ProviderManager</code>，它委托一组<code>AuthenticationProvider</code>实例来实现认证。<br><code>AuthenticationProvider</code>和<code>AuthenticationManager</code>类似，都包含<code>authenticate</code>，但它有一个额外的方法<code>supports</code>，以允许查询调用方是否支持给定<code>Authentication</code>类型：</p>
<pre><code>public interface AuthenticationProvider &#123;
Authentication authenticate(Authentication authentication)        throws AuthenticationException;boolean supports(Class&lt;?&gt; authentication);
&#125;
</code></pre>
<p>ProviderManager包含一组<code>AuthenticationProvider</code>，执行authenticate时，遍历Providers，然后调用supports，如果支持，则执行遍历当前provider的authenticate方法，如果一个provider认证成功，则break。</p>
<pre><code>public Authentication authenticate(Authentication authentication)        throws AuthenticationException &#123;    Class&lt;? extends Authentication&gt; toTest = authentication.getClass();    AuthenticationException lastException = null;    Authentication result = null;    boolean debug = logger.isDebugEnabled();
    for (AuthenticationProvider provider : getProviders()) &#123;        if (!provider.supports(toTest)) &#123;            continue;        &#125;
        if (debug) &#123;            logger.debug(&quot;Authentication attempt using &quot;                    + provider.getClass().getName());        &#125;
        try &#123;            result = provider.authenticate(authentication);
            if (result != null) &#123;                copyDetails(authentication, result);                break;            &#125;        &#125;        catch (AccountStatusException e) &#123;            prepareException(e, authentication);            // SEC-546: Avoid polling additional providers if auth failure is due to            // invalid account status            throw e;        &#125;        catch (InternalAuthenticationServiceException e) &#123;            prepareException(e, authentication);            throw e;        &#125;        catch (AuthenticationException e) &#123;            lastException = e;        &#125;    &#125;
    if (result == null &amp;&amp; parent != null) &#123;        // Allow the parent to try.        try &#123;            result = parent.authenticate(authentication);        &#125;        catch (ProviderNotFoundException e) &#123;            // ignore as we will throw below if no other exception occurred prior to            // calling parent and the parent            // may throw ProviderNotFound even though a provider in the child already            // handled the request        &#125;        catch (AuthenticationException e) &#123;            lastException = e;        &#125;    &#125;
    if (result != null) &#123;        if (eraseCredentialsAfterAuthentication                &amp;&amp; (result instanceof CredentialsContainer)) &#123;            // Authentication is complete. Remove credentials and other secret data            // from authentication            ((CredentialsContainer) result).eraseCredentials();        &#125;
        eventPublisher.publishAuthenticationSuccess(result);        return result;    &#125;
    // Parent was null, or didn&#39;t authenticate (or throw an exception).
    if (lastException == null) &#123;        lastException = new ProviderNotFoundException(messages.getMessage(                &quot;ProviderManager.providerNotFound&quot;,                new Object[] &#123; toTest.getName() &#125;,                &quot;No AuthenticationProvider found for &#123;0&#125;&quot;));    &#125;
    prepareException(lastException, authentication);
    throw lastException;&#125;
</code></pre>
<p>从上面的代码可以看出， <code>ProviderManager</code>有一个可选parent，如果parent不为空，则调用<code>parent.authenticate(authentication)</code></p>
<h3 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h3><p><code>AuthenticationProvider</code>有多种实现，大家最关注的通常是<code>DaoAuthenticationProvider</code>，继承于<code>AbstractUserDetailsAuthenticationProvider</code>，核心是通过<code>UserDetails</code>来实现认证,<code>DaoAuthenticationProvider</code>默认会自动加载，不用手动配。</p>
<p>先来看<code>AbstractUserDetailsAuthenticationProvide</code>r，看最核心的<code>authenticate</code>：</p>
<pre><code>public Authentication authenticate(Authentication authentication)        throws AuthenticationException &#123;    // 必须是UsernamePasswordAuthenticationToken    Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,            messages.getMessage(                    &quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;,                    &quot;Only UsernamePasswordAuthenticationToken is supported&quot;));
    //  获取用户名    String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot;            : authentication.getName();
    boolean cacheWasUsed = true;    // 从缓存获取    UserDetails user = this.userCache.getUserFromCache(username);
    if (user == null) &#123;        cacheWasUsed = false;
        try &#123;           // retrieveUser 抽象方法，获取用户            user = retrieveUser(username,                    (UsernamePasswordAuthenticationToken) authentication);        &#125;        catch (UsernameNotFoundException notFound) &#123;            logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;);
            if (hideUserNotFoundExceptions) &#123;                throw new BadCredentialsException(messages.getMessage(                        &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                        &quot;Bad credentials&quot;));            &#125;            else &#123;                throw notFound;            &#125;        &#125;
          Assert.notNull(user,                &quot;retrieveUser returned null - a violation of the interface contract&quot;);    &#125;
    try &#123;        // 预先检查，DefaultPreAuthenticationChecks，检查用户是否被lock或者账号是否可用        preAuthenticationChecks.check(user);                // 抽象方法，自定义检验        additionalAuthenticationChecks(user,                (UsernamePasswordAuthenticationToken) authentication);    &#125;    catch (AuthenticationException exception) &#123;        if (cacheWasUsed) &#123;            // There was a problem, so try again after checking            // we&#39;re using latest data (i.e. not from the cache)            cacheWasUsed = false;            user = retrieveUser(username,                    (UsernamePasswordAuthenticationToken) authentication);            preAuthenticationChecks.check(user);            additionalAuthenticationChecks(user,                    (UsernamePasswordAuthenticationToken) authentication);        &#125;        else &#123;            throw exception;        &#125;    &#125;
          // 后置检查 DefaultPostAuthenticationChecks，检查isCredentialsNonExpired    postAuthenticationChecks.check(user);
    if (!cacheWasUsed) &#123;        this.userCache.putUserInCache(user);    &#125;
    Object principalToReturn = user;
    if (forcePrincipalAsString) &#123;        principalToReturn = user.getUsername();    &#125;
       return createSuccessAuthentication(principalToReturn, authentication, user);&#125;
</code></pre>
<p>上面的检验主要基于UserDetails实现，其中获取用户和检验逻辑由具体的类去实现，默认实现是DaoAuthenticationProvider，这个类的核心是让开发者提供UserDetailsService来获取UserDetails以及 PasswordEncoder来检验密码是否有效：</p>
<pre><code>private UserDetailsService userDetailsService;
private PasswordEncoder passwordEncoder;
</code></pre>
<p>看具体的实现，<code>retrieveUser</code>,直接调用userDetailsService获取用户：</p>
<pre><code>protected final UserDetails retrieveUser(String username,        UsernamePasswordAuthenticationToken authentication)        throws AuthenticationException &#123;    UserDetails loadedUser;
    try &#123;        loadedUser = this.getUserDetailsService().loadUserByUsername(username);    &#125;    catch (UsernameNotFoundException notFound) &#123;        if (authentication.getCredentials() != null) &#123;            String presentedPassword = authentication.getCredentials().toString();            passwordEncoder.isPasswordValid(userNotFoundEncodedPassword,                    presentedPassword, null);        &#125;        throw notFound;    &#125;    catch (Exception repositoryProblem) &#123;        throw new InternalAuthenticationServiceException(                repositoryProblem.getMessage(), repositoryProblem);    &#125;
    if (loadedUser == null) &#123;        throw new InternalAuthenticationServiceException(                &quot;UserDetailsService returned null, which is an interface contract violation&quot;);    &#125;    return loadedUser;&#125;
</code></pre>
<p>再来看验证：</p>
<pre><code>protected void additionalAuthenticationChecks(UserDetails userDetails,        UsernamePasswordAuthenticationToken authentication)        throws AuthenticationException &#123;    Object salt = null;
    if (this.saltSource != null) &#123;        salt = this.saltSource.getSalt(userDetails);    &#125;
    if (authentication.getCredentials() == null) &#123;        logger.debug(&quot;Authentication failed: no credentials provided&quot;);
        throw new BadCredentialsException(messages.getMessage(                &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                &quot;Bad credentials&quot;));    &#125;
        // 获取用户密码    String presentedPassword = authentication.getCredentials().toString();
        // 比较passwordEncoder后的密码是否和userdetails的密码一致    if (!passwordEncoder.isPasswordValid(userDetails.getPassword(),            presentedPassword, salt)) &#123;        logger.debug(&quot;Authentication failed: password does not match stored value&quot;);
        throw new BadCredentialsException(messages.getMessage(                &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                &quot;Bad credentials&quot;));    &#125;&#125;
</code></pre>
<p>小结：要自定义认证，使用DaoAuthenticationProvider，只需要为其提供PasswordEncoder和UserDetailsService就可以了。</p>
<h3 id="定制-Authentication-Managers"><a href="#定制-Authentication-Managers" class="headerlink" title="定制 Authentication Managers"></a>定制 Authentication Managers</h3><p>Spring Security提供了一个Builder类<code>AuthenticationManagerBuilder</code>，借助它可以快速实现自定义认证。</p>
<p>看官方源码说明：</p>
<blockquote>
<p>SecurityBuilder used to create an AuthenticationManager . Allows for easily building in memory authentication, LDAP authentication, JDBC based authentication, adding UserDetailsService , and adding AuthenticationProvider’s.</p>
</blockquote>
<p>AuthenticationManagerBuilder可以用来Build一个AuthenticationManager，可以创建基于内存的认证、LDAP认证、 JDBC认证，以及添加UserDetailsService和AuthenticationProvider。</p>
<p>简单使用：</p>
<pre><code>@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class ApplicationSecurity extends WebSecurityConfigurerAdapter &#123;


  public SecurityConfiguration(AuthenticationManagerBuilder authenticationManagerBuilder, UserDetailsService userDetailsService,TokenProvider tokenProvider,CorsFilter corsFilter, SecurityProblemSupport problemSupport) &#123;
        this.authenticationManagerBuilder = authenticationManagerBuilder;
        this.userDetailsService = userDetailsService;
        this.tokenProvider = tokenProvider;
        this.corsFilter = corsFilter;
        this.problemSupport = problemSupport;
    &#125;

    @PostConstruct
    public void init() &#123;
        try &#123;
            authenticationManagerBuilder
                .userDetailsService(userDetailsService)
                .passwordEncoder(passwordEncoder());
        &#125; catch (Exception e) &#123;
            throw new BeanInitializationException(&quot;Security configuration failed&quot;, e);
        &#125;
    &#125;

   @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
            .antMatchers(&quot;/api/register&quot;).permitAll()
            .antMatchers(&quot;/api/activate&quot;).permitAll()
            .antMatchers(&quot;/api/authenticate&quot;).permitAll()
            .antMatchers(&quot;/api/account/reset-password/init&quot;).permitAll()
            .antMatchers(&quot;/api/account/reset-password/finish&quot;).permitAll()
            .antMatchers(&quot;/api/profile-info&quot;).permitAll()
            .antMatchers(&quot;/api/**&quot;).authenticated()
            .antMatchers(&quot;/management/health&quot;).permitAll()
            .antMatchers(&quot;/management/**&quot;).hasAuthority(AuthoritiesConstants.ADMIN)
            .antMatchers(&quot;/v2/api-docs/**&quot;).permitAll()
            .antMatchers(&quot;/swagger-resources/configuration/ui&quot;).permitAll()
            .antMatchers(&quot;/swagger-ui/index.html&quot;).hasAuthority(AuthoritiesConstants.ADMIN)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;
&#125;
</code></pre>
<h2 id="授权与访问控制"><a href="#授权与访问控制" class="headerlink" title="授权与访问控制"></a>授权与访问控制</h2><p>一旦认证成功，我们可以继续进行授权，授权是通过<code>AccessDecisionManager</code>来实现的。框架有三种实现，默认是AffirmativeBased，通过<code>AccessDecisionVoter</code>决策，有点像<code>ProviderManager</code>委托给<code>AuthenticationProviders</code>来认证。</p>
<pre><code>public void decide(Authentication authentication, Object object,        Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException &#123;    int deny = 0;
        // 遍历DecisionVoter     for (AccessDecisionVoter voter : getDecisionVoters()) &#123;        // 投票        int result = voter.vote(authentication, object, configAttributes);
        if (logger.isDebugEnabled()) &#123;            logger.debug(&quot;Voter: &quot; + voter + &quot;, returned: &quot; + result);        &#125;
        switch (result) &#123;        case AccessDecisionVoter.ACCESS_GRANTED:            return;
        case AccessDecisionVoter.ACCESS_DENIED:            deny++;
            break;
        default:            break;        &#125;    &#125;
           // 一票否决    if (deny &gt; 0) &#123;        throw new AccessDeniedException(messages.getMessage(                &quot;AbstractAccessDecisionManager.accessDenied&quot;, &quot;Access is denied&quot;));    &#125;
    // To get this far, every AccessDecisionVoter abstained    checkAllowIfAllAbstainDecisions();&#125;
</code></pre>
<p>来看AccessDecisionVoter：</p>
<pre><code>boolean supports(ConfigAttribute attribute);

boolean supports(Class&lt;?&gt; clazz);

int vote(Authentication authentication, S object,
        Collection&lt;ConfigAttribute&gt; attributes);
</code></pre>
<p>object是用户要访问的资源，ConfigAttribute则是访问object要满足的条件，通常payload是字符串，比如ROLE_ADMIN 。所以我们来看下RoleVoter的实现，其核心就是从authentication提取出GrantedAuthority，然后和ConfigAttribute比较是否满足条件。</p>
<pre><code>public boolean supports(ConfigAttribute attribute) &#123;    if ((attribute.getAttribute() != null)            &amp;&amp; attribute.getAttribute().startsWith(getRolePrefix())) &#123;        return true;    &#125;    else &#123;        return false;    &#125;&#125;
public boolean supports(Class&lt;?&gt; clazz) &#123;    return true;&#125;


public int vote(Authentication authentication, Object object,        Collection&lt;ConfigAttribute&gt; attributes) &#123;    if(authentication == null) &#123;        return ACCESS_DENIED;    &#125;    int result = ACCESS_ABSTAIN;        // 获取GrantedAuthority信息    Collection&lt;? extends GrantedAuthority&gt; authorities = extractAuthorities(authentication);
    for (ConfigAttribute attribute : attributes) &#123;        if (this.supports(attribute)) &#123;            // 默认拒绝访问            result = ACCESS_DENIED;
            // Attempt to find a matching granted authority            for (GrantedAuthority authority : authorities) &#123;                 // 判断是否有匹配的 authority                if (attribute.getAttribute().equals(authority.getAuthority())) &#123;                    // 可访问                    return ACCESS_GRANTED;                &#125;            &#125;        &#125;    &#125;
    return result;&#125;
</code></pre>
<p>这里要疑问，ConfigAttribute哪来的？其实就是上面ApplicationSecurity的configure里的。</p>
<h3 id="web-security-如何实现"><a href="#web-security-如何实现" class="headerlink" title="web security 如何实现"></a>web security 如何实现</h3><p>Web层中的Spring Security（用于UI和HTTP后端）基于Servlet <code>Filters</code>，下图显示了单个HTTP请求的处理程序的典型分层。</p>
<p><img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/filters.png" alt="过滤链委托给一个Servlet"></p>
<p>Spring Security通过<code>FilterChainProxy</code>作为单一的Filter注册到web层，Proxy内部的Filter。</p>
<p><img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/security-filters.png" alt="Spring安全筛选器"></p>
<p>FilterChainProxy相当于一个filter的容器，通过VirtualFilterChain来依次调用各个内部filter</p>
<pre><code>public void doFilter(ServletRequest request, ServletResponse response,        FilterChain chain) throws IOException, ServletException &#123;    boolean clearContext = request.getAttribute(FILTER_APPLIED) == null;    if (clearContext) &#123;        try &#123;            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);            doFilterInternal(request, response, chain);        &#125;        finally &#123;            SecurityContextHolder.clearContext();            request.removeAttribute(FILTER_APPLIED);        &#125;    &#125;    else &#123;        doFilterInternal(request, response, chain);    &#125;&#125;
private void doFilterInternal(ServletRequest request, ServletResponse response,        FilterChain chain) throws IOException, ServletException &#123;
    FirewalledRequest fwRequest = firewall            .getFirewalledRequest((HttpServletRequest) request);    HttpServletResponse fwResponse = firewall            .getFirewalledResponse((HttpServletResponse) response);
    List&lt;Filter&gt; filters = getFilters(fwRequest);
    if (filters == null || filters.size() == 0) &#123;        if (logger.isDebugEnabled()) &#123;            logger.debug(UrlUtils.buildRequestUrl(fwRequest)                    + (filters == null ? &quot; has no matching filters&quot;                            : &quot; has an empty filter list&quot;));        &#125;
        fwRequest.reset();
        chain.doFilter(fwRequest, fwResponse);
        return;    &#125;
    VirtualFilterChain vfc = new VirtualFilterChain(fwRequest, chain, filters);    vfc.doFilter(fwRequest, fwResponse);&#125;private static class VirtualFilterChain implements FilterChain &#123;    private final FilterChain originalChain;    private final List&lt;Filter&gt; additionalFilters;    private final FirewalledRequest firewalledRequest;    private final int size;    private int currentPosition = 0;
    private VirtualFilterChain(FirewalledRequest firewalledRequest,            FilterChain chain, List&lt;Filter&gt; additionalFilters) &#123;        this.originalChain = chain;        this.additionalFilters = additionalFilters;        this.size = additionalFilters.size();        this.firewalledRequest = firewalledRequest;    &#125;
    public void doFilter(ServletRequest request, ServletResponse response)            throws IOException, ServletException &#123;        if (currentPosition == size) &#123;            if (logger.isDebugEnabled()) &#123;                logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)                        + &quot; reached end of additional filter chain; proceeding with original chain&quot;);            &#125;
            // Deactivate path stripping as we exit the security filter chain            this.firewalledRequest.reset();
            originalChain.doFilter(request, response);        &#125;        else &#123;            currentPosition++;
            Filter nextFilter = additionalFilters.get(currentPosition - 1);
            if (logger.isDebugEnabled()) &#123;                logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)                        + &quot; at position &quot; + currentPosition + &quot; of &quot; + size                        + &quot; in additional filter chain; firing Filter: &#39;&quot;                        + nextFilter.getClass().getSimpleName() + &quot;&#39;&quot;);            &#125;
            nextFilter.doFilter(request, response, this);        &#125;    &#125;&#125;
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/topicals/spring-security-architecture/">https://spring.io/guides/topicals/spring-security-architecture/</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.0.5.RELEASE/reference/htmlsingle/#overall-architecture">https://docs.spring.io/spring-security/site/docs/5.0.5.RELEASE/reference/htmlsingle/#overall-architecture</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/05/28/jqpeng-%E5%BC%80%E6%BA%90APM%E7%B3%BB%E7%BB%9Fskywalking%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/05/28/jqpeng-%E5%BC%80%E6%BA%90APM%E7%B3%BB%E7%BB%9Fskywalking%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">开源APM系统skywalking介绍与使用</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-28 11:25:00" itemprop="dateCreated datePublished" datetime="2018-05-28T11:25:00+08:00">2018-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-12 21:28:27" itemprop="dateModified" datetime="2021-07-12T21:28:27+08:00">2021-07-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/skywalking-usage.html">开源APM系统skywalking介绍与使用</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>SkyWalking</strong> 创建与2015年，提供分布式追踪功能。从5.x开始，项目进化为一个完成功能的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_performance_management">Application Performance Management</a>系统。<br> 他被用于追踪、监控和诊断分布式系统，特别是使用微服务架构，云原生或容积技术。提供以下主要功能：</p>
<ul>
<li>分布式追踪和上下文传输</li>
<li>应用、实例、服务性能指标分析</li>
<li>根源分析</li>
<li>应用拓扑分析</li>
<li>应用和服务依赖分析</li>
<li>慢服务检测</li>
<li>性能优化</li>
</ul>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul>
<li>多语言探针或类库<ul>
<li>Java自动探针，追踪和监控程序时，不需要修改源码。</li>
<li>社区提供的其他多语言探针<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenSkywalking/skywalking-netcore">.NET Core</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenSkywalking/skywalking-nodejs">Node.js</a></li>
</ul>
</li>
</ul>
</li>
<li>多种后端存储： ElasticSearch， H2</li>
<li>支持<a target="_blank" rel="noopener" href="http://opentracing.io/">OpenTracing</a><ul>
<li>Java自动探针支持和OpenTracing API协同工作</li>
</ul>
</li>
<li>轻量级、完善功能的后端聚合和分析</li>
<li>现代化Web UI</li>
<li>日志集成</li>
<li>应用、实例和服务的告警</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://skywalkingtest.github.io/page-resources/5.0/architecture.png"></p>
<h3 id="在线体验"><a href="#在线体验" class="headerlink" title="在线体验"></a>在线体验</h3><ul>
<li>北京服务器. <a target="_blank" rel="noopener" href="http://49.4.12.44:8080/">前往</a></li>
<li>香港服务器. <a target="_blank" rel="noopener" href="http://159.138.0.181:8080/">前往</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装es"><a href="#安装es" class="headerlink" title="安装es"></a>安装es</h3><p>新版本的skywalking使用ES作为存储，所以先安装es，注意6.X版本不行，安装5.6.8：</p>
<pre><code>wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.8.tar.gz
tar zxvf elasticsearch-5.6.8.tar.gz
cd elasticsearch-5.6.8/
</code></pre>
<p>修改配置文件，主要修改cluster.name，并增加两行配置，<br> vim config/elasticsearch.yml：</p>
<pre><code>cluster.name: CollectorDBCluster

# ES监听的ip地址
network.host: 0.0.0.0
thread_pool.bulk.queue_size: 1000
</code></pre>
<p>保存，然后启动es：</p>
<pre><code>nohup bin/elasticsearch &amp;
</code></pre>
<h3 id="安装skywalking"><a href="#安装skywalking" class="headerlink" title="安装skywalking"></a>安装skywalking</h3><p>先下载编译好的版本并解压：</p>
<pre><code>wget http://mirrors.hust.edu.cn/apache/incubator/skywalking/5.0.0-beta/apache-skywalking-apm-incubating-5.0.0-beta.tar.gz
tar zxvf apache-skywalking-apm-incubating-5.0.0-beta.tar.gz 
cd apache-skywalking-apm-incubating/
</code></pre>
<p>然后部署，注意skywalking会使用(8080, 10800, 11800, 12800)端口，因此先排除端口占用情况。</p>
<p>然后运行bin/startup.sh，windows用户为.bat文件。</p>
<p>一切正常的话，访问localhost:8080就能看到页面了。</p>
<h4 id="安装过程问题解决"><a href="#安装过程问题解决" class="headerlink" title="安装过程问题解决"></a>安装过程问题解决</h4><ol>
<li>启动bin/startup.sh后，提示success，但是不能访问，ps 查看并无相关进程，经过检查发现是端口被占用</li>
<li>collector 不能正常启动，发现是es问题：<ul>
<li>es需要使用5.x版本</li>
<li>es的集群名称需要和collector的配置文件一致</li>
</ul>
</li>
</ol>
<h3 id="java程序使用skywalking探针"><a href="#java程序使用skywalking探针" class="headerlink" title="java程序使用skywalking探针"></a>java程序使用skywalking探针</h3><p>1.拷贝apache-skywalking-apm-incubating目录下的agent目录到应用程序位置，探针包含整个目录，请不要改变目录结构<br> 2.java程序启动时，增加JVM启动参数，-javaagent:/path/to/agent/skywalking-agent.jar。参数值为skywalking-agent.jar的绝对路径</p>
<p>在IDEA里调试程序怎么办？</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1527477582714.jpg" alt="enter description here" title="IDEA 配置"></p>
<p>增加VM参数即可。</p>
<p>agent探针配置，简单修改下agent.application_code即可</p>
<pre><code># 当前的应用编码，最终会显示在webui上。
# 建议一个应用的多个实例，使用有相同的application_code。请使用英文
agent.application_code=Your_ApplicationName

# 每三秒采样的Trace数量
# 默认为负数，代表在保证不超过内存Buffer区的前提下，采集所有的Trace
# agent.sample_n_per_3_secs=-1

# 设置需要忽略的请求地址
# 默认配置如下
# agent.ignore_suffix=.jpg,.jpeg,.js,.css,.png,.bmp,.gif,.ico,.mp3,.mp4,.html,.svg

# 探针调试开关，如果设置为true，探针会将所有操作字节码的类输出到/debugging目录下
# skywalking团队可能在调试，需要此文件
# agent.is_open_debugging_class = true

# 对应Collector的config/application.yml配置文件中 agent_server/jetty/port 配置内容
# 例如：
# 单节点配置：SERVERS=&quot;127.0.0.1:8080&quot; 
# 集群配置：SERVERS=&quot;10.2.45.126:8080,10.2.45.127:7600&quot; 
collector.servers=127.0.0.1:10800

# 日志文件名称前缀
logging.file_name=skywalking-agent.log

# 日志文件最大大小
# 如果超过此大小，则会生成新文件。
# 默认为300M
logging.max_file_size=314572800

# 日志级别，默认为DEBUG。
logging.level=DEBUG
</code></pre>
<p>一切正常的话，稍后就可以在skywalking ui看到了。</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1527477724637.jpg" alt="enter description here" title="SW UI"></p>
<p>可以看到累出了slow service等信息，更多的细节慢慢挖掘吧。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/jadepeng/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/jadepeng/">1</a><span class="space">&hellip;</span><a class="page-number" href="/jadepeng/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/jadepeng/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/jadepeng/page/10/">10</a><a class="extend next" rel="next" href="/jadepeng/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JadePeng"
      src="/jadepeng/images/avatar.gif">
  <p class="site-author-name" itemprop="name">JadePeng</p>
  <div class="site-description" itemprop="description">JadePeng的技术笔记本</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/jadepeng/archives/">
        
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/jadepeng/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/jadepeng/tags/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JadePeng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">668k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/jadepeng/lib/anime.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.ui.min.js"></script>

<script src="/jadepeng/js/utils.js"></script>

<script src="/jadepeng/js/motion.js"></script>


<script src="/jadepeng/js/schemes/muse.js"></script>


<script src="/jadepeng/js/next-boot.js"></script>




  




  
<script src="/jadepeng/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/jadepeng/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
