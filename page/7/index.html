<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/jadepeng/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/jadepeng/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/jadepeng/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/jadepeng/images/logo.svg" color="#222">

<link rel="stylesheet" href="/jadepeng/css/main.css">


<link rel="stylesheet" href="/jadepeng/lib/font-awesome/css/all.min.css">
<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.iflyresearch.com","root":"/jadepeng/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JadePeng的技术笔记本">
<meta property="og:type" content="website">
<meta property="og:title" content="JadePeng的技术笔记本">
<meta property="og:url" content="http://blog.iflyresearch.com/page/7/index.html">
<meta property="og:site_name" content="JadePeng的技术笔记本">
<meta property="og:description" content="JadePeng的技术笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="JadePeng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.iflyresearch.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JadePeng的技术笔记本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/jadepeng/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JadePeng的技术笔记本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">爱学习爱分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/jadepeng/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-博客">

    <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" rel="section"><i class="fa fa-th fa-fw"></i>博客</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/jadepeng/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/jadepeng/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/jadepeng/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/08/24/jqpeng-%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/08/24/jqpeng-%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">统一配置中心选型对比</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-24 11:03:00" itemprop="dateCreated datePublished" datetime="2018-08-24T11:03:00+08:00">2018-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/configserver-compair.html">统一配置中心选型对比</a></p>
<p>整理笔记时发现之前整理的一些东西，分享给大家。</p>
<h2 id="为什么需要集中配置"><a href="#为什么需要集中配置" class="headerlink" title="为什么需要集中配置"></a>为什么需要集中配置</h2><p><strong>程序的发展，需要引入集中配置</strong>：</p>
<ul>
<li>随着程序功能的日益复杂，程序的配置日益增多：各种功能的开关、参数的配置、服务器的地址……</li>
<li>并且对配置的期望也越来越高，配置修改后实时生效，灰度发布，分环境、分集群管理配置，完善的权限、审核机制……</li>
<li>并且随着采用分布式的开发模式，项目之间的相互引用随着服务的不断增多，相互之间的调用复杂度成指数升高，每次投产或者上线新的项目时苦不堪言，因此需要引用配置中心治理。</li>
</ul>
<p><strong>已有zookeeper、etcd还需要引入吗</strong>？</p>
<ul>
<li>之前的音乐服务项目，通过etcd实现了服务的注册与发现，且一些业务配置也存储到etcd中，通过实践我们收获了集中配置带来的优势</li>
<li>但是etcd并没有方便的UI管理工具，且缺乏权限、审核等机制</li>
<li>最重要的是，etcd和zookeeper通常定义为<strong>服务注册中心</strong>，统一配置中心的事情交给专业的工具去解决。</li>
</ul>
<h2 id="有哪些开源配置中心"><a href="#有哪些开源配置中心" class="headerlink" title="有哪些开源配置中心"></a>有哪些开源配置中心</h2><ol>
<li>spring-cloud/spring-cloud-config<br><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a><br>spring出品，可以和spring cloud无缝配合</li>
<li>淘宝 diamond<br><a target="_blank" rel="noopener" href="https://github.com/takeseem/diamond">https://github.com/takeseem/diamond</a><br>已经不维护</li>
<li>disconf<br><a target="_blank" rel="noopener" href="https://github.com/knightliao/disconf">https://github.com/knightliao/disconf</a><br>java开发，蚂蚁金服技术专家发起，业界使用广泛</li>
<li>ctrip apollo<br><a target="_blank" rel="noopener" href="https://github.com/ctripcorp/apollo/">https://github.com/ctripcorp/apollo/</a><br>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。</li>
</ol>
<h2 id="配置中心对别"><a href="#配置中心对别" class="headerlink" title="配置中心对别"></a>配置中心对别</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p>我们先从功能层面来对别</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>静态配置管理</td>
<td>高</td>
<td>基于file</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>动态配置管理</td>
<td>高</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>统一管理</td>
<td>高</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>多环境</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>本地配置缓存</td>
<td>高</td>
<td>无</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置锁</td>
<td>中</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不允许动态及远程更新</td>
</tr>
<tr>
<td>配置校验</td>
<td>中</td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>如：ip地址校验，配置</td>
</tr>
<tr>
<td>配置生效时间</td>
<td></td>
<td>重启生效，或手动refresh生效</td>
<td>实时</td>
<td>实时</td>
<td>需要结合热加载管理， springcloudconfig需要 git webhook+rabbitmq 实时生效</td>
</tr>
<tr>
<td>配置更新推送</td>
<td>高</td>
<td>需要手工触发</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置定时拉取</td>
<td>高</td>
<td>无</td>
<td>支持</td>
<td>配置更新目前依赖事件驱动， client重启或者server端推送操作</td>
<td></td>
</tr>
<tr>
<td>用户权限管理</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>授权、审核、审计</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>无</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>配置版本管理</td>
<td>高</td>
<td>Git做版本管理</td>
<td>界面上直接提供发布历史和回滚按钮</td>
<td>操作记录有落数据库，但无查询接口</td>
<td></td>
</tr>
<tr>
<td>配置合规检测</td>
<td>高</td>
<td>不支持</td>
<td>支持（但还需完善）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>实例配置监控</td>
<td>高</td>
<td>需要结合springadmin</td>
<td>支持</td>
<td>支持，可以查看每个配置在哪些机器上加载</td>
<td></td>
</tr>
<tr>
<td>灰度发布</td>
<td>中</td>
<td>不支持</td>
<td>支持</td>
<td>不支持部分更新</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>告警通知</td>
<td>中</td>
<td>不支持</td>
<td>支持，邮件方式告警</td>
<td>支持，邮件方式告警</td>
<td></td>
</tr>
<tr>
<td>依赖关系</td>
<td>高</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>配置与系统版本的依赖系统运行时的依赖关系</td>
</tr>
</tbody></table>
<h3 id="技术路线兼容性"><a href="#技术路线兼容性" class="headerlink" title="技术路线兼容性"></a>技术路线兼容性</h3><p>引入配置中心，需要考虑和现有项目的兼容性，以及是否引入额外的第三方组件。我们的java项目以SpringBoot为主，需要重点关注springboot支持性。</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SpringBoot支持</td>
<td>高</td>
<td>原生支持</td>
<td>支持</td>
<td>与spring boot无相关</td>
<td></td>
</tr>
<tr>
<td>SpringCloud支持</td>
<td>高</td>
<td>原生支持</td>
<td>支持</td>
<td>与spring cloud无相关</td>
<td></td>
</tr>
<tr>
<td>客户端支持</td>
<td>低</td>
<td>Java</td>
<td>Java、.Net</td>
<td>java</td>
<td></td>
</tr>
<tr>
<td>业务系统侵入性</td>
<td>高</td>
<td>侵入性弱</td>
<td>侵入性弱</td>
<td>侵入性弱，支持注解及xml方式</td>
<td></td>
</tr>
<tr>
<td>依赖组件</td>
<td>高</td>
<td>Eureka</td>
<td>Eureka</td>
<td>zookeeper</td>
<td></td>
</tr>
</tbody></table>
<h3 id="可用性与易用性"><a href="#可用性与易用性" class="headerlink" title="可用性与易用性"></a>可用性与易用性</h3><p>引入配置中心后，所有的应用都需要依赖配置中心，因此可用性需要重点关注，另外管理的易用性也需要关注。</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>单点故障（SPOF）</td>
<td>高</td>
<td>支持HA部署</td>
<td>支持HA部署</td>
<td>支持HA部署，高可用由zookeeper保证</td>
<td></td>
</tr>
<tr>
<td>多数据中心部署</td>
<td>高</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置获取性能</td>
<td>高</td>
<td>unkown</td>
<td>unkown（官方说比spring快）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>配置界面</td>
<td>中</td>
<td>无，需要通过git操作</td>
<td>统一界面（ng编写）</td>
<td>统一界面</td>
<td></td>
</tr>
</tbody></table>
<h2 id="最终选择"><a href="#最终选择" class="headerlink" title="最终选择"></a>最终选择</h2><p>综上，ctrip applo是较好的选择方案，最终选择applo。</p>
<ul>
<li>支持不同环境（开发、测试、生产）、不同集群</li>
<li>完善的管理系统，权限管理、发布审核、操作审计</li>
<li>SpringBoot集成友好 ，较小的迁移成本</li>
<li>配置修改实时生效（热发布）</li>
<li>版本发布管理</li>
</ul>
<h3 id="部署情况"><a href="#部署情况" class="headerlink" title="部署情况"></a>部署情况</h3><ul>
<li>管理Web：<a target="_blank" rel="noopener" href="http://config/">http://config</a>.***.com/</li>
<li>三个环境MetaServer：<ul>
<li>Dev： config.devmeta.***.com</li>
<li>Test： config.testmeta.***.com</li>
<li>PRO: config.prometa.***.com</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/08/19/jqpeng-Spring%20boot%E5%9B%BD%E9%99%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/08/19/jqpeng-Spring%20boot%E5%9B%BD%E9%99%85%E5%8C%96/" class="post-title-link" itemprop="url">Spring boot国际化</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-19 13:27:00" itemprop="dateCreated datePublished" datetime="2018-08-19T13:27:00+08:00">2018-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-boot-i18n.html">Spring boot国际化</a></p>
<p>国际化主要是引入了MessageSource，我们简单看下如何使用，以及其原理。</p>
<h2 id="1-1-设置资源文件"><a href="#1-1-设置资源文件" class="headerlink" title="1.1 设置资源文件"></a>1.1 设置资源文件</h2><p>在 properties新建i18n目录</p>
<p>新建message文件：</p>
<p>messages.properties</p>
<pre><code>error.title=Your request cannot be processed
</code></pre>
<p>messages_zh_CN.properties</p>
<pre><code>error.title=您的请求无法处理
</code></pre>
<h2 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h2><p>修改properties文件的目录：在application.yml或者application.properties中配置 spring.message.basename</p>
<pre><code>spring:
    application:
        name: test-worklog
    messages:
        basename: i18n/messages
        encoding: UTF-8
</code></pre>
<h2 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h2><p>引用自动注解的MessageSource,调用<code>messageSource.getMessage</code>即可，注意，需要通过<code> LocaleContextHolder.getLocale()</code>获取当前的地区。</p>
<pre><code>@Autowired
private MessageSource messageSource;
/**
 * 国际化
 *
 * @param result
 * @return
 */
public String getMessage(String result, Object[] params) &#123;
    String message = &quot;&quot;;
    try &#123;
        Locale locale = LocaleContextHolder.getLocale();
        message = messageSource.getMessage(result, params, locale);
    &#125; catch (Exception e) &#123;
        LOGGER.error(&quot;parse message error! &quot;, e);
    &#125;
    return message;
&#125;
</code></pre>
<p>如何设置个性化的地区呢? <code>forLanguageTag</code> 即可</p>
<pre><code> Locale locale = Locale.forLanguageTag(user.getLangKey());
</code></pre>
<h2 id="1-4-原理分析"><a href="#1-4-原理分析" class="headerlink" title="1.4 原理分析"></a>1.4 原理分析</h2><p><code>MessageSourceAutoConfiguration</code>中，实现了autoconfig</p>
<pre><code>@Configuration
@ConditionalOnMissingBean(value = MessageSource.class, search = SearchStrategy.CURRENT)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Conditional(ResourceBundleCondition.class)
@EnableConfigurationProperties
@ConfigurationProperties(prefix = &quot;spring.messages&quot;)
public class MessageSourceAutoConfiguration &#123;
</code></pre>
<p>该类一方面读取配置文件，一方面创建了MessageSource的实例:</p>
<pre><code>@Beanpublic MessageSource messageSource() &#123;    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();    if (StringUtils.hasText(this.basename)) &#123;        messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(                StringUtils.trimAllWhitespace(this.basename)));    &#125;    if (this.encoding != null) &#123;        messageSource.setDefaultEncoding(this.encoding.name());    &#125;    messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);    messageSource.setCacheSeconds(this.cacheSeconds);    messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);    return messageSource;&#125;
</code></pre>
<p>因此，默认是加载的<code>ResourceBundleMessageSource</code>，该类派生与于AbstractResourceBasedMessageSource</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532590285975.jpg" alt="enter description here" title="1532590285975"></p>
<pre><code>@Overridepublic final String getMessage(String code, Object[] args, String defaultMessage, Locale locale) &#123;    String msg = getMessageInternal(code, args, locale);    if (msg != null) &#123;        return msg;    &#125;    if (defaultMessage == null) &#123;        String fallback = getDefaultMessage(code);        if (fallback != null) &#123;            return fallback;        &#125;    &#125;    return renderDefaultMessage(defaultMessage, args, locale);&#125;
</code></pre>
<p>最终是调用resolveCode来获取message，通过ResourceBundle来获取message</p>
<pre><code>    @Overrideprotected MessageFormat resolveCode(String code, Locale locale) &#123;    // 遍历语言文件路径    Set&lt;String&gt; basenames = getBasenameSet();    for (String basename : basenames) &#123;        ResourceBundle bundle = getResourceBundle(basename, locale);        if (bundle != null) &#123;            MessageFormat messageFormat = getMessageFormat(bundle, code, locale);            if (messageFormat != null) &#123;                return messageFormat;            &#125;        &#125;    &#125;    return null;&#125;
// 获取ResourceBundle    
protected ResourceBundle getResourceBundle(String basename, Locale locale) &#123;    if (getCacheMillis() &gt;= 0) &#123;        // Fresh ResourceBundle.getBundle call in order to let ResourceBundle        // do its native caching, at the expense of more extensive lookup steps.        return doGetBundle(basename, locale);    &#125;    else &#123;        // Cache forever: prefer locale cache over repeated getBundle calls.        synchronized (this.cachedResourceBundles) &#123;            Map&lt;Locale, ResourceBundle&gt; localeMap = this.cachedResourceBundles.get(basename);            if (localeMap != null) &#123;                ResourceBundle bundle = localeMap.get(locale);                if (bundle != null) &#123;                    return bundle;                &#125;            &#125;            try &#123;                ResourceBundle bundle = doGetBundle(basename, locale);                if (localeMap == null) &#123;                    localeMap = new HashMap&lt;Locale, ResourceBundle&gt;();                    this.cachedResourceBundles.put(basename, localeMap);                &#125;                localeMap.put(locale, bundle);                return bundle;            &#125;            catch (MissingResourceException ex) &#123;                if (logger.isWarnEnabled()) &#123;                    logger.warn(&quot;ResourceBundle [&quot; + basename + &quot;] not found for MessageSource: &quot; + ex.getMessage());                &#125;                // Assume bundle not found                // -&gt; do NOT throw the exception to allow for checking parent message source.                return null;            &#125;        &#125;    &#125;&#125;

//  ResourceBundle    
protected ResourceBundle doGetBundle(String basename, Locale locale) throws MissingResourceException &#123;    return ResourceBundle.getBundle(basename, locale, getBundleClassLoader(), new MessageSourceControl());
&#125;
</code></pre>
<p>最后来看getMessageFormat：</p>
<pre><code>/** * Return a MessageFormat for the given bundle and code, * fetching already generated MessageFormats from the cache. * @param bundle the ResourceBundle to work on * @param code the message code to retrieve * @param locale the Locale to use to build the MessageFormat * @return the resulting MessageFormat, or &#123;@code null&#125; if no message * defined for the given code * @throws MissingResourceException if thrown by the ResourceBundle */protected MessageFormat getMessageFormat(ResourceBundle bundle, String code, Locale locale)        throws MissingResourceException &#123;
    synchronized (this.cachedBundleMessageFormats) &#123;        // 从缓存读取        Map&lt;String, Map&lt;Locale, MessageFormat&gt;&gt; codeMap = this.cachedBundleMessageFormats.get(bundle);        Map&lt;Locale, MessageFormat&gt; localeMap = null;        if (codeMap != null) &#123;            localeMap = codeMap.get(code);            if (localeMap != null) &#123;                MessageFormat result = localeMap.get(locale);                if (result != null) &#123;                    return result;                &#125;            &#125;        &#125;        // 缓存miss，从bundle读取        String msg = getStringOrNull(bundle, code);        if (msg != null) &#123;            if (codeMap == null) &#123;                codeMap = new HashMap&lt;String, Map&lt;Locale, MessageFormat&gt;&gt;();                this.cachedBundleMessageFormats.put(bundle, codeMap);            &#125;            if (localeMap == null) &#123;                localeMap = new HashMap&lt;Locale, MessageFormat&gt;();                codeMap.put(code, localeMap);            &#125;            MessageFormat result = createMessageFormat(msg, locale);            localeMap.put(locale, result);            return result;        &#125;
        return null;    &#125;&#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/08/09/jqpeng-%E7%AE%A1%E7%90%86%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/08/09/jqpeng-%E7%AE%A1%E7%90%86%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">管理培训笔记</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 10:41:00" itemprop="dateCreated datePublished" datetime="2018-08-09T10:41:00+08:00">2018-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/9447480.html">管理培训笔记</a></p>
<h2 id="开启-领导之路"><a href="#开启-领导之路" class="headerlink" title="开启 领导之路"></a>开启 领导之路</h2><h3 id="建立团队"><a href="#建立团队" class="headerlink" title="建立团队"></a>建立团队</h3><h4 id="什么是团队？"><a href="#什么是团队？" class="headerlink" title="什么是团队？"></a>什么是团队？</h4><ol>
<li>一群人为了共同目的而奋斗，惟有通过成员间有效合作共事才能达成目标</li>
<li>团队具有共同的目的：使命、职责、目标</li>
</ol>
<h4 id="使命"><a href="#使命" class="headerlink" title="使命"></a>使命</h4><p>包含三个方面：</p>
<ol>
<li>团队是谁</li>
<li>团队存在的理由</li>
<li>团队支持何种组织目标的实现</li>
</ol>
<h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h4><p>团队所负责的具体职责，是具体的可落地工作：</p>
<p>对于一个IT团队，可能的职责是：</p>
<ol>
<li>推动公司内部管理信息化， 负责内部网络信息系统的建设</li>
<li>负责公司电子商务 的应用推广工作</li>
<li>负责公司员工 电子商务系统应用的培训</li>
</ol>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>目标是短期、中长期具体工作规划。制定目标需要符合SMART原则。</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672418534.jpg" alt="SMART原则" title="SMART原则"></p>
<p>建立团队规范：<br> 沟通、会议、决策、冲突</p>
<h2 id="保障-运营卓越"><a href="#保障-运营卓越" class="headerlink" title="保障 运营卓越"></a>保障 运营卓越</h2><p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672674475.jpg" alt=" 任务规划与执行的步骤" title="1532672674475"></p>
<h3 id="1-明确需求"><a href="#1-明确需求" class="headerlink" title="1. 明确需求"></a>1. 明确需求</h3><h4 id="什么是计划"><a href="#什么是计划" class="headerlink" title="什么是计划"></a>什么是计划</h4><p>为实现目标，而规划自己与他人的行动</p>
<h4 id="什么是“执行力”？"><a href="#什么是“执行力”？" class="headerlink" title="什么是“执行力”？"></a>什么是“执行力”？</h4><p>有效运用资源，达成目标的能力</p>
<h4 id="任务规划与执行的步骤"><a href="#任务规划与执行的步骤" class="headerlink" title="任务规划与执行的步骤"></a>任务规划与执行的步骤</h4><ul>
<li>建立信息基础，分析整理已知信息，计划需要收集的信息</li>
<li>信息基础：假设、准则/条件、资源、行动</li>
<li>考虑个人特质： 客观、远见、主动</li>
</ul>
<h3 id="2-定计划"><a href="#2-定计划" class="headerlink" title="2. 定计划"></a>2. 定计划</h3><ul>
<li><p>任务和行动：</p>
<ul>
<li>任务并非单一的行动，而是若干个单一行动组成的</li>
<li>行动是可执行的步骤，是能够推进任务完成的、具体的、可实施的行动</li>
<li>行动需要为任务服务</li>
</ul>
</li>
<li><p>注意行动排序</p>
<ul>
<li>识别任务清单中各项行动的相互关联与依赖关系</li>
<li>并据各项行动的先后顺序，安排和确定工作</li>
</ul>
</li>
<li><p>评估风险、机会 四象限</p>
<ul>
<li>从影响大小、概率高低</li>
</ul>
<p>  <img src="http://oyqmmpkcm.bkt.clouddn.com/1532672842584.jpg" alt="评估风险/机会" title="1532672842584"></p>
</li>
</ul>
<h3 id="3-分职责"><a href="#3-分职责" class="headerlink" title="3. 分职责"></a>3. 分职责</h3><ul>
<li>团队分工：RACI<ul>
<li>Responsible 负责人</li>
<li>Accountable 当责人</li>
<li>Consult 被咨询人</li>
<li>Inform 知情者</li>
</ul>
</li>
</ul>
<p>需要注意，负责人和当责人之间的三不管地带：</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672894561.jpg" alt="团队分工:RACI" title="1532672894561"></p>
<p>任务分配时，需要明确期待的结果，方便跟踪和评价。</p>
<p>同时注意，选择合适人员  </p>
<ul>
<li>客观条件  </li>
<li>人员意愿  </li>
</ul>
<ul>
<li>不会做  </li>
<li>不能做  </li>
<li>不想做</li>
</ul>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532673100397.jpg" alt="enter description here" title="1532673100397"></p>
<h3 id="4-做追踪"><a href="#4-做追踪" class="headerlink" title="4. 做追踪"></a>4. 做追踪</h3><blockquote>
<p>郭士纳说：人们不会做你希望的，只会做你检查的；如果你强调什么，你就检查什么，你不检查就等于不重视</p>
</blockquote>
<p>因此，你强调什么，就一定要检查什么！</p>
<p>追踪流程：  </p>
<ul>
<li> 收集资料  </li>
<li> 对标找差  </li>
<li> 纠偏强化</li>
</ul>
<p>追踪需要重点关注结果和行为。</p>
<p>常见的追踪方法：  </p>
<ul>
<li> 召集 会议  </li>
<li> 观察 检查  </li>
<li> 定期反馈 及报告</li>
</ul>
<p>如何有效追踪：</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532673452477.jpg" alt="如何有效追踪" title="如何有效追踪"></p>
<h2 id="确保-沟通有效"><a href="#确保-沟通有效" class="headerlink" title="确保 沟通有效"></a>确保 沟通有效</h2><h3 id="破除沟通障碍"><a href="#破除沟通障碍" class="headerlink" title="破除沟通障碍"></a>破除沟通障碍</h3><h4 id="常见沟通障碍"><a href="#常见沟通障碍" class="headerlink" title="常见沟通障碍"></a>常见沟通障碍</h4><p>认知偏差、听不到位 无效表达、缺乏参与</p>
<h4 id="破除沟通障碍三法宝：-听、问、说"><a href="#破除沟通障碍三法宝：-听、问、说" class="headerlink" title="破除沟通障碍三法宝： 听、问、说"></a>破除沟通障碍三法宝： 听、问、说</h4><p>提高沟通效能</p>
<p>互动五流程：</p>
<ol>
<li>定方向</li>
<li>理情况</li>
<li>想方法</li>
<li>明作法</li>
<li>做总结</li>
</ol>
<h4 id="观人沟通术"><a href="#观人沟通术" class="headerlink" title="观人沟通术"></a>观人沟通术</h4><p>人际矩阵</p>
<p>理解自己，理解他人-PDP</p>
<p>利用PDP与风格不同的人更 好合作</p>
<h2 id="辅导员工"><a href="#辅导员工" class="headerlink" title="辅导员工"></a>辅导员工</h2><h3 id="主管，你是教练"><a href="#主管，你是教练" class="headerlink" title="主管，你是教练"></a>主管，你是教练</h3><p>常见辅导议题</p>
<h3 id="发现辅导机会"><a href="#发现辅导机会" class="headerlink" title="发现辅导机会"></a>发现辅导机会</h3><p>发现征兆、收集信息</p>
<p>检验原因、做出判断</p>
<h3 id="进行有效辅导"><a href="#进行有效辅导" class="headerlink" title="进行有效辅导"></a>进行有效辅导</h3><p>利用沟通三法宝和互动五流 程进行有效辅导</p>
<h3 id="辅导反馈与跟进"><a href="#辅导反馈与跟进" class="headerlink" title="辅导反馈与跟进"></a>辅导反馈与跟进</h3><p>有效反馈要诀： 及时、平衡、具体<br> 两种反馈工具： 正面反馈(STAR) 改进型反馈(STAR/AR)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/07/05/jqpeng-Jhipster%20Registry%EF%BC%88Eureka%20Server%EF%BC%89%20Docker%E5%8F%8C%E5%90%91%E8%81%94%E9%80%9A%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/07/05/jqpeng-Jhipster%20Registry%EF%BC%88Eureka%20Server%EF%BC%89%20Docker%E5%8F%8C%E5%90%91%E8%81%94%E9%80%9A%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">Jhipster Registry（Eureka Server） Docker双向联通与高可用部署</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 09:56:00" itemprop="dateCreated datePublished" datetime="2018-07-05T09:56:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/9266722.html">Jhipster Registry（Eureka Server） Docker双向联通与高可用部署</a></p>
<p>使用Compose来编排这个Eureka Server集群：</p>
<h2 id="peer1配置："><a href="#peer1配置：" class="headerlink" title="peer1配置："></a>peer1配置：</h2><pre><code>server:
    port: 8761

eureka:
    instance:
        hostname: eureka-peer-1
    server:
        # see discussion about enable-self-preservation:
        # https://github.com/jhipster/generator-jhipster/issues/3654
        enable-self-preservation: false
        registry-sync-retry-wait-ms: 500
        a-sgcache-expiry-timeout-ms: 60000
        eviction-interval-timer-in-ms: 30000
        peer-eureka-nodes-update-interval-ms: 30000
        renewal-threshold-update-interval-ms: 15000
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
            defaultZone: http://admin:$&#123;spring.security.user.password:admin&#125;@eureka-peer-2:8762/eureka/
</code></pre>
<h2 id="peer2配置："><a href="#peer2配置：" class="headerlink" title="peer2配置："></a>peer2配置：</h2><pre><code>server:
    port: 8762

eureka:
    instance:
        hostname: eureka-peer-2
    server:
        # see discussion about enable-self-preservation:
        # https://github.com/jhipster/generator-jhipster/issues/3654
        enable-self-preservation: false
        registry-sync-retry-wait-ms: 500
        a-sgcache-expiry-timeout-ms: 60000
        eviction-interval-timer-in-ms: 30000
        peer-eureka-nodes-update-interval-ms: 30000
        renewal-threshold-update-interval-ms: 15000
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
            defaultZone: http://admin:$&#123;spring.security.user.password:admin&#125;@eureka-peer-1:8761/eureka/
</code></pre>
<h2 id="构建Image"><a href="#构建Image" class="headerlink" title="构建Image"></a>构建Image</h2><p>使用官方的DockerFile：</p>
<pre><code>FROM openjdk:8-jre-alpine

ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \
    JAVA_OPTS=&quot;&quot; \
    JHIPSTER_SLEEP=0

VOLUME /tmp
EXPOSE 8761
CMD echo &quot;The application will start in $&#123;JHIPSTER_SLEEP&#125;s...&quot; &amp;&amp; \
    sleep $&#123;JHIPSTER_SLEEP&#125; &amp;&amp; \
    java $&#123;JAVA_OPTS&#125; -Djava.security.egd=file:/dev/./urandom -jar /app.war

# add directly the war
ADD *.war /app.war
</code></pre>
<p>构建Image并push到registry，这里是192.168.86.8:5000/registry-dev</p>
<h2 id="编写compose文件："><a href="#编写compose文件：" class="headerlink" title="编写compose文件："></a>编写compose文件：</h2><pre><code>version: &quot;3&quot; 
services:
  eureka-peer-1 :
    image: 192.168.86.8:5000/registry-dev:latest
    links:
      - eureka-peer-2
    ports:
      - &quot;8761:8761&quot;
    environment:
      spring.profiles.active: oauth2,peer1,swagger
    entrypoint:
      - java
      - -Dspring.profiles.active=oauth2,peer1,swagger
      - -Djava.security.egd=file:/dev/./urandom
      - -jar
      - /app.war
  eureka-peer-2:
    image: 192.168.86.8:5000/registry-dev:latest
    links:
      - eureka-peer-1
    expose:
      - &quot;8762&quot;
    ports:
      - &quot;8762:8762&quot;
    environment:
      spring.profiles.active: oauth2,peer2,swagger
    entrypoint:
      - java
      - -Dspring.profiles.active=oauth2,peer2,swagger
      - -Djava.security.egd=file:/dev/./urandom
      - -jar
      - /app.war
</code></pre>
<p>启动即可。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/06/29/jqpeng-%EF%BC%88%E8%BD%AC%E9%98%AE%E4%B8%80%E5%B3%B0%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OAuth%202.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/06/29/jqpeng-%EF%BC%88%E8%BD%AC%E9%98%AE%E4%B8%80%E5%B3%B0%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OAuth%202.0/" class="post-title-link" itemprop="url">（转阮一峰）深入理解OAuth 2.0</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-29 08:51:00" itemprop="dateCreated datePublished" datetime="2018-06-29T08:51:00+08:00">2018-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/9241712.html">（转阮一峰）深入理解OAuth 2.0</a></p>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/OAuth">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。</p>
<p>本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a target="_blank" rel="noopener" href="http://www.rfcreader.com/#rfc6749">RFC 6749</a>。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051201.png" alt="OAuth Logo"></p>
<h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p>
<p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051202.png" alt="云冲印"></p>
<p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p>
<p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p>
<blockquote>
<p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。</p>
<p>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</p>
<p>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。</p>
<p>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</p>
<p>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p>
</blockquote>
<p>OAuth就是为了解决上面这些问题而诞生的。</p>
<h2 id="二、名词定义"><a href="#二、名词定义" class="headerlink" title="二、名词定义"></a>二、名词定义</h2><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p>
<blockquote>
<p>（1） <strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</p>
<p>（2）<strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。</p>
<p>（3）<strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。</p>
<p>（4）<strong>User Agent</strong>：用户代理，本文中就是指浏览器。</p>
<p>（5）<strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</p>
<p>（6）<strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
</blockquote>
<p>知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p>
<h2 id="三、OAuth的思路"><a href="#三、OAuth的思路" class="headerlink" title="三、OAuth的思路"></a>三、OAuth的思路</h2><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<h2 id="四、运行流程"><a href="#四、运行流程" class="headerlink" title="四、运行流程"></a>四、运行流程</h2><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png" alt="OAuth运行流程"></p>
<blockquote>
<p>（A）用户打开客户端以后，客户端要求用户给予授权。</p>
<p>（B）用户同意给予客户端授权。</p>
<p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p>
<p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p>
<p>（E）客户端使用令牌，向资源服务器申请获取资源。</p>
<p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
</blockquote>
<p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<p>下面一一讲解客户端获取授权的四种模式。</p>
<h2 id="五、客户端的授权模式"><a href="#五、客户端的授权模式" class="headerlink" title="五、客户端的授权模式"></a>五、客户端的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h2 id="六、授权码模式"><a href="#六、授权码模式" class="headerlink" title="六、授权码模式"></a>六、授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051204.png" alt="授权码模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A步骤中，客户端申请认证的URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1<br>    Host: server.example.com</p>
</blockquote>
<p>C步骤中，服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 302 Found<br>    Location: <a target="_blank" rel="noopener" href="https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA">https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</a><br>              &amp;state=xyz</p>
</blockquote>
<p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>    Host: server.example.com<br>    Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>    Content-Type: application/x-www-form-urlencoded</p>
<pre><code>grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
</code></pre>
</blockquote>
<p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p>
<h2 id="七、简化模式"><a href="#七、简化模式" class="headerlink" title="七、简化模式"></a>七、简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051205.png" alt="简化模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端将用户导向认证服务器。</p>
<p>（B）用户决定是否给于客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p>
<p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p>
<p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p>
<p>（G）浏览器将令牌发给客户端。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，此处的值固定为”token”，必选项。</li>
<li>client_id：表示客户端的ID，必选项。</li>
<li>redirect_uri：表示重定向的URI，可选项。</li>
<li>scope：表示权限范围，可选项。</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1<br>        Host: server.example.com</p>
</blockquote>
<p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 302 Found<br>         Location: <a target="_blank" rel="noopener" href="http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA">http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</a><br>                   &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</p>
</blockquote>
<p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p>
<p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p>
<h2 id="八、密码模式"><a href="#八、密码模式" class="headerlink" title="八、密码模式"></a>八、密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051206.png" alt="密码模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户向客户端提供用户名和密码。</p>
<p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p>
<p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=password&amp;username=johndoe&amp;password=A3ddj3w
</code></pre>
</blockquote>
<p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<p>整个过程中，客户端不得保存用户的密码。</p>
<h2 id="九、客户端模式"><a href="#九、客户端模式" class="headerlink" title="九、客户端模式"></a>九、客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051207.png" alt="客户端模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p>
<p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”client_credentials”，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=client_credentials
</code></pre>
</blockquote>
<p>认证服务器必须以某种方式，验证客户端身份。</p>
<p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<h2 id="十、更新令牌"><a href="#十、更新令牌" class="headerlink" title="十、更新令牌"></a>十、更新令牌</h2><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，此处的值固定为”refresh_token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
</code></pre>
</blockquote>
<p>（完）</p>
<hr>
<p>出处：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/2014/05/oauth_2_0.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/06/14/jqpeng-%E5%9F%BA%E4%BA%8Espring%20security%20%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/06/14/jqpeng-%E5%9F%BA%E4%BA%8Espring%20security%20%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">基于spring security 实现前后端分离项目权限控制</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-14 09:04:00" itemprop="dateCreated datePublished" datetime="2018-06-14T09:04:00+08:00">2018-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security-usage.html">基于spring security 实现前后端分离项目权限控制</a></p>
<p>前后端分离的项目，前端有菜单（menu），后端有API（backendApi），一个menu对应的页面有N个API接口来支持，本文介绍如何基于spring security实现前后端的同步权限控制。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>还是基于Role来实现，具体的思路是，一个Role拥有多个Menu，一个menu有多个backendApi，其中Role和menu，以及menu和backendApi都是ManyToMany关系。</p>
<p>验证授权也很简单，用户登陆系统时，获取Role关联的Menu，页面访问后端API时，再验证下用户是否有访问API的权限。</p>
<h3 id="domain定义"><a href="#domain定义" class="headerlink" title="domain定义"></a>domain定义</h3><p>我们用JPA来实现，先来定义Role</p>
<pre><code>public class Role implements Serializable &#123;


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 名称
     */
    @NotNull
    @ApiModelProperty(value = &quot;名称&quot;, required = true)
    @Column(name = &quot;name&quot;, nullable = false)
    private String name;

    /**
     * 备注
     */
    @ApiModelProperty(value = &quot;备注&quot;)
    @Column(name = &quot;remark&quot;)
    private String remark;

    @JsonIgnore
    @ManyToMany
    @JoinTable(
        name = &quot;role_menus&quot;,
        joinColumns = &#123;@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)&#125;,
        inverseJoinColumns = &#123;@JoinColumn(name = &quot;menu_id&quot;, referencedColumnName = &quot;id&quot;)&#125;)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    @BatchSize(size = 100)
    private Set&lt;Menu&gt; menus = new HashSet&lt;&gt;();&#125;
</code></pre>
<p>以及Menu：</p>
<pre><code>public class Menu implements Serializable &#123;


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = &quot;parent_id&quot;)
    private Integer parentId;

    /**
     * 文本
     */
    @ApiModelProperty(value = &quot;文本&quot;)
    @Column(name = &quot;text&quot;)
    private String text;@ApiModelProperty(value = &quot;angular路由&quot;)
    @Column(name = &quot;link&quot;)
    private String link;
    @ManyToMany
    @JsonIgnore
    @JoinTable(name = &quot;backend_api_menus&quot;,
        joinColumns = @JoinColumn(name=&quot;menus_id&quot;, referencedColumnName=&quot;id&quot;),
        inverseJoinColumns = @JoinColumn(name=&quot;backend_apis_id&quot;, referencedColumnName=&quot;id&quot;))
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set&lt;BackendApi&gt; backendApis = new HashSet&lt;&gt;();

    @ManyToMany(mappedBy = &quot;menus&quot;)
    @JsonIgnore
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();&#125;
</code></pre>
<p>最后是BackendApi，区分method（HTTP请求方法）、tag（哪一个Controller）和path（API请求路径）：</p>
<pre><code>public class BackendApi implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = &quot;tag&quot;)
    private String tag;

    @Column(name = &quot;path&quot;)
    private String path;

    @Column(name = &quot;method&quot;)
    private String method;

    @Column(name = &quot;summary&quot;)
    private String summary;

    @Column(name = &quot;operation_id&quot;)
    private String operationId;

    @ManyToMany(mappedBy = &quot;backendApis&quot;)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set&lt;Menu&gt; menus = new HashSet&lt;&gt;();&#125;
</code></pre>
<h2 id="管理页面实现"><a href="#管理页面实现" class="headerlink" title="管理页面实现"></a>管理页面实现</h2><p>Menu菜单是业务需求确定的，因此提供CRUD编辑即可。<br> BackendAPI，可以通过swagger来获取。<br> 前端选择ng-algin，参见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/angular-ng-alain.html">Angular 中后台前端解决方案 - Ng Alain 介绍</a></p>
<h3 id="通过swagger获取BackendAPI"><a href="#通过swagger获取BackendAPI" class="headerlink" title="通过swagger获取BackendAPI"></a>通过swagger获取BackendAPI</h3><p>获取swagger api有多种方法，最简单的就是访问http接口获取json，然后解析，这很简单，这里不赘述，还有一种就是直接调用相关API获取Swagger对象。</p>
<p>查看官方的web代码，可以看到获取数据大概是这样的：</p>
<pre><code>        String groupName = Optional.fromNullable(swaggerGroup).or(Docket.DEFAULT_GROUP_NAME);
        Documentation documentation = documentationCache.documentationByGroup(groupName);
        if (documentation == null) &#123;
            return new ResponseEntity&lt;Json&gt;(HttpStatus.NOT_FOUND);
        &#125;
        Swagger swagger = mapper.mapDocumentation(documentation);
        UriComponents uriComponents = componentsFrom(servletRequest, swagger.getBasePath());
        swagger.basePath(Strings.isNullOrEmpty(uriComponents.getPath()) ? &quot;/&quot; : uriComponents.getPath());
        if (isNullOrEmpty(swagger.getHost())) &#123;
            swagger.host(hostName(uriComponents));
        &#125;
        return new ResponseEntity&lt;Json&gt;(jsonSerializer.toJson(swagger), HttpStatus.OK);
</code></pre>
<p>其中的documentationCache、environment、mapper等可以直接Autowired获得：</p>
<pre><code>@Autowired
    public SwaggerResource(
        Environment environment,
        DocumentationCache documentationCache,
        ServiceModelToSwagger2Mapper mapper,
        BackendApiRepository backendApiRepository,
        JsonSerializer jsonSerializer) &#123;

        this.hostNameOverride = environment.getProperty(&quot;springfox.documentation.swagger.v2.host&quot;, &quot;DEFAULT&quot;);
        this.documentationCache = documentationCache;
        this.mapper = mapper;
        this.jsonSerializer = jsonSerializer;

        this.backendApiRepository = backendApiRepository;

    &#125;
</code></pre>
<p>然后我们自动加载就简单了，写一个updateApi接口，读取swagger对象，然后解析成BackendAPI，存储到数据库：</p>
<pre><code>@RequestMapping(
        value = &quot;/api/updateApi&quot;,
        method = RequestMethod.GET,
        produces = &#123; APPLICATION_JSON_VALUE, HAL_MEDIA_TYPE &#125;)
    @PropertySourcedMapping(
        value = &quot;$&#123;springfox.documentation.swagger.v2.path&#125;&quot;,
        propertyKey = &quot;springfox.documentation.swagger.v2.path&quot;)
    @ResponseBody
    public ResponseEntity&lt;Json&gt; updateApi(
        @RequestParam(value = &quot;group&quot;, required = false) String swaggerGroup) &#123;

        // 加载已有的api
        Map&lt;String,Boolean&gt; apiMap = Maps.newHashMap();
        List&lt;BackendApi&gt; apis = backendApiRepository.findAll();
        apis.stream().forEach(api-&gt;apiMap.put(api.getPath()+api.getMethod(),true));

        // 获取swagger
        String groupName = Optional.fromNullable(swaggerGroup).or(Docket.DEFAULT_GROUP_NAME);
        Documentation documentation = documentationCache.documentationByGroup(groupName);
        if (documentation == null) &#123;
            return new ResponseEntity&lt;Json&gt;(HttpStatus.NOT_FOUND);
        &#125;
        Swagger swagger = mapper.mapDocumentation(documentation);

        // 加载到数据库
        for(Map.Entry&lt;String, Path&gt; item : swagger.getPaths().entrySet())&#123;
            String path = item.getKey();
            Path pathInfo = item.getValue();
            createApiIfNeeded(apiMap, path,  pathInfo.getGet(), HttpMethod.GET.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getPost(), HttpMethod.POST.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getDelete(), HttpMethod.DELETE.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getPut(), HttpMethod.PUT.name());
        &#125;
        return new ResponseEntity&lt;Json&gt;(HttpStatus.OK);
    &#125;
</code></pre>
<p>其中createApiIfNeeded，先判断下是否存在，不存在的则新增：</p>
<pre><code> private void createApiIfNeeded(Map&lt;String, Boolean&gt; apiMap, String path, Operation operation, String method) &#123;
        if(operation==null) &#123;
            return;
        &#125;
        if(!apiMap.containsKey(path+ method))&#123;
            apiMap.put(path+ method,true);

            BackendApi api = new BackendApi();
            api.setMethod( method);
            api.setOperationId(operation.getOperationId());
            api.setPath(path);
            api.setTag(operation.getTags().get(0));
            api.setSummary(operation.getSummary());

            // 保存
            this.backendApiRepository.save(api);
        &#125;
    &#125;
</code></pre>
<p>最后，做一个简单页面展示即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886480360.jpg" alt="enter description here" title="1528886480360"></p>
<h3 id="菜单管理"><a href="#菜单管理" class="headerlink" title="菜单管理"></a>菜单管理</h3><p>新增和修改页面，可以选择上级菜单，后台API做成按tag分组，可多选即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886647893.jpg" alt="enter description here" title="1528886647893"></p>
<p>列表页面</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886586348.jpg" alt="enter description here" title="1528886586348"></p>
<h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><p>普通的CRUD，最主要的增加一个菜单授权页面，菜单按层级显示即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886692091.jpg" alt="enter description here" title="1528886692091"></p>
<h2 id="认证实现"><a href="#认证实现" class="headerlink" title="认证实现"></a>认证实现</h2><p>管理页面可以做成千奇百样，最核心的还是如何实现认证。</p>
<p>在上一篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a>里我们说了，可以自定义<code>FilterInvocationSecurityMetadataSource</code>来实现。</p>
<p>实现<code>FilterInvocationSecurityMetadataSource</code>接口即可，核心是根据FilterInvocation的Request的method和path，获取对应的Role，然后交给RoleVoter去判断是否有权限。</p>
<h3 id="自定义FilterInvocationSecurityMetadataSource"><a href="#自定义FilterInvocationSecurityMetadataSource" class="headerlink" title="自定义FilterInvocationSecurityMetadataSource"></a>自定义FilterInvocationSecurityMetadataSource</h3><p>我们新建一个DaoSecurityMetadataSource实现FilterInvocationSecurityMetadataSource接口，主要看getAttributes方法：</p>
<pre><code>     @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;
        FilterInvocation fi = (FilterInvocation) object;

        List&lt;Role&gt; neededRoles = this.getRequestNeededRoles(fi.getRequest().getMethod(), fi.getRequestUrl());

        if (neededRoles != null) &#123;
            return SecurityConfig.createList(neededRoles.stream().map(role -&gt; role.getName()).collect(Collectors.toList()).toArray(new String[]&#123;&#125;));
        &#125;

        //  返回默认配置
        return superMetadataSource.getAttributes(object);
    &#125;
</code></pre>
<p>核心是getRequestNeededRoles怎么实现，获取到干净的RequestUrl（去掉参数）,然后看是否有对应的backendAPI，如果没有，则有可能该API有path参数，我们可以去掉最后的path，去库里模糊匹配，直到找到。</p>
<pre><code> public List&lt;Role&gt; getRequestNeededRoles(String method, String path) &#123;
        String rawPath = path;
        //  remove parameters
        if(path.indexOf(&quot;?&quot;)&gt;-1)&#123;
            path = path.substring(0,path.indexOf(&quot;?&quot;));
        &#125;
        // /menus/&#123;id&#125;
        BackendApi api = backendApiRepository.findByPathAndMethod(path, method);
        if (api == null)&#123;
            // try fetch by remove last path
            api = loadFromSimilarApi(method, path, rawPath);
        &#125;

        if (api != null &amp;&amp; api.getMenus().size() &gt; 0) &#123;
            return api.getMenus()
                .stream()
                .flatMap(menu -&gt; menuRepository.findOneWithRolesById(menu.getId()).getRoles().stream())
                .collect(Collectors.toList());
        &#125;
        return null;
    &#125;

    private BackendApi loadFromSimilarApi(String method, String path, String rawPath) &#123;
        if(path.lastIndexOf(&quot;/&quot;)&gt;-1)&#123;
            path = path.substring(0,path.lastIndexOf(&quot;/&quot;));
            List&lt;BackendApi&gt; apis = backendApiRepository.findByPathStartsWithAndMethod(path, method);

            // 如果为空，再去掉一层path
            while(apis==null)&#123;
                if(path.lastIndexOf(&quot;/&quot;)&gt;-1) &#123;
                    path = path.substring(0, path.lastIndexOf(&quot;/&quot;));
                    apis = backendApiRepository.findByPathStartsWithAndMethod(path, method);
                &#125;else&#123;
                    break;
                &#125;
            &#125;

            if(apis!=null)&#123;
                for(BackendApi backendApi : apis)&#123;
                    if (antPathMatcher.match(backendApi.getPath(), rawPath)) &#123;
                        return backendApi;
                    &#125;
                &#125;
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<p>其中，BackendApiRepository：</p>
<pre><code>    @EntityGraph(attributePaths = &quot;menus&quot;)
    BackendApi findByPathAndMethod(String path,String method);

    @EntityGraph(attributePaths = &quot;menus&quot;)
    List&lt;BackendApi&gt; findByPathStartsWithAndMethod(String path,String method);
</code></pre>
<p>以及MenuRepository</p>
<pre><code>    @EntityGraph(attributePaths = &quot;roles&quot;)
    Menu findOneWithRolesById(long id);
</code></pre>
<h3 id="使用DaoSecurityMetadataSource"><a href="#使用DaoSecurityMetadataSource" class="headerlink" title="使用DaoSecurityMetadataSource"></a>使用DaoSecurityMetadataSource</h3><p>需要注意的是，在DaoSecurityMetadataSource里，不能直接注入Repository，我们可以给DaoSecurityMetadataSource添加一个方法，方便传入：</p>
<pre><code>   public void init(MenuRepository menuRepository, BackendApiRepository backendApiRepository) &#123;
        this.menuRepository = menuRepository;
        this.backendApiRepository = backendApiRepository;
    &#125;
</code></pre>
<p>然后建立一个容器，存储实例化的DaoSecurityMetadataSource，我们可以建立如下的ApplicationContext来作为对象容器，存取对象：</p>
<pre><code>public class ApplicationContext &#123;
    static Map&lt;Class&lt;?&gt;,Object&gt; beanMap = Maps.newConcurrentMap();

    public static &lt;T&gt; T getBean(Class&lt;T&gt; requireType)&#123;
        return (T) beanMap.get(requireType);
    &#125;

    public static void registerBean(Object item)&#123;
        beanMap.put(item.getClass(),item);
    &#125;
&#125;
</code></pre>
<p>在SecurityConfiguration配置中使用<code>DaoSecurityMetadataSource</code>，并通过<code> ApplicationContext.registerBean</code>将<code>DaoSecurityMetadataSource</code>注册：</p>
<pre><code> @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)        ....
           // .withObjectPostProcessor()
            // 自定义accessDecisionManager
            .accessDecisionManager(accessDecisionManager())
            // 自定义FilterInvocationSecurityMetadataSource
            .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;
                @Override
                public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
                    O fsi) &#123;
                    fsi.setSecurityMetadataSource(daoSecurityMetadataSource(fsi.getSecurityMetadataSource()));
                    return fsi;
                &#125;
            &#125;)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;

    @Bean
    public DaoSecurityMetadataSource daoSecurityMetadataSource(FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource) &#123;
        DaoSecurityMetadataSource securityMetadataSource = new DaoSecurityMetadataSource(filterInvocationSecurityMetadataSource);
        ApplicationContext.registerBean(securityMetadataSource);
        return securityMetadataSource;
    &#125;
</code></pre>
<p>最后，在程序启动后，通过<code>ApplicationContext.getBean</code>获取到daoSecurityMetadataSource，然后调用init注入Repository</p>
<pre><code> public static void postInit()&#123;
        ApplicationContext
            .getBean(DaoSecurityMetadataSource.class)
 .init(applicationContext.getBean(MenuRepository.class),applicationContext.getBean(BackendApiRepository.class));
    &#125;

    static ConfigurableApplicationContext applicationContext;

    public static void main(String[] args) throws UnknownHostException &#123;
        SpringApplication app = new SpringApplication(UserCenterApp.class);
        DefaultProfileUtil.addDefaultProfile(app);
        applicationContext = app.run(args);

        // 后初始化
        postInit();
&#125;
</code></pre>
<p>大功告成！</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/06/07/jqpeng-spring%20security%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AEurl%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/06/07/jqpeng-spring%20security%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AEurl%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">spring security实现动态配置url权限的两种方法</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-07 15:33:00" itemprop="dateCreated datePublished" datetime="2018-06-07T15:33:00+08:00">2018-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a></p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>标准的RABC, 权限需要支持动态配置，spring security默认是在代码里约定好权限，真实的业务场景通常需要可以支持动态配置角色访问权限，即在运行时去配置url对应的访问角色。</p>
<p>基于spring security，如何实现这个需求呢？</p>
<p>最简单的方法就是自定义一个Filter去完成权限判断，但这脱离了spring security框架，如何基于spring security优雅的实现呢？</p>
<h2 id="spring-security-授权回顾"><a href="#spring-security-授权回顾" class="headerlink" title="spring security 授权回顾"></a>spring security 授权回顾</h2><p>spring security 通过FilterChainProxy作为注册到web的filter，FilterChainProxy里面一次包含了内置的多个过滤器，我们首先需要了解spring security内置的各种filter：</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Filter Class</th>
<th>Namespace Element or Attribute</th>
</tr>
</thead>
<tbody><tr>
<td>CHANNEL_FILTER</td>
<td>ChannelProcessingFilter</td>
<td>http/intercept-url@requires-channel</td>
</tr>
<tr>
<td>SECURITY_CONTEXT_FILTER</td>
<td>SecurityContextPersistenceFilter</td>
<td>http</td>
</tr>
<tr>
<td>CONCURRENT_SESSION_FILTER</td>
<td>ConcurrentSessionFilter</td>
<td>session-management/concurrency-control</td>
</tr>
<tr>
<td>HEADERS_FILTER</td>
<td>HeaderWriterFilter</td>
<td>http/headers</td>
</tr>
<tr>
<td>CSRF_FILTER</td>
<td>CsrfFilter</td>
<td>http/csrf</td>
</tr>
<tr>
<td>LOGOUT_FILTER</td>
<td>LogoutFilter</td>
<td>http/logout</td>
</tr>
<tr>
<td>X509_FILTER</td>
<td>X509AuthenticationFilter</td>
<td>http/x509</td>
</tr>
<tr>
<td>PRE_AUTH_FILTER</td>
<td>AbstractPreAuthenticatedProcessingFilter Subclasses</td>
<td>N/A</td>
</tr>
<tr>
<td>CAS_FILTER</td>
<td>CasAuthenticationFilter</td>
<td>N/A</td>
</tr>
<tr>
<td>FORM_LOGIN_FILTER</td>
<td>UsernamePasswordAuthenticationFilter</td>
<td>http/form-login</td>
</tr>
<tr>
<td>BASIC_AUTH_FILTER</td>
<td>BasicAuthenticationFilter</td>
<td>http/http-basic</td>
</tr>
<tr>
<td>SERVLET_API_SUPPORT_FILTER</td>
<td>SecurityContextHolderAwareRequestFilter</td>
<td>http/@servlet-api-provision</td>
</tr>
<tr>
<td>JAAS_API_SUPPORT_FILTER</td>
<td>JaasApiIntegrationFilter</td>
<td>http/@jaas-api-provision</td>
</tr>
<tr>
<td>REMEMBER_ME_FILTER</td>
<td>RememberMeAuthenticationFilter</td>
<td>http/remember-me</td>
</tr>
<tr>
<td>ANONYMOUS_FILTER</td>
<td>AnonymousAuthenticationFilter</td>
<td>http/anonymous</td>
</tr>
<tr>
<td>SESSION_MANAGEMENT_FILTER</td>
<td>SessionManagementFilter</td>
<td>session-management</td>
</tr>
<tr>
<td>EXCEPTION_TRANSLATION_FILTER</td>
<td>ExceptionTranslationFilter</td>
<td>http</td>
</tr>
<tr>
<td>FILTER_SECURITY_INTERCEPTOR</td>
<td>FilterSecurityInterceptor</td>
<td>http</td>
</tr>
<tr>
<td>SWITCH_USER_FILTER</td>
<td>SwitchUserFilter</td>
<td>N/A</td>
</tr>
</tbody></table>
<p>最重要的是<code>FilterSecurityInterceptor</code>，该过滤器实现了主要的鉴权逻辑，最核心的代码在这里：</p>
<pre><code>protected InterceptorStatusToken beforeInvocation(Object object) &#123;    // 获取访问URL所需权限    Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource()            .getAttributes(object);
    Authentication authenticated = authenticateIfRequired();
    // 通过accessDecisionManager鉴权    try &#123;        this.accessDecisionManager.decide(authenticated, object, attributes);    &#125;    catch (AccessDeniedException accessDeniedException) &#123;        publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated,                accessDeniedException));
        throw accessDeniedException;    &#125;
    if (debug) &#123;        logger.debug(&quot;Authorization successful&quot;);    &#125;
    if (publishAuthorizationSuccess) &#123;        publishEvent(new AuthorizedEvent(object, attributes, authenticated));    &#125;
    // Attempt to run as a different user    Authentication runAs = this.runAsManager.buildRunAs(authenticated, object,            attributes);
    if (runAs == null) &#123;        if (debug) &#123;            logger.debug(&quot;RunAsManager did not change Authentication object&quot;);        &#125;
        // no further work post-invocation        return new InterceptorStatusToken(SecurityContextHolder.getContext(), false,                attributes, object);    &#125;    else &#123;        if (debug) &#123;            logger.debug(&quot;Switching to RunAs Authentication: &quot; + runAs);        &#125;
        SecurityContext origCtx = SecurityContextHolder.getContext();        SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());        SecurityContextHolder.getContext().setAuthentication(runAs);
        // need to revert to token.Authenticated post-invocation        return new InterceptorStatusToken(origCtx, true, attributes, object);    &#125;&#125;
</code></pre>
<p>从上面可以看出，要实现动态鉴权，可以从两方面着手：</p>
<ul>
<li>自定义SecurityMetadataSource，实现从数据库加载ConfigAttribute</li>
<li>另外就是可以自定义accessDecisionManager，官方的UnanimousBased其实足够使用，并且他是基于AccessDecisionVoter来实现权限认证的，因此我们只需要自定义一个AccessDecisionVoter就可以了</li>
</ul>
<p>下面来看分别如何实现。</p>
<h2 id="自定义AccessDecisionManager"><a href="#自定义AccessDecisionManager" class="headerlink" title="自定义AccessDecisionManager"></a>自定义AccessDecisionManager</h2><p>官方的三个AccessDecisionManager都是基于AccessDecisionVoter来实现权限认证的，因此我们只需要自定义一个AccessDecisionVoter就可以了。</p>
<p>自定义主要是实现<code>AccessDecisionVoter</code>接口，我们可以仿照官方的RoleVoter实现一个：</p>
<pre><code>public class RoleBasedVoter implements AccessDecisionVoter&lt;Object&gt; &#123;

    @Override
    public boolean supports(ConfigAttribute attribute) &#123;
        return true;
    &#125;

    @Override
    public int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes) &#123;
        if(authentication == null) &#123;
            return ACCESS_DENIED;
        &#125;
        int result = ACCESS_ABSTAIN;
        Collection&lt;? extends GrantedAuthority&gt; authorities = extractAuthorities(authentication);

        for (ConfigAttribute attribute : attributes) &#123;
            if(attribute.getAttribute()==null)&#123;
                continue;
            &#125;
            if (this.supports(attribute)) &#123;
                result = ACCESS_DENIED;

                // Attempt to find a matching granted authority
                for (GrantedAuthority authority : authorities) &#123;
                    if (attribute.getAttribute().equals(authority.getAuthority())) &#123;
                        return ACCESS_GRANTED;
                    &#125;
                &#125;
            &#125;
        &#125;

        return result;
    &#125;

    Collection&lt;? extends GrantedAuthority&gt; extractAuthorities(
        Authentication authentication) &#123;
        return authentication.getAuthorities();
    &#125;

    @Override
    public boolean supports(Class clazz) &#123;
        return true;
    &#125;
&#125;
</code></pre>
<p>如何加入动态权限呢？</p>
<p><code>vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes) </code>里的<code>Object object</code>的类型是<code>FilterInvocation</code>，可以通过<code>getRequestUrl</code>获取当前请求的URL:</p>
<pre><code>  FilterInvocation fi = (FilterInvocation) object;
  String url = fi.getRequestUrl();
</code></pre>
<p>因此这里扩展空间就大了，可以从DB动态加载，然后判断URL的ConfigAttribute就可以了。</p>
<p>如何使用这个RoleBasedVoter呢？在configure里使用accessDecisionManager方法自定义，我们还是使用官方的<code>UnanimousBased</code>，然后将自定义的RoleBasedVoter加入即可。</p>
<pre><code>@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;

 
    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
            // 自定义accessDecisionManager
            .accessDecisionManager(accessDecisionManager())
          
        .and()
            .apply(securityConfigurerAdapter());

    &#125;


    @Bean
    public AccessDecisionManager accessDecisionManager() &#123;
        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters
            = Arrays.asList(
            new WebExpressionVoter(),
            // new RoleVoter(),
            new RoleBasedVoter(),
            new AuthenticatedVoter());
        return new UnanimousBased(decisionVoters);
    &#125;
</code></pre>
<h2 id="自定义SecurityMetadataSource"><a href="#自定义SecurityMetadataSource" class="headerlink" title="自定义SecurityMetadataSource"></a>自定义SecurityMetadataSource</h2><p>自定义FilterInvocationSecurityMetadataSource只要实现接口即可，在接口里从DB动态加载规则。</p>
<p>为了复用代码里的定义，我们可以将代码里生成的SecurityMetadataSource带上，在构造函数里传入默认的FilterInvocationSecurityMetadataSource。</p>
<pre><code>public class AppFilterInvocationSecurityMetadataSource implements org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource &#123;

    private FilterInvocationSecurityMetadataSource  superMetadataSource;

    @Override
    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123;
        return null;
    &#125;

    public AppFilterInvocationSecurityMetadataSource(FilterInvocationSecurityMetadataSource expressionBasedFilterInvocationSecurityMetadataSource)&#123;
         this.superMetadataSource = expressionBasedFilterInvocationSecurityMetadataSource;

         // TODO 从数据库加载权限配置
    &#125;

    private final AntPathMatcher antPathMatcher = new AntPathMatcher();
    // 这里的需要从DB加载
    private final Map&lt;String,String&gt; urlRoleMap = new HashMap&lt;String,String&gt;()&#123;&#123;
            put("/open/**","ROLE_ANONYMOUS");
            put("/health","ROLE_ANONYMOUS");
            put("/restart","ROLE_ADMIN");
            put("/demo","ROLE_USER");
        &#125;&#125;;

    @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;
        FilterInvocation fi = (FilterInvocation) object;
        String url = fi.getRequestUrl();

        for(Map.Entry&lt;String,String&gt; entry:urlRoleMap.entrySet())&#123;
            if(antPathMatcher.match(entry.getKey(),url))&#123;
                return SecurityConfig.createList(entry.getValue());
            &#125;
        &#125;

        //  返回代码定义的默认配置
        return superMetadataSource.getAttributes(object);
    &#125;



    @Override
    public boolean supports(Class&lt;?&gt; clazz) &#123;
        return FilterInvocation.class.isAssignableFrom(clazz);
    &#125;
&#125;
</code></pre>
<p>怎么使用？和<code>accessDecisionManager</code>不一样，<code>ExpressionUrlAuthorizationConfigurer</code> 并没有提供set方法设置<code>FilterSecurityInterceptor</code>的<code>FilterInvocationSecurityMetadataSource</code>，how to do?</p>
<p>发现一个扩展方法<code>withObjectPostProcessor</code>，通过该方法自定义一个处理<code>FilterSecurityInterceptor</code>类型的<code>ObjectPostProcessor</code>就可以修改<code>FilterSecurityInterceptor</code>。</p>
<pre><code>@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;

 
    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
              // 自定义FilterInvocationSecurityMetadataSource
            .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;
                @Override
                public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
                    O fsi) &#123;
                    fsi.setSecurityMetadataSource(mySecurityMetadataSource(fsi.getSecurityMetadataSource()));
                    return fsi;
                &#125;
            &#125;)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;


    @Bean
    public AppFilterInvocationSecurityMetadataSource mySecurityMetadataSource(FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource) &#123;
        AppFilterInvocationSecurityMetadataSource securityMetadataSource = new AppFilterInvocationSecurityMetadataSource(filterInvocationSecurityMetadataSource);
        return securityMetadataSource;
&#125;
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了两种基于spring security实现动态权限的方法，一是自定义accessDecisionManager，二是自定义FilterInvocationSecurityMetadataSource。实际项目里可以根据需要灵活选择。</p>
<p>延伸阅读:</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/06/06/jqpeng-Spring%20Security%20%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/06/06/jqpeng-Spring%20Security%20%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Spring Security 架构与源码分析</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-06 16:03:00" itemprop="dateCreated datePublished" datetime="2018-06-06T16:03:00+08:00">2018-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></p>
<p>Spring Security 主要实现了Authentication（认证，解决who are you? ） 和 Access Control（访问控制，也就是what are you allowed to do？，也称为Authorization）。Spring Security在架构上将认证与授权分离，并提供了扩展点。</p>
<h2 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h2><p>主要代码在<code>spring-security-core</code>包下面。要了解Spring Security，需要先关注里面的核心对象。</p>
<h3 id="SecurityContextHolder-SecurityContext-和-Authentication"><a href="#SecurityContextHolder-SecurityContext-和-Authentication" class="headerlink" title="SecurityContextHolder, SecurityContext 和 Authentication"></a>SecurityContextHolder, SecurityContext 和 Authentication</h3><p>SecurityContextHolder 是 SecurityContext的存放容器，默认使用ThreadLocal 存储，意味SecurityContext在相同线程中的方法都可用。<br> SecurityContext主要是存储应用的principal信息，在Spring Security中用Authentication 来表示。</p>
<p>获取principal：</p>
<pre><code>Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

if (principal instanceof UserDetails) &#123;
String username = ((UserDetails)principal).getUsername();
&#125; else &#123;
String username = principal.toString();
&#125;
</code></pre>
<p>在Spring Security中，可以看一下Authentication定义：</p>
<pre><code>public interface Authentication extends Principal, Serializable &#123;
Collection&lt;? extends GrantedAuthority&gt; getAuthorities();
/** * 通常是密码 */Object getCredentials();
/** * Stores additional details about the authentication request. These might be an IP * address, certificate serial number etc. */Object getDetails();
/** * 用来标识是否已认证，如果使用用户名和密码登录,通常是用户名  */Object getPrincipal();
/** * 是否已认证 */boolean isAuthenticated();
void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
&#125;
</code></pre>
<p>在实际应用中，通常使用<code>UsernamePasswordAuthenticationToken</code>：</p>
<pre><code>public abstract class AbstractAuthenticationToken implements Authentication,    CredentialsContainer &#123;    &#125;
public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken &#123;
&#125;
</code></pre>
<p>一个常见的认证过程通常是这样的，创建一个UsernamePasswordAuthenticationToken，然后交给authenticationManager认证（后面详细说明），认证通过则通过SecurityContextHolder存放Authentication信息。</p>
<pre><code> UsernamePasswordAuthenticationToken authenticationToken =
            new UsernamePasswordAuthenticationToken(loginVM.getUsername(), loginVM.getPassword());

Authentication authentication = this.authenticationManager.authenticate(authenticationToken);
SecurityContextHolder.getContext().setAuthentication(authentication);
</code></pre>
<h3 id="UserDetails与UserDetailsService"><a href="#UserDetails与UserDetailsService" class="headerlink" title="UserDetails与UserDetailsService"></a>UserDetails与UserDetailsService</h3><p>UserDetails 是Spring Security里的一个关键接口，他用来表示一个principal。</p>
<pre><code>public interface UserDetails extends Serializable &#123;/** * 用户的授权信息，可以理解为角色 */Collection&lt;? extends GrantedAuthority&gt; getAuthorities();
/** * 用户密码 * * @return the password */String getPassword();
/** * 用户名  *     */String getUsername();
boolean isAccountNonExpired();
boolean isAccountNonLocked();
boolean isCredentialsNonExpired();
boolean isEnabled();
&#125;
</code></pre>
<p>UserDetails提供了认证所需的必要信息，在实际使用里，可以自己实现UserDetails，并增加额外的信息，比如email、mobile等信息。</p>
<p>在Authentication中的principal通常是用户名，我们可以通过UserDetailsService来通过principal获取UserDetails：</p>
<pre><code>public interface UserDetailsService &#123;UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
&#125;
</code></pre>
<h3 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h3><p>在UserDetails里说了，GrantedAuthority可以理解为角色，例如 <code>ROLE_ADMINISTRATOR</code> or <code>ROLE_HR_SUPERVISOR</code>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>SecurityContextHolder</code>, 用来访问 <code>SecurityContext</code>.</li>
<li><code>SecurityContext</code>, 用来存储<code>Authentication</code> .</li>
<li><code>Authentication</code>, 代表凭证.</li>
<li><code>GrantedAuthority</code>, 代表权限.</li>
<li><code>UserDetails</code>, 用户信息.</li>
<li><code>UserDetailsService</code>,获取用户信息.</li>
</ul>
<h2 id="Authentication认证"><a href="#Authentication认证" class="headerlink" title="Authentication认证"></a>Authentication认证</h2><h3 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h3><p>实现认证主要是通过AuthenticationManager接口，它只包含了一个方法：</p>
<pre><code>public interface AuthenticationManager &#123;
  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
&#125;
</code></pre>
<p>authenticate()方法主要做三件事：</p>
<ol>
<li>如果验证通过，返回Authentication（通常带上authenticated=true）。</li>
<li>认证失败抛出<code>AuthenticationException</code></li>
<li>如果无法确定，则返回null</li>
</ol>
<p><code>AuthenticationException</code>是运行时异常,它通常由应用程序按通用方式处理，用户代码通常不用特意被捕获和处理这个异常。</p>
<p><code>AuthenticationManager</code>的默认实现是<code>ProviderManager</code>，它委托一组<code>AuthenticationProvider</code>实例来实现认证。<br><code>AuthenticationProvider</code>和<code>AuthenticationManager</code>类似，都包含<code>authenticate</code>，但它有一个额外的方法<code>supports</code>，以允许查询调用方是否支持给定<code>Authentication</code>类型：</p>
<pre><code>public interface AuthenticationProvider &#123;
Authentication authenticate(Authentication authentication)        throws AuthenticationException;boolean supports(Class&lt;?&gt; authentication);
&#125;
</code></pre>
<p>ProviderManager包含一组<code>AuthenticationProvider</code>，执行authenticate时，遍历Providers，然后调用supports，如果支持，则执行遍历当前provider的authenticate方法，如果一个provider认证成功，则break。</p>
<pre><code>public Authentication authenticate(Authentication authentication)        throws AuthenticationException &#123;    Class&lt;? extends Authentication&gt; toTest = authentication.getClass();    AuthenticationException lastException = null;    Authentication result = null;    boolean debug = logger.isDebugEnabled();
    for (AuthenticationProvider provider : getProviders()) &#123;        if (!provider.supports(toTest)) &#123;            continue;        &#125;
        if (debug) &#123;            logger.debug(&quot;Authentication attempt using &quot;                    + provider.getClass().getName());        &#125;
        try &#123;            result = provider.authenticate(authentication);
            if (result != null) &#123;                copyDetails(authentication, result);                break;            &#125;        &#125;        catch (AccountStatusException e) &#123;            prepareException(e, authentication);            // SEC-546: Avoid polling additional providers if auth failure is due to            // invalid account status            throw e;        &#125;        catch (InternalAuthenticationServiceException e) &#123;            prepareException(e, authentication);            throw e;        &#125;        catch (AuthenticationException e) &#123;            lastException = e;        &#125;    &#125;
    if (result == null &amp;&amp; parent != null) &#123;        // Allow the parent to try.        try &#123;            result = parent.authenticate(authentication);        &#125;        catch (ProviderNotFoundException e) &#123;            // ignore as we will throw below if no other exception occurred prior to            // calling parent and the parent            // may throw ProviderNotFound even though a provider in the child already            // handled the request        &#125;        catch (AuthenticationException e) &#123;            lastException = e;        &#125;    &#125;
    if (result != null) &#123;        if (eraseCredentialsAfterAuthentication                &amp;&amp; (result instanceof CredentialsContainer)) &#123;            // Authentication is complete. Remove credentials and other secret data            // from authentication            ((CredentialsContainer) result).eraseCredentials();        &#125;
        eventPublisher.publishAuthenticationSuccess(result);        return result;    &#125;
    // Parent was null, or didn&#39;t authenticate (or throw an exception).
    if (lastException == null) &#123;        lastException = new ProviderNotFoundException(messages.getMessage(                &quot;ProviderManager.providerNotFound&quot;,                new Object[] &#123; toTest.getName() &#125;,                &quot;No AuthenticationProvider found for &#123;0&#125;&quot;));    &#125;
    prepareException(lastException, authentication);
    throw lastException;&#125;
</code></pre>
<p>从上面的代码可以看出， <code>ProviderManager</code>有一个可选parent，如果parent不为空，则调用<code>parent.authenticate(authentication)</code></p>
<h3 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h3><p><code>AuthenticationProvider</code>有多种实现，大家最关注的通常是<code>DaoAuthenticationProvider</code>，继承于<code>AbstractUserDetailsAuthenticationProvider</code>，核心是通过<code>UserDetails</code>来实现认证,<code>DaoAuthenticationProvider</code>默认会自动加载，不用手动配。</p>
<p>先来看<code>AbstractUserDetailsAuthenticationProvide</code>r，看最核心的<code>authenticate</code>：</p>
<pre><code>public Authentication authenticate(Authentication authentication)        throws AuthenticationException &#123;    // 必须是UsernamePasswordAuthenticationToken    Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,            messages.getMessage(                    &quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;,                    &quot;Only UsernamePasswordAuthenticationToken is supported&quot;));
    //  获取用户名    String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot;            : authentication.getName();
    boolean cacheWasUsed = true;    // 从缓存获取    UserDetails user = this.userCache.getUserFromCache(username);
    if (user == null) &#123;        cacheWasUsed = false;
        try &#123;           // retrieveUser 抽象方法，获取用户            user = retrieveUser(username,                    (UsernamePasswordAuthenticationToken) authentication);        &#125;        catch (UsernameNotFoundException notFound) &#123;            logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;);
            if (hideUserNotFoundExceptions) &#123;                throw new BadCredentialsException(messages.getMessage(                        &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                        &quot;Bad credentials&quot;));            &#125;            else &#123;                throw notFound;            &#125;        &#125;
          Assert.notNull(user,                &quot;retrieveUser returned null - a violation of the interface contract&quot;);    &#125;
    try &#123;        // 预先检查，DefaultPreAuthenticationChecks，检查用户是否被lock或者账号是否可用        preAuthenticationChecks.check(user);                // 抽象方法，自定义检验        additionalAuthenticationChecks(user,                (UsernamePasswordAuthenticationToken) authentication);    &#125;    catch (AuthenticationException exception) &#123;        if (cacheWasUsed) &#123;            // There was a problem, so try again after checking            // we&#39;re using latest data (i.e. not from the cache)            cacheWasUsed = false;            user = retrieveUser(username,                    (UsernamePasswordAuthenticationToken) authentication);            preAuthenticationChecks.check(user);            additionalAuthenticationChecks(user,                    (UsernamePasswordAuthenticationToken) authentication);        &#125;        else &#123;            throw exception;        &#125;    &#125;
          // 后置检查 DefaultPostAuthenticationChecks，检查isCredentialsNonExpired    postAuthenticationChecks.check(user);
    if (!cacheWasUsed) &#123;        this.userCache.putUserInCache(user);    &#125;
    Object principalToReturn = user;
    if (forcePrincipalAsString) &#123;        principalToReturn = user.getUsername();    &#125;
       return createSuccessAuthentication(principalToReturn, authentication, user);&#125;
</code></pre>
<p>上面的检验主要基于UserDetails实现，其中获取用户和检验逻辑由具体的类去实现，默认实现是DaoAuthenticationProvider，这个类的核心是让开发者提供UserDetailsService来获取UserDetails以及 PasswordEncoder来检验密码是否有效：</p>
<pre><code>private UserDetailsService userDetailsService;
private PasswordEncoder passwordEncoder;
</code></pre>
<p>看具体的实现，<code>retrieveUser</code>,直接调用userDetailsService获取用户：</p>
<pre><code>protected final UserDetails retrieveUser(String username,        UsernamePasswordAuthenticationToken authentication)        throws AuthenticationException &#123;    UserDetails loadedUser;
    try &#123;        loadedUser = this.getUserDetailsService().loadUserByUsername(username);    &#125;    catch (UsernameNotFoundException notFound) &#123;        if (authentication.getCredentials() != null) &#123;            String presentedPassword = authentication.getCredentials().toString();            passwordEncoder.isPasswordValid(userNotFoundEncodedPassword,                    presentedPassword, null);        &#125;        throw notFound;    &#125;    catch (Exception repositoryProblem) &#123;        throw new InternalAuthenticationServiceException(                repositoryProblem.getMessage(), repositoryProblem);    &#125;
    if (loadedUser == null) &#123;        throw new InternalAuthenticationServiceException(                &quot;UserDetailsService returned null, which is an interface contract violation&quot;);    &#125;    return loadedUser;&#125;
</code></pre>
<p>再来看验证：</p>
<pre><code>protected void additionalAuthenticationChecks(UserDetails userDetails,        UsernamePasswordAuthenticationToken authentication)        throws AuthenticationException &#123;    Object salt = null;
    if (this.saltSource != null) &#123;        salt = this.saltSource.getSalt(userDetails);    &#125;
    if (authentication.getCredentials() == null) &#123;        logger.debug(&quot;Authentication failed: no credentials provided&quot;);
        throw new BadCredentialsException(messages.getMessage(                &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                &quot;Bad credentials&quot;));    &#125;
        // 获取用户密码    String presentedPassword = authentication.getCredentials().toString();
        // 比较passwordEncoder后的密码是否和userdetails的密码一致    if (!passwordEncoder.isPasswordValid(userDetails.getPassword(),            presentedPassword, salt)) &#123;        logger.debug(&quot;Authentication failed: password does not match stored value&quot;);
        throw new BadCredentialsException(messages.getMessage(                &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                &quot;Bad credentials&quot;));    &#125;&#125;
</code></pre>
<p>小结：要自定义认证，使用DaoAuthenticationProvider，只需要为其提供PasswordEncoder和UserDetailsService就可以了。</p>
<h3 id="定制-Authentication-Managers"><a href="#定制-Authentication-Managers" class="headerlink" title="定制 Authentication Managers"></a>定制 Authentication Managers</h3><p>Spring Security提供了一个Builder类<code>AuthenticationManagerBuilder</code>，借助它可以快速实现自定义认证。</p>
<p>看官方源码说明：</p>
<blockquote>
<p>SecurityBuilder used to create an AuthenticationManager . Allows for easily building in memory authentication, LDAP authentication, JDBC based authentication, adding UserDetailsService , and adding AuthenticationProvider’s.</p>
</blockquote>
<p>AuthenticationManagerBuilder可以用来Build一个AuthenticationManager，可以创建基于内存的认证、LDAP认证、 JDBC认证，以及添加UserDetailsService和AuthenticationProvider。</p>
<p>简单使用：</p>
<pre><code>@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class ApplicationSecurity extends WebSecurityConfigurerAdapter &#123;


  public SecurityConfiguration(AuthenticationManagerBuilder authenticationManagerBuilder, UserDetailsService userDetailsService,TokenProvider tokenProvider,CorsFilter corsFilter, SecurityProblemSupport problemSupport) &#123;
        this.authenticationManagerBuilder = authenticationManagerBuilder;
        this.userDetailsService = userDetailsService;
        this.tokenProvider = tokenProvider;
        this.corsFilter = corsFilter;
        this.problemSupport = problemSupport;
    &#125;

    @PostConstruct
    public void init() &#123;
        try &#123;
            authenticationManagerBuilder
                .userDetailsService(userDetailsService)
                .passwordEncoder(passwordEncoder());
        &#125; catch (Exception e) &#123;
            throw new BeanInitializationException(&quot;Security configuration failed&quot;, e);
        &#125;
    &#125;

   @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
            .antMatchers(&quot;/api/register&quot;).permitAll()
            .antMatchers(&quot;/api/activate&quot;).permitAll()
            .antMatchers(&quot;/api/authenticate&quot;).permitAll()
            .antMatchers(&quot;/api/account/reset-password/init&quot;).permitAll()
            .antMatchers(&quot;/api/account/reset-password/finish&quot;).permitAll()
            .antMatchers(&quot;/api/profile-info&quot;).permitAll()
            .antMatchers(&quot;/api/**&quot;).authenticated()
            .antMatchers(&quot;/management/health&quot;).permitAll()
            .antMatchers(&quot;/management/**&quot;).hasAuthority(AuthoritiesConstants.ADMIN)
            .antMatchers(&quot;/v2/api-docs/**&quot;).permitAll()
            .antMatchers(&quot;/swagger-resources/configuration/ui&quot;).permitAll()
            .antMatchers(&quot;/swagger-ui/index.html&quot;).hasAuthority(AuthoritiesConstants.ADMIN)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;
&#125;
</code></pre>
<h2 id="授权与访问控制"><a href="#授权与访问控制" class="headerlink" title="授权与访问控制"></a>授权与访问控制</h2><p>一旦认证成功，我们可以继续进行授权，授权是通过<code>AccessDecisionManager</code>来实现的。框架有三种实现，默认是AffirmativeBased，通过<code>AccessDecisionVoter</code>决策，有点像<code>ProviderManager</code>委托给<code>AuthenticationProviders</code>来认证。</p>
<pre><code>public void decide(Authentication authentication, Object object,        Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException &#123;    int deny = 0;
        // 遍历DecisionVoter     for (AccessDecisionVoter voter : getDecisionVoters()) &#123;        // 投票        int result = voter.vote(authentication, object, configAttributes);
        if (logger.isDebugEnabled()) &#123;            logger.debug(&quot;Voter: &quot; + voter + &quot;, returned: &quot; + result);        &#125;
        switch (result) &#123;        case AccessDecisionVoter.ACCESS_GRANTED:            return;
        case AccessDecisionVoter.ACCESS_DENIED:            deny++;
            break;
        default:            break;        &#125;    &#125;
           // 一票否决    if (deny &gt; 0) &#123;        throw new AccessDeniedException(messages.getMessage(                &quot;AbstractAccessDecisionManager.accessDenied&quot;, &quot;Access is denied&quot;));    &#125;
    // To get this far, every AccessDecisionVoter abstained    checkAllowIfAllAbstainDecisions();&#125;
</code></pre>
<p>来看AccessDecisionVoter：</p>
<pre><code>boolean supports(ConfigAttribute attribute);

boolean supports(Class&lt;?&gt; clazz);

int vote(Authentication authentication, S object,
        Collection&lt;ConfigAttribute&gt; attributes);
</code></pre>
<p>object是用户要访问的资源，ConfigAttribute则是访问object要满足的条件，通常payload是字符串，比如ROLE_ADMIN 。所以我们来看下RoleVoter的实现，其核心就是从authentication提取出GrantedAuthority，然后和ConfigAttribute比较是否满足条件。</p>
<pre><code>public boolean supports(ConfigAttribute attribute) &#123;    if ((attribute.getAttribute() != null)            &amp;&amp; attribute.getAttribute().startsWith(getRolePrefix())) &#123;        return true;    &#125;    else &#123;        return false;    &#125;&#125;
public boolean supports(Class&lt;?&gt; clazz) &#123;    return true;&#125;


public int vote(Authentication authentication, Object object,        Collection&lt;ConfigAttribute&gt; attributes) &#123;    if(authentication == null) &#123;        return ACCESS_DENIED;    &#125;    int result = ACCESS_ABSTAIN;        // 获取GrantedAuthority信息    Collection&lt;? extends GrantedAuthority&gt; authorities = extractAuthorities(authentication);
    for (ConfigAttribute attribute : attributes) &#123;        if (this.supports(attribute)) &#123;            // 默认拒绝访问            result = ACCESS_DENIED;
            // Attempt to find a matching granted authority            for (GrantedAuthority authority : authorities) &#123;                 // 判断是否有匹配的 authority                if (attribute.getAttribute().equals(authority.getAuthority())) &#123;                    // 可访问                    return ACCESS_GRANTED;                &#125;            &#125;        &#125;    &#125;
    return result;&#125;
</code></pre>
<p>这里要疑问，ConfigAttribute哪来的？其实就是上面ApplicationSecurity的configure里的。</p>
<h3 id="web-security-如何实现"><a href="#web-security-如何实现" class="headerlink" title="web security 如何实现"></a>web security 如何实现</h3><p>Web层中的Spring Security（用于UI和HTTP后端）基于Servlet <code>Filters</code>，下图显示了单个HTTP请求的处理程序的典型分层。</p>
<p><img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/filters.png" alt="过滤链委托给一个Servlet"></p>
<p>Spring Security通过<code>FilterChainProxy</code>作为单一的Filter注册到web层，Proxy内部的Filter。</p>
<p><img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/security-filters.png" alt="Spring安全筛选器"></p>
<p>FilterChainProxy相当于一个filter的容器，通过VirtualFilterChain来依次调用各个内部filter</p>
<pre><code>public void doFilter(ServletRequest request, ServletResponse response,        FilterChain chain) throws IOException, ServletException &#123;    boolean clearContext = request.getAttribute(FILTER_APPLIED) == null;    if (clearContext) &#123;        try &#123;            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);            doFilterInternal(request, response, chain);        &#125;        finally &#123;            SecurityContextHolder.clearContext();            request.removeAttribute(FILTER_APPLIED);        &#125;    &#125;    else &#123;        doFilterInternal(request, response, chain);    &#125;&#125;
private void doFilterInternal(ServletRequest request, ServletResponse response,        FilterChain chain) throws IOException, ServletException &#123;
    FirewalledRequest fwRequest = firewall            .getFirewalledRequest((HttpServletRequest) request);    HttpServletResponse fwResponse = firewall            .getFirewalledResponse((HttpServletResponse) response);
    List&lt;Filter&gt; filters = getFilters(fwRequest);
    if (filters == null || filters.size() == 0) &#123;        if (logger.isDebugEnabled()) &#123;            logger.debug(UrlUtils.buildRequestUrl(fwRequest)                    + (filters == null ? &quot; has no matching filters&quot;                            : &quot; has an empty filter list&quot;));        &#125;
        fwRequest.reset();
        chain.doFilter(fwRequest, fwResponse);
        return;    &#125;
    VirtualFilterChain vfc = new VirtualFilterChain(fwRequest, chain, filters);    vfc.doFilter(fwRequest, fwResponse);&#125;private static class VirtualFilterChain implements FilterChain &#123;    private final FilterChain originalChain;    private final List&lt;Filter&gt; additionalFilters;    private final FirewalledRequest firewalledRequest;    private final int size;    private int currentPosition = 0;
    private VirtualFilterChain(FirewalledRequest firewalledRequest,            FilterChain chain, List&lt;Filter&gt; additionalFilters) &#123;        this.originalChain = chain;        this.additionalFilters = additionalFilters;        this.size = additionalFilters.size();        this.firewalledRequest = firewalledRequest;    &#125;
    public void doFilter(ServletRequest request, ServletResponse response)            throws IOException, ServletException &#123;        if (currentPosition == size) &#123;            if (logger.isDebugEnabled()) &#123;                logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)                        + &quot; reached end of additional filter chain; proceeding with original chain&quot;);            &#125;
            // Deactivate path stripping as we exit the security filter chain            this.firewalledRequest.reset();
            originalChain.doFilter(request, response);        &#125;        else &#123;            currentPosition++;
            Filter nextFilter = additionalFilters.get(currentPosition - 1);
            if (logger.isDebugEnabled()) &#123;                logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)                        + &quot; at position &quot; + currentPosition + &quot; of &quot; + size                        + &quot; in additional filter chain; firing Filter: &#39;&quot;                        + nextFilter.getClass().getSimpleName() + &quot;&#39;&quot;);            &#125;
            nextFilter.doFilter(request, response, this);        &#125;    &#125;&#125;
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/topicals/spring-security-architecture/">https://spring.io/guides/topicals/spring-security-architecture/</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.0.5.RELEASE/reference/htmlsingle/#overall-architecture">https://docs.spring.io/spring-security/site/docs/5.0.5.RELEASE/reference/htmlsingle/#overall-architecture</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/05/28/jqpeng-%E5%BC%80%E6%BA%90APM%E7%B3%BB%E7%BB%9Fskywalking%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/05/28/jqpeng-%E5%BC%80%E6%BA%90APM%E7%B3%BB%E7%BB%9Fskywalking%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">开源APM系统skywalking介绍与使用</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-28 11:25:00" itemprop="dateCreated datePublished" datetime="2018-05-28T11:25:00+08:00">2018-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/skywalking-usage.html">开源APM系统skywalking介绍与使用</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>SkyWalking</strong> 创建与2015年，提供分布式追踪功能。从5.x开始，项目进化为一个完成功能的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application_performance_management">Application Performance Management</a>系统。<br> 他被用于追踪、监控和诊断分布式系统，特别是使用微服务架构，云原生或容积技术。提供以下主要功能：</p>
<ul>
<li>分布式追踪和上下文传输</li>
<li>应用、实例、服务性能指标分析</li>
<li>根源分析</li>
<li>应用拓扑分析</li>
<li>应用和服务依赖分析</li>
<li>慢服务检测</li>
<li>性能优化</li>
</ul>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul>
<li>多语言探针或类库<ul>
<li>Java自动探针，追踪和监控程序时，不需要修改源码。</li>
<li>社区提供的其他多语言探针<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenSkywalking/skywalking-netcore">.NET Core</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenSkywalking/skywalking-nodejs">Node.js</a></li>
</ul>
</li>
</ul>
</li>
<li>多种后端存储： ElasticSearch， H2</li>
<li>支持<a target="_blank" rel="noopener" href="http://opentracing.io/">OpenTracing</a><ul>
<li>Java自动探针支持和OpenTracing API协同工作</li>
</ul>
</li>
<li>轻量级、完善功能的后端聚合和分析</li>
<li>现代化Web UI</li>
<li>日志集成</li>
<li>应用、实例和服务的告警</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://skywalkingtest.github.io/page-resources/5.0/architecture.png"></p>
<h3 id="在线体验"><a href="#在线体验" class="headerlink" title="在线体验"></a>在线体验</h3><ul>
<li>北京服务器. <a target="_blank" rel="noopener" href="http://49.4.12.44:8080/">前往</a></li>
<li>香港服务器. <a target="_blank" rel="noopener" href="http://159.138.0.181:8080/">前往</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装es"><a href="#安装es" class="headerlink" title="安装es"></a>安装es</h3><p>新版本的skywalking使用ES作为存储，所以先安装es，注意6.X版本不行，安装5.6.8：</p>
<pre><code>wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.8.tar.gz
tar zxvf elasticsearch-5.6.8.tar.gz
cd elasticsearch-5.6.8/
</code></pre>
<p>修改配置文件，主要修改cluster.name，并增加两行配置，<br> vim config/elasticsearch.yml：</p>
<pre><code>cluster.name: CollectorDBCluster

# ES监听的ip地址
network.host: 0.0.0.0
thread_pool.bulk.queue_size: 1000
</code></pre>
<p>保存，然后启动es：</p>
<pre><code>nohup bin/elasticsearch &amp;
</code></pre>
<h3 id="安装skywalking"><a href="#安装skywalking" class="headerlink" title="安装skywalking"></a>安装skywalking</h3><p>先下载编译好的版本并解压：</p>
<pre><code>wget http://mirrors.hust.edu.cn/apache/incubator/skywalking/5.0.0-beta/apache-skywalking-apm-incubating-5.0.0-beta.tar.gz
tar zxvf apache-skywalking-apm-incubating-5.0.0-beta.tar.gz 
cd apache-skywalking-apm-incubating/
</code></pre>
<p>然后部署，注意skywalking会使用(8080, 10800, 11800, 12800)端口，因此先排除端口占用情况。</p>
<p>然后运行bin/startup.sh，windows用户为.bat文件。</p>
<p>一切正常的话，访问localhost:8080就能看到页面了。</p>
<h4 id="安装过程问题解决"><a href="#安装过程问题解决" class="headerlink" title="安装过程问题解决"></a>安装过程问题解决</h4><ol>
<li>启动bin/startup.sh后，提示success，但是不能访问，ps 查看并无相关进程，经过检查发现是端口被占用</li>
<li>collector 不能正常启动，发现是es问题：<ul>
<li>es需要使用5.x版本</li>
<li>es的集群名称需要和collector的配置文件一致</li>
</ul>
</li>
</ol>
<h3 id="java程序使用skywalking探针"><a href="#java程序使用skywalking探针" class="headerlink" title="java程序使用skywalking探针"></a>java程序使用skywalking探针</h3><p>1.拷贝apache-skywalking-apm-incubating目录下的agent目录到应用程序位置，探针包含整个目录，请不要改变目录结构<br> 2.java程序启动时，增加JVM启动参数，-javaagent:/path/to/agent/skywalking-agent.jar。参数值为skywalking-agent.jar的绝对路径</p>
<p>在IDEA里调试程序怎么办？</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1527477582714.jpg" alt="enter description here" title="IDEA 配置"></p>
<p>增加VM参数即可。</p>
<p>agent探针配置，简单修改下agent.application_code即可</p>
<pre><code># 当前的应用编码，最终会显示在webui上。
# 建议一个应用的多个实例，使用有相同的application_code。请使用英文
agent.application_code=Your_ApplicationName

# 每三秒采样的Trace数量
# 默认为负数，代表在保证不超过内存Buffer区的前提下，采集所有的Trace
# agent.sample_n_per_3_secs=-1

# 设置需要忽略的请求地址
# 默认配置如下
# agent.ignore_suffix=.jpg,.jpeg,.js,.css,.png,.bmp,.gif,.ico,.mp3,.mp4,.html,.svg

# 探针调试开关，如果设置为true，探针会将所有操作字节码的类输出到/debugging目录下
# skywalking团队可能在调试，需要此文件
# agent.is_open_debugging_class = true

# 对应Collector的config/application.yml配置文件中 agent_server/jetty/port 配置内容
# 例如：
# 单节点配置：SERVERS=&quot;127.0.0.1:8080&quot; 
# 集群配置：SERVERS=&quot;10.2.45.126:8080,10.2.45.127:7600&quot; 
collector.servers=127.0.0.1:10800

# 日志文件名称前缀
logging.file_name=skywalking-agent.log

# 日志文件最大大小
# 如果超过此大小，则会生成新文件。
# 默认为300M
logging.max_file_size=314572800

# 日志级别，默认为DEBUG。
logging.level=DEBUG
</code></pre>
<p>一切正常的话，稍后就可以在skywalking ui看到了。</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1527477724637.jpg" alt="enter description here" title="SW UI"></p>
<p>可以看到累出了slow service等信息，更多的细节慢慢挖掘吧。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/05/04/jqpeng-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/05/04/jqpeng-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">知识图谱学习笔记（1）</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-04 17:25:00" itemprop="dateCreated datePublished" datetime="2018-05-04T17:25:00+08:00">2018-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/kg-study-part-1.html">知识图谱学习笔记（1）</a></p>
<p>知识图谱学习笔记第一部分，包含RDF介绍，以及Jena RDF API使用</p>
<h2 id="知识图谱的基石：RDF"><a href="#知识图谱的基石：RDF" class="headerlink" title="知识图谱的基石：RDF"></a>知识图谱的基石：RDF</h2><p>RDF(Resource Description Framework)，即资源描述框架，其本质是一个数据模型（Data Model）。它提供了一个统一的标准，用于描述实体/资源。简单来说，就是表示事物的一种方法和手段。<br><img src="https://pic2.zhimg.com/80/v2-e3478e02c36ead3875e598b0668830fd_hd.jpg" alt="enter description here"></p>
<h3 id="RDF序列化方法"><a href="#RDF序列化方法" class="headerlink" title="RDF序列化方法"></a>RDF序列化方法</h3><p>RDF序列化的方式主要有：RDF/XML，N-Triples，Turtle，RDFa，JSON-LD等几种。</p>
<ol>
<li>RDF/XML，顾名思义，就是用XML的格式来表示RDF数据</li>
<li>N-Triples，即用多个三元组来表示RDF数据集，是最直观的表示方法。在文件中，每一行表示一个三元组，方便机器解析和处理。开放领域知识图谱DBpedia通常是用这种格式来发布数据的。</li>
<li>Turtle, [‘tɝtl] 应该是使用得最多的一种RDF序列化方式了。它比RDF/XML紧凑，且可读性比N-Triples好。</li>
<li>RDFa,即“The Resource Description Framework in Attributes”，是HTML5的一个扩展，在不改变任何显示效果的情况下，让网站构建者能够在页面中标记实体，像人物、地点、时间、评论等等</li>
<li>JSON-LD，即“JSON for Linking Data”，用键值对的方式来存储RDF数据</li>
</ol>
<p>Example1 N-Triples:</p>
<pre><code>&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/chineseName&gt; &quot;罗纳尔多·路易斯·纳萨里奥·德·利马&quot;^^string.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/career&gt; &quot;足球运动员&quot;^^string.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/fullName&gt; &quot;Ronaldo Luís Nazário de Lima&quot;^^string.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/birthDate&gt; &quot;1976-09-18&quot;^^date.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/height&gt; &quot;180&quot;^^int.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/weight&gt; &quot;98&quot;^^int.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/nationality&gt; &quot;巴西&quot;^^string.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/hasBirthPlace&gt; &lt;http://www.kg.com/place/10086&gt;.
&lt;http://www.kg.com/place/10086&gt; &lt;http://www.kg.com/ontology/address&gt; &quot;里约热内卢&quot;^^string.
&lt;http://www.kg.com/place/10086&gt; &lt;http://www.kg.com/ontology/coordinate&gt; &quot;-22.908333, -43.196389&quot;^^string.
</code></pre>
<p>Example2 Turtle:</p>
<pre><code>@prefix person: &lt;http://www.kg.com/person/&gt; .
@prefix place: &lt;http://www.kg.com/place/&gt; .
@prefix : &lt;http://www.kg.com/ontology/&gt; .

person:1 :chineseName &quot;罗纳尔多·路易斯·纳萨里奥·德·利马&quot;^^string.
person:1 :career &quot;足球运动员&quot;^^string.
person:1 :fullName &quot;Ronaldo Luís Nazário de Lima&quot;^^string.
person:1 :birthDate &quot;1976-09-18&quot;^^date.
person:1 :height &quot;180&quot;^^int. 
person:1 :weight &quot;98&quot;^^int.
person:1 :nationality &quot;巴西&quot;^^string. 
person:1 :hasBirthPlace place:10086.
place:10086 :address &quot;里约热内卢&quot;^^string.
place:10086 :coordinate &quot;-22.908333, -43.196389&quot;^^string.
</code></pre>
<h3 id="RDF的表达能力"><a href="#RDF的表达能力" class="headerlink" title="RDF的表达能力"></a>RDF的表达能力</h3><p>RDF的表达能力有限，无法区分类和对象，也无法定义和描述类的关系/属性。RDF是对具体事物的描述，缺乏抽象能力，无法对同一个类别的事物进行定义和描述。就以罗纳尔多这个知识图为例，RDF能够表达罗纳尔多和里约热内卢这两个实体具有哪些属性，以及它们之间的关系。但如果我们想定义罗纳尔多是人，里约热内卢是地点，并且人具有哪些属性，地点具有哪些属性，人和地点之间存在哪些关系，这个时候RDF就表示无能为力了。</p>
<h2 id="RDFS-OWL"><a href="#RDFS-OWL" class="headerlink" title="RDFS/OWL"></a>RDFS/OWL</h2><p>RDFS/OWL本质上是一些预定义词汇（vocabulary）构成的集合，用于对RDF进行类似的类定义及其属性的定义。</p>
<blockquote>
<p>RDFS/OWL序列化方式和RDF没什么不同，其实在表现形式上，它们就是RDF。其常用的方式主要是RDF/XML，Turtle。另外，通常我们用小写开头的单词或词组来表示属性，大写开头的表示类。数据属性（data property，实体和literal字面量的关系）通常由名词组成，而对象数据（object property，实体和实体之间的关系）通常由动词（has，is之类的）加名词组成。剩下的部分符合驼峰命名法。</p>
</blockquote>
<h3 id="轻量级的模式语言——RDFS"><a href="#轻量级的模式语言——RDFS" class="headerlink" title="轻量级的模式语言——RDFS"></a>轻量级的模式语言——RDFS</h3><p>RDFS，即“Resource Description Framework Schema”，是最基础的模式语言。还是以罗纳尔多知识图为例，我们在概念、抽象层面对RDF数据进行定义。下面的RDFS定义了人和地点这两个类，及每个类包含的属性。</p>
<pre><code>@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix : &lt;http://www.kg.com/ontology/&gt; .

### 这里我们用词汇rdfs:Class定义了“人”和“地点”这两个类。
:Person rdf:type rdfs:Class.
:Place rdf:type rdfs:Class.

### rdfs当中不区分数据属性和对象属性，词汇rdf:Property定义了属性，即RDF的“边”。

:chineseName rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:string .

:career rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:string .

:fullName rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:string .

:birthDate rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:date .

:height rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:int .

:weight rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:int .

:nationality rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:string .

:hasBirthPlace rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range :Place .

:address rdf:type rdf:Property;    rdfs:domain :Place;    rdfs:range xsd:string .

:coordinate rdf:type rdf:Property;    rdfs:domain :Place;    rdfs:range xsd:string .
</code></pre>
<p>RDFS几个比较重要，常用的词汇：</p>
<ol>
<li>rdfs:Class. 用于定义类</li>
<li>rdfs:domain. 用于表示该属性属于哪个类别</li>
<li>rdfs:range. 用于描述该属性的取值类型</li>
<li>rdfs:subClassOf. 用于描述该类的父类</li>
<li>rdfs:subProperty. 用于描述该属性的父属性</li>
</ol>
<p><img src="https://pic3.zhimg.com/v2-9950314f9ab6e6c44a2300d03e022bb1_r.jpg" alt="enter description here"></p>
<p>Data层是我们用RDF对罗纳尔多知识图的具体描述，Vocabulary是我们自己定义的一些词汇（类别，属性），RDF(S)则是预定义词汇。从下到上是一个具体到抽象的过程。图中我们用红色圆角矩形表示类，绿色字体表示rdf:type，rdfs:domain，rdfs:range三种预定义词汇，虚线表示rdf:type这种所属关系。</p>
<h3 id="RDFS的扩展——OWL"><a href="#RDFS的扩展——OWL" class="headerlink" title="RDFS的扩展——OWL"></a>RDFS的扩展——OWL</h3><p>RDFS本质上是RDF词汇的一个扩展。后来人们发现RDFS的表达能力还是相当有限，因此提出了OWL。我们也可以把OWL当做是RDFS的一个扩展，其添加了额外的预定义词汇。</p>
<p>OWL，即“Web Ontology Language”，语义网技术栈的核心之一。OWL有两个主要的功能：</p>
<ol>
<li>提供快速、灵活的数据建模能力。</li>
<li>高效的自动推理。</li>
</ol>
<p>用OWL对罗纳尔多知识图进行语义层的描述：</p>
<pre><code>@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix : &lt;http://www.kg.com/ontology/&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .

### 这里我们用词汇owl:Class定义了“人”和“地点”这两个类。
:Person rdf:type owl:Class.
:Place rdf:type owl:Class.

### owl区分数据属性和对象属性（对象属性表示实体和实体之间的关系）。词汇owl:DatatypeProperty定义了数据属性，owl:ObjectProperty定义了对象属性。
:chineseName rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:string .

:career rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:string .

:fullName rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:string .

:birthDate rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:date .

:height rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:int .

:weight rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:int .

:nationality rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:string .

:hasBirthPlace rdf:type owl:ObjectProperty;    rdfs:domain :Person;    rdfs:range :Place .

:address rdf:type owl:DatatypeProperty;    rdfs:domain :Place;    rdfs:range xsd:string .

:coordinate rdf:type owl:DatatypeProperty;    rdfs:domain :Place;    rdfs:range xsd:string .
</code></pre>
<p>schema层的描述语言换为OWL后，层次图表示为：<br><img src="https://pic2.zhimg.com/v2-ef0de6ba9620d27ca0f2d2f4b0f18f53_r.jpg" alt="enter description here"></p>
<p>owl区分数据属性和对象属性（对象属性表示实体和实体之间的关系）。词汇owl:DatatypeProperty定义了数据属性，owl:ObjectProperty定义了对象属性。</p>
<p>上图中，数据属性用青色表示，对象属性由蓝色表示。</p>
<p>描述属性特征的词汇</p>
<ol>
<li>owl:TransitiveProperty. 表示该属性具有传递性质。例如，我们定义“位于”是具有传递性的属性，若A位于B，B位于C，那么A肯定位于C。</li>
<li>owl:SymmetricProperty. 表示该属性具有对称性。例如，我们定义“认识”是具有对称性的属性，若A认识B，那么B肯定认识A。</li>
<li>owl:FunctionalProperty. 表示该属性取值的唯一性。 例如，我们定义“母亲”是具有唯一性的属性，若A的母亲是B，在其他地方我们得知A的母亲是C，那么B和C指的是同一个人。</li>
<li>owl:inverseOf. 定义某个属性的相反关系。例如，定义“父母”的相反关系是“子女”，若A是B的父母，那么B肯定是A的子女。</li>
</ol>
<p>本体映射词汇（Ontology Mapping）</p>
<ol>
<li>owl:equivalentClass. 表示某个类和另一个类是相同的。</li>
<li>owl:equivalentProperty. 表示某个属性和另一个属性是相同的。</li>
<li>owl:sameAs. 表示两个实体是同一个实体。</li>
</ol>
<h3 id="RDFS-OWL推理的推理机（reasoner）"><a href="#RDFS-OWL推理的推理机（reasoner）" class="headerlink" title="RDFS,OWL推理的推理机（reasoner）"></a>RDFS,OWL推理的推理机（reasoner）</h3><p>RDFS同样支持推理，由于缺乏丰富的表达能力，推理能力也不强。举个例子，我们用RDFS定义人和动物两个类，另外，定义人是动物的一个子类。此时推理机能够推断出一个实体若是人，那么它也是动物。OWL当然支持这种基本的推理，除此之外，凭借其强大的表达能力，我们能进行更有实际意义的推理。想象一个场景，我们有一个庞大数据库存储人物的亲属关系。里面很多关系都是单向的，比如，其只保存了A的父亲（母亲）是B，但B的子女字段里面没有A，可以推理得到B的子女A。</p>
<p>。<img src="https://pic4.zhimg.com/80/v2-b27db971f3fa1cefc83a47be5234dc18_hd.jpg" alt="enter description here"></p>
<h2 id="RDF查询语言SPARQL"><a href="#RDF查询语言SPARQL" class="headerlink" title="RDF查询语言SPARQL"></a>RDF查询语言SPARQL</h2><p>SPARQL即SPARQL Protocol and RDF Query Language的递归缩写，专门用于访问和操作RDF数据，是语义网的核心技术之一。W3C的RDF数据存取小组（RDF Data Access Working Group, RDAWG）对其进行了标准化。在2008年，SPARQL 1.0成为W3C官方所推荐的标准。2013年发布了SPARQL 1.1。相对第一个版本，其支持RDF图的更新，提供更强大的查询，比如：子查询、聚合操作（像我们常用的count）等等。</p>
<p>由两个部分组成：协议和查询语言。</p>
<ol>
<li>查询语言很好理解，就像SQL用于查询关系数据库中的数据，XQuery用于查询XML数据，SPARQL用于查询RDF数据。</li>
<li>协议是指我们可以通过HTTP协议在客户端和SPARQL服务器（SPARQL endpoint）之间传输查询和结果，这也是和其他查询语言最大的区别。</li>
</ol>
<p>一个SPARQL查询本质上是一个带有变量的RDF图，以我们之前提到的罗纳尔多RDF数据为例：</p>
<pre><code>&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/chineseName&gt; &quot;罗纳尔多·路易斯·纳萨里奥·德·利马&quot;^^string.
</code></pre>
<p>查询SPARQL</p>
<pre><code>&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/chineseName&gt; ?x.
</code></pre>
<p>SPARQL查询是基于图匹配的思想。我们把上述的查询与RDF图进行匹配，找到符合该匹配模式的所有子图，最后得到变量的值。就上面这个例子而言，在RDF图中找到匹配的子图后，将”罗纳尔多·路易斯·纳萨里奥·德·利马”和“?x”绑定，我们就得到最后的结果。简而言之，SPARQL查询分为三个步骤：</p>
<ol>
<li>构建查询图模式，表现形式就是带有变量的RDF。</li>
<li>匹配，匹配到符合指定图模式的子图。</li>
<li>绑定，将结果绑定到查询图模式对应的变量上。</li>
</ol>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>如何查询所有数据</strong></p>
<pre><code>PREFIX : &lt;http://www.kgdemo.com#&gt;
PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX owl: &lt;http://www.w3.org/2002/07/owl#&gt;
PREFIX xsd: &lt;XML Schema&gt;
PREFIX vocab: &lt;http://localhost:2020/resource/vocab/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX map: &lt;http://localhost:2020/resource/#&gt;
PREFIX db: &lt;http://localhost:2020/resource/&gt;

SELECT * WHERE &#123;
  ?s ?p ?o
&#125;
</code></pre>
<p>SPARQL的部分关键词：</p>
<ol>
<li>SELECT， 指定我们要查询的变量。在这里我们查询所有的变量，用*代替。</li>
<li>WHERE，指定我们要查询的图模式。含义上和SQL的WHERE没有区别。</li>
<li>FROM，指定查询的RDF数据集。我们这里只有一个图，因此省去了FROM关键词。 PREFIX，用于IRI的缩写。</li>
</ol>
<p>“周星驰出演了哪些电影”：</p>
<pre><code>PREFIX : &lt;http://www.kgdemo.com#&gt;
PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX owl: &lt;http://www.w3.org/2002/07/owl#&gt;
PREFIX xsd: &lt;XML Schema&gt;
PREFIX vocab: &lt;http://localhost:2020/resource/vocab/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX map: &lt;http://localhost:2020/resource/#&gt;
PREFIX db: &lt;http://localhost:2020/resource/&gt;

SELECT ?n WHERE &#123;
  ?s rdf:type :Person.
  ?s :personName &#39;周星驰&#39;.
  ?s :hasActedIn ?o.
  ?o :movieTitle ?n
&#125;
</code></pre>
<h2 id="使用Jena-构建知识图谱"><a href="#使用Jena-构建知识图谱" class="headerlink" title="使用Jena 构建知识图谱"></a>使用Jena 构建知识图谱</h2><p>Jena是Apache基金会旗下的开源Java框架，用于构建Semantic Web 和 Linked Data 应用。</p>
<p>下面简要的介绍下API，要使用jena，可以下载jar包或者使用maven（推荐），建议测试时下面的都加上：</p>
<pre><code>    &lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;apache-jena-libs&lt;/artifactId&gt;    &lt;type&gt;pom&lt;/type&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;jena-sdb&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;jena-base&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;jena-fuseki-embedded&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt; &lt;!-- Set the version --&gt;&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.apache.jena/jena-arq --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;jena-arq&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;
</code></pre>
<h3 id="Jena-RDF-API"><a href="#Jena-RDF-API" class="headerlink" title="Jena RDF API"></a>Jena RDF API</h3><p>首先，三元组（triple）组成的图称之为Model，这个图里的Node可以是resources(实体）、literals（文本）或者blank nodes。</p>
<p>一个三元组，在jena里称之为Statement，一个 statement 包含三部分：:</p>
<ul>
<li>the subject ：实体</li>
<li>the predicate ：属性</li>
<li>the object ： 值</li>
</ul>
<h4 id="创建Model"><a href="#创建Model" class="headerlink" title="创建Model"></a>创建Model</h4><pre><code>// URI 定义
static String personURI    = &quot;http://somewhere/JohnSmith&quot;;
static String fullName     = &quot;John Smith&quot;;

// 创建一个空模型（KG)
Model model = ModelFactory.createDefaultModel();

// 创建一个resource（一个subject)
Resource johnSmith = model.createResource(personURI);

// 添加属性，这里的value是一个literals（文本）
 johnSmith.addProperty(VCARD.FN, fullName);
</code></pre>
<p>当然，你还可以使用链式API,为resource添加多个Property</p>
<pre><code>// create the resource
//   and add the properties cascading style
Resource johnSmith
  = model.createResource(personURI)     .addProperty(VCARD.FN, fullName)     .addProperty(VCARD.N,                  model.createResource()                       .addProperty(VCARD.Given, givenName)                       .addProperty(VCARD.Family, familyName));
</code></pre>
<h4 id="遍历Model"><a href="#遍历Model" class="headerlink" title="遍历Model"></a>遍历Model</h4><p>使用model.listStatements遍历statements，返回一个迭代器，使用hasNext判断是否还有数据，通过getSubject，getPredicate，getObject 获取三元组信息。</p>
<pre><code>// list the statements in the Model
StmtIterator iter = model.listStatements();

// print out the predicate, subject and object of each statement
while (iter.hasNext()) &#123;
    Statement stmt      = iter.nextStatement();  // get next statement
    Resource  subject   = stmt.getSubject();     // get the subject
    Property  predicate = stmt.getPredicate();   // get the predicate
    RDFNode   object    = stmt.getObject();      // get the object
    System.out.print(subject.toString());
    System.out.print(&quot; &quot; + predicate.toString() + &quot; &quot;);
    if (object instanceof Resource) &#123;
       System.out.print(object.toString());
    &#125; else &#123;
        // object is a literal
        System.out.print(&quot; \&quot;&quot; + object.toString() + &quot;\&quot;&quot;);
    &#125;
    System.out.println(&quot; .&quot;);
&#125; 
</code></pre>
<p>运行结果：</p>
<pre><code>http://somewhere/JohnSmith http://www.w3.org/2001/vcard-rdf/3.0#N 80aeb72e-ef9c-4879-807d-62daf3c13b72 .
http://somewhere/JohnSmith http://www.w3.org/2001/vcard-rdf/3.0#FN  &quot;John Smith&quot; .
80aeb72e-ef9c-4879-807d-62daf3c13b72 http://www.w3.org/2001/vcard-rdf/3.0#Family  &quot;Smith&quot; .
80aeb72e-ef9c-4879-807d-62daf3c13b72 http://www.w3.org/2001/vcard-rdf/3.0#Given  &quot;John&quot; .
</code></pre>
<h4 id="保存为-RDF文件"><a href="#保存为-RDF文件" class="headerlink" title="保存为 RDF文件"></a>保存为 RDF文件</h4><p>可以使用model.write方便的把Model保存为rdf文件，write默认保存为XML格式</p>
<pre><code>// now write the model in XML form to a file
model.write(System.out);



&lt;rdf:RDF
  xmlns:rdf=&#39;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#39;
  xmlns:vcard=&#39;http://www.w3.org/2001/vcard-rdf/3.0#&#39;
 &gt;
  &lt;rdf:Description rdf:about=&#39;http://somewhere/JohnSmith&#39;&gt;
    &lt;vcard:FN&gt;John Smith&lt;/vcard:FN&gt;
    &lt;vcard:N rdf:nodeID=&quot;A0&quot;/&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description rdf:nodeID=&quot;A0&quot;&gt;
    &lt;vcard:Given&gt;John&lt;/vcard:Given&gt;
    &lt;vcard:Family&gt;Smith&lt;/vcard:Family&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</code></pre>
<p>write还提供重载版本write( OutputStream out, String lang )，lang可以为”RDF/XML-ABBREV”, “N-TRIPLE”, “TURTLE”, (and “TTL”) and “N3”<br> 我们来保存为常见的TURTLE：</p>
<pre><code>model.write(System.out, &quot;TURTLE&quot;);
</code></pre>
<p>结果：</p>
<pre><code>&lt;http://somewhere/JohnSmith&gt;    &lt;http://www.w3.org/2001/vcard-rdf/3.0#FN&gt;            &quot;John Smith&quot; ;    &lt;http://www.w3.org/2001/vcard-rdf/3.0#N&gt;            [ &lt;http://www.w3.org/2001/vcard-rdf/3.0#Family&gt;                      &quot;Smith&quot; ;              &lt;http://www.w3.org/2001/vcard-rdf/3.0#Given&gt;                      &quot;John&quot;            ] .
</code></pre>
<p>jena还提供prefix功能，我们可以指定prefix来简化turtle,下面的代码将指定prefix，并保存到文件1.rdf里：</p>
<pre><code>    model.setNsPrefix( &quot;vCard&quot;, &quot;http://www.w3.org/2001/vcard-rdf/3.0#&quot; );    model.setNsPrefix( &quot;rdf&quot;, &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot; );    try &#123;        model.write(new FileOutputStream(&quot;1.rdf&quot;),&quot;TURTLE&quot;);    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;
</code></pre>
<p>结果：</p>
<pre><code>@prefix rdf:   &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix vCard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

&lt;http://somewhere/JohnSmith&gt;    vCard:FN  &quot;John Smith&quot; ;    vCard:N   [ vCard:Family  &quot;Smith&quot; ;                vCard:Given   &quot;John&quot;              ] .
</code></pre>
<h4 id="读取rdf"><a href="#读取rdf" class="headerlink" title="读取rdf"></a>读取rdf</h4><p>Mode的read(Reader reader, String base)方法，提供 读取RDF文件的功能：</p>
<pre><code>    static final String inputFileName  = &quot;1.rdf&quot;;
                              
    public static void main (String args[]) &#123;
        // create an empty model
        Model model = ModelFactory.createDefaultModel();

        InputStream in = FileManager.get().open( inputFileName );
        if (in == null) &#123;
            throw new IllegalArgumentException( &quot;File: &quot; + inputFileName + &quot; not found&quot;);
        &#125;
        
        // read the RDF/XML file
        model.read(in, &quot;&quot;,&quot;TURTLE&quot;);
                    
        // write it to standard out
        model.write(System.out);            
    &#125;
</code></pre>
<p>注意，read的时候，默认是读取XML，如果是其他格式，需要指定lang。</p>
<h4 id="从模型读取Resouce"><a href="#从模型读取Resouce" class="headerlink" title="从模型读取Resouce"></a>从模型读取Resouce</h4><p>一个resouce都有一个唯一的URI，我们可以通过URI来获取对应的Resouce：<br> 函数原型：</p>
<pre><code>    /**    Return a Resource instance with the given URI in this model. &lt;i&gt;This method    behaves identically to &lt;code&gt;createResource(String)&lt;/code&gt;&lt;/i&gt; and exists as    legacy: createResource is now capable of, and allowed to, reuse existing objects.&lt;p&gt;    Subsequent operations on the returned object may modify this model.   @return a resource instance   @param uri the URI of the resource*/Resource getResource(String uri) ;
</code></pre>
<p>获取到Resouce后，通过getRequiredProperty获取属性，如果一个属性包含多个值，可以使用listProperties获取。</p>
<pre><code> static final String inputFileName = &quot;1.rdf&quot;;
    static final String johnSmithURI = &quot;http://somewhere/JohnSmith&quot;;
    
    public static void main (String args[]) &#123;
        // create an empty model
        Model model = ModelFactory.createDefaultModel();
       
        // use the FileManager to find the input file
        InputStream in = FileManager.get().open(inputFileName);
        if (in == null) &#123;
            throw new IllegalArgumentException( &quot;File: &quot; + inputFileName + &quot; not found&quot;);
        &#125;
        
        // read the RDF/XML file
        model.read(new InputStreamReader(in), &quot;&quot;);
        
        // retrieve the Adam Smith vcard resource from the model
        Resource vcard = model.getResource(johnSmithURI);

        // retrieve the value of the N property
        Resource name = (Resource) vcard.getRequiredProperty(VCARD.N)
                                        .getObject();
        // retrieve the given name property
        String fullName = vcard.getRequiredProperty(VCARD.FN)
                               .getString();
        // add two nick name properties to vcard
        vcard.addProperty(VCARD.NICKNAME, &quot;Smithy&quot;)
             .addProperty(VCARD.NICKNAME, &quot;Adman&quot;);
        
        // set up the output
        System.out.println(&quot;The nicknames of \&quot;&quot; + fullName + &quot;\&quot; are:&quot;);
        // list the nicknames
        StmtIterator iter = vcard.listProperties(VCARD.NICKNAME);
        while (iter.hasNext()) &#123;
            System.out.println(&quot;    &quot; + iter.nextStatement().getObject()
                                            .toString());
        &#125;

        try &#123;
            model.write(new FileOutputStream(&quot;1.rdf&quot;));
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h4 id="查询模型"><a href="#查询模型" class="headerlink" title="查询模型"></a>查询模型</h4><p>可以通过listResourcesWithProperty查询包含Property的数据：</p>
<pre><code>    ResIterator iter = model.listResourcesWithProperty(VCARD.FN);
        if (iter.hasNext()) &#123;
            System.out.println(&quot;The database contains vcards for:&quot;);
            while (iter.hasNext()) &#123;
                System.out.println(&quot;  &quot; + iter.nextResource()
                                              .getRequiredProperty(VCARD.FN)
                                              .getString() );
            &#125;
        &#125; else &#123;
            System.out.println(&quot;No vcards were found in the database&quot;);
        &#125;        
</code></pre>
<p>通过listStatements(SimpleSelector)查询Statement：</p>
<pre><code>        // select all the resources with a VCARD.FN property
        // whose value ends with &quot;Smith&quot;
        StmtIterator iter = model.listStatements(
            new 
                SimpleSelector(null, VCARD.FN, (RDFNode) null) &#123;
                    @Override
                    public boolean selects(Statement s) &#123;
                            return s.getString().endsWith(&quot;Smith&quot;);
                    &#125;
                &#125;);
        if (iter.hasNext()) &#123;
            System.out.println(&quot;The database contains vcards for:&quot;);
            while (iter.hasNext()) &#123;
                System.out.println(&quot;  &quot; + iter.nextStatement()
                                              .getString());
            &#125;
        &#125; else &#123;
            System.out.println(&quot;No Smith&#39;s were found in the database&quot;);
        &#125;     
</code></pre>
<h4 id="模型合并"><a href="#模型合并" class="headerlink" title="模型合并"></a>模型合并</h4><p>可以通过union合并两个模型：</p>
<p><img src="https://jena.apache.org/tutorials/figures/fig4.png" alt="enter description here"><br><img src="https://jena.apache.org/tutorials/figures/fig5.png" alt="enter description here"></p>
<p>合并后：<br><img src="http://oyqmmpkcm.bkt.clouddn.com/1524907704194.jpg" alt="enter description here" title="1524907704194"></p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32122644">知识图谱基础之RDF，RDFS与OWL</a></li>
<li></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/jadepeng/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/jadepeng/">1</a><span class="space">&hellip;</span><a class="page-number" href="/jadepeng/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/jadepeng/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/jadepeng/page/10/">10</a><a class="extend next" rel="next" href="/jadepeng/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JadePeng"
      src="/jadepeng/images/avatar.gif">
  <p class="site-author-name" itemprop="name">JadePeng</p>
  <div class="site-description" itemprop="description">JadePeng的技术笔记本</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/jadepeng/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/jadepeng/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/jadepeng/tags/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JadePeng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">642k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/jadepeng/lib/anime.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.ui.min.js"></script>

<script src="/jadepeng/js/utils.js"></script>

<script src="/jadepeng/js/motion.js"></script>


<script src="/jadepeng/js/schemes/muse.js"></script>


<script src="/jadepeng/js/next-boot.js"></script>




  




  
<script src="/jadepeng/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/jadepeng/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
