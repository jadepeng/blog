<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/jadepeng/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/jadepeng/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/jadepeng/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/jadepeng/images/logo.svg" color="#222">

<link rel="stylesheet" href="/jadepeng/css/main.css">


<link rel="stylesheet" href="/jadepeng/lib/font-awesome/css/all.min.css">
<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.iflyresearch.com","root":"/jadepeng/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JadePeng的技术笔记本">
<meta property="og:type" content="website">
<meta property="og:title" content="JadePeng的技术笔记本">
<meta property="og:url" content="http://blog.iflyresearch.com/page/9/index.html">
<meta property="og:site_name" content="JadePeng的技术笔记本">
<meta property="og:description" content="JadePeng的技术笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="JadePeng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.iflyresearch.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JadePeng的技术笔记本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/jadepeng/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JadePeng的技术笔记本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">爱学习爱分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/jadepeng/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-博客">

    <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" rel="section"><i class="fa fa-th fa-fw"></i>博客</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/jadepeng/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/jadepeng/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/jadepeng/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/11/21/jqpeng-%E4%BB%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E3%80%81BK%E6%A0%91%E5%88%B0%E6%96%87%E6%9C%AC%E7%BA%A0%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/11/21/jqpeng-%E4%BB%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E3%80%81BK%E6%A0%91%E5%88%B0%E6%96%87%E6%9C%AC%E7%BA%A0%E9%94%99/" class="post-title-link" itemprop="url">从编辑距离、BK树到文本纠错</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-21 10:33:00" itemprop="dateCreated datePublished" datetime="2017-11-21T10:33:00+08:00">2017-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/BK-Tree.html">从编辑距离、BK树到文本纠错</a></p>
<p>搜索引擎里有一个很重要的话题，就是文本纠错，主要有两种做法，一是从词典纠错，一是分析用户搜索日志，今天我们探讨使用基于词典的方式纠错，核心思想就是基于编辑距离，使用BK树。下面我们来逐一探讨：</p>
<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>1965年，俄国科学家Vladimir<br> Levenshtein给字符串相似度做出了一个明确的定义叫做Levenshtein距离，我们通常叫它“编辑距离”。</p>
<p>字符串A到B的编辑距离是指，只用插入、删除和替换三种操作，最少需要多少步可以把A变成B。例如，从FAME到GATE需要两步（两次替换），从GAME到ACM则需要三步（删除G和E再添加C）。Levenshtein给出了编辑距离的一般求法，就是大家都非常熟悉的经典动态规划问题。</p>
<pre><code> class LevenshteinDistanceFunction &#123;

        private final boolean isCaseSensitive;

        public LevenshteinDistanceFunction(boolean isCaseSensitive) &#123;
            this.isCaseSensitive = isCaseSensitive;
        &#125;

        public int distance(CharSequence left, CharSequence right) &#123;
            int leftLength = left.length(), rightLength = right.length();

            // special cases.
            if (leftLength == 0)
                return rightLength;
            if (rightLength == 0)
                return leftLength;

            // Use the iterative matrix method.
            int[] currentRow = new int[rightLength + 1];
            int[] nextRow    = new int[rightLength + 1];

            // Fill first row with all edit counts.
            for (int i = 0; i &lt;= rightLength; i++)
                currentRow[i] = i;

            for (int i = 1; i &lt;= leftLength; i++) &#123;
                nextRow[0] = i;

                for(int j = 1; j &lt;= rightLength; j++) &#123;
                    int subDistance = currentRow[j - 1]; // Distance without insertions or deletions.
                    if (!charEquals(left.charAt(i - 1), right.charAt(j - 1), isCaseSensitive))
                            subDistance++; // Add one edit if letters are different.
                    nextRow[j] = Math.min(Math.min(nextRow[j - 1], currentRow[j]) + 1, subDistance);
                &#125;

                // Swap rows, use last row for next row.
                int[] t = currentRow;
                currentRow = nextRow;
                nextRow = t;
            &#125;

            return currentRow[rightLength];
        &#125;

    &#125;
</code></pre>
<h1 id="BK树"><a href="#BK树" class="headerlink" title="BK树"></a>BK树</h1><p>编辑距离的经典应用就是用于拼写检错，如果用户输入的词语不在词典中，自动从词典中找出编辑距离小于某个数n的单词，让用户选择正确的那一个，n通常取到2或者3。</p>
<p>这个问题的难点在于，怎样才能快速在字典里找出最相近的单词？可以像 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi/archive/2012/08/10/2633025.html">使用贝叶斯做英文拼写检查（c#)</a> 里是那样，通过单词自动修改一个单词，检查是否在词典里，这样有暴力破解的嫌疑，是否有更优雅的方案呢？</p>
<p>1973年，Burkhard和Keller提出的BK树有效地解决了这个问题。BK树的核心思想是：</p>
<pre><code>令d(x,y)表示字符串x到y的Levenshtein距离，那么显然：
d(x,y) = 0 当且仅当 x=y （Levenshtein距离为0 &lt;==&gt; 字符串相等）
d(x,y) = d(y,x) （从x变到y的最少步数就是从y变到x的最少步数）
d(x,y) + d(y,z) &gt;= d(x,z) （从x变到z所需的步数不会超过x先变成y再变成z的步数）
</code></pre>
<p>最后这一个性质叫做三角形不等式。就好像一个三角形一样，两边之和必然大于第三边。</p>
<h2 id="BK建树"><a href="#BK建树" class="headerlink" title="BK建树"></a>BK建树</h2><p>首先我们随便找一个单词作为根（比如GAME）。以后插入一个单词时首先计算单词与根的Levenshtein距离：如果这个距离值是该节点处头一次出现，建立一个新的儿子节点；否则沿着对应的边递归下去。例如，我们插入单词FAME，它与GAME的距离为1，于是新建一个儿子，连一条标号为1的边；下一次插入GAIN，算得它与GAME的距离为2，于是放在编号为2的边下。再下次我们插入GATE，它与GAME距离为1，于是沿着那条编号为1的边下去，递归地插入到FAME所在子树；GATE与FAME的距离为2，于是把GATE放在FAME节点下，边的编号为2。</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1511232052823.jpg" alt="enter description here" title="BK树"></p>
<h2 id="BK查询"><a href="#BK查询" class="headerlink" title="BK查询"></a>BK查询</h2><p>如果我们需要返回与错误单词距离不超过n的单词，这个错误单词与树根所对应的单词距离为d，那么接下来我们只需要递归地考虑编号在d-n到d+n范围内的边所连接的子树。由于n通常很小，因此每次与某个节点进行比较时都可以<strong>排除很多子树</strong>。</p>
<p>可以通过下图（来自 <a target="_blank" rel="noopener" href="http://blog.csdn.net/tradymeky/article/details/40581547">超酷算法（1）：BK树 （及个人理解）</a>）理解：</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1511229083171.jpg" alt="enter description here" title="1511229083171"></p>
<h2 id="BK-实现"><a href="#BK-实现" class="headerlink" title="BK 实现"></a>BK 实现</h2><p>知道了原理实现就简单了，这里从<a target="_blank" rel="noopener" href="https://github.com/sk-scd91/BKTree">github</a>找一段代码</p>
<p>建树：</p>
<pre><code>public boolean add(T t) &#123;
        if (t == null)
            throw new NullPointerException();

        if (rootNode == null) &#123;
            rootNode = new Node&lt;&gt;(t);
            length = 1;
            modCount++; // Modified tree by adding root.
            return true;
        &#125;

        Node&lt;T&gt; parentNode = rootNode;
        Integer distance;
        while ((distance = distanceFunction.distance(parentNode.item, t)) != 0
                || !t.equals(parentNode.item)) &#123;
            Node&lt;T&gt; childNode = parentNode.children.get(distance);
            if (childNode == null) &#123;
                parentNode.children.put(distance, new Node&lt;&gt;(t));
                length++;
                modCount++; // Modified tree by adding a child.
                return true;
            &#125;
            parentNode = childNode;
        &#125;

        return false;
    &#125;
</code></pre>
<p>查找：</p>
<pre><code> public List&lt;SearchResult&lt;T&gt;&gt; search(T t, int radius) &#123;
        if (t == null)
            return Collections.emptyList();
        ArrayList&lt;SearchResult&lt;T&gt;&gt; searchResults = new ArrayList&lt;&gt;();
        ArrayDeque&lt;Node&lt;T&gt;&gt; nextNodes = new ArrayDeque&lt;&gt;();
        if (rootNode != null)
            nextNodes.add(rootNode);

        while(!nextNodes.isEmpty()) &#123;
            Node&lt;T&gt; nextNode = nextNodes.poll();
            int distance = distanceFunction.distance(nextNode.item, t);
            if (distance &lt;= radius)
                searchResults.add(new SearchResult&lt;&gt;(distance, nextNode.item));
            int lowBound = Math.max(0, distance - radius), highBound = distance + radius;
            for (Integer i = lowBound; i &lt;= highBound; i++) &#123;
                if (nextNode.children.containsKey(i))
                    nextNodes.add(nextNode.children.get(i));
            &#125;
        &#125;

        searchResults.trimToSize();
        Collections.sort(searchResults);
        return Collections.unmodifiableList(searchResults);
    &#125;
</code></pre>
<h1 id="使用BK树做文本纠错"><a href="#使用BK树做文本纠错" class="headerlink" title="使用BK树做文本纠错"></a>使用BK树做文本纠错</h1><p>准备词典，18万的影视名称：<br><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1511231191970.jpg" alt="enter description here" title="1511231191970"></p>
<p>测试代码：</p>
<pre><code>  static void outputSearchResult( List&lt;SearchResult&lt;CharSequence&gt;&gt; results)&#123;
        for(SearchResult&lt;CharSequence&gt; item : results)&#123;
            System.out.println(item.item);
        &#125;
    &#125;

    static void test(BKTree&lt;CharSequence&gt; tree,String word)&#123;
        System.out.println(word+&quot;的最相近结果：&quot;);
        outputSearchResult(tree.search(word,Math.max(1,word.length()/4)));
    &#125;

    public static void main(String[] args) &#123;

        BKTree&lt;CharSequence&gt; tree = new BKTree(DistanceFunctions.levenshteinDistance());
        List&lt;String&gt; testStrings = FileUtil.readLine(&quot;./src/main/resources/act/name.txt&quot;);
        System.out.println(&quot;词典条数：&quot;+testStrings.size());
        long startTime = System.currentTimeMillis();
        for(String testStr: testStrings)&#123;
            tree.add(testStr.replace(&quot;.&quot;,&quot;&quot;));
        &#125;
        System.out.println(&quot;建树耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;);
        startTime = System.currentTimeMillis();
        String[] testWords = new String[]&#123;
                &quot;湄公河凶案&quot;,
                &quot;葫芦丝兄弟&quot;,
                &quot;少林足球&quot;
        &#125;;

        for (String testWord: testWords)&#123;
            test(tree,testWord);
        &#125;
        System.out.println(&quot;测试耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;);
    &#125;
</code></pre>
<p>结果：</p>
<pre><code>词典条数：18513
建树耗时：421ms
湄公河凶案的最相近结果：
湄公河大案
葫芦丝兄弟的最相近结果：
葫芦兄弟
少林足球的最相近结果：
少林足球
笑林足球
测试耗时：20ms
</code></pre>
<p>参考：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/tradymeky/article/details/40581547">http://blog.csdn.net/tradymeky/article/details/40581547</a><br><a target="_blank" rel="noopener" href="https://github.com/sk-scd91/BKTree">https://github.com/sk-scd91/BKTree</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/data2value/p/5707973.html">https://www.cnblogs.com/data2value/p/5707973.html</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/11/13/jqpeng-%E4%BB%8ETrie%E6%A0%91%E5%88%B0%E5%8F%8C%E6%95%B0%E7%BB%84Trie%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/11/13/jqpeng-%E4%BB%8ETrie%E6%A0%91%E5%88%B0%E5%8F%8C%E6%95%B0%E7%BB%84Trie%E6%A0%91/" class="post-title-link" itemprop="url">从Trie树到双数组Trie树</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-13 10:44:00" itemprop="dateCreated datePublished" datetime="2017-11-13T10:44:00+08:00">2017-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/Trie.html">从Trie树到双数组Trie树</a></p>
<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，能在常数时间O(len)内实现插入和查询操作，是一种以空间换取时间的数据结构，广泛用于词频统计和输入统计领域。</p>
<p>来看看Trie树长什么样，我们从百度找一张图片：</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1509691910484.jpg" alt="enter description here" title="1509691910484"></p>
<p>字典树在查找时，先看第一个字是否在字典树里，如果在继续往下，如果不在，则字典里不存在，因此，对于一个长度为len的字符串，可以在O（len)时间内完成查询。</p>
<h2 id="实现trie树"><a href="#实现trie树" class="headerlink" title="实现trie树"></a>实现trie树</h2><p>怎么实现trie树呢，trie树的关键是一个节点要在O（1）时间跳转到下一级节点，因此链表方式不可取，最好用数组来存储下一级节点。问题就来了，如果是纯英文字母，长度26的数组就可以搞定，N个节点的数，就需要N个长度为26的数组。但是，如果包含中文等字符呢，就需要N个65535的数组，特别占用存储空间。当然，可以考虑使用map来存储下级节点。</p>
<p>定义一个Node，包含节点的Character word，以及下级节点nexts和节点可能附件的值values：</p>
<pre><code>public static class Node&lt;T&gt; &#123;
        Character word;

        List&lt;T&gt; values;

        Map&lt;Character, Node&gt; nexts = new HashMap&lt;&gt;(24);

        public Node() &#123;
        &#125;

        public Node(Character word) &#123;
            this.word = word;
        &#125;

        public Character getWord() &#123;
            return word;
        &#125;

        public void setWord(Character word) &#123;
            this.word = word;
        &#125;

        public void addValue(T value)&#123;
            if(values == null)&#123;
                values = new ArrayList&lt;&gt;();
            &#125;
            values.add(value);
        &#125;

        public List&lt;T&gt; getValues() &#123;
            return values;
        &#125;

        public Map&lt;Character, Node&gt; getNexts() &#123;
            return nexts;
        &#125;

        /**
         * @param node
         */
        public void addNext(Node node) &#123;
            this.nexts.put(node.getWord(), node);
        &#125;

        public Node getNext(Character word) &#123;
            return this.nexts.get(word);
        &#125;
    &#125;
</code></pre>
<p>来看如何构建字典树，首先定义一棵树，包含根节点即可</p>
<pre><code>    public static class Trie&lt;T&gt; &#123;
        Node&lt;T&gt; rootNode;

        public Trie() &#123;
            this.rootNode = new Node&lt;T&gt;();
        &#125;

        public Node&lt;T&gt; getRootNode() &#123;
            return rootNode;
        &#125;

    &#125;
</code></pre>
<p>构建树，拆分成单字，然后逐级构建树。</p>
<pre><code> public static class TrieBuilder &#123;
        public static  Trie&lt;String&gt; buildTrie(String... values)&#123;
            Trie&lt;String&gt; trie = new Trie&lt;String&gt;();
            for(String sentence : values)&#123;
                // 根节点
                Node&lt;String&gt; currentNode = trie.getRootNode();
                for (int i = 0; i &lt; sentence.length(); i++) &#123;
                    Character character = sentence.charAt(i);
                    // 寻找首个节点
                    Node&lt;String&gt; node = currentNode.getNext(character);
                    if(node == null)&#123;
                        // 不存在，创建节点
                        node = new Node&lt;String&gt;(character);
                        currentNode.addNext(node);
                    &#125;
                    currentNode = node;
                &#125;

                // 添加数据
                currentNode.addValue(sentence);
            &#125;

            return trie;
        &#125;
</code></pre>
<h2 id="Trie树应用"><a href="#Trie树应用" class="headerlink" title="Trie树应用"></a>Trie树应用</h2><p>比如判断一个词是否在字典树里，非常简单，逐级匹配，末了判断最后的节点是否包含数据：</p>
<pre><code>   public boolean isContains(String word) &#123;
            if (word == null || word.length() == 0) &#123;
                return false;
            &#125;
            Node&lt;T&gt; currentState = rootNode;
            for (int i = 0; i &lt; word.length(); i++) &#123;
                currentState = currentState.getNext(word.charAt(i));
                if (currentState == null) &#123;
                    return false;
                &#125;
            &#125;
            return currentState.getValues()!=null;
        &#125;
</code></pre>
<p>测试代码:</p>
<pre><code>        public static void main(String[] args) &#123;

            Trie trie = TrieBuilder.buildTrie(&quot;刘德华&quot;,&quot;刘三姐&quot;,&quot;刘德刚&quot;,&quot;江姐&quot;);
            System.out.println(trie.isContains(&quot;刘德华&quot;));
            System.out.println(trie.isContains(&quot;刘德&quot;));
            System.out.println(trie.isContains(&quot;刘大大&quot;));
        &#125;
</code></pre>
<p>结果：</p>
<pre><code>true
false
false
</code></pre>
<h1 id="双数组Trie树"><a href="#双数组Trie树" class="headerlink" title="双数组Trie树"></a>双数组Trie树</h1><p>在Trie数实现过程中，我们发现了每个节点均需要 一个数组来存储next节点，非常占用存储空间，空间复杂度大，双数组Trie树正是解决这个问题的。双数组Trie树(DoubleArrayTrie)是一种空间复杂度低的Trie树，应用于字符区间大的语言（如中文、日文等）分词领域。</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>双数组的原理是，将原来需要多个数组才能表示的Trie树，使用两个数据就可以存储下来，可以极大的减小空间复杂度。具体来说：</p>
<p>使用两个数组base和check来维护Trie树，base负责记录状态，check负责检查各个字符串是否是从同一个状态转移而来，当check[i]为负值时，表示此状态为字符串的结束。</p>
<p>上面的有点抽象，举个例子，假定两个单词ta,tb,base和check的值会满足下面的条件：<br> base[t] + a.code = base[ta]<br> base[t] + b.code = base[tb]<br> check[ta] = check[tb]</p>
<p>在每个节点插入的过程中会修改这两个数组，具体说来：</p>
<p>1、初始化root节点base[0] = 1; check[0] = 0;</p>
<p>2、对于每一群兄弟节点，寻找一个begin值使得check[begin + a1…an]  == 0，也就是找到了n个空闲空间,a1…an是siblings中的n个节点对应的code。</p>
<p>3、然后将这群兄弟节点的check设为check[begin + a1…an] = begin</p>
<p>4、接着对每个兄弟节点，如果它没有孩子，令其base为负值；否则为该节点的子节点的插入位置（也就是begin值），同时插入子节点（迭代跳转到步骤2）。</p>
<pre><code>码表：
   胶    名    动    知    下    成    举    一    能    天    万    
33014 21517 21160 30693 19979 25104 20030 19968 33021 22825 19975 

DoubleArrayTrie&#123;
char =      ×    一    万     ×    举     ×    动     ×     下    名    ×    知      ×     ×    能    一    天    成    胶
i    =      0 19970 19977 20032 20033 21162 21164 21519 21520 21522 30695 30699 33023 33024 33028 40001 44345 45137 66038
base =      1     2     6    -1 20032    -2 21162    -3     5 21519    -4 30695    -5    -6 33023     3  1540     4 33024
check=      0     1     1 20032     2 21162     3 21519  1540     4 30695     5 33023 33024     6 20032 21519 20032 33023
size=66039, allocSize=2097152, key=[一举, 一举一动, 一举成名, 一举成名天下知, 万能, 万能胶], keySize=6, progress=6, nextCheckPos=33024, error_=0&#125;
</code></pre>
<p>首层:一[19968],万[ 19975]<br> base[一] = base[0]+19968-19968 = 1<br> base[万] = base[0]+19975-19968 =</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参考 <a target="_blank" rel="noopener" href="http://www.hankcs.com/program/java/%E5%8F%8C%E6%95%B0%E7%BB%84trie%E6%A0%91doublearraytriejava%E5%AE%9E%E7%8E%B0.html">双数组Trie树(DoubleArrayTrie)Java实现</a><br> 开源项目：<a target="_blank" rel="noopener" href="https://github.com/komiya-atsushi/darts-java">https://github.com/komiya-atsushi/darts-java</a></p>
<h1 id="双数组Trie-AC自动机"><a href="#双数组Trie-AC自动机" class="headerlink" title="双数组Trie+AC自动机"></a>双数组Trie+AC自动机</h1><p>参见：<a target="_blank" rel="noopener" href="http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html">http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html</a></p>
<p>结合了AC自动机+双数组Trie树：<br> AC自动机能高速完成多模式匹配，然而具体实现聪明与否决定最终性能高低。大部分实现都是一个Map&lt;Character, State&gt;了事，无论是TreeMap的对数复杂度，还是HashMap的巨额空间复杂度与哈希函数的性能消耗，都会降低整体性能。</p>
<p>双数组Trie树能高速O(n)完成单串匹配，并且内存消耗可控，然而软肋在于多模式匹配，如果要匹配多个模式串，必须先实现前缀查询，然后频繁截取文本后缀才可多匹配，这样一份文本要回退扫描多遍，性能极低。</p>
<p>如果能用双数组Trie树表达AC自动机，就能集合两者的优点，得到一种近乎完美的数据结构。在我的Java实现中，我称其为AhoCorasickDoubleArrayTrie，支持泛型和持久化，自己非常喜爱。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/06/22/jqpeng-%E4%BD%BF%E7%94%A8websocket-sharp%E6%9D%A5%E5%88%9B%E5%BB%BAc#%E7%89%88%E6%9C%AC%E7%9A%84websocket%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/06/22/jqpeng-%E4%BD%BF%E7%94%A8websocket-sharp%E6%9D%A5%E5%88%9B%E5%BB%BAc#%E7%89%88%E6%9C%AC%E7%9A%84websocket%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">使用websocket-sharp来创建c#版本的websocket服务</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-22 17:34:00" itemprop="dateCreated datePublished" datetime="2017-06-22T17:34:00+08:00">2017-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/websocket-sharp.html">使用websocket-sharp来创建c#版本的websocket服务</a></p>
<p>当前有一个需求，需要网页端调用扫描仪，javascript不具备调用能力，因此需要在机器上提供一个ws服务给前端网页调用扫描仪。而扫描仪有一个c#版本的API，因此需要寻找一个c#的websocket库。</p>
<p>java里有大名鼎鼎的netty，通过搜索，c#可以选择<a target="_blank" rel="noopener" href="https://github.com/sta/websocket-sharp">websocket-sharp</a>来实现websocket Server。</p>
<h3 id="使用websocket-sharp创建websocket-server"><a href="#使用websocket-sharp创建websocket-server" class="headerlink" title="使用websocket-sharp创建websocket server###"></a>使用websocket-sharp创建websocket server###</h3><pre><code>using System;
using WebSocketSharp;
using WebSocketSharp.Server;

namespace Example
&#123;
  public class Laputa : WebSocketBehavior
  &#123;
    protected override void OnMessage (MessageEventArgs e)
    &#123;
      var msg = e.Data == &quot;BALUS&quot;
                ? &quot;I&#39;ve been balused already...&quot;
                : &quot;I&#39;m not available now.&quot;;

      Send (msg);
    &#125;
  &#125;

  public class Program
  &#123;
    public static void Main (string[] args)
    &#123;
      var wssv = new WebSocketServer (&quot;ws://dragonsnest.far&quot;);
      wssv.AddWebSocketService&lt;Laputa&gt; (&quot;/Laputa&quot;);
      wssv.Start ();
      Console.ReadKey (true);
      wssv.Stop ();
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h4><p>Required namespace.</p>
<pre><code>using WebSocketSharp.Server;
</code></pre>
<p>The <code>WebSocketBehavior</code> and <code>WebSocketServer</code> 两个类需要引用 <code>WebSocketSharp.Server</code> namespace.</p>
<h4 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h4><p>编写处理类，需要继承 <code>WebSocketBehavior</code> class.</p>
<p>例如，如果你要创建一个echo Service,</p>
<pre><code>using System;
using WebSocketSharp;
using WebSocketSharp.Server;

public class Echo : WebSocketBehavior
&#123;
  protected override void OnMessage (MessageEventArgs e)
  &#123;
    Send (e.Data);
  &#125;
&#125;
</code></pre>
<p>再提供一个 chat service,</p>
<pre><code>using System;
using WebSocketSharp;
using WebSocketSharp.Server;

public class Chat : WebSocketBehavior
&#123;
  private string _suffix;

  public Chat ()
    : this (null)
  &#123;
  &#125;

  public Chat (string suffix)
  &#123;
    _suffix = suffix ?? String.Empty;
  &#125;

  protected override void OnMessage (MessageEventArgs e)
  &#123;
    Sessions.Broadcast (e.Data + _suffix);
  &#125;
&#125;
</code></pre>
<p>可以通过继承<code>WebSocketBehavior</code>类来自定义Service.</p>
<p>通过重载 <code>WebSocketBehavior.OnMessage (MessageEventArgs)</code> 方法, 来处理消息</p>
<p>同时你也可以重载 <code>WebSocketBehavior.OnOpen ()</code>, <code>WebSocketBehavior.OnError (ErrorEventArgs)</code>, 和 <code>WebSocketBehavior.OnClose (CloseEventArgs)</code> 方法,来处理websocket连接事件。</p>
<p>通过<code>WebSocketBehavior.Send</code> 方法来给客户端发送消息。</p>
<p>If you would like to get the sessions in the service, you should access the <code>WebSocketBehavior.Sessions</code> property (returns a <code>WebSocketSharp.Server.WebSocketSessionManager</code>).</p>
<p>The <code>WebSocketBehavior.Sessions.Broadcast</code> method can send data to every client in the service.</p>
<h4 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h4><p>创建 <code>WebSocketServer</code> 对象.</p>
<pre><code>var wssv = new WebSocketServer (4649);
wssv.AddWebSocketService&lt;Echo&gt; (&quot;/Echo&quot;);
wssv.AddWebSocketService&lt;Chat&gt; (&quot;/Chat&quot;);
wssv.AddWebSocketService&lt;Chat&gt; (&quot;/ChatWithNyan&quot;, () =&gt; new Chat (&quot; Nyan!&quot;));
</code></pre>
<h4 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h4><p>启动 WebSocket server.</p>
<pre><code>wssv.Start ();
</code></pre>
<h4 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h4><p>停止 WebSocket server.</p>
<pre><code>wssv.Stop (code, reason);
</code></pre>
<h3 id="测试Demo"><a href="#测试Demo" class="headerlink" title="测试Demo"></a>测试Demo</h3><p><code>目的</code>：对外提供一个websocket服务，让网页端的js可以调用扫描仪</p>
<h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><pre><code> class Program
    &#123;
        static void Main(string[] args)
        &#123;
            var wssv = new WebSocketServer(10086);
            wssv.AddWebSocketService&lt;ScannerHandler&gt;(&quot;/scan&quot;);
            wssv.Start();
            if (wssv.IsListening)
            &#123;
                Console.WriteLine(&quot;Listening on port &#123;0&#125;, and providing WebSocket services:&quot;, wssv.Port);
                foreach (var path in wssv.WebSocketServices.Paths)
                    Console.WriteLine(&quot;- &#123;0&#125;&quot;, path);
            &#125;

            Console.WriteLine(&quot;\nPress Enter key to stop the server...&quot;);
            Console.ReadLine();

            wssv.Stop();
        &#125;
    &#125;

    public class ScannerHandler : WebSocketBehavior
    &#123;
        protected override void OnMessage(MessageEventArgs e)
        &#123;
            if(e.Data == &quot;scan&quot;)
            &#123;
                ScanResult result = ScanerHelper.Scan(&quot;D:\\test.jpg&quot;);
                if (result.Success)
                &#123;
                    Console.WriteLine(&quot;scan success&quot;);
                    Send(&quot;scan success&quot;);
                &#125;
                else
                &#123;
                    Send(&quot;scan eror&quot;);
                &#125;
            &#125;
           
        &#125;
    &#125;
</code></pre>
<h4 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h4><p>javascript代码</p>
<pre><code>     var ws;
    function initWS() &#123;
        ws = new WebSocket(&quot;ws://127.0.0.1:10086/scan&quot;);
        ws.onopen = function () &#123;
            console.log(&quot;Openened connection to websocket&quot;);

        &#125;;
        ws.onclose = function () &#123;
            console.log(&quot;Close connection to websocket&quot;);
            // 断线重连
            initWS();
        &#125;

        ws.onmessage = function (e) &#123;
            alert(e.data)
        &#125;
    &#125;
    initWS();
    function scan() &#123;
        ws &amp;&amp; ws.send(&#39;scan&#39;);
    &#125;
</code></pre>
<p>html代码</p>
<pre><code>&lt;button onclick=&quot;scan()&quot;&gt;扫描&lt;/button&gt;
</code></pre>
<ul>
<li>initWS创建连接，支持断线重连</li>
<li>可以调用scan函数，发送scan指令</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/06/19/jqpeng-IDEA+PHP+XDebug%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/06/19/jqpeng-IDEA+PHP+XDebug%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">IDEA+PHP+XDebug调试配置</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-19 14:38:00" itemprop="dateCreated datePublished" datetime="2017-06-19T14:38:00+08:00">2017-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/xdbug.html">IDEA+PHP+XDebug调试配置</a></p>
<h2 id="XDebug调试配置"><a href="#XDebug调试配置" class="headerlink" title="XDebug调试配置"></a>XDebug调试配置</h2><p>临时需要调试服务器上的PHP web程序，因此安装xdebug，下面简单记录</p>
<h3 id="安装xdebug"><a href="#安装xdebug" class="headerlink" title="安装xdebug"></a>安装xdebug</h3><h4 id="下载最新并解压"><a href="#下载最新并解压" class="headerlink" title="下载最新并解压"></a>下载最新并解压</h4><pre><code>wget https://xdebug.org/files/xdebug-2.5.4.tgz
tar zxvf xdebug-2.5.4.tgz 
cd xdebug-2.5.4/
</code></pre>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>按照README里的步骤安装</p>
<pre><code>./configure --enable-xdebug
···

报错
&gt;checking Check for supported PHP versions... configure: error: not supported. Need a PHP version &gt;= 5.5.0 and &lt; 7.2.0 (found 5.3.10-1ubuntu3.21)


原来服务器上的php版本比较低：
&gt;PHP 5.3.10-1ubuntu3.26 with Suhosin-Patch (cli) (built: Feb 13 2017 20:37:53) 
Copyright (c) 1997-2012 The PHP Group
Zend Engine v2.3.0, Copyright (c) 1998-2012 Zend Technologies

最稳妥起见，下载老版本的xdebug，下载2.2.2版本

``` bash
wget https://xdebug.org/files/xdebug-2.2.2.tgz
tar zxvf xdebug-2.2.2.tgz 
cd xdebug-2.2.2/
./configure --enable-xdebug
make
</code></pre>
<p>make完成后，modules下面就有了编译好的xdebug.so:</p>
<pre><code>root@nginx01:/opt/research/xdebug-2.2.2# ll modules/
total 808
drwxr-xr-x 2 root root   4096 Jun 19 14:17 ./
drwxr-xr-x 9 root root   4096 Jun 19 13:10 ../
-rw-r--r-- 1 root root    939 Jun 19 13:09 xdebug.la
-rwxr-xr-x 1 root root 814809 Jun 19 13:09 xdebug.so*
</code></pre>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>修改php.ini，服务器使用的php5-fpm，配置文件在/etc/php5/fpm/php.ini</p>
<p>修改，增加xdebug配置信息</p>
<pre><code>zend_extension=&quot;/opt/research/xdebug-2.2.2/modules/xdebug.so&quot;
xdebug.remote_enable = On
xdebug.remote_handler = dbgp
xdebug.remote_port = 9001 #端口9001
xdebug.remote_connect_back = 1 
#xdebug.remote_host= 192.168.xxx.xxx
xdebug.idekey = PHPSTORM
xdebug.remote_log = /opt/research/xdebug-2.2.2/xdebug.log
</code></pre>
<h3 id="IDEA-配置"><a href="#IDEA-配置" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h3><h4 id="配置xdebug端口为9001"><a href="#配置xdebug端口为9001" class="headerlink" title="配置xdebug端口为9001"></a>配置xdebug端口为9001</h4><p>在设置里搜索XDEBUG，配置端口9001<br><img src="https://ooo.0o0.ooo/2017/06/19/5947709e37cf4.jpg" alt="enter description here" title="1497854105384"></p>
<h4 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h4><p>在RUN-Edit Configuratins里，新增PHP Web Application<br><img src="https://ooo.0o0.ooo/2017/06/19/5947707361211.jpg" alt="enter description here" title="1497854062372"></p>
<p>Server新增服务器地址，Debugger设置为Xdebug，将服务器上的绝对地址，映射到本地</p>
<p><img src="https://ooo.0o0.ooo/2017/06/19/59477034b6e7f.jpg" alt="XDEBUG配置" title="1497853999274"></p>
<p>然后就可以启动调试了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/06/12/jqpeng-HTML5%E5%BD%95%E9%9F%B3%E6%8E%A7%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/06/12/jqpeng-HTML5%E5%BD%95%E9%9F%B3%E6%8E%A7%E4%BB%B6/" class="post-title-link" itemprop="url">HTML5录音控件</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-12 17:07:00" itemprop="dateCreated datePublished" datetime="2017-06-12T17:07:00+08:00">2017-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/6993912.html">HTML5录音控件</a></p>
<p>最近的项目又需要用到录音，年前有过调研，再次翻出来使用，这里做一个记录。</p>
<p>HTML5提供了录音支持，因此可以方便使用HTML5来录音，来实现录音、语音识别等功能，语音开发必备。但是ES标准提供的API并不人性化，不方便使用，并且不提供保存为wav的功能，开发起来费劲啊！！</p>
<p>github寻找轮子，发现<a target="_blank" rel="noopener" href="https://github.com/mattdiamond/Recorderjs">Recorder.js</a>，基本上可以满足需求了，良好的封装，支持导出wav，但是存在：</p>
<ul>
<li>wav采样率不可调整</li>
<li>recorder创建麻烦，需要自己初始化getUserMedia</li>
<li>无实时数据回调，不方便绘制波形</li>
<li>。。。</li>
</ul>
<h2 id="改造轮子"><a href="#改造轮子" class="headerlink" title="改造轮子"></a>改造轮子</h2><h3 id="创建recorder工具方法"><a href="#创建recorder工具方法" class="headerlink" title="创建recorder工具方法"></a>创建recorder工具方法</h3><p>提供创建recorder工具函数，封装audio接口：</p>
<pre><code>static createRecorder(callback,config)&#123;
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        window.URL = window.URL || window.webkitURL;
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
        
        if (navigator.getUserMedia) &#123;
            navigator.getUserMedia(
                &#123; audio: true &#125; //只启用音频
                , function (stream) &#123;
                    var audio_context = new AudioContext;
                    var input = audio_context.createMediaStreamSource(stream);
                    var rec = new Recorder(input, config);
                    callback(rec);
                &#125;
                , function (error) &#123;
                    switch (error.code || error.name) &#123;
                        case &#39;PERMISSION_DENIED&#39;:
                        case &#39;PermissionDeniedError&#39;:
                            throwError(&#39;用户拒绝提供信息。&#39;);
                            break;
                        case &#39;NOT_SUPPORTED_ERROR&#39;:
                        case &#39;NotSupportedError&#39;:
                            throwError(&#39;浏览器不支持硬件设备。&#39;);
                            break;
                        case &#39;MANDATORY_UNSATISFIED_ERROR&#39;:
                        case &#39;MandatoryUnsatisfiedError&#39;:
                            throwError(&#39;无法发现指定的硬件设备。&#39;);
                            break;
                        default:
                            throwError(&#39;无法打开麦克风。异常信息:&#39; + (error.code || error.name));
                            break;
                    &#125;
                &#125;);
        &#125; else &#123;
            throwError(&#39;当前浏览器不支持录音功能。&#39;); return;
        &#125;
    &#125;
</code></pre>
<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>H5录制的默认是44k的，文件大，不方便传输，因此需要进行重新采样，一般采用插值取点方法：</p>
<p>以下代码主要来自stackoverflow：</p>
<pre><code>             /**
             * 转换采样率
             * @param data
             * @param newSampleRate 目标采样率
             * @param oldSampleRate 原始数据采样率
             * @returns &#123;any[]|Array&#125;
             */
            function interpolateArray(data, newSampleRate, oldSampleRate) &#123;
                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));
                var newData = new Array();
                var springFactor = new Number((data.length - 1) / (fitCount - 1));
                newData[0] = data[0]; // for new allocation
                for (var i = 1; i &lt; fitCount - 1; i++) &#123;
                    var tmp = i * springFactor;
                    var before = new Number(Math.floor(tmp)).toFixed();
                    var after = new Number(Math.ceil(tmp)).toFixed();
                    var atPoint = tmp - before;
                    newData[i] = this.linearInterpolate(data[before], data[after], atPoint);
                &#125;
                newData[fitCount - 1] = data[data.length - 1]; // for new allocation
                return newData;
            &#125;

            function linearInterpolate(before, after, atPoint) &#123;
                return before + (after - before) * atPoint;
            &#125;
</code></pre>
<p>修改导出wav函数exportWAV，增加采样率选项：</p>
<pre><code>            /**
             * 导出wav
             * @param type
             * @param desiredSamplingRate 期望的采样率
             */
            function exportWAV(type,desiredSamplingRate) &#123;
                // 默认为16k
                desiredSamplingRate = desiredSamplingRate || 16000;
                var buffers = [];
                for (var channel = 0; channel &lt; numChannels; channel++) &#123;
                    var buffer = mergeBuffers(recBuffers[channel], recLength);
                    // 需要转换采样率
                    if (desiredSamplingRate!=sampleRate) &#123;
                        // 插值去点
                        buffer = interpolateArray(buffer, desiredSamplingRate, sampleRate);
                    &#125;
                    buffers.push(buffer);
                &#125;
                var interleaved = numChannels === 2 ? interleave(buffers[0], buffers[1]) : buffers[0];
                var dataview = encodeWAV(interleaved,desiredSamplingRate);
                var audioBlob = new Blob([dataview], &#123; type: type &#125;);
                self.postMessage(&#123; command: &#39;exportWAV&#39;, data: audioBlob &#125;);
            &#125;
</code></pre>
<h3 id="实时录音数据回调"><a href="#实时录音数据回调" class="headerlink" title="实时录音数据回调"></a>实时录音数据回调</h3><p>为了方便绘制音量、波形图，需要获取到实时数据：</p>
<p>config新增一个回调函数onaudioprocess：</p>
<pre><code>  config = &#123;
        bufferLen: 4096,
        numChannels: 1, // 默认单声道
        mimeType: &#39;audio/wav&#39;,
        onaudioprocess:null
    &#125;;
</code></pre>
<p>修改录音数据处理函数：</p>
<pre><code>        this.node.onaudioprocess = (e) =&gt; &#123;
            if (!this.recording) return;
            var buffer = [];

            for (var channel = 0; channel &lt; this.config.numChannels; channel++) &#123;
                buffer.push(e.inputBuffer.getChannelData(channel));
            &#125;

            // 发送给worker
            this.worker.postMessage(&#123;
                command: &#39;record&#39;,
                buffer: buffer
            &#125;);

            // 数据回调
            if(this.config.onaudioprocess)&#123;
                this.config.onaudioprocess(buffer[0]);
            &#125;
        &#125;;
</code></pre>
<p>这样，在创建recorder时，配置onaudioprocess就可以获取到实时数据了</p>
<h3 id="实时数据编码"><a href="#实时数据编码" class="headerlink" title="实时数据编码"></a>实时数据编码</h3><p>编码计算耗时，需要放到worker执行：</p>
<p>接口函数新增encode，发送消息给worker，让worker执行：</p>
<pre><code>    encode(cb,buffer,sampleRate) &#123;
        cb = cb || this.config.callback;
        if (!cb) throw new Error(&#39;Callback not set&#39;);
        this.callbacks.encode.push(cb);
        this.worker.postMessage(&#123; command: &#39;encode&#39;,buffer:buffer,sampleRate:sampleRate&#125;);
    &#125;
</code></pre>
<p>worker里新增encode函数，处理encode请求，完成后执行回调</p>
<pre><code> self.onmessage = function (e) &#123;
                switch (e.data.command) &#123;

                    case &#39;encode&#39;:
                        encode(e.data.buffer,e.data.sampleRate);
                        break;

                &#125;
            &#125;;        
    encode(cb,buffer,sampleRate) &#123;
        cb = cb || this.config.callback;
        if (!cb) throw new Error(&#39;Callback not set&#39;);
        this.callbacks.encode.push(cb);
        this.worker.postMessage(&#123; command: &#39;encode&#39;,buffer:buffer,sampleRate:sampleRate&#125;);
    &#125;
</code></pre>
<h3 id="wav上传"><a href="#wav上传" class="headerlink" title="wav上传"></a>wav上传</h3><p>增加一个上传函数：</p>
<pre><code>     exportWAVAndUpload(url, callback) &#123;
        var _url = url;
        exportWAV(function(blob)&#123;
            var fd = new FormData();
            fd.append(&quot;audioData&quot;, blob);
            var xhr = new XMLHttpRequest();
            if (callback) &#123;
                xhr.upload.addEventListener(&quot;progress&quot;, function (e) &#123;
                    callback(&#39;uploading&#39;, e);
                &#125;, false);
                xhr.addEventListener(&quot;load&quot;, function (e) &#123;
                    callback(&#39;ok&#39;, e);
                &#125;, false);
                xhr.addEventListener(&quot;error&quot;, function (e) &#123;
                    callback(&#39;error&#39;, e);
                &#125;, false);
                xhr.addEventListener(&quot;abort&quot;, function (e) &#123;
                    callback(&#39;cancel&#39;, e);
                &#125;, false);
            &#125;
            xhr.open(&quot;POST&quot;, url);
            xhr.send(fd);
        &#125;)     
    &#125;
</code></pre>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>=<a target="_blank" rel="noopener" href="http://files.cnblogs.com/files/xiaoqi/recorder.js">点击下载</a></p>
<h2 id="发现新轮子"><a href="#发现新轮子" class="headerlink" title="发现新轮子"></a>发现新轮子</h2><p>今天再次看这个项目，发现这个项目已经不维护了，</p>
<blockquote>
<p>Note: This repository is not being actively maintained due to lack of time and interest. If you maintain or know of a good fork, please let me know so I can direct future visitors to it. In the meantime, if this library isn’t working, you can find a list of popular forks here: <a target="_blank" rel="noopener" href="http://forked.yannick.io/mattdiamond/recorderjs">http://forked.yannick.io/mattdiamond/recorderjs</a>.</p>
</blockquote>
<p>作者推荐<a target="_blank" rel="noopener" href="https://github.com/chris-rudmin/Recorderjs">https://github.com/chris-rudmin/Recorderjs</a>，提供更多的功能：</p>
<ul>
<li><strong>bitRate</strong> (<em>optional</em>) Specifies the target bitrate in bits/sec. The encoder selects an application-specific default when this is not specified.</li>
<li><strong>bufferLength</strong> - (<em>optional</em>) The length of the buffer that the internal JavaScriptNode uses to capture the audio. Can be tweaked if experiencing performance issues. Defaults to <code>4096</code>.</li>
<li><strong>encoderApplication</strong> - (<em>optional</em>) Specifies the encoder application. Supported values are <code>2048</code> - Voice, <code>2049</code> - Full Band Audio, <code>2051</code> - Restricted Low Delay. Defaults to <code>2049</code>.</li>
<li><strong>encoderComplexity</strong> - (<em>optional</em>) Value between 0 and 10 which determines latency and processing for resampling. <code>0</code> is fastest with lowest complexity. <code>10</code> is slowest with highest complexity. The encoder selects a default when this is not specified.</li>
<li><strong>encoderFrameSize</strong> (<em>optional</em>) Specifies the frame size in ms used for encoding. Defaults to <code>20</code>.</li>
<li><strong>encoderPath</strong> - (<em>optional</em>) Path to encoderWorker.min.js worker script. Defaults to <code>encoderWorker.min.js</code></li>
<li><strong>encoderSampleRate</strong> - (<em>optional</em>) Specifies the sample rate to encode at. Defaults to <code>48000</code>. Supported values are <code>8000</code>, <code>12000</code>, <code>16000</code>, <code>24000</code> or <code>48000</code>.</li>
<li><strong>leaveStreamOpen</strong> - (<em>optional</em>) Keep the stream around when trying to <code>stop</code> recording, so you can re-<code>start</code> without re-<code>initStream</code>. Defaults to <code>false</code>.</li>
<li><strong>maxBuffersPerPage</strong> - (<em>optional</em>) Specifies the maximum number of buffers to use before generating an Ogg page. This can be used to lower the streaming latency. The lower the value the more overhead the ogg stream will incur. Defaults to <code>40</code>.</li>
<li><strong>monitorGain</strong> - (<em>optional</em>) Sets the gain of the monitoring output. Gain is an a-weighted value between <code>0</code> and <code>1</code>. Defaults to <code>0</code></li>
<li><strong>numberOfChannels</strong> - (<em>optional</em>) The number of channels to record. <code>1</code> = mono, <code>2</code> = stereo. Defaults to <code>1</code>. Maximum <code>2</code> channels are supported.</li>
<li><strong>originalSampleRateOverride</strong> - (<em>optional</em>) Override the ogg opus ‘input sample rate’ field. Google Speech API requires this field to be <code>16000</code>.</li>
<li><strong>resampleQuality</strong> - (<em>optional</em>) Value between 0 and 10 which determines latency and processing for resampling. <code>0</code> is fastest with lowest quality. <code>10</code> is slowest with highest quality. Defaults to <code>3</code>.</li>
<li><strong>streamPages</strong> - (<em>optional</em>) <code>dataAvailable</code> event will fire after each encoded page. Defaults to <code>false</code>.</li>
</ul>
<p>推荐使用</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/06/07/jqpeng-Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8jar%E5%A4%96%E9%83%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/06/07/jqpeng-Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8jar%E5%A4%96%E9%83%A8/" class="post-title-link" itemprop="url">Spring Boot配置文件放在jar外部</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-07 09:17:00" itemprop="dateCreated datePublished" datetime="2017-06-07T09:17:00+08:00">2017-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/6955288.html">Spring Boot配置文件放在jar外部</a></p>
<p>Spring Boot程序默认从application.properties或者application.yaml读取配置，如何将配置信息外置，方便配置呢？</p>
<p>查询官网，可以得到下面的几种方案:</p>
<h2 id="通过命令行指定"><a href="#通过命令行指定" class="headerlink" title="通过命令行指定"></a>通过命令行指定</h2><p>SpringApplication会默认将命令行选项参数转换为配置信息<br> 例如，启动时命令参数指定：</p>
<pre><code>java -jar myproject.jar --server.port = 9000
</code></pre>
<p>从命令行指定配置项的优先级最高，不过你可以通过setAddCommandLineProperties来禁用</p>
<pre><code>SpringApplication.setAddCommandLineProperties(false).
</code></pre>
<h2 id="外置配置文件"><a href="#外置配置文件" class="headerlink" title="外置配置文件"></a>外置配置文件</h2><p>Spring程序会按优先级从下面这些路径来加载application.properties配置文件</p>
<ul>
<li>当前目录下的/config目录</li>
<li>当前目录</li>
<li>classpath里的/config目录</li>
<li>classpath 跟目录</li>
</ul>
<p>因此，要外置配置文件就很简单了，在jar所在目录新建config文件夹，然后放入配置文件，或者直接放在配置文件在jar目录</p>
<h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p>如果你不想使用application.properties作为配置文件，怎么办？完全没问题</p>
<pre><code>java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties
</code></pre>
<p>或者</p>
<pre><code>java -jar -Dspring.config.location=D:\config\config.properties springbootrestdemo-0.0.1-SNAPSHOT.jar 
</code></pre>
<p>当然，还能在代码里指定</p>
<pre><code>@SpringBootApplication
@PropertySource(value=&#123;&quot;file:config.properties&quot;&#125;)
public class SpringbootrestdemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(SpringbootrestdemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<h2 id="按Profile不同环境读取不同配置"><a href="#按Profile不同环境读取不同配置" class="headerlink" title="按Profile不同环境读取不同配置"></a>按Profile不同环境读取不同配置</h2><p>不同环境的配置设置一个配置文件，例如：</p>
<ul>
<li>dev环境下的配置配置在application-dev.properties中；</li>
<li>prod环境下的配置配置在application-prod.properties中。</li>
</ul>
<p>在application.properties中指定使用哪一个文件</p>
<pre><code>spring.profiles.active = dev
</code></pre>
<p>当然，你也可以在运行的时候手动指定：</p>
<pre><code>java -jar myproject.jar --spring.profiles.active = prod
</code></pre>
<p>参考：<br> 1    参见<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">Externalized Configuration</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/06/01/jqpeng-Netty%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/06/01/jqpeng-Netty%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E/" class="post-title-link" itemprop="url">Netty断线重连</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-01 09:52:00" itemprop="dateCreated datePublished" datetime="2017-06-01T09:52:00+08:00">2017-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/6927387.html">Netty断线重连</a></p>
<h1 id="Netty断线重连"><a href="#Netty断线重连" class="headerlink" title="Netty断线重连"></a>Netty断线重连</h1><p>最近使用Netty开发一个中转服务，需要一直保持与Server端的连接，网络中断后需要可以自动重连，查询官网资料，实现方案很简单，核心思想是在channelUnregistered钩子函数里执行重连。</p>
<h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><p>需要把configureBootstrap重构为一个函数，方便后续复用</p>
<ol>
<li>EventLoopGroup group = new NioEventLoopGroup(); </li>
</ol>
<hr>
<ol start="2">
<li>private volatile Bootstrap bootstrap; </li>
</ol>
<hr>
<ol start="3">
<li><hr>
</li>
<li>public void init(String host, int port) throws RobotException { </li>
</ol>
<hr>
<ol start="5">
<li>this.serverIp = host; </li>
</ol>
<hr>
<ol start="6">
<li>this.serverPort = port; </li>
</ol>
<hr>
<ol start="7">
<li>try { </li>
</ol>
<hr>
<ol start="8">
<li>// 创建并初始化 Netty 客户端 Bootstrap 对象 </li>
</ol>
<hr>
<ol start="9">
<li>bootstrap = configureBootstrap(new Bootstrap(),group); </li>
</ol>
<hr>
<ol start="10">
<li>bootstrap.option(ChannelOption.TCP_NODELAY, true); </li>
</ol>
<hr>
<ol start="11">
<li>doConnect(bootstrap); </li>
</ol>
<hr>
<ol start="12">
<li>} </li>
</ol>
<hr>
<ol start="13">
<li>catch(Exception ex){ </li>
</ol>
<hr>
<ol start="14">
<li>ex.printStackTrace(); </li>
</ol>
<hr>
<ol start="15">
<li>throw new RobotException(“connect remote control server error!”,ex.getCause()); </li>
</ol>
<hr>
<ol start="16">
<li>} </li>
</ol>
<hr>
<ol start="17">
<li>} </li>
</ol>
<hr>
<ol start="18">
<li><hr>
</li>
<li>Bootstrap configureBootstrap(Bootstrap b, EventLoopGroup g) { </li>
</ol>
<hr>
<ol start="20">
<li>b.group(g).channel(NioSocketChannel.class) </li>
</ol>
<hr>
<ol start="21">
<li>.remoteAddress(serverIp, serverPort) </li>
</ol>
<hr>
<ol start="22">
<li>.handler(new ChannelInitializer&lt;SocketChannel&gt;() { </li>
</ol>
<hr>
<ol start="23">
<li>@Override </li>
</ol>
<hr>
<ol start="24">
<li>public void initChannel(SocketChannel channel) throws Exception { </li>
</ol>
<hr>
<ol start="25">
<li>ChannelPipeline pipeline = channel.pipeline(); </li>
</ol>
<hr>
<ol start="26">
<li>// 编解码器 </li>
</ol>
<hr>
<ol start="27">
<li>pipeline.addLast(protoCodec); </li>
</ol>
<hr>
<ol start="28">
<li>// 请求处理 </li>
</ol>
<hr>
<ol start="29">
<li>pipeline.addLast(RobotClient.this); </li>
</ol>
<hr>
<ol start="30">
<li>} </li>
</ol>
<hr>
<ol start="31">
<li>}); </li>
</ol>
<hr>
<ol start="32">
<li><hr>
</li>
<li>return b; </li>
</ol>
<hr>
<ol start="34">
<li>} </li>
</ol>
<hr>
<ol start="35">
<li><hr>
</li>
<li>void doConnect(Bootstrap b) { </li>
</ol>
<hr>
<ol start="37">
<li>try { </li>
</ol>
<hr>
<ol start="38">
<li><hr>
</li>
<li>ChannelFuture future = b.connect(); </li>
</ol>
<hr>
<ol start="40">
<li>future.addListener(new ChannelFutureListener() { </li>
</ol>
<hr>
<ol start="41">
<li>@Override </li>
</ol>
<hr>
<ol start="42">
<li>public void operationComplete(ChannelFuture future) throws Exception { </li>
</ol>
<hr>
<ol start="43">
<li>if (future.isSuccess()) { </li>
</ol>
<hr>
<ol start="44">
<li>System.out.println(“Started Tcp Client: “ + serverIp); </li>
</ol>
<hr>
<ol start="45">
<li>} else { </li>
</ol>
<hr>
<ol start="46">
<li>System.out.println(“Started Tcp Client Failed: “); </li>
</ol>
<hr>
<ol start="47">
<li>} </li>
</ol>
<hr>
<ol start="48">
<li>if (future.cause() != null) { </li>
</ol>
<hr>
<ol start="49">
<li>future.cause().printStackTrace(); </li>
</ol>
<hr>
<ol start="50">
<li>} </li>
</ol>
<hr>
<ol start="51">
<li><hr>
</li>
<li>} </li>
</ol>
<hr>
<ol start="53">
<li>}); </li>
</ol>
<hr>
<ol start="54">
<li>} catch (Exception e) { </li>
</ol>
<hr>
<ol start="55">
<li>e.printStackTrace(); </li>
</ol>
<hr>
<ol start="56">
<li>} </li>
</ol>
<hr>
<ol start="57">
<li>} </li>
</ol>
<hr>
<h2 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h2><p>来看断线重连的关键代码：</p>
<ol>
<li>@ChannelHandler.Sharable </li>
</ol>
<hr>
<ol start="2">
<li>public class RobotClient extends SimpleChannelInboundHandler&lt;RobotProto&gt; { </li>
</ol>
<hr>
<ol start="3">
<li>@Override </li>
</ol>
<hr>
<ol start="4">
<li>public void channelUnregistered(ChannelHandlerContext ctx) throws Exception { </li>
</ol>
<hr>
<ol start="5">
<li>// 状态重置 </li>
</ol>
<hr>
<ol start="6">
<li>isConnected = false; </li>
</ol>
<hr>
<ol start="7">
<li>this.serverStatus = -1; </li>
</ol>
<hr>
<ol start="8">
<li><hr>
</li>
<li>final EventLoop loop = ctx.channel().eventLoop(); </li>
</ol>
<hr>
<ol start="10">
<li>loop.schedule(new Runnable() { </li>
</ol>
<hr>
<ol start="11">
<li>@Override </li>
</ol>
<hr>
<ol start="12">
<li>public void run() { </li>
</ol>
<hr>
<ol start="13">
<li>doConnect(configureBootstrap(new Bootstrap(), loop)); </li>
</ol>
<hr>
<ol start="14">
<li>} </li>
</ol>
<hr>
<ol start="15">
<li>}, 1, TimeUnit.SECONDS); </li>
</ol>
<hr>
<ol start="16">
<li>} </li>
</ol>
<hr>
<ol start="17">
<li>} </li>
</ol>
<hr>
<p>需要注意，Client类需要添加@ChannelHandler.Sharable注解，否则重连时会报错</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/04/26/jqpeng-%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/04/26/jqpeng-%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">高效沟通技巧</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-26 14:51:00" itemprop="dateCreated datePublished" datetime="2017-04-26T14:51:00+08:00">2017-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>804</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/effective-commnunication.html">高效沟通技巧</a></p>
<p>高效沟通是工作中的必备技巧，本文为学习总结。</p>
<h2 id="什么是沟通"><a href="#什么是沟通" class="headerlink" title="什么是沟通?"></a>什么是沟通?</h2><ul>
<li>沟通是达成共识，理解一致</li>
<li>沟通 VS. 表达 ： 沟通是双向交流，而表达是单向</li>
<li>沟通关键在于<strong>通</strong>，需要抓住时机<strong>及时沟通到位</strong>，并不是讲过了就通了</li>
</ul>
<h2 id="沟通技巧"><a href="#沟通技巧" class="headerlink" title="沟通技巧"></a>沟通技巧</h2><h3 id="沟通障碍在于认知偏差"><a href="#沟通障碍在于认知偏差" class="headerlink" title="沟通障碍在于认知偏差"></a>沟通障碍在于认知偏差</h3><p>每个人的背景、价值观并不尽相同，对同一个事物的认识会产生较多的偏差，因此这个认知偏差会导致沟通出现障碍。</p>
<p>克服认知偏差小技巧：</p>
<ul>
<li>刚开始不要说定性的结论</li>
<li>及时沟通到位，一次不行，多次沟通</li>
<li>要有为能做好事情<strong>找方法</strong>，而不是为不能做<strong>找理由</strong>!</li>
</ul>
<p>认知偏差通常会由这些原因导致：</p>
<ul>
<li>听不到位</li>
<li>缺乏参与</li>
<li>无效表达</li>
</ul>
<h3 id="聆听技巧"><a href="#聆听技巧" class="headerlink" title="聆听技巧"></a>聆听技巧</h3><p>关注下听的繁体字：<strong>聽</strong></p>
<ul>
<li>十目</li>
<li>一心</li>
<li>一耳</li>
<li>一王</li>
</ul>
<h4 id="聆听小秘诀"><a href="#聆听小秘诀" class="headerlink" title="聆听小秘诀"></a>聆听小秘诀</h4><ul>
<li>理解确认<ul>
<li>用自己的语言<strong>复述</strong>对方所表达的意思</li>
<li>在复述后通过<strong>澄清</strong>与对方确认理解，确认对话说话的目的</li>
</ul>
</li>
<li>回应情绪<ul>
<li>同理心</li>
<li>表示理解</li>
<li>让对方释放情绪</li>
<li>不要一上来就将应该怎么做</li>
</ul>
</li>
</ul>
<p>沟通重在通，是双向的，因此需要提升参与度</p>
<h3 id="提升参与"><a href="#提升参与" class="headerlink" title="提升参与"></a>提升参与</h3><h4 id="沟通三技巧"><a href="#沟通三技巧" class="headerlink" title="沟通三技巧"></a>沟通三技巧</h4><ul>
<li>收集信息、了解真相</li>
<li>澄清疑虑、核对想法</li>
<li>拓展思维，鼓励参与</li>
</ul>
<h4 id="用开放式问题，激发思考"><a href="#用开放式问题，激发思考" class="headerlink" title="用开放式问题，激发思考"></a>用开放式问题，激发思考</h4><ul>
<li>WHAT<ul>
<li>你的建议是什么</li>
<li>有什么困难挑战障碍</li>
</ul>
</li>
<li>WHEN<ul>
<li>你认为什么时候可以完成</li>
</ul>
</li>
<li>WHY<ul>
<li>这样的理由是？</li>
<li>你认为可能是什么原因</li>
</ul>
</li>
<li>WHO<ul>
<li>谁可以帮忙</li>
<li>可以从谁那里获取帮助</li>
</ul>
</li>
<li>HOW<ul>
<li>你打算如何开始</li>
<li>要怎么做才可以</li>
</ul>
</li>
<li>WHERE</li>
</ul>
<h4 id="提问技巧"><a href="#提问技巧" class="headerlink" title="提问技巧"></a>提问技巧</h4><ul>
<li>一次一个问题</li>
<li>保持开放</li>
<li>由广泛到具体</li>
<li>尊重隐私</li>
<li>不带威胁</li>
</ul>
<h2 id="沟通互动流程"><a href="#沟通互动流程" class="headerlink" title="沟通互动流程"></a>沟通互动流程</h2><p>但凡沟通，可以按这个秘籍（套路）来做：</p>
<ol>
<li>定方向<ul>
<li>确定沟通的目的——今天主要是。。。</li>
<li>然后再将讲重要性  ——  有什么重要性</li>
</ul>
</li>
<li>理情况<ul>
<li>摆事实、看数据</li>
<li>问题、疑虑</li>
</ul>
</li>
<li>想方案<ul>
<li>方向</li>
<li>资源</li>
<li>支持</li>
</ul>
</li>
<li>明做法<ul>
<li>行动计划</li>
<li>追踪、应变</li>
</ul>
</li>
<li>做总结<ul>
<li>要点</li>
<li>信心</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/04/21/jqpeng-Latex%20%E5%85%AC%E5%BC%8F%E5%9C%A8%E7%BA%BF%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/04/21/jqpeng-Latex%20%E5%85%AC%E5%BC%8F%E5%9C%A8%E7%BA%BF%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91%E5%99%A8/" class="post-title-link" itemprop="url">Latex 公式在线可视化编辑器</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-21 09:00:00" itemprop="dateCreated datePublished" datetime="2017-04-21T09:00:00+08:00">2017-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/latex-editor.html">Latex 公式在线可视化编辑器</a></p>
<h2 id="寻觅"><a href="#寻觅" class="headerlink" title="寻觅"></a>寻觅</h2><p>最近的一个demo需要用到Latex公式在线编辑器，从搜索引擎一般会得到类似<a target="_blank" rel="noopener" href="http://latex.codecogs.com/eqneditor/editor.php">http://latex.codecogs.com/eqneditor/editor.php</a>的结果，这个编辑器的问题在于使用成本高，并且界面不美观。<br><img src="https://ooo.0o0.ooo/2017/04/20/58f847b5b0998.jpg" alt="codecogs" title="codecogs"></p>
<p>继续探寻，发现了<a target="_blank" rel="noopener" href="http://www.wiris.com/editor/demo/en/examples">wiris Editor</a>：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f8474b37a60.jpg" alt="wiris Editor" title="wiris"></p>
<p>支持mathml和latex：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f847990789b.jpg" alt="wiris Editor" title="mathml和latex"></p>
<p>那么就它了！</p>
<h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>首先，我们不会直接使用这个编辑器，只是在编辑公式的时候才使用，所以要选择合适的版本。<br><img src="https://ooo.0o0.ooo/2017/04/20/58f849cd99f29.jpg" alt="wiris Editor" title="1492666829731"><br> 以前用过CKEditor，所以就这它了！选用<a target="_blank" rel="noopener" href="http://www.wiris.com/en/downloads/files/1376/011ckeditor/java-demo_ckeditor_wiris4-4.2.0.1365.zip">java版本</a><br> 我们的数据已经是latex的，在wiris 编辑器显示需要注意latex需要用两个$$包括起来<br> 例如:</p>
<pre><code>The history of $$\sqrt(2)$$.
</code></pre>
<p>但是CK版本的wiris对latex的支持是非可视化支持，在编辑器里输入latex还是显示为latex：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f8490c90a9e.jpg" alt="enter description here" title="1492666637204"></p>
<p>将焦点移动到$$内部，再点击按钮出现wiris的公式编辑器：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/20/58f84a34a07e2.jpg" alt="enter description here" title="1492666933326"><br> 这种设计适合对latex熟悉的人员，可以裸写latex，同时对不熟悉的人来说，可以使用公式编辑器。但是，这样不直观啊！你让不会latex的看到的就一堆符号！</p>
<h2 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h2><p>简单试用可以发现，如果直接使用公式编辑器插入公式，是直观显示的：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f84c7433958.jpg" alt="enter description here" title="1492667508804"></p>
<p>可以看到保存的时候，mathml是：</p>
<pre><code>&lt;math class=&quot;wrs_chemistry&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msqrt&gt;    &lt;mn&gt;2&lt;/mn&gt;&lt;/msqrt&gt;
&lt;/math&gt;
</code></pre>
<p>那么在latex输入情况下呢：</p>
<pre><code>&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;    &lt;mrow&gt;        &lt;msqrt&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;/msqrt&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;    &lt;/mrow&gt;    &lt;annotation encoding=&quot;LaTeX&quot;&gt;\sqrt(2)&lt;/annotation&gt;&lt;/semantics&gt;
&lt;/math&gt;
</code></pre>
<p>原来问题在这里，正是mathML的区别导致处理的区别。也就是说一开始就生成不带LaTeX的mathML，然后再放入编辑器。简单查看代码，可以知道先调用wrs_endParse，再wrs_initParse就可以了。</p>
<pre><code>CKEDITOR.on(&quot;instanceReady&quot;, function(event)&#123;    CKEDITOR.instances.example.focus();    var mathxml = wrs_endParse(&quot;已知向量$$\\vec&#123;a&#125;=(\\sqrt&#123;3&#125;,2)$$,$$\\vec&#123;b&#125;=(0,-2)$$,向量$$\\vec&#123;c&#125;=(k,\\sqrt&#123;2&#125;)$$.$$\\vec&#123;a&#125;-1\\vec&#123;b&#125;$$与$$\\vec&#123;d&#125;$$共线,$$k=$$__.&quot;);    CKEDITOR.instances.example.setData(wrs_initParse(mathxml));    // 等待完成    window.setTimeout(updateFunction,0);&#125;);
</code></pre>
<p><img src="https://ooo.0o0.ooo/2017/04/21/58f954fc81b80.jpg" alt="Latex" title="Latex可视化"></p>
<p>直观显示没问题了，但是mathml如何再转换成Latex呢？core.js里的wrs_parseMathmlToLatex函数是直接从mathml里将<annotation encoding="LaTeX">。。。</annotation>里的内容提取出来：</p>
<pre><code>function wrs_parseMathmlToLatex(content, characters)&#123;
    ....
    var openTarget = characters.tagOpener + &#39;annotation encoding=&#39; + characters.doubleQuote + &#39;LaTeX&#39; + characters.doubleQuote + characters.tagCloser;
 
        mathml = content.substring(start, end);

        startAnnotation = mathml.indexOf(openTarget);    // 包含 encoding=latex，保留latex
        if (startAnnotation != -1)&#123;
            startAnnotation += openTarget.length;
            closeAnnotation = mathml.indexOf(closeTarget);
            var latex = mathml.substring(startAnnotation, closeAnnotation);
            if (characters == _wrs_safeXmlCharacters) &#123;
                latex = wrs_mathmlDecode(latex);
            &#125;
            output += &#39;$$&#39; + latex + &#39;$$&#39;;
            // Populate latex into cache.
            wrs_populateLatexCache(latex, mathml);
        &#125;else&#123;
            output += mathml;
        &#125;
   ......
&#125;
</code></pre>
<p>但是现在的mathml不包含这个信息，如何处理？查看官方文档，发现有一个mathml2latex的服务，查看官方给的java demo里servlet并不包含这个服务，但是jar包里存在代码，于是自己封装一个servlet即可：</p>
<pre><code>public class ServiceServlet extends com.wiris.plugin.dispatchers.MainServlet &#123;

    @Override
    public void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)
            throws ServletException, IOException &#123;
        PluginBuilder pb = newPluginBuilder(request);
        String origin = request.getHeader(&quot;origin&quot;);
        HttpResponse res = new HttpResponse(response);
        pb.addCorsHeaders(res, origin);
        String pathInfo = request.getServletPath();
        if (pathInfo.equals(&quot;/mathml2latex&quot;)) &#123;
            response.setContentType(&quot;text/plain; charset=utf-8&quot;);
            ParamsProvider provider = pb.getCustomParamsProvider();
            String mml = provider.getParameter(&quot;mml&quot;, (String)null);
            String r = pb.newTextService().mathml2latex(mml);
            PrintWriter out = response.getWriter();
            out.print(r);
            out.close();
        &#125;
</code></pre>
<p>js里，调用这个服务：</p>
<pre><code>var _wrs_mathmlCache = &#123;&#125;;
function wrs_getLatexFromMathML(mml) &#123;
    if (_wrs_mathmlCache.hasOwnProperty(mml)) &#123;
        return _wrs_mathmlCache[mml];
    &#125;
    var data = &#123;
        &#39;service&#39;: &#39;mathml2latex&#39;,
        &#39;mml&#39;: mml
    &#125;;

    var latex = wrs_getContent(_wrs_conf_servicePath, data);
    // Populate LatexCache.
    if (!_wrs_mathmlCache.hasOwnProperty(mml)) &#123;
        _wrs_mathmlCache[mml] = latex;
    &#125;
    return latex.split(&quot;\r&quot;).join(&#39;&#39;).split(&quot;\n&quot;).join(&#39; &#39;);
&#125;
</code></pre>
<p>wrs_getLatexFromMathML只能将一个mathml转换为latex，对于编辑器里的内容来说，需要将mathML抽取出来逐一转换：</p>
<pre><code>function wrs_parseRawMathmlToLatex(content, characters)&#123;
    var output = &#39;&#39;;
    var mathTagBegin = characters.tagOpener + &#39;math&#39;;
    var mathTagEnd = characters.tagOpener + &#39;/math&#39; + characters.tagCloser;
    var start = content.indexOf(mathTagBegin);
    var end = 0;
    var mathml, startAnnotation, closeAnnotation;

    while (start != -1) &#123;
        output += content.substring(end, start);
        end = content.indexOf(mathTagEnd, start);

        if (end == -1) &#123;
            end = content.length - 1;
        &#125;
        else &#123;
            end += mathTagEnd.length;
        &#125;

        mathml = content.substring(start, end);

        output += wrs_getLatexFromMathML(mathml);

        start = content.indexOf(mathTagBegin, end);
    &#125;

    output += content.substring(end, content.length);
    return output;
&#125;
function wrs_getLatex(code) &#123;
    return wrs_parseRawMathmlToLatex(code, _wrs_xmlCharacters);
&#125;
</code></pre>
<p>末了，为了方便获取，可以将latex放到_current_latex变量里：</p>
<pre><code>    // 获取数据editor.on(&#39;getData&#39;, function (e) &#123;    e.data.dataValue = wrs_endParse(e.data.dataValue || &quot;&quot;);    _current_latex = wrs_getLatex(e.data.dataValue || &quot;&quot;);&#125;);
</code></pre>
<p>再简单修改下网页，显示latex：<br><img src="https://ooo.0o0.ooo/2017/04/21/58f9588ca5b8f.jpg" alt="enter description here" title="获取Latex"></p>
<p>收官!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/04/13/jqpeng-RPC%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/04/13/jqpeng-RPC%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">RPC框架原理与实现</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-13 16:04:00" itemprop="dateCreated datePublished" datetime="2017-04-13T16:04:00+08:00">2017-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/java-rpc.html">RPC框架原理与实现</a></p>
<p>RPC，全称 Remote Procedure Call（远程过程调用），即调用远程计算机上的服务，就像调用本地服务一样。那么RPC的原理是什么呢？了解一个技术最好的思路就是寻找一个该类型麻雀虽小五脏俱全的开源项目，不负所期，找到一个<a target="_blank" rel="noopener" href="http://git.oschina.net/huangyong/rpc">轻量级分布式 RPC 框架</a>，本文从这个项目入手来解读RPC的原理及其实现。</p>
<p>其实说到RPC，大家应该不会陌生才是，以往流行的Web Service就是一种RPC，一般来说RPC 可基于 HTTP 或 TCP 协议，因为Web Service 基于HTTP，所以具有良好的跨平台性，但由于HTTP是应用层协议，相比TCP性能有所损耗。</p>
<p>与本地调用不一样，远程调用需要通过网络层传输，因此涉及到的一个问题就是序列化，不同的序列化方式影响调用性能，流行的序列化包括Protobuf、Kryo、Hessian、Jackson、Thrift。</p>
<p>下面，让我们来一关如何从零开始实现分布式RPC框架。</p>
<h2 id="RPC框架组件"><a href="#RPC框架组件" class="headerlink" title="RPC框架组件"></a>RPC框架组件</h2><p>建设一个框架，一个系统，首先要做的就是分析需要哪些组件，他们的关系是什么？</p>
<p>简单分析下，一个RPC框架需要包括：</p>
<ul>
<li>APP ：应用端，调用服务</li>
<li>Server 服务容器，对外提供服务</li>
<li>Service Registry 服务注册表</li>
</ul>
<blockquote>
<p>我们需要将服务部署在分布式环境下的不同节点上，通过服务注册的方式，让客户端来自动发现当前可用的服务，并调用这些服务。这需要一种服务注册表（Service Registry）的组件，让它来注册分布式环境下所有的服务地址（包括：主机名与端口号）。</p>
</blockquote>
<p><img src="https://ooo.0o0.ooo/2017/04/13/58ef302271951.jpg" alt="RPC框架图" title="RPC"><br> 每台 Server 上可发布多个 Service，这些 Service 共用一个 host 与 port，在分布式环境下会提供 Server 共同对外提供 Service。此外，为防止 Service Registry 出现单点故障，因此需要将其搭建为集群环境。</p>
<h2 id="RPC框架实现"><a href="#RPC框架实现" class="headerlink" title="RPC框架实现"></a>RPC框架实现</h2><h3 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h3><p>首先定义服务接口，接口可以单独放在一个jar包中</p>
<pre><code>public interface HelloService &#123;
String hello(String name);
String hello(Person person);
&#125;
</code></pre>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>然后，增加一种实现</p>
<pre><code>@RpcService(HelloService.class)
public class HelloServiceImpl implements HelloService &#123;

    @Override
    public String hello(String name) &#123;
        return &quot;Hello! &quot; + name;
    &#125;

    @Override
    public String hello(Person person) &#123;
        return &quot;Hello! &quot; + person.getFirstName() + &quot; &quot; + person.getLastName();
    &#125;
&#125;
</code></pre>
<p>这里的RpcService注解，定义在服务接口的实现类上，可以让框架通过这个注解找到服务实现类。</p>
<p>更进一步，如果哪天服务版本升级了，但是历史服务还有人在使用，怎么办？解决方案就是服务需要分版本，按版本调用。</p>
<pre><code>@RpcService(value = HelloService.class, version = &quot;sample.hello2&quot;)
public class HelloServiceImpl2 implements HelloService &#123;

    @Override
    public String hello(String name) &#123;
        return &quot;你好! &quot; + name;
    &#125;

    @Override
    public String hello(Person person) &#123;
        return &quot;你好! &quot; + person.getFirstName() + &quot; &quot; + person.getLastName();
    &#125;
&#125;
</code></pre>
<p>再来看下 RPC 服务注解</p>
<pre><code>/**
 * RPC 服务注解（标注在服务实现类上）
 */
@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface RpcService &#123;

    /**
     * 服务接口类
     */
    Class&lt;?&gt; value();

    /**
     * 服务版本号
     */
    String version() default &quot;&quot;;
&#125;
</code></pre>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><p>Server端主要基于Netty（一个NIO框架）+Spring</p>
<p>回到开头讲的，RPC关键点之一就是传输序列化，简单来说就是客户端调用service时，需要构建一个请求，然后将这个请求序列化传输到服务端，服务端完成调用后，再将结果 序列化后返回，简单画一下：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/13/58ef300978eca.jpg" alt="RPC请求" title="RPC"></p>
<h4 id="定义Request"><a href="#定义Request" class="headerlink" title="定义Request"></a>定义Request</h4><pre><code>public class RpcRequest &#123;

    private String requestId;
    private String interfaceName;
    private String serviceVersion;
    private String methodName;
    private Class&lt;?&gt;[] parameterTypes;
    private Object[] parameters;

&#125;
</code></pre>
<h4 id="定义RpcResponse"><a href="#定义RpcResponse" class="headerlink" title="定义RpcResponse"></a>定义RpcResponse</h4><pre><code>public class RpcResponse &#123;

    private String requestId;
    private Exception exception;
    private Object result;

&#125;
</code></pre>
<h4 id="Encoder与Decoder"><a href="#Encoder与Decoder" class="headerlink" title="Encoder与Decoder"></a>Encoder与Decoder</h4><p>因为项目基于Netty，所以按Netty那一套搞就行，核心是SerializationUtil，这个根据需要可以采用不同的序列化框架，比如pb。</p>
<pre><code>public class RpcEncoder extends MessageToByteEncoder &#123;

    private Class&lt;?&gt; genericClass;

    public RpcEncoder(Class&lt;?&gt; genericClass) &#123;
        this.genericClass = genericClass;
    &#125;

    @Override
    public void encode(ChannelHandlerContext ctx, Object in, ByteBuf out) throws Exception &#123;
        if (genericClass.isInstance(in)) &#123;
            byte[] data = SerializationUtil.serialize(in);
            out.writeInt(data.length);
            out.writeBytes(data);
        &#125;
    &#125;
&#125;



public class RpcDecoder extends ByteToMessageDecoder &#123;

    private Class&lt;?&gt; genericClass;

    public RpcDecoder(Class&lt;?&gt; genericClass) &#123;
        this.genericClass = genericClass;
    &#125;

    @Override
    public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;
        if (in.readableBytes() &lt; 4) &#123;
            return;
        &#125;
        in.markReaderIndex();
        int dataLength = in.readInt();
        if (in.readableBytes() &lt; dataLength) &#123;
            in.resetReaderIndex();
            return;
        &#125;
        byte[] data = new byte[dataLength];
        in.readBytes(data);
        out.add(SerializationUtil.deserialize(data, genericClass));
    &#125;
&#125;
</code></pre>
<h4 id="扫描服务"><a href="#扫描服务" class="headerlink" title="扫描服务"></a>扫描服务</h4><p>服务端采用Spring，并且服务加了RpcService注解，所以服务器启动的时候扫描一下带RpcService的就行</p>
<p>下面的代码实现了将服务找出来，并放到handlerMap里，这样，调用服务的时候就可以根据服务名称从Map里找到服务对象，知道了服务对象和服务方法，就能直接调用了。</p>
<pre><code>    private Map&lt;String, Object&gt; handlerMap = new HashMap&lt;&gt;();

    public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123;
        // 扫描带有 RpcService 注解的类并初始化 handlerMap 对象
        Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);
        if (MapUtils.isNotEmpty(serviceBeanMap)) &#123;
            for (Object serviceBean : serviceBeanMap.values()) &#123;
                RpcService rpcService = serviceBean.getClass().getAnnotation(RpcService.class);
                String serviceName = rpcService.value().getName();
                String serviceVersion = rpcService.version();
                if (StringUtil.isNotEmpty(serviceVersion)) &#123;
                    serviceName += &quot;-&quot; + serviceVersion;
                &#125;
                handlerMap.put(serviceName, serviceBean);
            &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h4><p>按照Netty服务器标准代码，启动服务，注意Encoder和Decoder</p>
<pre><code> @Override
    public void afterPropertiesSet() throws Exception &#123;
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try &#123;
            // 创建并初始化 Netty 服务端 Bootstrap 对象
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup);
            bootstrap.channel(NioServerSocketChannel.class);
            bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                public void initChannel(SocketChannel channel) throws Exception &#123;
                    ChannelPipeline pipeline = channel.pipeline();
                    pipeline.addLast(new RpcDecoder(RpcRequest.class)); // 解码 RPC 请求
                    pipeline.addLast(new RpcEncoder(RpcResponse.class)); // 编码 RPC 响应
                    pipeline.addLast(new RpcServerHandler(handlerMap)); // 处理 RPC 请求
                &#125;
            &#125;);
            bootstrap.option(ChannelOption.SO_BACKLOG, 1024);
            bootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);
            // 获取 RPC 服务器的 IP 地址与端口号
            String[] addressArray = StringUtil.split(serviceAddress, &quot;:&quot;);
            String ip = addressArray[0];
            int port = Integer.parseInt(addressArray[1]);
            // 启动 RPC 服务器
            ChannelFuture future = bootstrap.bind(ip, port).sync();
            // 注册 RPC 服务地址
            if (serviceRegistry != null) &#123;
                for (String interfaceName : handlerMap.keySet()) &#123;
                    serviceRegistry.register(interfaceName, serviceAddress);
                    LOGGER.debug(&quot;register service: &#123;&#125; =&gt; &#123;&#125;&quot;, interfaceName, serviceAddress);
                &#125;
            &#125;
            LOGGER.debug(&quot;server started on port &#123;&#125;&quot;, port);
            // 关闭 RPC 服务器
            future.channel().closeFuture().sync();
        &#125; finally &#123;
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        &#125;
    &#125;
</code></pre>
<h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>RpcServerHandler负责处理请求，熟悉Netty的应该知道，继承SimpleChannelInboundHandler，在channelRead0函数里处理即可，注意，因为pipline里前面已经解码为RpcRequest对象了，所以在这里可以直接使用。</p>
<pre><code>    public class RpcServerHandler extends SimpleChannelInboundHandler&lt;RpcRequest&gt; &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcServerHandler.class);

    private final Map&lt;String, Object&gt; handlerMap;

    public RpcServerHandler(Map&lt;String, Object&gt; handlerMap) &#123;
        this.handlerMap = handlerMap;
    &#125;

    @Override
    public void channelRead0(final ChannelHandlerContext ctx, RpcRequest request) throws Exception &#123;
        // 创建并初始化 RPC 响应对象
        RpcResponse response = new RpcResponse();
        response.setRequestId(request.getRequestId());
        try &#123;
            Object result = handle(request);
            response.setResult(result);
        &#125; catch (Exception e) &#123;
            LOGGER.error(&quot;handle result failure&quot;, e);
            response.setException(e);
        &#125;
        // 写入 RPC 响应对象并自动关闭连接
        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
    &#125;
&#125;
</code></pre>
<p>框架没什么说的，核心是怎么handle，无非就是从Reques里获取到服务名称和版本号，然后从handlerMap里寻找服务对象，然后调用方法。</p>
<blockquote>
<p>已知方法名和Class，可以通过反射进行调用，但是反射性能较低，可以使用cglib里的FastClass来执行invoke，详情参见<a target="_blank" rel="noopener" href="http://blog.jobbole.com/105423/">说说 cglib 动态代理</a></p>
</blockquote>
<pre><code>    private Object handle(RpcRequest request) throws Exception &#123;
        // 获取服务对象
        String serviceName = request.getInterfaceName();
        String serviceVersion = request.getServiceVersion();
        if (StringUtil.isNotEmpty(serviceVersion)) &#123;
            serviceName += &quot;-&quot; + serviceVersion;
        &#125;
        Object serviceBean = handlerMap.get(serviceName);
        if (serviceBean == null) &#123;
            throw new RuntimeException(String.format(&quot;can not find service bean by key: %s&quot;, serviceName));
        &#125;
        // 获取反射调用所需的参数
        Class&lt;?&gt; serviceClass = serviceBean.getClass();
        String methodName = request.getMethodName();
        Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();
        Object[] parameters = request.getParameters();
        // 执行反射调用
//        Method method = serviceClass.getMethod(methodName, parameterTypes);
//        method.setAccessible(true);
//        return method.invoke(serviceBean, parameters);
        // 使用 CGLib 执行反射调用
        FastClass serviceFastClass = FastClass.create(serviceClass);
        FastMethod serviceFastMethod = serviceFastClass.getMethod(methodName, parameterTypes);
        return serviceFastMethod.invoke(serviceBean, parameters);
    &#125;
</code></pre>
<h4 id="服务发现与注册"><a href="#服务发现与注册" class="headerlink" title="服务发现与注册"></a>服务发现与注册</h4><p>在分布式系统里，服务的自动发现与注册是标配功能，一般来说都是使用集中配置中心，开源届有Zookeeper、etcd等实现。这里，使用zk作为配置中心。</p>
<p>服务发现与注册的核心是，服务启动时，将服务名称和服务地址写入到配置中心，客户端调用的时候，先从集中配置中心读取所要调用服务的服务器地址，如果有多个，随机挑选一个（当然随机的话会存在负载不均衡问题），连接服务器并调用。</p>
<blockquote>
<p>个人认为较好的实现方式是，服务层面加一个HA层，客户端直接调用HA，HA负责负载Service。</p>
</blockquote>
<p>回到代码解读，这里使用的zookeeper，我们来看怎么实现。</p>
<p>先是定义接口：</p>
<pre><code>public interface ServiceRegistry &#123;

    /**
     * 注册服务名称与服务地址
     *
     * @param serviceName    服务名称
     * @param serviceAddress 服务地址
     */
    void register(String serviceName, String serviceAddress);
&#125;

public interface ServiceDiscovery &#123;

    /**
     * 根据服务名称查找服务地址
     *
     * @param serviceName 服务名称
     * @return 服务地址
     */
    String discover(String serviceName);
&#125;
</code></pre>
<p>再看谈实现，zk有两种类型的节点，永久节点和临时节点，这种特性非常适合做服务发现与注册。<br> 试想：</p>
<ul>
<li>新启动一台Server，自动注册到ZK，写一个临时节点，客户端调用的时候就能读取到这个节点</li>
<li>一台Server挂了，临时节点失效，客户端调用的时候就读取不到这个节点，自然不会调用</li>
<li>当服务调用量太大，可以新启动服务，服务小的时候再停掉</li>
</ul>
<p>不再赘述，看代码：</p>
<pre><code>public class ZooKeeperServiceRegistry implements ServiceRegistry &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(ZooKeeperServiceRegistry.class);

    private final ZkClient zkClient;

    public ZooKeeperServiceRegistry(String zkAddress) &#123;
        // 创建 ZooKeeper 客户端
        zkClient = new ZkClient(zkAddress, Constant.ZK_SESSION_TIMEOUT, Constant.ZK_CONNECTION_TIMEOUT);
        LOGGER.debug(&quot;connect zookeeper&quot;);
    &#125;

    @Override
    public void register(String serviceName, String serviceAddress) &#123;
        // 创建 registry 节点（持久）
        String registryPath = Constant.ZK_REGISTRY_PATH;
        if (!zkClient.exists(registryPath)) &#123;
            zkClient.createPersistent(registryPath);
            LOGGER.debug(&quot;create registry node: &#123;&#125;&quot;, registryPath);
        &#125;
        // 创建 service 节点（持久）
        String servicePath = registryPath + &quot;/&quot; + serviceName;
        if (!zkClient.exists(servicePath)) &#123;
            zkClient.createPersistent(servicePath);
            LOGGER.debug(&quot;create service node: &#123;&#125;&quot;, servicePath);
        &#125;
        // 创建 address 节点（临时）
        String addressPath = servicePath + &quot;/address-&quot;;
        String addressNode = zkClient.createEphemeralSequential(addressPath, serviceAddress);
        LOGGER.debug(&quot;create address node: &#123;&#125;&quot;, addressNode);
    &#125;
&#125;
</code></pre>
<p>原理就是创建了一个临时节点存储服务地址</p>
<p>再来看服务发现：</p>
<pre><code>public class ZooKeeperServiceDiscovery implements ServiceDiscovery &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(ZooKeeperServiceDiscovery.class);

    private String zkAddress;

    public ZooKeeperServiceDiscovery(String zkAddress) &#123;
        this.zkAddress = zkAddress;
    &#125;

    @Override
    public String discover(String name) &#123;
        // 创建 ZooKeeper 客户端
        ZkClient zkClient = new ZkClient(zkAddress, Constant.ZK_SESSION_TIMEOUT, Constant.ZK_CONNECTION_TIMEOUT);
        LOGGER.debug(&quot;connect zookeeper&quot;);
        try &#123;
            // 获取 service 节点
            String servicePath = Constant.ZK_REGISTRY_PATH + &quot;/&quot; + name;
            if (!zkClient.exists(servicePath)) &#123;
                throw new RuntimeException(String.format(&quot;can not find any service node on path: %s&quot;, servicePath));
            &#125;
            List&lt;String&gt; addressList = zkClient.getChildren(servicePath);
            if (CollectionUtil.isEmpty(addressList)) &#123;
                throw new RuntimeException(String.format(&quot;can not find any address node on path: %s&quot;, servicePath));
            &#125;
            // 获取 address 节点
            String address;
            int size = addressList.size();
            if (size == 1) &#123;
                // 若只有一个地址，则获取该地址
                address = addressList.get(0);
                LOGGER.debug(&quot;get only address node: &#123;&#125;&quot;, address);
            &#125; else &#123;
                // 若存在多个地址，则随机获取一个地址
                address = addressList.get(ThreadLocalRandom.current().nextInt(size));
                LOGGER.debug(&quot;get random address node: &#123;&#125;&quot;, address);
            &#125;
            // 获取 address 节点的值
            String addressPath = servicePath + &quot;/&quot; + address;
            return zkClient.readData(addressPath);
        &#125; finally &#123;
            zkClient.close();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><h4 id="服务代理"><a href="#服务代理" class="headerlink" title="服务代理"></a>服务代理</h4><p>可以先查看(<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi/p/java-proxy.html">http://www.cnblogs.com/xiaoqi/p/java-proxy.html</a>)了解java的动态代理。</p>
<p>使用 Java 提供的动态代理技术实现 RPC 代理（当然也可以使用 CGLib 来实现），具体代码如下：</p>
<pre><code>public class RpcProxy &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcProxy.class);

    private String serviceAddress;

    private ServiceDiscovery serviceDiscovery;

    public RpcProxy(String serviceAddress) &#123;
        this.serviceAddress = serviceAddress;
    &#125;

    public RpcProxy(ServiceDiscovery serviceDiscovery) &#123;
        this.serviceDiscovery = serviceDiscovery;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T create(final Class&lt;?&gt; interfaceClass) &#123;
        return create(interfaceClass, &quot;&quot;);
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T create(final Class&lt;?&gt; interfaceClass, final String serviceVersion) &#123;
        // 创建动态代理对象
        return (T) Proxy.newProxyInstance(
                interfaceClass.getClassLoader(),
                new Class&lt;?&gt;[]&#123;interfaceClass&#125;,
                new InvocationHandler() &#123;
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                        // 创建 RPC 请求对象并设置请求属性
                        RpcRequest request = new RpcRequest();
                        request.setRequestId(UUID.randomUUID().toString());
                        request.setInterfaceName(method.getDeclaringClass().getName());
                        request.setServiceVersion(serviceVersion);
                        request.setMethodName(method.getName());
                        request.setParameterTypes(method.getParameterTypes());
                        request.setParameters(args);
                        // 获取 RPC 服务地址
                        if (serviceDiscovery != null) &#123;
                            String serviceName = interfaceClass.getName();
                            if (StringUtil.isNotEmpty(serviceVersion)) &#123;
                                serviceName += &quot;-&quot; + serviceVersion;
                            &#125;
                            serviceAddress = serviceDiscovery.discover(serviceName);
                            LOGGER.debug(&quot;discover service: &#123;&#125; =&gt; &#123;&#125;&quot;, serviceName, serviceAddress);
                        &#125;
                        if (StringUtil.isEmpty(serviceAddress)) &#123;
                            throw new RuntimeException(&quot;server address is empty&quot;);
                        &#125;
                        // 从 RPC 服务地址中解析主机名与端口号
                        String[] array = StringUtil.split(serviceAddress, &quot;:&quot;);
                        String host = array[0];
                        int port = Integer.parseInt(array[1]);
                        // 创建 RPC 客户端对象并发送 RPC 请求
                        RpcClient client = new RpcClient(host, port);
                        long time = System.currentTimeMillis();
                        RpcResponse response = client.send(request);
                        LOGGER.debug(&quot;time: &#123;&#125;ms&quot;, System.currentTimeMillis() - time);
                        if (response == null) &#123;
                            throw new RuntimeException(&quot;response is null&quot;);
                        &#125;
                        // 返回 RPC 响应结果
                        if (response.hasException()) &#123;
                            throw response.getException();
                        &#125; else &#123;
                            return response.getResult();
                        &#125;
                    &#125;
                &#125;
        );
    &#125;
&#125;
</code></pre>
<h4 id="RPC客户端"><a href="#RPC客户端" class="headerlink" title="RPC客户端"></a>RPC客户端</h4><p>使用RpcClient类实现 RPC 客户端，只需扩展 Netty 提供的SimpleChannelInboundHandler抽象类即可，代码如下：</p>
<pre><code>public class RpcClient extends SimpleChannelInboundHandler&lt;RpcResponse&gt; &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcClient.class);

    private final String host;
    private final int port;

    private RpcResponse response;

    public RpcClient(String host, int port) &#123;
        this.host = host;
        this.port = port;
    &#125;

    @Override
    public void channelRead0(ChannelHandlerContext ctx, RpcResponse response) throws Exception &#123;
        this.response = response;
    &#125;

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        LOGGER.error(&quot;api caught exception&quot;, cause);
        ctx.close();
    &#125;

    public RpcResponse send(RpcRequest request) throws Exception &#123;
        EventLoopGroup group = new NioEventLoopGroup();
        try &#123;
            // 创建并初始化 Netty 客户端 Bootstrap 对象
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(group);
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                public void initChannel(SocketChannel channel) throws Exception &#123;
                    ChannelPipeline pipeline = channel.pipeline();
                    pipeline.addLast(new RpcEncoder(RpcRequest.class)); // 编码 RPC 请求
                    pipeline.addLast(new RpcDecoder(RpcResponse.class)); // 解码 RPC 响应
                    pipeline.addLast(RpcClient.this); // 处理 RPC 响应
                &#125;
            &#125;);
            bootstrap.option(ChannelOption.TCP_NODELAY, true);
            // 连接 RPC 服务器
            ChannelFuture future = bootstrap.connect(host, port).sync();
            // 写入 RPC 请求数据并关闭连接
            Channel channel = future.channel();
            channel.writeAndFlush(request).sync();
            channel.closeFuture().sync();
            // 返回 RPC 响应对象
            return response;
        &#125; finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="服务测试"><a href="#服务测试" class="headerlink" title="服务测试"></a>服务测试</h4><pre><code>public class HelloClient &#123;

    public static void main(String[] args) throws Exception &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        RpcProxy rpcProxy = context.getBean(RpcProxy.class);

        HelloService helloService = rpcProxy.create(HelloService.class);
        String result = helloService.hello(&quot;World&quot;);
        System.out.println(result);

        HelloService helloService2 = rpcProxy.create(HelloService.class, &quot;sample.hello2&quot;);
        String result2 = helloService2.hello(&quot;世界&quot;);
        System.out.println(result2);

        System.exit(0);
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<pre><code>connect zookeeper
get only address node: address-0000000001
discover service: com.xxx.rpc.sample.api.HelloService =&gt; 127.0.0.1:8000
time: 569ms
Hello! World
connect zookeeper
get only address node: address-0000000001
discover service: com.xxx.rpc.sample.api.HelloService-sample.hello2 =&gt; 127.0.0.1:8000
time: 36ms
你好! 世界
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/jadepeng/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/jadepeng/">1</a><span class="space">&hellip;</span><a class="page-number" href="/jadepeng/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/jadepeng/page/10/">10</a><a class="extend next" rel="next" href="/jadepeng/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JadePeng"
      src="/jadepeng/images/avatar.gif">
  <p class="site-author-name" itemprop="name">JadePeng</p>
  <div class="site-description" itemprop="description">JadePeng的技术笔记本</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/jadepeng/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/jadepeng/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/jadepeng/tags/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JadePeng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">642k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/jadepeng/lib/anime.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.ui.min.js"></script>

<script src="/jadepeng/js/utils.js"></script>

<script src="/jadepeng/js/motion.js"></script>


<script src="/jadepeng/js/schemes/muse.js"></script>


<script src="/jadepeng/js/next-boot.js"></script>




  




  
<script src="/jadepeng/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/jadepeng/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
