<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/jadepeng/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/jadepeng/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/jadepeng/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/jadepeng/images/logo.svg" color="#222">

<link rel="stylesheet" href="/jadepeng/css/main.css">


<link rel="stylesheet" href="/jadepeng/lib/font-awesome/css/all.min.css">
<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.iflyresearch.com","root":"/jadepeng/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JadePeng的技术笔记本">
<meta property="og:type" content="website">
<meta property="og:title" content="JadePeng的技术笔记本">
<meta property="og:url" content="http://blog.iflyresearch.com/page/8/index.html">
<meta property="og:site_name" content="JadePeng的技术笔记本">
<meta property="og:description" content="JadePeng的技术笔记本">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="JadePeng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.iflyresearch.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JadePeng的技术笔记本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/jadepeng/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JadePeng的技术笔记本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">爱学习爱分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/jadepeng/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-博客">

    <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" rel="section"><i class="fa fa-th fa-fw"></i>博客</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/jadepeng/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/jadepeng/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/jadepeng/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/04/16/jqpeng-%E6%96%B0%E5%9E%8B%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E4%B8%89%E4%B8%AA%E5%A2%83%E7%95%8C%20%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BD%AC%E5%89%8D%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/04/16/jqpeng-%E6%96%B0%E5%9E%8B%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E4%B8%89%E4%B8%AA%E5%A2%83%E7%95%8C%20%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BD%AC%E5%89%8D%E7%AB%AF/" class="post-title-link" itemprop="url">新型前端开发工程师的三个境界 后端开发工程师如何快速转前端</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-16 19:14:00" itemprop="dateCreated datePublished" datetime="2018-04-16T19:14:00+08:00">2018-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/front-dev.html">新型前端开发工程师的三个境界 后端开发工程师如何快速转前端</a></p>
<p>初入软件开发这一行时，当时还没有前后端分离这个概念，所有的开发工程师既能写html，也能写后台服务，随着技术的发展，前后端分离成为趋势，目前团队不少人能熟悉的写java后台服务，却难以hold住前端页面的开发，前端页面开发成为瓶颈。针对这个情况，筹划了一个前端培训专题，让后端的同事可以通过学习快速掌握前端开发技能。</p>
<h2 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h2><ul>
<li>培养全栈工程师，前后端均可以Hold住</li>
</ul>
<h2 id="前端技能梳理"><a href="#前端技能梳理" class="headerlink" title="前端技能梳理"></a>前端技能梳理</h2><p>我们把前端同事做的事情简单的梳理下，大概可以分为：</p>
<h3 id="效果图-gt-HTML还原"><a href="#效果图-gt-HTML还原" class="headerlink" title="效果图 -&gt; HTML还原"></a>效果图 -&gt; HTML还原</h3><p>将UED设计的效果图还原为页面，这个也是以前狭义的UI完成的工作。梳理下这个工作需要的技能：</p>
<ul>
<li>熟悉HTML\CSS、熟悉常见布局，div+css</li>
<li>熟悉浏览器兼容</li>
<li>熟悉PS切图</li>
</ul>
<p>随着前端UI框架的发展，当你使用bootstrap、elements、iview这类框架时，80%的功能开发可以不需要这一步，因此一个小团队有1个这样的工程师就OK了。</p>
<h3 id="HTML-gt-应用"><a href="#HTML-gt-应用" class="headerlink" title="HTML-&gt;应用"></a>HTML-&gt;应用</h3><p>单独的HTML是缺乏灵魂的，还需要绑定数据，这样才是一个完整的页面。在前后端未分离的时代，通常是后端基于前端还原的html来进行开发，通过模板技术绑定数据。而随着ajax的兴起，前端 MVVM框架的流行，前后端分离，数据绑定工作前移到前端，因此前端的职责之一就是调用后端的服务，并显示到页面上。</p>
<p>同样的，梳理下这个工作需要的技能：</p>
<ul>
<li>了解或者熟悉html</li>
<li>熟悉HTTP</li>
<li>基本的javascript应用</li>
<li>熟悉一个js框架的应用，比如jq、vue.js</li>
</ul>
<p>一个合格的后端，在熟悉javascript的情况下，可以很快掌握。</p>
<h3 id="复杂的单页应用"><a href="#复杂的单页应用" class="headerlink" title="复杂的单页应用"></a>复杂的单页应用</h3><p>现在流行一个词“大前端”，前端更大的挑战就是构建复杂的单页应用，比如易企秀的H5编辑器，单个页面里包含了非常多的功能和逻辑，这类页面有个特点：</p>
<ul>
<li>包含复杂的业务逻辑</li>
<li>通常需要上千行的javascript代码</li>
<li>需要良好的设计模式来组织和维护代码，MVC\MVVM等概念在前端运用</li>
</ul>
<p>而随着技术的发展，javascript可以用来开发手机端app（react-native、weex），本质上来说还是开发复杂的单页应用。特别是使用vuex这类状态管理库时，如果懂的后端的数据库概念，可以事半功倍的理解其原理。</p>
<p>总结一下，开发复杂的单页应用，需要具备的技能：</p>
<ul>
<li>熟悉数据结构和算法</li>
<li>熟悉常用的设计模式</li>
<li>OOP思维</li>
<li>模块化开发</li>
<li>db思维</li>
<li>熟悉javascript，熟悉es2015\es2017</li>
</ul>
<p>一句话总结起来，<strong>复杂的前端应用开发所需要的技能，恰恰是后端开发所擅长的</strong>，只是编程语言从java、c#变成了javascript，仅此而已。</p>
<h2 id="新型前后端一体化工程师的三个境界"><a href="#新型前后端一体化工程师的三个境界" class="headerlink" title="新型前后端一体化工程师的三个境界"></a>新型前后端一体化工程师的三个境界</h2><p>怎么来评价一个人的前端能力，简单起见，划分为三个境界：</p>
<ul>
<li><p>第一层（必须具备）</p>
<ul>
<li>依葫芦画瓢</li>
<li>可以根据还原的HTML或者UI框架，实现简单页面的开发和数据绑定</li>
<li>熟悉HTML常见标签、CSS盒子模型、CSS优先级，常见布局</li>
<li>会使用Vue.js/jquery，Iview、Element等工具库</li>
</ul>
</li>
<li><p>第二层（努力可以达到）</p>
<ul>
<li>可以熟练的开发单页应用</li>
<li>javascript了然于心，es2015\2016信手拈来</li>
<li>熟悉Vue、React、angular、知道各自的优缺点，根据需要选择合理的方案</li>
<li>跟踪前端发展趋势、不盲从、独立思考</li>
</ul>
</li>
<li><p>第三层（尽量追求，需要时间和积累）</p>
<ul>
<li>融会贯通，可以改造轮子、造新的轮子提升效率</li>
<li>在公司、业界前端形成影响力</li>
</ul>
</li>
</ul>
<h2 id="培训规划"><a href="#培训规划" class="headerlink" title="培训规划"></a>培训规划</h2><p>最后来定一下培训的规划。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>所有人达到第一层境界</li>
<li>骨干需要达到第二层</li>
</ul>
<h3 id="培训内容"><a href="#培训内容" class="headerlink" title="培训内容"></a>培训内容</h3><h4 id="课时1：HTTP-HTML-CSS基础-常见布局-HTML5-CSS3"><a href="#课时1：HTTP-HTML-CSS基础-常见布局-HTML5-CSS3" class="headerlink" title="课时1：HTTP+HTML+CSS基础+常见布局+HTML5+CSS3"></a>课时1：HTTP+HTML+CSS基础+常见布局+HTML5+CSS3</h4><ul>
<li>HTTP<ul>
<li>HTTP get/post/put/delete</li>
<li>HTTP响应码</li>
<li>chrome F12 network使用</li>
</ul>
</li>
<li>html块元素、内联元素、表单</li>
<li>CSS 与盒子模型</li>
<li>响应式布局</li>
<li>H5语义标签，audio，canvas</li>
<li>CSS3动画</li>
</ul>
<h4 id="课时2：javascript-基础"><a href="#课时2：javascript-基础" class="headerlink" title="课时2：javascript 基础"></a>课时2：javascript 基础</h4><ul>
<li>数据类型，数组、对象，表达式、条件、循环等</li>
<li>javascript常用对象</li>
<li>DOM编程</li>
<li>AJAX、jsonp</li>
<li>正则、表单验证</li>
</ul>
<h4 id="课时3：javascript进阶"><a href="#课时3：javascript进阶" class="headerlink" title="课时3：javascript进阶"></a>课时3：javascript进阶</h4><ul>
<li>深入js<ul>
<li>模块化、AMD，require.js</li>
<li>作用域链</li>
<li>原型链与继承</li>
<li>闭包</li>
<li>OOP</li>
</ul>
</li>
<li>es2015/2017<ul>
<li>箭头函数等新语法糖</li>
</ul>
</li>
<li>TypeScript</li>
</ul>
<h4 id="课时4：项目框架应用-Vue-js-IView使用培训"><a href="#课时4：项目框架应用-Vue-js-IView使用培训" class="headerlink" title="课时4：项目框架应用 Vue.js +IView使用培训"></a>课时4：项目框架应用 Vue.js +IView使用培训</h4><ul>
<li>Vue.js 渐进式理解</li>
<li>Vue.js 模板绑定</li>
<li>Vue.js 组件</li>
<li>Vue.js 单页应用</li>
<li>Vuex 状态管理</li>
<li>Vue Router</li>
<li>IView 组件库介绍</li>
<li>项目案例讲解</li>
</ul>
<h4 id="课时5：基于Nodejs的前端新生态"><a href="#课时5：基于Nodejs的前端新生态" class="headerlink" title="课时5：基于Nodejs的前端新生态"></a>课时5：基于Nodejs的前端新生态</h4><ul>
<li>NodeJs原理、历史、发展</li>
<li>webpack</li>
<li>less</li>
<li>代码质量eslint</li>
</ul>
<h4 id="课时6：-vue-js与手机app、微信小程序开发"><a href="#课时6：-vue-js与手机app、微信小程序开发" class="headerlink" title="课时6： vue.js与手机app、微信小程序开发"></a>课时6： vue.js与手机app、微信小程序开发</h4><ul>
<li>使用vue.js+weex开发手机app</li>
<li>微信小程序开发</li>
</ul>
<p>最后，欢迎大家拍砖和提出建议。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/04/14/jqpeng-axios%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%20axios%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/04/14/jqpeng-axios%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%20axios%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">axios介绍与使用说明 axios中文文档</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-14 12:00:00" itemprop="dateCreated datePublished" datetime="2018-04-14T12:00:00+08:00">2018-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/axios.html">axios介绍与使用说明 axios中文文档</a></p>
<p>本周在做一个使用vuejs的前端项目，访问后端服务使用axios库，这里对照官方文档，简单记录下，也方便大家参考。</p>
<p>Axios 是一个基于  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 的 HTTP 库，可以用在浏览器和 node.js 中。github开源地址<a target="_blank" rel="noopener" href="https://github.com/axios/axios">https://github.com/axios/axios</a></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>在浏览器中创建 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a></li>
<li>在 node.js 则创建 <a target="_blank" rel="noopener" href="http://nodejs.org/api/http.html">http</a> 请求</li>
<li>支持 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</li>
<li>支持拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></li>
</ul>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>支持Chrome、火狐、Edge、IE8+等浏览器</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm安装:</p>
<pre><code>$ npm install axios
</code></pre>
<p>使用 bower:</p>
<pre><code>$ bower install axios
</code></pre>
<p>或者直接使用 cdn:</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2><p>执行 <code>GET</code> 请求</p>
<pre><code>// 为给定 ID 的 user 创建请求
axios.get(&#39;/user?ID=12345&#39;)
  .then(function (response) &#123;
    console.log(response);
  &#125;)
  .catch(function (error) &#123;
    console.log(error);
  &#125;);

// GET 参数可以放到params里（推荐）
axios.get(&#39;/user&#39;, &#123;
    params: &#123;
      ID: 12345
    &#125;
  &#125;)
  .then(function (response) &#123;
    console.log(response);
  &#125;)
  .catch(function (error) &#123;
    console.log(error);
  &#125;);

// 还可以使用ECMAScript 2017里的async/await，添加 `async` keyword to your outer function/method.
async function getUser() &#123;
  try &#123;
    const response = await axios.get(&#39;/user?ID=12345&#39;);
    console.log(response);
  &#125; catch (error) &#123;
    console.error(error);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>async/await 是 ECMAScript 2017新提供的功能 ，Internet Explorer 和一些旧的浏览器并不支持</p>
</blockquote>
<p>执行 <code>POST</code> 请求</p>
<pre><code>axios.post(&#39;/user&#39;, &#123;
    firstName: &#39;Fred&#39;,
    lastName: &#39;Flintstone&#39;
  &#125;)
  .then(function (response) &#123;
    console.log(response);
  &#125;)
  .catch(function (error) &#123;
    console.log(error);
  &#125;);
</code></pre>
<p>执行多个并发请求</p>
<pre><code>function getUserAccount() &#123;
  return axios.get(&#39;/user/12345&#39;);
&#125;

function getUserPermissions() &#123;
  return axios.get(&#39;/user/12345/permissions&#39;);
&#125;
axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) &#123;
    // 两个请求现在都执行完成
  &#125;));
</code></pre>
<h2 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h2><p>可以通过向 <code>axios</code> 传递相关配置来创建请求</p>
<h5 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h5><pre><code>// 发送 POST 请求
axios(&#123;
  method: &#39;post&#39;,
  url: &#39;/user/12345&#39;,
  data: &#123;
    firstName: &#39;Fred&#39;,
    lastName: &#39;Flintstone&#39;
  &#125;
&#125;);
//  GET 请求远程图片
axios(&#123;
  method:&#39;get&#39;,
  url:&#39;http://bit.ly/2mTM3nY&#39;,
  responseType:&#39;stream&#39;
&#125;)
  .then(function(response) &#123;
  response.data.pipe(fs.createWriteStream(&#39;ada_lovelace.jpg&#39;))
&#125;);
</code></pre>
<h5 id="axios-url-config"><a href="#axios-url-config" class="headerlink" title="axios(url[, config])"></a>axios(url[, config])</h5><pre><code>// 发送 GET 请求（默认的方法）
axios(&#39;/user/12345&#39;);
</code></pre>
<h3 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h3><p>为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求：</p>
<h5 id="axios-request-config"><a href="#axios-request-config" class="headerlink" title="axios.request(config)"></a>axios.request(config)</h5><h5 id="axios-get-url-config"><a href="#axios-get-url-config" class="headerlink" title="axios.get(url[, config])"></a>axios.get(url[, config])</h5><h5 id="axios-delete-url-config"><a href="#axios-delete-url-config" class="headerlink" title="axios.delete(url[, config])"></a>axios.delete(url[, config])</h5><h5 id="axios-head-url-config"><a href="#axios-head-url-config" class="headerlink" title="axios.head(url[, config])"></a>axios.head(url[, config])</h5><h5 id="axios-post-url-data-config"><a href="#axios-post-url-data-config" class="headerlink" title="axios.post(url[, data[, config]])"></a>axios.post(url[, data[, config]])</h5><h5 id="axios-put-url-data-config"><a href="#axios-put-url-data-config" class="headerlink" title="axios.put(url[, data[, config]])"></a>axios.put(url[, data[, config]])</h5><h5 id="axios-patch-url-data-config"><a href="#axios-patch-url-data-config" class="headerlink" title="axios.patch(url[, data[, config]])"></a>axios.patch(url[, data[, config]])</h5><h6 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h6><p>在使用别名方法时， <code>url</code>、<code>method</code>、<code>data</code> 这些属性都不必在配置中指定。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>处理并发请求的助手函数</p>
<h5 id="axios-all-iterable"><a href="#axios-all-iterable" class="headerlink" title="axios.all(iterable)"></a>axios.all(iterable)</h5><h5 id="axios-spread-callback"><a href="#axios-spread-callback" class="headerlink" title="axios.spread(callback)"></a>axios.spread(callback)</h5><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>可以使用自定义配置新建一个 axios 实例</p>
<h5 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create([config])"></a>axios.create([config])</h5><pre><code>const instance = axios.create(&#123;
  baseURL: &#39;https://some-domain.com/api/&#39;,
  timeout: 1000,
  headers: &#123;&#39;X-Custom-Header&#39;: &#39;foobar&#39;&#125;
&#125;);
</code></pre>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>以下是可用的实例方法。指定的配置将与实例的配置合并</p>
<h5 id="axios-request-config-1"><a href="#axios-request-config-1" class="headerlink" title="axios#request(config)"></a>axios#request(config)</h5><h5 id="axios-get-url-config-1"><a href="#axios-get-url-config-1" class="headerlink" title="axios#get(url[, config])"></a>axios#get(url[, config])</h5><h5 id="axios-delete-url-config-1"><a href="#axios-delete-url-config-1" class="headerlink" title="axios#delete(url[, config])"></a>axios#delete(url[, config])</h5><h5 id="axios-head-url-config-1"><a href="#axios-head-url-config-1" class="headerlink" title="axios#head(url[, config])"></a>axios#head(url[, config])</h5><h5 id="axios-post-url-data-config-1"><a href="#axios-post-url-data-config-1" class="headerlink" title="axios#post(url[, data[, config]])"></a>axios#post(url[, data[, config]])</h5><h5 id="axios-put-url-data-config-1"><a href="#axios-put-url-data-config-1" class="headerlink" title="axios#put(url[, data[, config]])"></a>axios#put(url[, data[, config]])</h5><h5 id="axios-patch-url-data-config-1"><a href="#axios-patch-url-data-config-1" class="headerlink" title="axios#patch(url[, data[, config]])"></a>axios#patch(url[, data[, config]])</h5><h2 id="请求配置项"><a href="#请求配置项" class="headerlink" title="请求配置项"></a>请求配置项</h2><p>下面是创建请求时可用的配置选项，注意只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>get</code> 方法。</p>
<pre><code>&#123;
  // `url` 是用于请求的服务器 URL
  url: &quot;/user&quot;,

  // `method` 是创建请求时使用的方法
  method: &quot;get&quot;, // 默认是 get

  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。
  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL
  baseURL: &quot;https://some-domain.com/api/&quot;,

  // `transformRequest` 允许在向服务器发送前，修改请求数据
  // 只能用在 &quot;PUT&quot;, &quot;POST&quot; 和 &quot;PATCH&quot; 这几个请求方法
  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream
  transformRequest: [function (data) &#123;
    // 对 data 进行任意转换处理

    return data;
  &#125;],

  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据
  transformResponse: [function (data) &#123;
    // 对 data 进行任意转换处理

    return data;
  &#125;],

  // `headers` 是即将被发送的自定义请求头
  headers: &#123;&quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;&#125;,

  // `params` 是即将与请求一起发送的 URL 参数
  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象
  params: &#123;
    ID: 12345
  &#125;,

  // `paramsSerializer` 是一个负责 `params` 序列化的函数
  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
  paramsSerializer: function(params) &#123;
    return Qs.stringify(params, &#123;arrayFormat: &quot;brackets&quot;&#125;)
  &#125;,

  // `data` 是作为请求主体被发送的数据
  // 只适用于这些请求方法 &quot;PUT&quot;, &quot;POST&quot;, 和 &quot;PATCH&quot;
  // 在没有设置 `transformRequest` 时，必须是以下类型之一：
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - 浏览器专属：FormData, File, Blob
  // - Node 专属： Stream
  data: &#123;
    firstName: &quot;Fred&quot;
  &#125;,

  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)
  // 如果请求话费了超过 `timeout` 的时间，请求将被中断
  timeout: 1000,

  // `withCredentials` 表示跨域请求时是否需要使用凭证
  withCredentials: false, // 默认的

  // `adapter` 允许自定义处理请求，以使测试更轻松
  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).
  adapter: function (config) &#123;
    /* ... */
  &#125;,

  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据
  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头
  auth: &#123;
    username: &quot;janedoe&quot;,
    password: &quot;s00pers3cret&quot;
  &#125;,

  // `responseType` 表示服务器响应的数据类型，可以是 &quot;arraybuffer&quot;, &quot;blob&quot;, &quot;document&quot;, &quot;json&quot;, &quot;text&quot;, &quot;stream&quot;
  responseType: &quot;json&quot;, // 默认的

  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称
  xsrfCookieName: &quot;XSRF-TOKEN&quot;, // default

  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称
  xsrfHeaderName: &quot;X-XSRF-TOKEN&quot;, // 默认的

  // `onUploadProgress` 允许为上传处理进度事件
  onUploadProgress: function (progressEvent) &#123;
    // 对原生进度事件的处理
  &#125;,

  // `onDownloadProgress` 允许为下载处理进度事件
  onDownloadProgress: function (progressEvent) &#123;
    // 对原生进度事件的处理
  &#125;,

  // `maxContentLength` 定义允许的响应内容的最大尺寸
  maxContentLength: 2000,

  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte
  validateStatus: function (status) &#123;
    return status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300; // 默认的
  &#125;,

  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目
  // 如果设置为0，将不会 follow 任何重定向
  maxRedirects: 5, // 默认的

  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：
  // `keepAlive` 默认没有启用
  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),
  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),

  // &quot;proxy&quot; 定义代理服务器的主机名称和端口
  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据
  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。
  proxy: &#123;
    host: &quot;127.0.0.1&quot;,
    port: 9000,
    auth: : &#123;
      username: &quot;mikeymike&quot;,
      password: &quot;rapunz3l&quot;
    &#125;
  &#125;,

  // `cancelToken` 指定用于取消请求的 cancel token
  // （查看后面的 Cancellation 这节了解更多）
  cancelToken: new CancelToken(function (cancel) &#123;
  &#125;)
&#125;
</code></pre>
<h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><p>axios请求的响应包含以下信息：</p>
<pre><code>&#123;
  // `data` 由服务器提供的响应
  data: &#123;&#125;,

  // `status`  HTTP 状态码
  status: 200,

  // `statusText` 来自服务器响应的 HTTP 状态信息
  statusText: &quot;OK&quot;,

  // `headers` 服务器响应的头
  headers: &#123;&#125;,

  // `config` 是为请求提供的配置信息
  config: &#123;&#125;
&#125;
</code></pre>
<p>使用 <code>then</code> 时，会接收下面这样的响应：</p>
<pre><code>axios.get(&quot;/user/12345&quot;)
  .then(function(response) &#123;
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  &#125;);
</code></pre>
<p>在使用 <code>catch</code> 时，或传递 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">rejection callback</a> 作为 <code>then</code> 的第二个参数时，响应可以通过 <code>error</code> 对象可被使用，正如在错误处理这一节所讲。</p>
<h2 id="配置的默认值-defaults"><a href="#配置的默认值-defaults" class="headerlink" title="配置的默认值/defaults"></a>配置的默认值/defaults</h2><p>你可以指定将被用在各个请求的配置默认值</p>
<h3 id="全局的-axios-默认值"><a href="#全局的-axios-默认值" class="headerlink" title="全局的 axios 默认值"></a>全局的 axios 默认值</h3><pre><code>axios.defaults.baseURL = &quot;https://api.example.com&quot;;
axios.defaults.headers.common[&quot;Authorization&quot;] = AUTH_TOKEN;
axios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;;
</code></pre>
<h3 id="自定义实例默认值"><a href="#自定义实例默认值" class="headerlink" title="自定义实例默认值"></a>自定义实例默认值</h3><pre><code>// 创建实例时设置配置的默认值
var instance = axios.create(&#123;
  baseURL: &quot;https://api.example.com&quot;
&#125;);

// 在实例已创建后修改默认值
instance.defaults.headers.common[&quot;Authorization&quot;] = AUTH_TOKEN;
</code></pre>
<h3 id="配置的优先级"><a href="#配置的优先级" class="headerlink" title="配置的优先级"></a>配置的优先级</h3><p>配置会以一个优先顺序进行合并。</p>
<p>请求的config &gt; 实例的 <code>defaults</code> 属性 &gt; 库默认值：</p>
<pre><code>// 使用由库提供的配置的默认值来创建实例
// 此时超时配置的默认值是 `0`
var instance = axios.create();

// 覆写库的超时默认值
// 现在，在超时前，所有请求都会等待 2.5 秒
instance.defaults.timeout = 2500;

// 为已知需要花费很长时间的请求覆写超时设置
instance.get(&quot;/longRequest&quot;, &#123;
  timeout: 5000
&#125;);
</code></pre>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>可以自定义拦截器，在在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p>
<pre><code>// 添加请求拦截器
axios.interceptors.request.use(function (config) &#123;
    // 在发送请求之前做些什么
    return config;
  &#125;, function (error) &#123;
    // 对请求错误做些什么
    return Promise.reject(error);
  &#125;);

// 添加响应拦截器
axios.interceptors.response.use(function (response) &#123;
    // 对响应数据做点什么
    return response;
  &#125;, function (error) &#123;
    // 对响应错误做点什么
    return Promise.reject(error);
  &#125;);
</code></pre>
<p>如果你想在稍后移除拦截器，可以这样：</p>
<pre><code>var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);
axios.interceptors.request.eject(myInterceptor);
</code></pre>
<p>可以为自定义 axios 实例添加拦截器</p>
<pre><code>var instance = axios.create();
instance.interceptors.request.use(function () &#123;/*...*/&#125;);
</code></pre>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><pre><code>axios.get(&quot;/user/12345&quot;)
  .catch(function (error) &#123;
    if (error.response) &#123;
      // 请求已发出，但服务器响应的状态码不在 2xx 范围内
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
    &#125; else &#123;
      // Something happened in setting up the request that triggered an Error
      console.log(&quot;Error&quot;, error.message);
    &#125;
    console.log(error.config);
  &#125;);
</code></pre>
<p>可以使用 <code>validateStatus</code> 配置选项定义一个自定义 HTTP 状态码的错误范围。</p>
<pre><code>axios.get(&quot;/user/12345&quot;, &#123;
  validateStatus: function (status) &#123;
    return status &lt; 500; // 状态码在大于或等于500时才会 reject
  &#125;
&#125;)
</code></pre>
<h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p>使用 <em>cancel token</em> 取消请求</p>
<blockquote>
<p>Axios 的 cancel token API 基于<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-cancelable-promises">cancelable promises proposal</a></p>
</blockquote>
<p>可以使用 <code>CancelToken.source</code> 工厂方法创建 cancel token，像这样：</p>
<pre><code>const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get(&#39;/user/12345&#39;, &#123;
  cancelToken: source.token
&#125;).catch(function(thrown) &#123;
  if (axios.isCancel(thrown)) &#123;
    console.log(&#39;Request canceled&#39;, thrown.message);
  &#125; else &#123;
    // handle error
  &#125;
&#125;);

axios.post(&#39;/user/12345&#39;, &#123;
  name: &#39;new name&#39;
&#125;, &#123;
  cancelToken: source.token
&#125;)

// cancel the request (the message parameter is optional)
source.cancel(&#39;Operation canceled by the user.&#39;);
</code></pre>
<p>还可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token：</p>
<pre><code>var CancelToken = axios.CancelToken;
var cancel;

axios.get(&quot;/user/12345&quot;, &#123;
  cancelToken: new CancelToken(function executor(c) &#123;
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  &#125;)
&#125;);

// 取消请求
cancel();
</code></pre>
<p>Note : 可以使用同一个 cancel token 取消多个请求</p>
<h2 id="请求时使用-application-x-www-form-urlencoded"><a href="#请求时使用-application-x-www-form-urlencoded" class="headerlink" title="请求时使用 application/x-www-form-urlencoded"></a>请求时使用 application/x-www-form-urlencoded</h2><p>axios会默认序列化  JavaScript 对象为 JSON. 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置.</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>在浏览器环境，你可以使用  URLSearchParams API ：:</p>
<pre><code>const params = new URLSearchParams();
params.append(&#39;param1&#39;, &#39;value1&#39;);
params.append(&#39;param2&#39;, &#39;value2&#39;);
axios.post(&#39;/foo&#39;, params);
</code></pre>
<blockquote>
<p>URLSearchParams不是所有的浏览器均支持</p>
</blockquote>
<p>除此之外，你可以使用qs库来编码数据:</p>
<pre><code>const qs = require(&#39;qs&#39;);
axios.post(&#39;/foo&#39;, qs.stringify(&#123; &#39;bar&#39;: 123 &#125;));

// Or in another way (ES6),

import qs from &#39;qs&#39;;
const data = &#123; &#39;bar&#39;: 123 &#125;;
const options = &#123;
  method: &#39;POST&#39;,
  headers: &#123; &#39;content-type&#39;: &#39;application/x-www-form-urlencoded&#39; &#125;,
  data: qs.stringify(data),
  url,
&#125;;
axios(options);
</code></pre>
<h3 id="Node-js环境"><a href="#Node-js环境" class="headerlink" title="Node.js环境"></a>Node.js环境</h3><p>在 node.js里, 可以使用 querystring module:</p>
<pre><code>const querystring = require(&#39;querystring&#39;);
axios.post(&#39;http://something.com/&#39;, querystring.stringify(&#123; foo: &#39;bar&#39; &#125;));
</code></pre>
<p>当然，同浏览器一样，你还可以使用 qs library.</p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>axios 依赖原生的 ES6 Promise 实现而<a target="_blank" rel="noopener" href="http://caniuse.com/promises">被支持</a>.<br> 如果你的环境不支持 ES6 Promise，你可以使用 <a target="_blank" rel="noopener" href="https://github.com/jakearchibald/es6-promise">polyfill</a>.</p>
<h2 id="TypeScript支持"><a href="#TypeScript支持" class="headerlink" title="TypeScript支持"></a>TypeScript支持</h2><p>axios 包含 <a target="_blank" rel="noopener" href="http://typescriptlang.org/">TypeScript</a> definitions.</p>
<pre><code>import axios from &quot;axios&quot;;
axios.get(&quot;/user?ID=12345&quot;);
</code></pre>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mzabriskie/axios/blob/master/CHANGELOG.md">变更记录</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mzabriskie/axios/blob/master/UPGRADE_GUIDE.md">升级指南</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mzabriskie/axios/blob/master/ECOSYSTEM.md">生态</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mzabriskie/axios/blob/master/CONTRIBUTING.md">贡献引导</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mzabriskie/axios/blob/master/CODE_OF_CONDUCT.md">Code of Conduct</a></li>
</ul>
<h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><p>axios 受<a target="_blank" rel="noopener" href="https://angularjs.org/">Angular</a>.提供的<a target="_blank" rel="noopener" href="https://docs.angularjs.org/api/ng/service/$http">$http service</a> 启发而创建， 致力于以提供一个脱离于ng的 <code>$http</code>模块。</p>
<h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p>采用MIT</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/04/04/jqpeng-Spring%20boot%20web%E7%A8%8B%E5%BA%8Fstatic%E8%B5%84%E6%BA%90%E6%94%BE%E5%9C%A8jar%E5%A4%96%E9%83%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/04/04/jqpeng-Spring%20boot%20web%E7%A8%8B%E5%BA%8Fstatic%E8%B5%84%E6%BA%90%E6%94%BE%E5%9C%A8jar%E5%A4%96%E9%83%A8/" class="post-title-link" itemprop="url">Spring boot web程序static资源放在jar外部</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-04 10:27:00" itemprop="dateCreated datePublished" datetime="2018-04-04T10:27:00+08:00">2018-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>731</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/8715860.html">Spring boot web程序static资源放在jar外部</a></p>
<p>spring boot程序的static目录默认在resources/static目录， 打包为jar的时候，会把static目录打包进去，这样会存在一些问题：</p>
<ul>
<li>static文件过多，造成jar包体积过大</li>
<li>临时修改不方便</li>
</ul>
<p>查看官方文档，可以发现，static其实是可以外置的。</p>
<h2 id="方法1-直接修改配置文件"><a href="#方法1-直接修改配置文件" class="headerlink" title="方法1 直接修改配置文件"></a>方法1 直接修改配置文件</h2><pre><code>spring.resources.static-locations=file:///E://resources/static
</code></pre>
<h2 id="自定义Configuration方法"><a href="#自定义Configuration方法" class="headerlink" title="自定义Configuration方法"></a>自定义Configuration方法</h2><pre><code>@Configuration
public class StaticResourceConfiguration extends WebMvcConfigurerAdapter &#123;
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;file:/path/to/my/dropbox/&quot;);
    &#125;
&#125;
</code></pre>
<p>推荐使用方法1，安全无害</p>
<p>相关阅读：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi/p/6955288.html">Spring Boot配置文件放在jar外部</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/03/08/jqpeng-%E6%98%93%E4%BC%81%E7%A7%80%E5%89%8D%E7%AB%AF%E5%8E%8B%E7%BC%A9%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/03/08/jqpeng-%E6%98%93%E4%BC%81%E7%A7%80%E5%89%8D%E7%AB%AF%E5%8E%8B%E7%BC%A9%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F/" class="post-title-link" itemprop="url">易企秀前端压缩源码分析与还原</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-08 17:50:00" itemprop="dateCreated datePublished" datetime="2018-03-08T17:50:00+08:00">2018-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/8529899.html">易企秀前端压缩源码分析与还原</a></p>
<p>你是否想知道易企秀炫酷的H5是如何实现的，原理是什么，本文会为你揭秘并还原压缩过的源代码。</p>
<p>易企秀是一款h5页面制作工具，因方便易用成为业界标杆。后续一个项目会用到类似易企秀这样的自定义H5的功能，因此首先分析下易企秀的前端代码，看看他们是怎么实现的，再取其精华去其糟粕。<br> 由于代码较多，且是压缩处理过的，阅读和还原起来较为困难，不过可以先大概分析下原理，然后有针对性的看主要代码，并借助VS Code等工具对变量、函数进行重命名，稍微耐心一点就能大概还原源代码。</p>
<h2 id="分析数据模型"><a href="#分析数据模型" class="headerlink" title="分析数据模型"></a>分析数据模型</h2><p>前端分析第一步，看看易企秀的数据模型：</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1520492536143.jpg" alt="数据模型" title="1520492536143"></p>
<p>dataList是页面配置信息，elemengts是页面元素的配置信息，obj是H5的配置信息，</p>
<h2 id="加载流程分析"><a href="#加载流程分析" class="headerlink" title="加载流程分析"></a>加载流程分析</h2><p>查看H5源代码，发现入口函数是：</p>
<pre><code> eqShow.bootstrap();
</code></pre>
<p>顺藤摸瓜，大概分析下，主要流程如下：</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1520493739334.jpg" alt="加载主要流程" title="1520493739334"></p>
<p>主要的功能函数在eqxiu和window对象下面，其中的重点是parsePage、renderPage和app,下面一一来分析。</p>
<h2 id="parsePage"><a href="#parsePage" class="headerlink" title="parsePage"></a>parsePage</h2><p>先看主要代码（重命名后的），主要功能是为每一页生成一个section并appendTo(“.nr”)，另外如果页面有特效，加载相关js库并执行，最后再renderPage。</p>
<pre><code>function parsePage(dataList, response) &#123;

        for (var pageIndex = 1; pageIndex &lt;= dataList.length; pageIndex++) &#123;
            // 分页容器
            $(&#39;&lt;section class=&quot;main-page&quot;&gt;&lt;div class=&quot;m-img&quot; id=&quot;page&#39; + pageIndex + &#39;&quot;&gt;&lt;/div&gt;&lt;/section&gt;&#39;).appendTo(&quot;.nr&quot;);

            if (10 == pageMode) &#123;
                $(&quot;#page&quot; + pageIndex).parent(&quot;.main-page&quot;).wrap(&#39;&lt;div class=&quot;flip-mask&quot; id=&quot;flip&#39; + pageIndex + &#39;&quot;&gt;&lt;/div&gt;&#39;),
                    $(&quot;.main-page&quot;).css(&#123;
                        width: $(&quot;.nr&quot;).width() + &quot;px&quot;,
                        height: $(&quot;.nr&quot;).height() + &quot;px&quot;
                    &#125;);
            &#125;

            if (dataList.length &gt; 1 &amp;&amp; 14 != pageMode &amp;&amp; !response.obj.property.forbidHandFlip) &#123;
                if (0 == pageMode || 1 == pageMode || 2 == pageMode || 6 == pageMode || 7 == pageMode ||
                    8 == pageMode || 11 == pageMode || 12 == pageMode || 13 == pageMode || 14 == pageMode) &#123;
                    $(&#39;&lt;section class=&quot;u-arrow-bottom&quot;&gt;&lt;div class=&quot;pre-wrap&quot;&gt;&lt;div class=&quot;pre-box1&quot;&gt;&lt;div class=&quot;pre1&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;pre-box2&quot;&gt;&lt;div class=&quot;pre2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&#39;)
                        .appendTo(&quot;#page&quot; + pageIndex)
                &#125; else if (3 == pageMode || 4 == pageMode || 5 == pageMode || 9 == pageMode || 10 == pageMode) &#123;
                    $(&#39;&lt;section class=&quot;u-arrow-right&quot;&gt;&lt;div class=&quot;pre-wrap-right&quot;&gt;&lt;div class=&quot;pre-box3&quot;&gt;&lt;div class=&quot;pre3&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;pre-box4&quot;&gt;&lt;div class=&quot;pre4&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&#39;)
                        .appendTo(&quot;#page&quot; + pageIndex);
                &#125;
            &#125;

              ....
           renderPage(eqShow, pageIndex, dataList);

                // 最后一页
                if (pageIndex == dataList.length) &#123;
                    eqxiu.app($(&quot;.nr&quot;), response.obj.pageMode, dataList, response);
                    addEnabledClassToPageCtrl(response);
                &#125;
            &#125;

        &#125;

        hasSymbols || addReportToLastPage(dataList, response);
    &#125;
</code></pre>
<h2 id="渲染页面和组件"><a href="#渲染页面和组件" class="headerlink" title="渲染页面和组件"></a>渲染页面和组件</h2><p>parsePage搭建了页面框架，renderPage实现页面渲染。</p>
<p>rendepage里，核心代码是：</p>
<pre><code>eqShow.templateParser(&quot;jsonParser&quot;).parse(&#123;
    def: dataList[pageIndex - 1],
    appendTo: &quot;#page&quot; + pageIndex,
    mode: &quot;view&quot;,
    disEvent: disEvent
&#125;);
</code></pre>
<p>templateParser负责将页面上的elements还原为组件，因此这里核心是要了解下templateParser，大致还原的代码如下：</p>
<pre><code>            var jsonTemplateParser = eqShow.templateParser(&quot;jsonParser&quot;, function () &#123;

                function createContainerFunction(container) &#123;
                    return function (key, value) &#123;
                        container[key] = value
                    &#125;
                &#125;

                function wrapComp(element, mode) &#123;
                    try &#123;
                        var comp = components[(&quot;&quot; + element.type).charAt(0)](element, mode)
                    &#125; catch (e) &#123;
                        return
                    &#125;
                    if (comp) &#123;
                        var elementContainer = $(&#39;&lt;li comp-drag comp-rotate class=&quot;comp-resize comp-rotate inside&quot; id=&quot;inside_&#39; + element.id + &#39;&quot; num=&quot;&#39; +
                                element.num + &#39;&quot; ctype=&quot;&#39; + element.type + &#39;&quot;&gt;&lt;/li&gt;&#39;),
                            elementType = (&quot;&quot; + element.type).charAt(0);

                        if (&quot;3&quot; !== elementType &amp;&amp; &quot;1&quot; !== elementType) &#123;
                            elementContainer.attr(&quot;comp-resize&quot;, &quot;&quot;)
                        &#125;

                        // 组件类型
                        /**
                         *  2 文本
                         *  3 背景
                         *  9 音乐
                         *  v video
                         *  4 图片
                         *  h shape形状
                         *  p 图集
                         *  5 输入框
                         *  r radio
                         *  c checkbox
                         *  z 多选按钮
                         *  a 评分组件
                         *  b 留言板
                         *  6 提交按钮
                         */
                        switch (elementType) &#123;
                            case &quot;p&quot;:
                                elementContainer.removeAttr(&quot;comp-rotate&quot;);
                                break;
                            case &quot;1&quot;:
                                elementContainer.removeAttr(&quot;comp-drag&quot;);
                                break;
                            case &quot;2&quot;: // 文本
                                elementContainer.addClass(&quot;wsite-text&quot;);
                                break;
                            case &quot;3&quot;:
                                // 背景
                                break;
                            case &quot;x&quot;:
                                elementContainer.addClass(&quot;show-text&quot;);
                                break;
                            case &quot;4&quot;:
                                // image
                                element.properties.imgStyle &amp;&amp; $(comp).css(element.properties.imgStyle), elementContainer.addClass(&quot;wsite-image&quot;);
                                break;
                            case &quot;n&quot;:
                                elementContainer.addClass(&quot;wsite-image&quot;);
                                break;
                            case &quot;h&quot;:
                                elementContainer.addClass(&quot;wsite-shape&quot;)
                                break;
                            case &quot;5&quot;:
                                elementContainer.removeAttr(&quot;comp-input&quot;);
                                break;
                            case &quot;6&quot;:
                            case &quot;8&quot;:
                                elementContainer.removeAttr(&quot;comp-button&quot;);
                                break;
                            case &quot;v&quot;:
                                elementContainer.removeAttr(&quot;comp-video&quot;);
                                elementContainer.addClass(&quot;wsite-video&quot;);
                                if (element.properties &amp;&amp; element.properties.lock) &#123;
                                    elementContainer.addClass(&quot;alock&quot;)
                                &#125;
                                break;
                            case &quot;b&quot;:
                                elementContainer.removeAttr(&quot;comp-boards&quot;);
                                elementContainer.attr(&quot;min-h&quot;, 60),
                                    elementContainer.attr(&quot;min-w&quot;, 230);
                                break;
                            default:
                                break;
                        &#125;

                        elementContainer.mouseenter(function () &#123;
                                $(this).addClass(&quot;inside-hover&quot;)
                            &#125;),
                            elementContainer.mouseleave(function () &#123;
                                $(this).removeClass(&quot;inside-hover&quot;)
                            &#125;);

                        // edit或者非文本type，再套一层
                        if (&quot;edit&quot; === jsonTemplateParser.mode || &quot;x&quot; !== (&quot;&quot; + element.type).charAt(0)) &#123;
                            var elementBoxContent = $(&#39;&lt;div class=&quot;element-box-contents&quot;&gt;&#39;),
                                elementBox = $(&#39;&lt;div class=&quot;element-box&quot;&gt;&#39;).append(elementBoxContent.append(comp));
                            elementContainer.append(elementBox),
                                &quot;5&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp; &quot;6&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp; &quot;r&quot; !== element.type &amp;&amp; &quot;c&quot; !== element.type &amp;&amp; &quot;a&quot; !== element.type &amp;&amp; &quot;8&quot; !== element.type &amp;&amp; &quot;l&quot; !== element.type &amp;&amp; &quot;s&quot; !== element.type &amp;&amp; &quot;i&quot; !== element.type &amp;&amp; &quot;h&quot; !== element.type &amp;&amp; &quot;z&quot; !== element.type || &quot;edit&quot; !== mode || $(comp).before($(&#39;&lt;div class=&quot;element&quot; style=&quot;position: absolute; height: 100%; width: 100%;z-index: 1;&quot;&gt;&#39;))
                        &#125;

                        // 文本类型，处理font
                        var k, eleFonts = element.fonts || element.css.fontFamily || element.fontFamily;
                        if (&quot;2&quot; === elementType || &quot;x&quot; === elementType) &#123;
                            for (var content = element.content, font_pattern = /font-family:(.*?);/g, matchResults = [], fonts = []; null !== (matchResults = font_pattern.exec(content));)
                                fonts.push(matchResults[1].trim());
                            if (1 !== fonts.length || &quot;defaultFont&quot; !== fonts[0] &amp;&amp; &quot;moren&quot; !== fonts[0] || (eleFonts = null),
                                eleFonts) &#123;
                                if (&quot;view&quot; === jsonTemplateParser.mode &amp;&amp; element.css.fontFamily &amp;&amp; window.scene &amp;&amp; (window.scene.publishTime || !mobilecheck() &amp;&amp; !tabletCheck() || (k = &quot;@font-face&#123;font-family:&quot; + element.css.fontFamily + &#39;;src: url(&quot;&#39; + element.properties.localFontPath + &#39;&quot;) format(&quot;truetype&quot;);&#125;&#39;,
                                        b(k))),
                                    &quot;object&quot; == typeof eleFonts &amp;&amp; eleFonts.constructor === Object) &#123;
                                    if (!jQuery.isEmptyObject(eleFonts))
                                        for (var q in eleFonts)
                                            u[q] || (&quot;edit&quot; === jsonTemplateParser.mode ? k = &quot;@font-face&#123;font-family:&quot; + q + &quot;;src: url(&quot; + PREFIX_FILE_HOST + eleFonts[q] + &quot;) format(woff);&#125;&quot; : window.scene &amp;&amp; window.scene.publishTime &amp;&amp; (k = &quot;@font-face&#123;font-family:&quot; + q + &#39;;src: url(&quot;&#39; + PREFIX_S2_URL + &quot;fc/&quot; + q + &quot;_&quot; + element.sceneId + &quot;_&quot; + scene.publishTime + &#39;.woff&quot;) format(&quot;woff&quot;);&#125;&#39;),
                                                b(k),
                                                u[q] = !0)
                                &#125; else
                                    u[eleFonts] || (&quot;edit&quot; === jsonTemplateParser.mode ? k = &quot;@font-face&#123;font-family:&quot; + eleFonts + &quot;;src: url(&quot; + PREFIX_FILE_HOST + element.preWoffPath + &quot;) format(woff);&#125;&quot; : window.scene &amp;&amp; window.scene.publishTime &amp;&amp; (k = &quot;@font-face&#123;font-family:&quot; + eleFonts + &#39;;src: url(&quot;&#39; + PREFIX_S2_URL + &quot;fc/&quot; + eleFonts + &quot;_&quot; + element.sceneId + &quot;_&quot; + scene.publishTime + &#39;.woff&quot;) format(&quot;woff&quot;);&#125;&#39;),
                                        b(k),
                                        u[eleFonts] = !0);
                                &quot;edit&quot; === jsonTemplateParser.mode &amp;&amp; localStorage.setItem(&quot;shoppingFontFamily&quot;, JSON.stringify(u))
                            &#125;
                        &#125;

                        // 处理css
                        if (element.css) &#123;
                            var elementWidth = 320 - parseInt(element.css.left, 10);
                            elementContainer.css(&#123;
                                width: elementWidth
                            &#125;);
                            elementContainer.css(&#123;
                                width: element.css.width,
                                height: element.css.height,
                                left: element.css.left,
                                top: element.css.top,
                                zIndex: element.css.zIndex,
                                bottom: element.css.bottom,
                                transform: element.css.transform
                            &#125;);
                            if (0 === element.css.boxShadowSize || &quot;&quot; + element.css.boxShadowSize == &quot;0&quot;) &#123;
                                element.css.boxShadow = &quot;0px 0px 0px rgba(0,0,0,0.5)&quot;;
                                if (&quot;edit&quot; !== jsonTemplateParser.mode &amp;&amp; &quot;x&quot; === (&quot;&quot; + element.type).charAt(0)) &#123;
                                    return elementContainer.append(comp),
                                        elementContainer.find(&quot;.element-box&quot;).css(&#123;
                                            borderStyle: element.css.borderStyle,
                                            borderWidth: element.css.borderWidth,
                                            borderColor: element.css.borderColor,
                                            borderTopLeftRadius: element.css.borderTopLeftRadius,
                                            borderTopRightRadius: element.css.borderTopRightRadius,
                                            borderBottomRightRadius: element.css.borderBottomRightRadius,
                                            borderBottomLeftRadius: element.css.borderBottomLeftRadius,
                                            boxShadow: element.css.boxShadow,
                                            backgroundColor: element.css.backgroundColor,
                                            opacity: element.css.opacity,
                                            width: &quot;100%&quot;,
                                            height: &quot;100%&quot;,
                                            overflow: &quot;hidden&quot;
                                        &#125;),
                                        elementContainer.find(&quot;img&quot;).css(&#123;
                                            width: &quot;100%&quot;
                                        &#125;),
                                        elementContainer;
                                &#125;
                            &#125;

                            // Android 微信，图片，设置borderColor
                            isAndroid() &amp;&amp;
                                isWeixin() &amp;&amp;
                                &quot;&quot; + element.type == &quot;4&quot; &amp;&amp;
                                &quot;0px&quot; !== element.css.borderRadius &amp;&amp;
                                0 === element.css.borderWidth &amp;&amp;
                                element.properties.anim &amp;&amp; (element.css.borderWidth = 1, element.css.borderColor = &quot;rgba(0,0,0,0)&quot;);

                            var elementCss = $.extend(!0, &#123;&#125;, element.css);
                            delete elementCss.fontFamily,
                                elementBox.css(elementCss).css(&#123;
                                    width: &quot;100%&quot;,
                                    height: &quot;100%&quot;,
                                    transform: &quot;none&quot;
                                &#125;),
                                elementBox.children(&quot;.element-box-contents&quot;).css(&#123;
                                    width: &quot;100%&quot;,
                                    height: &quot;100%&quot;
                                &#125;),
                                // 设置宽高
                                &quot;4&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                &quot;n&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                &quot;p&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                &quot;h&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp; &quot;t&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                &quot;z&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                $(comp).css(&#123;
                                    width: element.css.width,
                                    height: element.css.height
                                &#125;),
                                // w01 w02 设置lineHeight
                                (&quot;w01&quot; === element.type || &quot;w02&quot; === element.type) &amp;&amp;
                                $(comp).css(&#123;
                                    lineHeight: element.css.height + &quot;px&quot;
                                &#125;),
                                // shape 类型
                                &quot;h&quot; === (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                ($(comp).find(&quot;g&quot;).length ?
                                    $(comp).find(&quot;g&quot;).attr(&quot;fill&quot;, element.css.color) :
                                    $(comp).children().attr(&quot;fill&quot;, element.css.color),
                                    elementBox.children(&quot;.element-box-contents&quot;).css(&quot;position&quot;, &quot;relative&quot;))
                        &#125;
                        return elementContainer
                    &#125;
                &#125;

                /**
                 * 将element按zindex排序
                 */
                function sortElementsByZindex(elements) &#123;
                    for (var i = 0; i &lt; elements.length - 1; i++)
                        for (var j = i + 1; j &lt; elements.length; j++)
                            if (parseInt(elements[i].css.zIndex, 10) &gt; parseInt(elements[j].css.zIndex, 10)) &#123;
                                var element = elements[i];
                                elements[i] = elements[j],
                                    elements[j] = element
                            &#125;
                    for (var e = 0; e &lt; elements.length; e++)
                        elements[e].css.zIndex = e + 1 + &quot;&quot;;
                    return elements
                &#125;

                function parseElements(pageDef, $edit_wrapper, mode) &#123;
                    $edit_wrapper = $edit_wrapper.find(&quot;.edit_area&quot;);
                    var i, elements = pageDef.elements;
                    if (elements)
                        for (elements = sortElementsByZindex(elements),
                            i = 0; i &lt; elements.length; i++)
                            if (elements[i].sceneId = pageDef.sceneId,
                                &quot;&quot; + elements[i].type == &quot;3&quot;) &#123;
                                // type == 3 
                                var component = components[(&quot;&quot; + elements[i].type).charAt(0)](elements[i], $edit_wrapper);

                                // if is edit mode, dispatch edit event
                                &quot;edit&quot; === mode
                                    &amp;&amp;
                                    editEvents[(&quot;&quot; + elements[i].type).charAt(0)] &amp;&amp;
                                    editEvents[(&quot;&quot; + elements[i].type).charAt(0)](component, elements[i])
                            &#125; else &#123;
                                var comp = wrapComp(elements[i], mode);
                                if (!comp)
                                    continue;
                                $edit_wrapper.append(comp);

                                // invoke interceptors
                                for (var n = 0; n &lt; interceptors.length; n++)
                                    interceptors[n](comp, elements[i], mode);

                                afterRenderEvents[(&quot;&quot; + elements[i].type).charAt(0)] &amp;&amp;
                                    (
                                        afterRenderEvents[(&quot;&quot; + elements[i].type).charAt(0)](comp, elements[i]),
                                        &quot;edit&quot; !== mode &amp;&amp; (
                                            parseElementTrigger(comp, elements[i]),
                                            r(comp, elements[i])
                                        )
                                    ),

                                    &quot;edit&quot; === mode &amp;&amp;
                                    editEvents[(&quot;&quot; + elements[i].type).charAt(0)] &amp;&amp;
                                    editEvents[(&quot;&quot; + elements[i].type).charAt(0)](comp, elements[i])
                            &#125;
                &#125;

                function getEventHandlers() &#123;
                    return editEvents
                &#125;

                function getComponents() &#123;
                    return components
                &#125;

                function addInterceptor(interceptor) &#123;
                    interceptors.push(interceptor)
                &#125;

                function getInterceptors() &#123;
                    return interceptors
                &#125;
                var components = &#123;&#125;,
                    editEvents = &#123;&#125;,
                    afterRenderEvents = &#123;&#125;,
                    interceptors = [],
                    _width = containerWidth = 320,
                    _height = containerHeight = 486,
                    p = 1,
                    s = 1,
                    parser = &#123;
                        getComponents: getComponents,
                        getEventHandlers: getEventHandlers,
                        addComponent: createContainerFunction(components),
                        bindEditEvent: createContainerFunction(editEvents),
                        bindAfterRenderEvent: createContainerFunction(afterRenderEvents),
                        addInterceptor: addInterceptor,
                        getInterceptors: getInterceptors,
                        wrapComp: wrapComp,
                        disEvent: !1,
                        mode: &quot;view&quot;,
                        parse: function (parseInfo) &#123;
                            var edit_wrapper = $(&#39;&lt;div class=&quot;edit_wrapper&quot; data-scene-id=&quot;&#39; + parseInfo.def.sceneId + &#39;&quot;&gt;&lt;ul eqx-edit-destroy id=&quot;edit_area&#39; + parseInfo.def.id + &#39;&quot; paste-element class=&quot;edit_area weebly-content-area weebly-area-active&quot;&gt;&lt;/div&gt;&#39;),
                                mode = this.mode = parseInfo.mode;
                            // page 定义
                            this.def = parseInfo.def,
                                parseInfo.disEvent &amp;&amp; (this.disEvent = !0),
                                &quot;view&quot; === mode &amp;&amp; tplCount++;
                            // 页面容器
                            var pageContainer = $(parseInfo.appendTo);
                            return containerWidth = pageContainer.width(),
                                containerHeight = pageContainer.height(),
                                p = _width / containerWidth,
                                s = _height / containerHeight,
                                parseElements(parseInfo.def, edit_wrapper.appendTo($(parseInfo.appendTo)), mode)
                        &#125;
                    &#125;;
                return parser
            &#125;);
</code></pre>
<p>上面的重点是parseElements，先把elements按zindex排序，然后逐个渲染。<br> 注意，渲染是根据elementType,从components找到对应的组件，然后创建一个实例，因此这里要单独说下组件是如何定义的。</p>
<p>先看下一个组件的配置信息大概是这样，有id，css，type和动画等配置信息：</p>
<pre><code>    &#123;
    &quot;id&quot;: 29,
    &quot;css&quot;: &#123;
        &quot;top&quot;: 124.93546211843,
        &quot;left&quot;: 62.967731059217,
        &quot;color&quot;: &quot;#676767&quot;,
        &quot;width&quot;: 195,
        &quot;height&quot;: 195,
        &quot;zIndex&quot;: &quot;1&quot;,
        &quot;opacity&quot;: 1,
        &quot;boxShadow&quot;: &quot;0px 0px 0px rgba(0,0,0,0.5)&quot;,
        &quot;transform&quot;: &quot;rotateZ(45deg)&quot;,
        &quot;lineHeight&quot;: 1,
        &quot;paddingTop&quot;: 0,
        &quot;borderColor&quot;: &quot;rgba(255,255,255,1)&quot;,
        &quot;borderStyle&quot;: &quot;double&quot;,
        &quot;borderWidth&quot;: 4,
        &quot;borderRadius&quot;: &quot;0px&quot;,
        &quot;boxShadowSize&quot;: 0,
        &quot;paddingBottom&quot;: 0,
        &quot;backgroundColor&quot;: &quot;rgba(252,230,238,0.16)&quot;,
        &quot;borderRadiusPerc&quot;: 0,
        &quot;boxShadowDirection&quot;: 0,
        &quot;textAlign&quot;: &quot;left&quot;,
        &quot;borderBottomRightRadius&quot;: &quot;0px&quot;,
        &quot;borderBottomLeftRadius&quot;: &quot;0px&quot;,
        &quot;borderTopRightRadius&quot;: &quot;0px&quot;,
        &quot;borderTopLeftRadius&quot;: &quot;0px&quot;
    &#125;,
    &quot;type&quot;: &quot;2&quot;,
    &quot;pageId&quot;: &quot;24642&quot;,
    &quot;content&quot;: &quot;&lt;div style=\&quot;text-align: center;\&quot;&gt;&lt;br&gt;&lt;/div&gt;&quot;,
    &quot;sceneId&quot;: 8831293,
    &quot;properties&quot;: &#123;
        &quot;anim&quot;: &#123;
            &quot;type&quot;: 4,
            &quot;delay&quot;: 0.6,
            &quot;countNum&quot;: 1,
            &quot;duration&quot;: 1,
            &quot;direction&quot;: 0
        &#125;,
        &quot;width&quot;: 195,
        &quot;height&quot;: 195
    &#125;
&#125;
</code></pre>
<p>jsonParser里用一个components对象存储组件，通过addComponent添加组件，key就是组件的type：</p>
<pre><code>addComponent: createContainerFunction(components)
function createContainerFunction(container) &#123;
                return function (key, value) &#123;
                    container[key] = value
                &#125;
            &#125;
</code></pre>
<p>添加组件时，type 作为key，value为创建组件的函数：</p>
<pre><code>// 添加组件1jsonTemplateParser.addComponent(&quot;1&quot;, function (element, mode) &#123;    var comp = document.createElement(&quot;div&quot;);    if (comp.id = element.id,        comp.setAttribute(&quot;class&quot;, &quot;element comp_title&quot;),        // 设置组件content        element.content &amp;&amp; (comp.textContent = element.content),        element.css) &#123;        var item, elementCss = element.css;        for (item in elementCss)            comp.style[item] = elementCss[item]    &#125;    if (element.properties.labels)        for (var labels = element.properties.labels, f = 0; f &lt; labels.length; f++)            $(&#39;&lt;a class = &quot;label_content&quot; style = &quot;display: inline-block;&quot;&gt;&#39;)            .appendTo($(comp))            .html(labels[f].title)            .css(labels[f].color)            .css(&quot;width&quot;, 100 / labels.length + &quot;%&quot;);    return comp&#125;);
</code></pre>
<p>这样渲染组件时，根据element的类型就能找到createCompFunction，从而创建组件。</p>
<h2 id="组件动画播放"><a href="#组件动画播放" class="headerlink" title="组件动画播放"></a>组件动画播放</h2><p>H5之所以炫酷，很大一部分因为每个组件都有定制好的CSS3动画，我们这里来看看这些动画是如何执行的。</p>
<p>代码还是上一部分的代码，我们注意到组件渲染后，有一段代码;</p>
<pre><code>  // invoke interceptorsfor (var n = 0; n &lt; interceptors.length; n++)    interceptors[n](comp, elements[i], mode);
</code></pre>
<p>执行interceptors，这个interceptors可以通过addInterceptor注册拦截器，在组件渲染完成后会调用定义的拦截器，组件的动画就是这样来调用的。</p>
<pre><code>        // 添加拦截器执行动画
        jsonTemplateParser.addInterceptor(function (comp, element, mode) &#123;
            eqxCommon.animation(comp, element, mode, jsonTemplateParser.def.properties)
        &#125;);
</code></pre>
<p>我们发现，eqxiu通过addInterceptor注册了一个拦截器，该拦截器调用eqxCommon.animation执行组件动画，因此分析eqxCommon.animation就可以了解动画是如何实现的。</p>
<p>还是先看element里的定义：</p>
<pre><code>     &quot;properties&quot;: &#123;        &quot;anim&quot;: &#123;            &quot;type&quot;: 4,            &quot;delay&quot;: 0.6,            &quot;countNum&quot;: 1,            &quot;duration&quot;: 1,            &quot;direction&quot;: 0        &#125;,
</code></pre>
<p>我们看到，anim里定义了type，delay，duration等配置信息，可以设想播放动画无非就是解析这个配置，然后执行，其中type应该是对应的各种动画类型，分析代码吧，下面给出破解后的代码：</p>
<pre><code>        // 动画播放序号
        var animIndex = 0;

        // 处理动画属性
        if (element.properties &amp;&amp; element.properties.anim) &#123;
            var anim = [];
            element.properties.anim.length ? anim = element.properties.anim : anim.push(element.properties.anim);
            var elementBox = $(&quot;.element-box&quot;, comp);
            elementBox.attr(&quot;element-anim&quot;, &quot;&quot;);

            // 找出animations
            for (var animType, animTypes = [], anims = [], index = 0, animLength = anim.length; animLength &gt; index; index++)
                if (null != anim[index].type &amp;&amp;
                    -1 != anim[index].type) &#123;
                    animType = eqxCommon.convertType(anim[index]),
                        animTypes.push(animType),
                        anims.push(anim[index]);
                &#125;

            if (properties &amp;&amp; properties.scale)
                return;

            // 动画播放类型
            element.properties.anim.trigger ?
                comp.click(function () &#123;
                    // 点击播放
                    playAnimation(elementBox, animType, element.properties.anim)
                &#125;) :
                properties &amp;&amp; properties.longPage ?
                playAnimation(elementBox, animTypes, anims, !0, element.css) // longpage
                :
                playAnimation(elementBox, animTypes, anims)
        &#125;
</code></pre>
<p>上面的逻辑是先从element里找到anim，放入数组，然后再playAnimation。这里使用了convertType函数将数字type转换为真实的动画类型：</p>
<pre><code>var convertType = function (a) &#123;
        var animType, c, d = a.type;
        return &quot;typer&quot; === d &amp;&amp; (animType = &quot;typer&quot;),
            0 === d &amp;&amp; (animType = &quot;fadeIn&quot;),
            1 === d &amp;&amp; (c = a.direction,
                0 === c &amp;&amp; (animType = &quot;fadeInLeft&quot;),
                1 === c &amp;&amp; (animType = &quot;fadeInDown&quot;),
                2 === c &amp;&amp; (animType = &quot;fadeInRight&quot;),
                3 === c &amp;&amp; (animType = &quot;fadeInUp&quot;)),
            6 === d &amp;&amp; (animType = &quot;wobble&quot;),
            5 === d &amp;&amp; (animType = &quot;rubberBand&quot;),
            7 === d &amp;&amp; (animType = &quot;rotateIn&quot;),
            8 === d &amp;&amp; (animType = &quot;flip&quot;),
            9 === d &amp;&amp; (animType = &quot;swing&quot;),
            2 === d &amp;&amp; (c = a.direction,
                0 === c &amp;&amp; (animType = &quot;bounceInLeft&quot;),
                1 === c &amp;&amp; (animType = &quot;bounceInDown&quot;),
                2 === c &amp;&amp; (animType = &quot;bounceInRight&quot;),
                3 === c &amp;&amp; (animType = &quot;bounceInUp&quot;)),
            3 === d &amp;&amp; (animType = &quot;bounceIn&quot;),
            4 === d &amp;&amp; (animType = &quot;zoomIn&quot;),
            10 === d &amp;&amp; (animType = &quot;fadeOut&quot;),
            11 === d &amp;&amp; (animType = &quot;flipOutY&quot;),
            12 === d &amp;&amp; (animType = &quot;rollIn&quot;),
            13 === d &amp;&amp; (animType = &quot;lightSpeedIn&quot;),
            14 === d &amp;&amp; (animType = &quot;bounceOut&quot;),
            15 === d &amp;&amp; (animType = &quot;rollOut&quot;),
            16 === d &amp;&amp; (animType = &quot;lightSpeedOut&quot;),
            17 === d &amp;&amp; (c = a.direction,
                0 === c &amp;&amp; (animType = &quot;fadeOutRight&quot;),
                1 === c &amp;&amp; (animType = &quot;fadeOutDown&quot;),
                2 === c &amp;&amp; (animType = &quot;fadeOutLeft&quot;),
                3 === c &amp;&amp; (animType = &quot;fadeOutUp&quot;)),
            18 === d &amp;&amp; (animType = &quot;zoomOut&quot;),
            19 === d &amp;&amp; (c = a.direction,
                0 === c &amp;&amp; (animType = &quot;bounceOutRight&quot;),
                1 === c &amp;&amp; (animType = &quot;bounceOutDown&quot;),
                2 === c &amp;&amp; (animType = &quot;bounceOutLeft&quot;),
                3 === c &amp;&amp; (animType = &quot;bounceOutUp&quot;)),
            20 === d &amp;&amp; (animType = &quot;flipInY&quot;),
            21 === d &amp;&amp; (animType = &quot;tada&quot;),
            22 === d &amp;&amp; (animType = &quot;jello&quot;),
            23 === d &amp;&amp; (animType = &quot;flash&quot;),
            26 === d &amp;&amp; (animType = &quot;twisterInDown&quot;),
            27 === d &amp;&amp; (animType = &quot;puffIn&quot;),
            28 === d &amp;&amp; (animType = &quot;puffOut&quot;),
            29 === d &amp;&amp; (animType = &quot;slideDown&quot;),
            30 === d &amp;&amp; (animType = &quot;slideUp&quot;),
            24 === d &amp;&amp; (animType = &quot;flipInX&quot;),
            25 === d &amp;&amp; (animType = &quot;flipOutX&quot;),
            31 === d &amp;&amp; (animType = &quot;twisterInUp&quot;),
            32 == d &amp;&amp; (animType = &quot;vanishOut&quot;),
            33 == d &amp;&amp; (animType = &quot;vanishIn&quot;),
            animType
    &#125;;
</code></pre>
<p>播放动画函数在playAnimation里：</p>
<ul>
<li>大概是先判断类型是否是typer，typer的话是打字机特效，调用相关代码</li>
<li>设置element的的css animation属性，本质上是CSS3的animation动画,可以参见（<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/css3/css3_animation.asp%EF%BC%89">http://www.w3school.com.cn/css3/css3_animation.asp）</a></li>
</ul>
<pre><code> elementBox.css(&quot;animation&quot;, &quot;&quot;);
                elementBox.css(&quot;animation&quot;, animTypes[animIndex] + &quot; &quot; + anims[animIndex].duration + &quot;s ease &quot; + anims[animIndex].delay + &quot;s &quot; +
                    (anims[animIndex].countNum ? anims[animIndex].countNum : &quot;&quot;));                 anims[animIndex].count &amp;&amp; animIndex == anims.length - 1 &amp;&amp; elementBox.css(&quot;animation-iteration-count&quot;, &quot;infinite&quot;);
                    elementBox.css(&quot;animation-fill-mode&quot;, &quot;both&quot;);
</code></pre>
<p>最后，如果有多个动画，在播放完成后继续播放下一个：</p>
<pre><code>// 动画播放结束，播放下一个动画（一个组件可能有多个动画）
                elementBox.one(&quot;webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend&quot;, function () &#123;
                    animIndex++;
                    playAnimation(elementBox, animTypes, anims);
                &#125;)
</code></pre>
<h2 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h2><p>由于是多页应用，因此涉及到页面切换，并且页面切换时还需要有对应的切换动画，改工作是由一个eqxiu对象来管理和实现的。</p>
<p>老套路，先看这块的配置吧，页面的配置在obj下面,其中pageMode定义了翻页效果：</p>
<pre><code>&quot;obj&quot;: &#123;
    &quot;id&quot;: 8831293,
    &quot;name&quot;: &quot;房产广告&quot;,
    &quot;createUser&quot;: &quot;1&quot;,
    &quot;type&quot;: 103,
    &quot;pageMode&quot;: 4,
    &quot;image&quot;: &#123;&#125;,
    &quot;property&quot;: &quot;&#123;\&quot;triggerLoop\&quot;:true,\&quot;slideNumber\&quot;:true,\&quot;autoFlipTime\&quot;:4,\&quot;shareDes\&quot;:\&quot;\&quot;,\&quot;eqAdType\&quot;:1,\&quot;hideEqAd\&quot;:false,\&quot;autoFlip\&quot;:true,\&quot;lastPageId\&quot;:604964&#125;&quot;,
    &quot;timeout&quot;: &quot;&quot;,
    &quot;timeout_url&quot;: &quot;&quot;,
    &quot;accessCode&quot;: null,
    &quot;cover&quot;: &quot;syspic/pageimg/yq0KA1UrbkOAV_yiAAFuhyGx9LE397.jpg&quot;,
    &quot;bgAudio&quot;: &quot;&#123;\&quot;url\&quot;:\&quot;syspic/mp3/yq0KA1RHT3iAMXYOAAgPq1MjV9M930.mp3\&quot;,\&quot;type\&quot;:\&quot;3\&quot;&#125;&quot;,
    &quot;isTpl&quot;: 0,
    &quot;isPromotion&quot;: 0,
    &quot;status&quot;: 1,
    &quot;openLimit&quot;: 0,
    &quot;startDate&quot;: null,
    &quot;endDate&quot;: null,
    &quot;updateTime&quot;: 1426045746000,
    &quot;createTime&quot;: 1426572693000,
    &quot;publishTime&quot;: 1426572693000,
    &quot;applyTemplate&quot;: 0,
    &quot;applyPromotion&quot;: 0,
    &quot;sourceId&quot;: null,
    &quot;code&quot;: &quot;U903078B74Q5&quot;,
    &quot;description&quot;: &quot;房产广告&quot;,
    &quot;sort&quot;: 0,
    &quot;pageCount&quot;: 0,
    &quot;dataCount&quot;: 0,
    &quot;showCount&quot;: 44,
    &quot;eqcode&quot;: &quot;&quot;,
    &quot;userLoginName&quot;: null,
    &quot;userName&quot;: null
&#125;,
</code></pre>
<p>pagemode是这样定义的：</p>
<pre><code>pagemodes = [&#123;        id: 0,        name: &quot;上下翻页&quot;    &#125;, &#123;        id: 4,        name: &quot;左右翻页&quot;    &#125;, &#123;        id: 1,        name: &quot;上下惯性翻页&quot;    &#125;, &#123;        id: 3,        name: &quot;左右惯性翻页&quot;    &#125;, &#123;        id: 11,        name: &quot;上下连续翻页&quot;    &#125;, &#123;        id: 5,        name: &quot;左右连续翻页&quot;    &#125;, &#123;        id: 6,        name: &quot;立体翻页&quot;    &#125;, &#123;        id: 7,        name: &quot;卡片翻页&quot;    &#125;, &#123;        id: 8,        name: &quot;放大翻页&quot;    &#125;, &#123;        id: 9,        name: &quot;交换翻页&quot;    &#125;, &#123;        id: 10,        name: &quot;翻书翻页&quot;    &#125;, &#123;        id: 12,        name: &quot;掉落翻页&quot;    &#125;, &#123;        id: 13,        name: &quot;淡入翻页&quot;    &#125;];
</code></pre>
<p>在renderpage结束后，调用eqxiu.app：</p>
<pre><code>                  // 最后一页
                if (pageIndex == dataList.length) &#123;
                    eqxiu.app($(&quot;.nr&quot;), response.obj.pageMode, dataList, response);
                    addEnabledClassToPageCtrl(response);
                &#125;
</code></pre>
<p>来分析eqxiu.app代码，通过pagemode，我们可以看出翻页打开分为上下翻页、左右翻页两个大类：</p>
<pre><code>if (&quot;8&quot; == pageMode || &quot;9&quot; == pageMode) &#123;
            transformTime = 0.7;
            timeoutDelay = 800;
        &#125;
        // 上下翻页  上下惯性翻页 立体翻页 卡片翻页 放大翻页 上下连续翻页 上下连续翻页
        if (0 == pageMode || (1 == pageMode || (2 == pageMode || (6 == pageMode || (7 == pageMode || (8 == pageMode || (11 == pageMode || 12 == pageMode))))))) &#123;
            /** @type &#123;boolean&#125; */
            upDownMode = true;
        &#125; else &#123;
            // 左右惯性翻页 左右翻页 左右连续翻页  翻书翻页
            if (3 == pageMode || (4 == pageMode || (5 == pageMode || 10 == pageMode))) &#123;
                /** @type &#123;boolean&#125; */
                leftRightMode = true;
            &#125;
        &#125;
</code></pre>
<p>然后配置里有一个autoFlip，代表是否自动翻页,通过setInterval设置定时翻页任务：</p>
<pre><code>        // 自动翻页
        if (response.obj.property.autoFlip) &#123;
            // 自动翻页时间
            autoFlipTimeMS = 1000 * response.obj.property.autoFlipTime;
            setAndStartAutoFlip(autoFlipTimeMS);
        &#125;    
    /**
     * 设置翻页时间间隔并启动翻页
     * @param &#123;number&#125; textStatus
     * @return &#123;undefined&#125;
     */
    function setAndStartAutoFlip(autoFlipTime) &#123;
        autoFlipTime = autoFlipTime;
        pauseAutoFlip();
        startAutoFlip();
    &#125;           /**
     * 启动自动翻页
     * @return &#123;undefined&#125;
     */
    function startAutoFlip() &#123;
        // 通过setInterval
        autoFlipIntervalId = setInterval(function () &#123;
            if (!(10 === self._scrollMode)) &#123;
                if (!isTouching) &#123;
                    nextPage();
                &#125;
            &#125;
        &#125;, autoFlipTimeMS);
    &#125;
</code></pre>
<p>默认情况下H5是支持touch滑动翻页的，这种滑动操作一般是监听相关事件，开始滑动、滑动中和滑动结束，为了同时支持移动端和PC端，还需要加上鼠标点击事件：</p>
<pre><code>        var isTouch = false;
        self._$app.on(&quot;mousedown touchstart&quot;, function (e) &#123;
            if (!self._isforbidHandFlip) &#123;
                onTouchStart(e);
                isTouch = true;
            &#125;
        &#125;).on(&quot;mousemove touchmove&quot;, function (e) &#123;
            if (!self._isforbidHandFlip) &#123;
                if (isTouch) &#123;
                    onTouchMove(e);
                &#125;
            &#125;
        &#125;).on(&quot;mouseup touchend mouseleave&quot;, function (events) &#123;
            if (!self._isforbidHandFlip) &#123;
                onTouchEnd(events);
                /** @type &#123;boolean&#125; */
                isTouch = false;
            &#125;
        &#125;);
</code></pre>
<p>翻页的核心无非就是判断位移是否超过特定的值，比如左右翻页X位移是否大于Y位移并且X的偏移量大于20。因此onTouchStart开始时，记录初始位置，onTouchMove时计算offset变化，按照pageMode执行对应的动画，onTouchEnd时判断位移是否足够，足够就切换页面，否则复位。</p>
<pre><code>/**
         * 开始滑动
         * @param &#123;Object&#125; e
         * @return &#123;undefined&#125;
         */
        onTouchStart = function (e) &#123;
            /** @type &#123;boolean&#125; */
            fa = false;
            if (isMobile) &#123;
                if (e) &#123;
                    e = event;
                &#125;
            &#125;
            if (!self._isDisableFlipPage) &#123;
                self.$currentPage = self._$pages.filter(&quot;.z-current&quot;).get(0);
                if (!C) &#123;
                    /** @type &#123;null&#125; */
                    self.$activePage = null;
                &#125;
                if (self.$currentPage) &#123;
                    if (completeEffect($(self.$currentPage))) &#123;
                        isTouching = true;
                        isCursorAtEnd = false;
                        ignoreEvent = true;
                        offsetX = 0;
                        offsetY = 0;
                        if (e &amp;&amp; &quot;mousedown&quot; == e.type) &#123;
                            currentPageX = e.pageX;
                            currentPageY = e.pageY;
                        &#125; else if (e &amp;&amp; &quot;touchstart&quot; == e.type) &#123;
                            currentPageX = e.touches ? e.touches[0].pageX : e.originalEvent.touches[0].pageX;
                            currentPageY = e.touches ? e.touches[0].pageY : e.originalEvent.touches[0].pageY;
                        &#125;
                        self.$currentPage.classList.add(&quot;z-move&quot;);
                        setAttribute(self.$currentPage.style, &quot;Transition&quot;, &quot;none&quot;);
                        if (&quot;12&quot; == self._scrollMode) &#123;
                            /** @type &#123;number&#125; */
                            self.$currentPage.style.zIndex = 3;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;;

        /**
         * 滑动处理
         * @param &#123;Object&#125; e
         * @return &#123;undefined&#125;
         */
        onTouchMove = function (e) &#123;
            if (isMobile) &#123;
                if (e) &#123;
                    e = event;
                &#125;
            &#125;
            if (isTouching) &#123;
                if (self._$pages.length &gt; 1) &#123;
                    if (e &amp;&amp; &quot;mousemove&quot; == e.type) &#123;
                        offsetX = e.pageX - currentPageX;
                        offsetY = e.pageY - currentPageY;
                    &#125; else &#123;
                        if (e) &#123;
                            if (&quot;touchmove&quot; == e.type) &#123;
                                offsetX = (e.touches ? e.touches[0].pageX : e.originalEvent.touches[0].pageX) - currentPageX;
                                offsetY = (e.touches ? e.touches[0].pageY : e.originalEvent.touches[0].pageY) - currentPageY;
                            &#125;
                        &#125;
                    &#125;
                    if (!fa) &#123;
                        if (Math.abs(offsetX) &gt; 20 || Math.abs(offsetY) &gt; 20) &#123;
                            /** @type &#123;boolean&#125; */
                            fa = true;
                        &#125;
                    &#125;

                    switch (self._scrollMode + &quot;&quot;) &#123;
                        case &quot;0&quot;:
                        case &quot;1&quot;:
                        case &quot;2&quot;:
                        case &quot;15&quot;:
                            //上下翻页
                            upDownFlip();
                            break;
                        case &quot;3&quot;:
                        case &quot;4&quot;:
                            // 左右翻页
                            leftRightFlip();
                            break;
                        case &quot;5&quot;:
                            // 左右连续翻页
                            leftRightLoopFlip();
                            break;
                        case &quot;7&quot;:
                            cardFlip();
                            break;
                        case &quot;8&quot;:
                            scaleUpFlip();
                            break;
                        case &quot;9&quot;:
                            switchFlip();
                            break;
                        case &quot;11&quot;:
                            //上下连续翻页
                            upDownContinuousFlip();
                            break;
                        case &quot;12&quot;:
                            //掉落翻页
                            dropFlip();
                            break;
                        case &quot;13&quot;:
                        case &quot;14&quot;:
                            //淡入翻页
                            fadeFlip();
                            break;
                        default:
                            break;
                    &#125;
                &#125;
            &#125;
        &#125;;


        /**
         *  滑动结束
         * @param &#123;?&#125; e
         * @return &#123;undefined&#125;
         */
        onTouchEnd = function (e) &#123;
            if (isTouching &amp;&amp; completeEffect($(self.$currentPage))) &#123;
                isTouching = false;
                if (self.$activePage) &#123;
                    self._isDisableFlipPage = true;
                    var ease;
                    ease = &quot;6&quot; == self._scrollMode || &quot;7&quot; == self._scrollMode ? &quot;cubic-bezier(0,0,0.99,1)&quot; : &quot;12&quot; == self._scrollMode ? &quot;cubic-bezier(.17,.67,.87,.13)&quot; : &quot;linear&quot;;
                    self.$currentPage.style.webkitTransition = &quot;-webkit-transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$activePage.style.webkitTransition = &quot;-webkit-transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$currentPage.style.mozTransition = &quot;-moz-transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$activePage.style.mozTransition = &quot;-moz-transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$currentPage.style.transition = &quot;transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$activePage.style.transition = &quot;transform &quot; + transformTime + &quot;s &quot; + ease;

                    // 完成翻页
                    if (&quot;0&quot; == self._scrollMode || (&quot;2&quot; == self._scrollMode || (&quot;1&quot; == self._scrollMode || &quot;15&quot; == self._scrollMode))) &#123;
                        endUpDownFlip();
                    &#125; else if (&quot;4&quot; == self._scrollMode || &quot;3&quot; == self._scrollMode) &#123;
                        // 左右翻页
                        endLeftRightFlip();
                    &#125; else if (&quot;5&quot; == self._scrollMode) &#123;
                        //左右连续翻页
                        endLeftRightContinueFlip();
                    &#125; else if (&quot;6&quot; == self._scrollMode) &#123;
                        //立体翻页
                        endCubeFlip();
                    &#125; else if (&quot;7&quot; == self._scrollMode) &#123;
                        //卡片翻页
                        endCardFlip();
                    &#125; else if (&quot;8&quot; == self._scrollMode) &#123;
                        //放大翻页
                        endScaleUpFlip();
                    &#125; else if (&quot;9&quot; == self._scrollMode) &#123;
                        //交换翻页
                        endSwitchFlip();
                    &#125; else if (&quot;11&quot; == self._scrollMode) &#123;
                        //上下连续翻页
                        endUpDownContinueFlip();
                    &#125; else if (&quot;12&quot; == self._scrollMode) &#123;
                        //掉落翻页
                        endDropFlip();
                    &#125; else if (&quot;13&quot; == self._scrollMode || &quot;14&quot; == self._scrollMode) &#123;
                        //淡入翻页
                        endFadeFlip();
                    &#125; 

                    /** @type &#123;number&#125; */
                    var pageIndex = $(self.$activePage).find(&quot;.m-img&quot;).attr(&quot;id&quot;).replace(&quot;page&quot;, &quot;&quot;) - 1;
                    if (self._pageData[pageIndex].properties) &#123;
                        if (self._pageData[pageIndex].properties.longPage) &#123;
                            $(document).trigger(&quot;clearTouchPos&quot;);
                        &#125;
                    &#125;
                    $(self.$activePage).find(&quot;li.comp-resize&quot;).each(function (dataAndEvents) &#123;
                        /** @type &#123;number&#125; */
                        var i = 0;
                        for (; i &lt; self._pageData[pageIndex].elements.length; i++) &#123;
                            if (self._pageData[pageIndex].elements[i].id == parseInt($(this).attr(&quot;id&quot;).substring(7), 10)) &#123;
                                eqxCommon.animation($(this), self._pageData[pageIndex].elements[i], &quot;view&quot;, self._pageData[pageIndex].properties);
                                var r20 = getComp(self._pageData[pageIndex].elements[i].id);
                                eqxCommon.bindTrigger(r20, self._pageData[pageIndex].elements[i]);
                            &#125;
                        &#125;
                    &#125;);
                    /** @type &#123;number&#125; */
                    var i = 0;
                    for (; i &lt; self._pageData.length; i++) &#123;
                        if (self._pageData[i].effObj) &#123;
                            /** @type &#123;boolean&#125; */
                            self._pageData[i].effObj.pause = true;
                        &#125;
                    &#125;
                    if (self._pageData[pageIndex].effObj) &#123;
                        self._pageData[pageIndex].effObj.startPlay();
                    &#125;
                    eqShow.setPageHis(self._pageData[pageIndex].id);
                &#125; else &#123;
                    self.$currentPage.classList.remove(&quot;z-move&quot;);
                &#125;
            &#125;
            C = false;
        &#125;;
</code></pre>
<p>然后再来看自动翻页nextPage</p>
<pre><code>  /**
     * 启动自动翻页
     * @return &#123;undefined&#125;
     */
    function startAutoFlip() &#123;
        // 通过setInterval
        autoFlipIntervalId = setInterval(function () &#123;
            if (!(10 === self._scrollMode)) &#123;
                if (!isTouching) &#123;
                    nextPage();
                &#125;
            &#125;
        &#125;, autoFlipTimeMS);
    &#125;
</code></pre>
<p>自动翻页比较简单，模拟滑动操作，当位移足够时就可以自动翻页了：</p>
<pre><code>/**
     *  上一页
     * @param &#123;number&#125; direction
     * @return &#123;undefined&#125;
     */
    function prePage(direction) &#123;
        if (!(leftRightMode &amp;&amp; 2 == direction || upDownMode &amp;&amp; 1 == direction)) &#123;
            if (&quot;10&quot; != self._scrollMode) &#123;
                var offset = 0;
                // 开启滑动
                onTouchStart();
                // 定时器，增加offset,模拟滑动
                var poll = setInterval(function () &#123;
                    offset += 2;
                    if (&quot;0&quot; == self._scrollMode || (&quot;1&quot; == self._scrollMode || (&quot;2&quot; == self._scrollMode || (&quot;6&quot; == self._scrollMode || (&quot;7&quot; == self._scrollMode || (&quot;8&quot; == self._scrollMode || (&quot;11&quot; == self._scrollMode || (&quot;12&quot; == self._scrollMode || (&quot;13&quot; == self._scrollMode || (&quot;14&quot; == self._scrollMode || &quot;15&quot; == self._scrollMode)))))))))) &#123;
                        // 纵向翻页，增加y
                        offsetY = offset;
                    &#125; else &#123;
                        if (&quot;3&quot; == self._scrollMode || (&quot;4&quot; == self._scrollMode || (&quot;5&quot; == self._scrollMode || &quot;9&quot; == self._scrollMode))) &#123;
                            // 横向翻页，增加x
                            offsetX = offset;
                        &#125;
                    &#125;
                    // 触发move操作，模拟滑动
                    onTouchMove();
                    if (offset &gt;= 21) &#123;
                        // 位移超过20，
                        clearInterval(poll);
                        // 停止滑动,完成翻页
                        onTouchEnd();
                    &#125;
                &#125;, 1);
            &#125; else &#123;
                // 翻书
                $(document).trigger(&quot;bookFlipPre&quot;);
            &#125;
        &#125;
    &#125;

    /**
     * 下一页，逻辑和prePage类似
     * @param &#123;number&#125; direction
     * @return &#123;undefined&#125;
     */
    function nextPage(direction) &#123;
        if (!(leftRightMode &amp;&amp; 2 == direction || upDownMode &amp;&amp; 1 == direction)) &#123;
            if (&quot;10&quot; != self._scrollMode) &#123;
                u = false;
                var offset = 0;
                if (&quot;block&quot; == $(&quot;body .boards-panel&quot;).css(&quot;display&quot;)) &#123;
                    $(&quot;body .boards-panel&quot;).hide();
                    $(&quot;body .z-current&quot;).show();
                &#125;
                onTouchStart();
                var poll = setInterval(function () &#123;
                    offset -= 2;
                    if (&quot;0&quot; == self._scrollMode || (&quot;1&quot; == self._scrollMode || (&quot;2&quot; == self._scrollMode || (&quot;6&quot; == self._scrollMode || (&quot;7&quot; == self._scrollMode || (&quot;8&quot; == self._scrollMode || (&quot;11&quot; == self._scrollMode || (&quot;12&quot; == self._scrollMode || (&quot;13&quot; == self._scrollMode || (&quot;14&quot; == self._scrollMode || &quot;15&quot; == self._scrollMode)))))))))) &#123;
                        offsetY = offset;
                    &#125; else &#123;
                        if (&quot;3&quot; == self._scrollMode || (&quot;4&quot; == self._scrollMode || (&quot;5&quot; == self._scrollMode || &quot;9&quot; == self._scrollMode))) &#123;
                            offsetX = offset;
                        &#125;
                    &#125;
                    onTouchMove();
                    if (-21 &gt;= offset) &#123;
                        clearInterval(poll);
                        onTouchEnd();
                        if (!triggerLoop) &#123;
                            if (!self.$activePage) &#123;
                                clearInterval(autoFlipIntervalId);
                            &#125;
                        &#125;
                    &#125;
                &#125;, 1);
            &#125; else &#123;
                $(document).trigger(&quot;bookFlipNext&quot;);
            &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是花了大概一天多的时间阅读代码的成果，总结经验就是阅读代码先分析大的流程，再层层递进分析一些细节，就能一步一步接近真相。</p>
<p>另外，阅读压缩过的代码，可以借助VS Code，善用F2重命名，修改的越多，越接近本来的代码：）</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/02/28/jqpeng-Spring%20boot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%AD%97%E7%AC%A6%E7%94%BB%EF%BC%88banner%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/02/28/jqpeng-Spring%20boot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%AD%97%E7%AC%A6%E7%94%BB%EF%BC%88banner%EF%BC%89/" class="post-title-link" itemprop="url">Spring boot自定义启动字符画（banner）</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-28 11:11:00" itemprop="dateCreated datePublished" datetime="2018-02-28T11:11:00+08:00">2018-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/springboot-banner.html">Spring boot自定义启动字符画（banner）</a></p>
<p>spring boot项目启动时会打印spring boot的ANSI字符画，可以进行自定义。</p>
<h2 id="如何自定义"><a href="#如何自定义" class="headerlink" title="如何自定义"></a>如何自定义</h2><p>实现方式非常简单，我们只需要在Spring Boot工程的/src/main/resources目录下创建一个banner.txt文件，然后将ASCII字符画复制进去，就能替换默认的banner了。</p>
<pre><code>█████████████████████████████████████████████████████████████████████████████████████████████████████

 █████╗ ██╗██╗   ██╗██╗    ███████╗ █████╗  █████╗ ███████╗
██╔══██╗██║██║   ██║██║    ██╔════╝██╔══██╗██╔══██╗██╔════╝
███████║██║██║   ██║██║    ███████╗███████║███████║███████╗
██╔══██║██║██║   ██║██║    ╚════██║██╔══██║██╔══██║╚════██║
██║  ██║██║╚██████╔╝██║    ███████║██║  ██║██║  ██║███████║
╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═╝    ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝

█████████████████████████████████████████████████████████████████████████████████████████████████████
</code></pre>
<h2 id="如何生成字符画"><a href="#如何生成字符画" class="headerlink" title="如何生成字符画"></a>如何生成字符画</h2><p>如果让我们手工的来编辑这些字符画，显然是一件非常困难的差事。</p>
<p>正好刚接触jhipster，发现有一个 <a target="_blank" rel="noopener" href="https://github.com/PierreBesson/generator-jhipster-banner">generator-jhipster-banner插件</a>，可以生成banner.</p>
<p>首先安装：</p>
<pre><code>npm install -g generator-jhipster-banner
</code></pre>
<p>使用：</p>
<pre><code>yo jhipster-banner.
</code></pre>
<p>没有安装yo的，先安装：</p>
<pre><code>npm install -g yo
</code></pre>
<p>按提示输入文本和选择颜色即可。</p>
<p>其他方法：</p>
<p><a target="_blank" rel="noopener" href="http://patorjk.com/software/taag">http://patorjk.com/software/taag</a><br><a target="_blank" rel="noopener" href="http://www.network-science.de/ascii/">http://www.network-science.de/ascii/</a><br><a target="_blank" rel="noopener" href="http://www.degraeve.com/img2txt.php">http://www.degraeve.com/img2txt.php</a></p>
<h2 id="彩蛋：永不宕机佛祖"><a href="#彩蛋：永不宕机佛祖" class="headerlink" title="彩蛋：永不宕机佛祖"></a>彩蛋：永不宕机佛祖</h2><pre><code>$&#123;AnsiColor.BRIGHT_YELLOW&#125;
////////////////////////////////////////////////////////////////////
//                          _ooOoo_                               //
//                         o8888888o                              //
//                         88&quot; . &quot;88                              //
//                         (| ^_^ |)                              //
//                         O\  =  /O                              //
//                      ____/`---&#39;\____                           //
//                    .&#39;  \\|     |//  `.                         //
//                   /  \\|||  :  |||//  \                        //
//                  /  _||||| -:- |||||-  \                       //
//                  |   | \\\  -  /// |   |                       //
//                  | \_|  &#39;&#39;\---/&#39;&#39;  |   |                       //
//                  \  .-\__  `-`  ___/-. /                       //
//                ___`. .&#39;  /--.--\  `. . ___                     //
//              .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.                  //
//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //
//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //
//      ========`-.____`-.___\_____/___.-`____.-&#39;========         //
//                           `=---=&#39;                              //
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //
//            佛祖保佑       永不宕机     永无BUG                  //
////////////////////////////////////////////////////////////////////
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2018/01/04/jqpeng-gitbook%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2018/01/04/jqpeng-gitbook%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">gitbook安装与使用，并使用docker部署</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-04 17:03:00" itemprop="dateCreated datePublished" datetime="2018-01-04T17:03:00+08:00">2018-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/gitbook-setup-and-usage-publish-with-docker.html">gitbook安装与使用，并使用docker部署</a></p>
<p>本文简单介绍如何安装并使用gitbook，最后如何使用docker构建书籍镜像。</p>
<h1 id="1-前置条件"><a href="#1-前置条件" class="headerlink" title="1. 前置条件"></a>1. 前置条件</h1><p>需要Nodejs环境，安装npm，国内用户再安装cnpm</p>
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<h1 id="2-安装gitbook"><a href="#2-安装gitbook" class="headerlink" title="2. 安装gitbook"></a>2. 安装gitbook</h1><pre><code>cnpm install -g gitbook-cli
gitbook -V 
CLI version: 2.3.2
Installing GitBook 3.2.3
gitbook@3.2.3 ..\AppData\Local\Temp\tmp-20544doJtj1hfVp40\node_modules\gitbook
├── escape-string-regexp@1.0.5
├── escape-html@1.0.3
 。。。。
GitBook version: 3.2.3
</code></pre>
<h1 id="3-gitbook使用"><a href="#3-gitbook使用" class="headerlink" title="3. gitbook使用"></a>3. gitbook使用</h1><h2 id="3-1-生成目录和图书结构"><a href="#3-1-生成目录和图书结构" class="headerlink" title="3.1 生成目录和图书结构"></a>3.1 生成目录和图书结构</h2><pre><code>mkdir docker-start
gitbook init
warn: no summary file in this book
info: create README.md
info: create SUMMARY.md
info: initialization is finished
</code></pre>
<p>编辑SUMMARY.md，输入：</p>
<pre><code>* [简介](README.md)
* [1.Docker入门](chapter1/README.md)
 - [1.1 什么是Docker](chapter1/section1.md)
 - [1.2 Docker基本概念](chapter1/section2.md)
 - [1.3 安装Docker](chapter1/section3.md)
 - [1.4 使用Docker镜像](chapter1/section4.md)
 - [1.5 操作容器](chapter1/section5.md)
 - [1.6 访问仓库](chapter1/section6.md)
 - [1.6 数据管理](chapter1/section7.md)
* [2.使用Docker部署web应用](chapter2/README.md)
 - [2.1 编写DockerFile](chapter2/section1.md)
 - [2.2 编写web应用](chapter2/section2.md)
 - [2.3 构建镜像](chapter2/section3.md)
 - [2.4 运行web应用](chapter2/section4.md)
 - [2.5 分享镜像](chapter2/section5.md)
* [结束](end/README.md)
</code></pre>
<p>再次执行：</p>
<pre><code>gitbook init
info: create chapter1/README.md
info: create chapter1/section1.md
info: create chapter1/section2.md
info: create chapter1/section3.md
info: create chapter1/section4.md
info: create chapter1/section5.md
info: create chapter1/section6.md
info: create chapter1/section7.md
info: create chapter2/README.md
info: create chapter2/section1.md
info: create chapter2/section2.md
info: create chapter2/section3.md
info: create chapter2/section4.md
info: create chapter2/section5.md
info: create end/README.md
info: create SUMMARY.md
info: initialization is finished
</code></pre>
<h2 id="3-2-生成图书"><a href="#3-2-生成图书" class="headerlink" title="3.2 生成图书"></a>3.2 生成图书</h2><p>使用：</p>
<pre><code>gitbook serve .
Live reload server started on port: 35729
Press CTRL+C to quit ...

info: 7 plugins are installed
info: loading plugin &quot;livereload&quot;... OK
info: loading plugin &quot;highlight&quot;... OK
info: loading plugin &quot;search&quot;... OK
info: loading plugin &quot;lunr&quot;... OK
info: loading plugin &quot;sharing&quot;... OK
info: loading plugin &quot;fontsettings&quot;... OK
info: loading plugin &quot;theme-default&quot;... OK
info: found 16 pages
info: found 15 asset files
info: &gt;&gt; generation finished with success in 4.0s !

Starting server ...
Serving book on http://localhost:4000
</code></pre>
<p>访问 <a target="_blank" rel="noopener" href="http://localhost:4000/">http://localhost:4000</a> ，就可以看到图书了</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1515048112496.jpg" alt="enter description here" title="1515048112496"></p>
<p>编辑生成的md，gitbook会自动Restart，</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1515048702182.jpg" alt="enter description here" title="1515048702182"></p>
<p>在当前目录下，会生成一个_book目录 ，里面是生成的静态html，可以发布到服务器直接使用。</p>
<h1 id="4-使用docker发布gitbook书籍"><a href="#4-使用docker发布gitbook书籍" class="headerlink" title="4. 使用docker发布gitbook书籍"></a>4. 使用docker发布gitbook书籍</h1><p>首先 将_book目录里的内容拷贝到一个新目录。</p>
<p>然后编写Dockerfile</p>
<pre><code>FROM nginx
WORKDIR /usr/share/nginx/html
ADD . /usr/share/nginx/html
EXPOSE 80
</code></pre>
<p>build：</p>
<pre><code>docker build -t docker-start-web .
Sending build context to Docker daemon  4.766MB
Step 1/4 : FROM nginx
 ---&gt; 3f8a4339aadd
Step 2/4 : WORKDIR /usr/share/nginx/html
Removing intermediate container a4232f4b6b62
 ---&gt; 91a66299ecad
Step 3/4 : ADD . /usr/share/nginx/html
 ---&gt; 9a9fef80da3b
Step 4/4 : EXPOSE 80
 ---&gt; Running in 59f2b829aba6
Removing intermediate container 59f2b829aba6
 ---&gt; b92c92688046
Successfully built b92c92688046
Successfully tagged docker-start-web:latest
</code></pre>
<p>执行：</p>
<pre><code>docker run -p 4000:80 --name docker-start-web -d docker-start-web
f91cf4446b3746c665476b3dd214446a941d838fa9a3ad47680190bb08c9aa48
</code></pre>
<p>访问服务器ip:4000就可以查看到了。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/12/26/jqpeng-%E4%BD%BF%E7%94%A8Spring%E8%AE%BF%E9%97%AEMongodb%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E2%80%94%E2%80%94Spring%20Data%20MongoDB%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/12/26/jqpeng-%E4%BD%BF%E7%94%A8Spring%E8%AE%BF%E9%97%AEMongodb%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E2%80%94%E2%80%94Spring%20Data%20MongoDB%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">使用Spring访问Mongodb的方法大全——Spring Data MongoDB查询指南</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-26 16:28:00" itemprop="dateCreated datePublished" datetime="2017-12-26T16:28:00+08:00">2017-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/queries-in-spring-data-mongodb.html">使用Spring访问Mongodb的方法大全——Spring Data MongoDB查询指南</a></p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>Spring Data MongoDB 是Spring框架访问mongodb的神器，借助它可以非常方便的读写mongo库。本文介绍使用Spring Data MongoDB来访问mongodb数据库的几种方法：</p>
<ul>
<li>使用Query和Criteria类</li>
<li>JPA自动生成的查询方法</li>
<li>使用@Query 注解基于JSON查询</li>
</ul>
<p>在开始前，首先需要引入maven依赖</p>
<h2 id="1-1-添加Maven的依赖"><a href="#1-1-添加Maven的依赖" class="headerlink" title="1.1 添加Maven的依赖"></a>1.1 添加Maven的依赖</h2><p>如果您想使用Spring Data MongoDB，则需要将以下条目添加到您的pom.xml文件中：</p>
<pre><code>&lt;dependency&gt;&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;&lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt;&lt;version&gt;1.9.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>版本根据需要选择。</p>
<h1 id="2-文档查询"><a href="#2-文档查询" class="headerlink" title="2.文档查询"></a>2.文档查询</h1><p>使用Spring Data来查询MongoDB的最常用方法之一是使用Query和Criteria类 ， 它们非常接近本地操作符。</p>
<h2 id="2-1-is查询"><a href="#2-1-is查询" class="headerlink" title="2.1 is查询"></a>2.1 is查询</h2><p>在以下示例中 - 我们正在寻找名为Eric的用户。</p>
<p>我们来看看我们的数据库：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 55&#125;
&#125;]
</code></pre>
<p>让我们看看查询代码：</p>
<pre><code>Query query = new Query();
query.addCriteria(Criteria.where(&quot;name&quot;).is(&quot;Eric&quot;));
List&lt;User&gt; users = mongoTemplate.find(query, User.class);
</code></pre>
<p>如预期的那样，这个逻辑返回：</p>
<pre><code>&#123;&quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),&quot;_class&quot; : &quot;org.baeldung.model.User&quot;,&quot;name&quot; : &quot;Eric&quot;,&quot;age&quot; : 45
&#125;
</code></pre>
<h2 id="2-2-正则查询"><a href="#2-2-正则查询" class="headerlink" title="2.2 正则查询"></a>2.2 正则查询</h2><p>正则表达式是一个更灵活和强大的查询类型。这使用了一个使用MongoDB $ regex的标准，该标准返回适用于这个字段的这个正则表达式的所有记录。</p>
<p>它的作用类似于startingWith，endingWith操作 - 让我们来看一个例子。</p>
<p>寻找名称以A开头的所有用户，这是数据库的状态：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<p>我们来创建查询：</p>
<pre><code>Query query = new Query();
query.addCriteria(Criteria.where(&quot;name&quot;).regex(&quot;^A&quot;));
List&lt;User&gt; users = mongoTemplate.find(query,User.class);
</code></pre>
<p>这运行并返回2条记录：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<p>下面是另一个简单的例子，这次查找名称以c结尾的所有用户：</p>
<pre><code>Query query = new Query();
query.addCriteria(Criteria.where(&quot;name&quot;).regex(&quot;c$&quot;));
List&lt;User&gt; users = mongoTemplate.find(query, User.class);
</code></pre>
<p>所以结果是：</p>
<pre><code>&#123;&quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),&quot;_class&quot; : &quot;org.baeldung.model.User&quot;,&quot;name&quot; : &quot;Eric&quot;,&quot;age&quot; : 45
&#125;
</code></pre>
<h2 id="2-3-LT和GT"><a href="#2-3-LT和GT" class="headerlink" title="2.3 LT和GT"></a>2.3 LT和GT</h2><p>$ lt（小于）运算符和$ gt（大于）。</p>
<p>让我们快速看一个例子 - 我们正在寻找年龄在20岁到50岁之间的所有用户。</p>
<p>数据库是：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 55&#125;
&#125;
</code></pre>
<p>构造查询：</p>
<pre><code>Query query = new Query();
query.addCriteria(Criteria.where(&quot;age&quot;).lt(50).gt(20));
List&lt;User&gt; users = mongoTemplate.find(query,User.class);
</code></pre>
<p>结果 - 年龄大于20且小于50的所有用户：</p>
<pre><code>&#123;&quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),&quot;_class&quot; : &quot;org.baeldung.model.User&quot;,&quot;name&quot; : &quot;Eric&quot;,&quot;age&quot; : 45
&#125;
</code></pre>
<h2 id="2-4-结果排序"><a href="#2-4-结果排序" class="headerlink" title="2.4 结果排序"></a>2.4 结果排序</h2><p>Sort用于指定结果的排序顺序。</p>
<p>首先 - 这里是现有的数据：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<p>执行排序后：</p>
<pre><code>Query query = new Query();
query.with(new Sort(Sort.Direction.ASC, &quot;age&quot;));
List&lt;User&gt; users = mongoTemplate.find(query,User.class);
</code></pre>
<p>这是查询的结果 - 很好地按年龄排序：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;
]
</code></pre>
<h2 id="2-5-分页"><a href="#2-5-分页" class="headerlink" title="2.5 分页"></a>2.5 分页</h2><p>我们来看一个使用分页的简单例子。</p>
<p>这是数据库的状态：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<p>现在，查询逻辑，只需要一个大小为2的页面：</p>
<pre><code>final Pageable pageableRequest = new PageRequest(0, 2);
Query query = new Query();
query.with(pageableRequest);
</code></pre>
<p>结果 ：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;
]
</code></pre>
<p>为了探索这个API的全部细节，这里是Query和Criteria类的文档。</p>
<h2 id="3-生成的查询方法（Generated-Query-Methods）"><a href="#3-生成的查询方法（Generated-Query-Methods）" class="headerlink" title="3.生成的查询方法（Generated Query Methods）"></a>3.生成的查询方法（Generated Query Methods）</h2><p>生成查询方法是JPA的一个特性，在Spring Data Mongodb里也可以使用。</p>
<p>要做到2里功能，只需要在接口上声明方法即可，</p>
<pre><code>public interface UserRepository 
  extends MongoRepository&lt;User, String&gt;, QueryDslPredicateExecutor&lt;User&gt; &#123;...
&#125;
</code></pre>
<h2 id="3-1-FindByX"><a href="#3-1-FindByX" class="headerlink" title="3.1 FindByX"></a>3.1 FindByX</h2><p>我们将通过探索findBy类型的查询来简单地开始 - 在这种情况下，通过名称查找：</p>
<pre><code>List&lt;User&gt; findByName(String name);
</code></pre>
<p>与上一节相同 2.1 - 查询将具有相同的结果，查找具有给定名称的所有用户：</p>
<pre><code>List&lt;User&gt; users = userRepository.findByName(&quot;Eric&quot;);
</code></pre>
<h2 id="3-2-StartingWith-and-endingWith"><a href="#3-2-StartingWith-and-endingWith" class="headerlink" title="3.2  StartingWith and endingWith."></a>3.2  StartingWith and endingWith.</h2><p>下面是操作过程的一个简单例子：</p>
<pre><code>List&lt;User&gt; findByNameStartingWith(String regexp);

List&lt;User&gt; findByNameEndingWith(String regexp);
</code></pre>
<p>实际使用这个例子当然会非常简单：</p>
<pre><code>List&lt;User&gt; users = userRepository.findByNameStartingWith(&quot;A&quot;);
List&lt;User&gt; users = userRepository.findByNameEndingWith(&quot;c&quot;);
</code></pre>
<p>结果是完全一样的。</p>
<h2 id="3-3-Between"><a href="#3-3-Between" class="headerlink" title="3.3 Between"></a>3.3 Between</h2><p>类似于2.3，这将返回年龄在ageGT和ageLT之间的所有用户：</p>
<pre><code>List&lt;User&gt; findByAgeBetween(int ageGT, int ageLT);
List&lt;User&gt; users = userRepository.findByAgeBetween(20, 50);
</code></pre>
<h2 id="3-4-Like和OrderBy"><a href="#3-4-Like和OrderBy" class="headerlink" title="3.4 Like和OrderBy"></a>3.4 Like和OrderBy</h2><p>让我们来看看这个更高级的示例 - 为生成的查询组合两种类型的修饰符。</p>
<p>我们将要查找名称中包含字母A的所有用户，我们也将按年龄顺序排列结果：</p>
<pre><code>List&lt;User&gt; users = userRepository.findByNameLikeOrderByAgeAsc(&quot;A&quot;);
</code></pre>
<p>结果：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<h1 id="4-JSON查询方法"><a href="#4-JSON查询方法" class="headerlink" title="4. JSON查询方法"></a>4. JSON查询方法</h1><p>如果我们无法用方法名称或条件来表示查询，那么我们可以做更低层次的事情 - 使用@Query注解。</p>
<p>通过这个注解，我们可以指定一个原始查询 - 作为一个Mongo JSON查询字符串。</p>
<h2 id="4-1-FindBy"><a href="#4-1-FindBy" class="headerlink" title="4.1 FindBy"></a>4.1 FindBy</h2><p>让我们先从简单的，看看我们是如何将是一个通过查找类型的方法第一：</p>
<pre><code>@Query(&quot;&#123; &#39;name&#39; : ?0 &#125;&quot;)
List&lt;User&gt; findUsersByName(String name);
</code></pre>
<p>这个方法应该按名称返回用户 - 占位符?0引用方法的第一个参数。</p>
<h2 id="4-2-regex"><a href="#4-2-regex" class="headerlink" title="4.2 $regex"></a>4.2 $regex</h2><p>让我们来看一个正则表达式驱动的查询 - 这当然会产生与2.2和3.2相同的结果：</p>
<pre><code>@Query(&quot;&#123; &#39;name&#39; : &#123; $regex: ?0 &#125; &#125;&quot;)
List&lt;User&gt; findUsersByRegexpName(String regexp);
</code></pre>
<p>用法也完全一样：</p>
<pre><code>List&lt;User&gt; users = userRepository.findUsersByRegexpName(&quot;^A&quot;);
List&lt;User&gt; users = userRepository.findUsersByRegexpName(&quot;c$&quot;);
</code></pre>
<h2 id="4-3-lt和-gt"><a href="#4-3-lt和-gt" class="headerlink" title="4.3. $ lt和$ gt"></a>4.3. $ lt和$ gt</h2><p>现在我们来实现lt和gt查询：</p>
<pre><code>@Query(&quot;&#123; &#39;age&#39; : &#123; $gt: ?0, $lt: ?1 &#125; &#125;&quot;)
List&lt;User&gt; findUsersByAgeBetween(int ageGT, int ageLT);
</code></pre>
<h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h1><p>在本文中，我们探讨了使用Spring Data MongoDB进行查询的常用方法。</p>
<p>本文示例可以从 <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/spring-data-mongodb">spring-data-mongodb</a>这里下载。</p>
<p>本文参考<a target="_blank" rel="noopener" href="http://www.baeldung.com/queries-in-spring-data-mongodb">A Guide to Queries in Spring Data MongoDB</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/12/22/jqpeng-kgtemp%E6%96%87%E4%BB%B6%E8%BD%ACmp3%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/12/22/jqpeng-kgtemp%E6%96%87%E4%BB%B6%E8%BD%ACmp3%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">kgtemp文件转mp3工具</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-22 13:24:00" itemprop="dateCreated datePublished" datetime="2017-12-22T13:24:00+08:00">2017-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/8085563.html">kgtemp文件转mp3工具</a></p>
<p>kgtemp文件是酷我音乐软件的缓存文件，本文从技术层面探讨如何解密该文件为mp3文件，并通过读取ID3信息来重命名。</p>
<p>备注：针对老版本的酷我音乐生效，新版本不支持！！！</p>
<h2 id="kgtemp解密"><a href="#kgtemp解密" class="headerlink" title="kgtemp解密"></a>kgtemp解密</h2><p>kgtemp文件前1024个字节是固定的包头信息，解密方案详细可以参见(<a target="_blank" rel="noopener" href="http://www.cnblogs.com/KMBlog/p/6877752.html">http://www.cnblogs.com/KMBlog/p/6877752.html</a>)：</p>
<pre><code>class Program&#123;    static void Main(string[] args)    &#123;
        byte[] key=&#123;0xAC,0xEC,0xDF,0x57&#125;;        using (var input = new FileStream(@&quot;E:\KuGou\Temp\236909b6016c6e98365e5225f488dd7a.kgtemp&quot;, FileMode.Open, FileAccess.Read))        &#123;            var output = File.OpenWrite(@&quot;d:\test.mp3&quot;);//输出文件            input.Seek(1024, SeekOrigin.Begin);//跳过1024字节的包头            byte[] buffer = new byte[key.Length];            int length;            while((length=input.Read(buffer,0,buffer.Length))&gt;0)            &#123;                for(int i=0;i&lt;length;i++)                &#123;                    var k = key[i];                    var kh = k &gt;&gt; 4;                    var kl = k &amp; 0xf;                    var b = buffer[i];                    var low = b &amp; 0xf ^ kl;//解密后的低4位                    var high = (b &gt;&gt; 4) ^ kh ^ low &amp; 0xf;//解密后的高4位                    buffer[i] = (byte)(high &lt;&lt; 4 | low);                &#125;                output.Write(buffer, 0, length);            &#125;            output.Close();        &#125;        Console.WriteLine(&quot;按任意键退出...&quot;);        Console.ReadKey();    &#125;&#125;
</code></pre>
<p>这样解密出来就是mp3文件了</p>
<h2 id="读取ID3信息"><a href="#读取ID3信息" class="headerlink" title="读取ID3信息"></a>读取ID3信息</h2><p>解密出来的文件还需要手动命名，不是很方便，可以读取ID3V1信息重命名文件。<br> ID3V1比较简单，它是存放在MP3文件的末尾，用16进制的编辑器打开一个MP3文件，查看其末尾的128个顺序存放字节，数据结构定义如下：<br> char Header<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1513919861693.jpg" title="1513919861693">3</a>;    /<em>标签头必须是”TAG”否则认为没有标签</em>/<br> char Title[30];    /<em>标题</em>/<br> char Artist[30];   /<em>作者</em>/<br> char Album[30];    /<em>专集</em>/<br> char Year<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1513920067729.jpg" title="1513920067729">4</a>;    /<em>出品年代</em>/<br> char Comment[30];   /<em>备注</em>/<br> char Genre;    /<em>类型，流派</em>/</p>
<p>解析代码比较简单，注意中文歌曲用GBK编码就可以了：</p>
<pre><code>  private static Mp3Info FormatMp3Info(byte[] Info, System.Text.Encoding Encoding)    &#123;        Mp3Info myMp3Info = new Mp3Info();        string str = null;        int i;        int position = 0主要代码jia，; //循环的起始值        int currentIndex = 0; //Info的当前索引值
        //获取TAG标识        for (i = currentIndex; i &lt; currentIndex + 3; i++)        &#123;            str = str + (char)Info[i];            position++;        &#125;        currentIndex = position;        myMp3Info.identify = str;
        //获取歌名        str = null;        byte[] bytTitle = new byte[30]; //将歌名部分读到一个单独的数组中        int j = 0;        for (i = currentIndex; i &lt; currentIndex + 30; i++)        &#123;            bytTitle[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Title = ByteToString(bytTitle, Encoding);
        //获取歌手名        str = null;        j = 0;        byte[] bytArtist = new byte[30]; //将歌手名部分读到一个单独的数组中        for (i = currentIndex; i &lt; currentIndex + 30; i++)        &#123;            bytArtist[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Artist = ByteToString(bytArtist, Encoding);
        //获取唱片名        str = null;        j = 0;        byte[] bytAlbum = new byte[30]; //将唱片名部分读到一个单独的数组中        for (i = currentIndex; i &lt; currentIndex + 30; i++)        &#123;            bytAlbum[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Album = ByteToString(bytAlbum, Encoding);
        //获取年        str = null;        j = 0;        byte[] bytYear = new byte[4]; //将年部分读到一个单独的数组中        for (i = currentIndex; i &lt; currentIndex + 4; i++)        &#123;            bytYear[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Year = ByteToString(bytYear, Encoding);
        //获取注释        str = null;        j = 0;        byte[] bytComment = new byte[28]; //将注释部分读到一个单独的数组中        for (i = currentIndex; i &lt; currentIndex + 25; i++)        &#123;            bytComment[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Comment = ByteToString(bytComment, Encoding);
        //以下获取保留位        myMp3Info.reserved1 = (char)Info[++position];        myMp3Info.reserved2 = (char)Info[++position];        myMp3Info.reserved3 = (char)Info[++position];
        //        return myMp3Info;    &#125;
</code></pre>
<h2 id="转换小工具"><a href="#转换小工具" class="headerlink" title="转换小工具"></a>转换小工具</h2><p>写了一个小工具，来进行转换</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1513919861693.jpg" alt="装换工具" title="1513919861693"></p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1o7FIsPk">https://pan.baidu.com/s/1o7FIsPk</a></p>
<p>PS:上面只读取了IDV1，部分歌曲可能不存在<br> 可以下载@缤纷 提供的程序，增加了ID3V2的支持：<br><a target="_blank" rel="noopener" href="https://files.cnblogs.com/files/gxlxzys/kgtemp%E6%96%87%E4%BB%B6%E8%BD%ACmp3%E5%B7%A5%E5%85%B7.zip">https://files.cnblogs.com/files/gxlxzys/kgtemp文件转mp3工具.zip</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/12/08/jqpeng-%E4%BD%BF%E7%94%A8SpringBoot%E5%BC%80%E5%8F%91REST%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/12/08/jqpeng-%E4%BD%BF%E7%94%A8SpringBoot%E5%BC%80%E5%8F%91REST%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">使用SpringBoot开发REST服务</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-08 16:35:00" itemprop="dateCreated datePublished" datetime="2017-12-08T16:35:00+08:00">2017-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/SpringBootRest.html">使用SpringBoot开发REST服务</a></p>
<p>本文介绍如何基于Spring Boot搭建一个简易的REST服务框架，以及如何通过自定义注解实现Rest服务鉴权</p>
<h1 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>首先，引入相关依赖，数据库使用mongodb，同时使用redis做缓存</p>
<pre><code>注意，这里没有使用tomcat，而是使用undertow



    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;
    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;
    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;    &lt;/dependency&gt;
    &lt;!--redis支持--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;
    &lt;!--mongodb支持--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;    &lt;/dependency&gt;
</code></pre>
<ul>
<li>引入spring-boot-starter-web支持web服务</li>
<li>引入spring-boot-starter-data-redis 和spring-boot-starter-data-mongodb就可以方便的使用mongodb和redis了</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="profiles功能"><a href="#profiles功能" class="headerlink" title="profiles功能"></a>profiles功能</h3><p>为了方便 区分开发环境和线上环境，可以使用profiles功能，在application.properties里增加<br> spring.profiles.active=dev</p>
<p>然后增加application-dev.properties作为dev配置文件。</p>
<h3 id="mondb配置"><a href="#mondb配置" class="headerlink" title="mondb配置"></a>mondb配置</h3><p>配置数据库地址即可</p>
<pre><code>spring.data.mongodb.uri=mongodb://ip:port/database?readPreference=primaryPreferred
</code></pre>
<h3 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h3><pre><code>spring.redis.database=0  
# Redis服务器地址
spring.redis.host=ip
# Redis服务器连接端口
spring.redis.port=6379  
# Redis服务器连接密码（默认为空）
spring.redis.password=
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.pool.max-active=8  
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.pool.max-wait=-1  
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8  
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0  
# 连接超时时间（毫秒）
spring.redis.timeout=0  
</code></pre>
<h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h3 id="mongdb"><a href="#mongdb" class="headerlink" title="mongdb"></a>mongdb</h3><p>mongdb访问很简单，直接定义接口extends MongoRepository即可，另外可以支持JPA语法，例如：</p>
<pre><code>@Component
public interface UserRepository extends MongoRepository&lt;User, Integer&gt; &#123;
public User findByUserName(String userName);
&#125;
</code></pre>
<p>使用时，加上@Autowired注解即可。</p>
<pre><code>@Component
public class AuthService extends BaseService &#123;
@AutowiredUserRepository userRepository;&#125;
</code></pre>
<h3 id="Redis访问"><a href="#Redis访问" class="headerlink" title="Redis访问"></a>Redis访问</h3><p>使用StringRedisTemplate即可直接访问Redis</p>
<pre><code>@Component
public class BaseService &#123;@Autowiredprotected MongoTemplate mongoTemplate;
@Autowiredprotected StringRedisTemplate stringRedisTemplate;
&#125;
</code></pre>
<p>储存数据：</p>
<pre><code>.stringRedisTemplate.opsForValue().set(token_key, user.getId()+&quot;&quot;,token_max_age, TimeUnit.SECONDS);
</code></pre>
<p>删除数据：</p>
<pre><code>stringRedisTemplate.delete(getFormatToken(accessToken,platform));
</code></pre>
<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><p>定义一个Controller类，加上RestController即可，使用RequestMapping用来设置url route</p>
<pre><code>@RestController
public class AuthController extends BaseController &#123;
@RequestMapping(value = &#123;&quot;/&quot;&#125;, produces = &quot;application/json;charset=utf-8&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)@ResponseBodypublic String main() &#123;    return &quot;hello world！&quot;;&#125;

&#125;
</code></pre>
<p>现在启动，应该就能看到hello world！了</p>
<h1 id="服务鉴权"><a href="#服务鉴权" class="headerlink" title="服务鉴权"></a>服务鉴权</h1><h2 id="简易accessToken机制"><a href="#简易accessToken机制" class="headerlink" title="简易accessToken机制"></a>简易accessToken机制</h2><p>提供登录接口，认证成功后，生成一个accessToken，以后访问接口时，带上accessToken，服务端通过accessToken来判断是否是合法用户。</p>
<p>为了方便，可以将accessToken存入redis，设定有效期。</p>
<pre><code>        String token = EncryptionUtils.sha256Hex(String.format(&quot;%s%s&quot;, user.getUserName(), System.currentTimeMillis()));    String token_key = getFormatToken(token, platform);    this.stringRedisTemplate.opsForValue().set(token_key, user.getId()+&quot;&quot;,token_max_age, TimeUnit.SECONDS);
</code></pre>
<h2 id="拦截器身份认证"><a href="#拦截器身份认证" class="headerlink" title="拦截器身份认证"></a>拦截器身份认证</h2><p>为了方便做统一的身份认证，可以基于Spring的拦截器机制，创建一个拦截器来做统一认证。</p>
<pre><code>public class AuthCheckInterceptor implements HandlerInterceptor &#123;
&#125;
</code></pre>
<p>要使拦截器生效，还需要一步，增加配置：</p>
<pre><code>@Configuration
public class SessionConfiguration extends WebMvcConfigurerAdapter &#123;
@AutowiredAuthCheckInterceptor authCheckInterceptor;
@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    super.addInterceptors(registry);    // 添加拦截器    registry.addInterceptor(authCheckInterceptor).addPathPatterns(&quot;/**&quot;);&#125;
&#125;
</code></pre>
<h2 id="自定义认证注解"><a href="#自定义认证注解" class="headerlink" title="自定义认证注解"></a>自定义认证注解</h2><p>为了精细化权限认证，比如有的接口只能具有特定权限的人才能访问，可以通过自定义注解轻松解决。在自定义的注解里，加上roles即可。</p>
<pre><code>/**
 *  权限检验注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface AuthCheck &#123;
/** *  角色列表 * @return */String[] roles() default &#123;&#125;;
&#125;
</code></pre>
<p>检验逻辑：</p>
<ul>
<li>只要接口加上了AuthCheck注解，就必须是登陆用户</li>
<li>如果指定了roles，则除了登录外，用户还应该具备相应的角色。</li>
</ul>
<pre><code>    String[] ignoreUrls = new String[]&#123;
            &quot;/user/.*&quot;,
            &quot;/cat/.*&quot;,
            &quot;/app/.*&quot;,
            &quot;/error&quot;
    &#125;;
 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception &#123;

        // 0 检验公共参数
        if(!checkParams(&quot;platform&quot;,httpServletRequest,httpServletResponse))&#123;
            return  false;
        &#125;

        // 1、忽略验证的URL
        String url = httpServletRequest.getRequestURI().toString();
        for(String ignoreUrl :ignoreUrls)&#123;
            if(url.matches(ignoreUrl))&#123;
                return true;
            &#125;
        &#125;

        // 2、查询验证注解
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        // 查询注解
        AuthCheck authCheck = method.getAnnotation(AuthCheck.class);
        if (authCheck == null) &#123;
            // 无注解，不需要
            return true;
        &#125;

        // 3、有注解，先检查accessToken
        if(!checkParams(&quot;accessToken&quot;,httpServletRequest,httpServletResponse))&#123;
            return  false;
        &#125;
        // 检验token是否过期
        Integer userId = authService.getUserIdFromToken(httpServletRequest.getParameter(&quot;accessToken&quot;),
                httpServletRequest.getParameter(&quot;platform&quot;));
        if(userId==null)&#123;
            logger.debug(&quot;accessToken timeout&quot;);
            output(ResponseResult.Builder.error(&quot;accessToken已过期&quot;).build(),httpServletResponse);
            return false;
        &#125;

        // 4、再检验是否包含必要的角色
        if(authCheck.roles()!=null&amp;&amp;authCheck.roles().length&gt;0)&#123;
            User user = authService.getUser(userId);
            boolean isMatch = false;
            for(String role : authCheck.roles())&#123;
                if(user.getRole().getName().equals(role))&#123;
                    isMatch =  true;
                    break;
                &#125;
            &#125;
            // 角色未匹配，验证失败
            if(!isMatch)&#123;
                return false;
            &#125;
        &#125;

        return true;
    &#125;
</code></pre>
<h1 id="服务响应结果封装"><a href="#服务响应结果封装" class="headerlink" title="服务响应结果封装"></a>服务响应结果封装</h1><p>增加一个Builder，方便生成最终结果</p>
<pre><code>public class ResponseResult &#123;

    public static class Builder&#123;
        ResponseResult responseResult;

        Map&lt;String,Object&gt; dataMap = Maps.newHashMap();

        public Builder()&#123;
            this.responseResult = new ResponseResult();
        &#125;

        public Builder(String state)&#123;
            this.responseResult = new ResponseResult(state);
        &#125;


        public static Builder newBuilder()&#123;
           return new Builder();
        &#125;

        public static Builder success()&#123;
            return new Builder(&quot;success&quot;);
        &#125;

        public static Builder error(String message)&#123;
            Builder builder =  new Builder(&quot;error&quot;);
            builder.responseResult.setError(message);
            return builder;
        &#125;

        public  Builder append(String key,Object data)&#123;
            this.dataMap.put(key,data);
            return this;
        &#125;

        /**
         *  设置列表数据
         * @param datas 数据
         * @return
         */
        public  Builder setListData(List&lt;?&gt; datas)&#123;
            this.dataMap.put(&quot;result&quot;,datas);
            this.dataMap.put(&quot;total&quot;,datas.size());
            return this;
        &#125;

        public  Builder setData(Object data)&#123;
            this.dataMap.clear();
            this.responseResult.setData(data);
            return this;
        &#125;

        boolean wrapData = false;

        /**
         * 将数据包裹在data中
         * @param wrapData
         * @return
         */
        public  Builder wrap(boolean wrapData)&#123;
            this.wrapData = wrapData;
            return this;
        &#125;

        public String build()&#123;

            JSONObject jsonObject = new JSONObject();
            jsonObject.put(&quot;state&quot;,this.responseResult.getState());
            if(this.responseResult.getState().equals(&quot;error&quot;))&#123;
                jsonObject.put(&quot;error&quot;,this.responseResult.getError());
            &#125;
            if(this.responseResult.getData()!=null)&#123;
                jsonObject.put(&quot;data&quot;, JSON.toJSON(this.responseResult.getData()));
            &#125;else  if(dataMap.size()&gt;0)&#123;
                if(wrapData) &#123;
                    JSONObject data = new JSONObject();
                    dataMap.forEach((key, value) -&gt; &#123;
                        data.put(key, value);
                    &#125;);
                    jsonObject.put(&quot;data&quot;, data);
                &#125;else&#123;
                    dataMap.forEach((key, value) -&gt; &#123;
                        jsonObject.put(key, value);
                    &#125;);
                &#125;
            &#125;
            return jsonObject.toJSONString();
        &#125;

    &#125;

    private String state;
    private Object data;
    private String error;


    public String getError() &#123;
        return error;
    &#125;

    public void setError(String error) &#123;
        this.error = error;
    &#125;

    public ResponseResult()&#123;&#125;

    public ResponseResult(String rc)&#123;
        this.state = rc;
    &#125;

    /**
     * 成功时返回
     * @param rc
     * @param result
     */
    public ResponseResult(String rc, Object result)&#123;
        this.state = rc;
        this.data = result;
    &#125;

    public String getState() &#123;
        return state;
    &#125;

    public void setState(String state) &#123;
        this.state = state;
    &#125;

    public Object getData() &#123;
        return data;
    &#125;

    public void setData(Object data) &#123;
        this.data = data;
    &#125;

&#125;
</code></pre>
<p>调用时可以优雅一点</p>
<pre><code>    @RequestMapping(value = &#123;&quot;/user/login&quot;,&quot;/pc/user/login&quot;&#125;, produces = &quot;application/json;charset=utf-8&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)
    @ResponseBody
    public String login(String userName,String password,Integer platform) &#123;
        User user = this.authService.login(userName,password);
        if(user!=null)&#123;
            //  登陆
            String token = authService.updateToken(user,platform);
            return ResponseResult.Builder                 .success()
                    .append(&quot;accessToken&quot;,token)
                    .append(&quot;userId&quot;,user.getId())
                    .build();
        &#125;
        return ResponseResult.Builder.error(&quot;用户不存在或密码错误&quot;).build();
    &#125;
    protected String error(String message)&#123;
        return  ResponseResult.Builder.error(message).build();
    &#125;

    protected String success()&#123;
        return  ResponseResult.Builder
                .success()
                .build();
    &#125;

    protected String successDataList(List&lt;?&gt; data)&#123;
        return ResponseResult.Builder
                .success()
                .wrap(true) // data包裹
                .setListData(data)
                .build();
    &#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.iflyresearch.com/2017/12/01/jqpeng-%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81%E4%B9%8Bzookeeper(1)%20--%20%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/jadepeng/images/avatar.gif">
      <meta itemprop="name" content="JadePeng">
      <meta itemprop="description" content="JadePeng的技术笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JadePeng的技术笔记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/jadepeng/2017/12/01/jqpeng-%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81%E4%B9%8Bzookeeper(1)%20--%20%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">一起读源码之zookeeper(1) -- 启动分析</a>
        </h2>

        <div class="post-meta">

         
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-01 14:43:00" itemprop="dateCreated datePublished" datetime="2017-12-01T14:43:00+08:00">2017-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 18:09:47" itemprop="dateModified" datetime="2021-05-14T18:09:47+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/jadepeng/categories/%E5%8D%9A%E5%AE%A2/jqpeng/" itemprop="url" rel="index"><span itemprop="name">jqpeng</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章作者:jqpeng<br>原文链接: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoqi/p/7942234.html">一起读源码之zookeeper(1) – 启动分析</a></p>
<p>从本文开始，不定期分析一个开源项目源代码，起篇从大名鼎鼎的zookeeper开始。<br> 为什么是zk，因为用到zk的场景实在太多了，大部分耳熟能详的分布式系统都有zookeeper的影子，比如hbase，storm，dubbo，kafka等等，另外前面提到的<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi/p/java-rpc.html">RPC框架原理与实现</a>也用到了zookeeper。</p>
<p>目录</p>
<ul>
<li>1 环境准备<ul>
<li>1.1 导入代码</li>
<li>1.2 设置配置文件</li>
<li>1.3 调试配置</li>
</ul>
</li>
<li>2 启动分析<ul>
<li>2.1 QuorumPeerMain</li>
<li>2.2 ZooKeeperServerMain</li>
<li>2.3 ServerCnxnFactory</li>
<li>2.4 ZooKeeperServer</li>
<li>2.5 服务启动<ul>
<li>2.5.1 配置cnxnFactory</li>
<li>2.5.2 启动cnxnFactory<ul>
<li>socket处理线程</li>
<li>socket网络请求处理</li>
<li>读取连接请求</li>
<li>创建session</li>
</ul>
</li>
<li>2.5.3 zk服务器启动<ul>
<li>SessionTracker</li>
</ul>
</li>
<li>2.5.4  ZooKeeperServer请求处理器链介绍<ul>
<li>RequestProcessor</li>
<li>PrepRequestProcessor</li>
<li>SyncRequestProcessor</li>
<li>FinalRequestProcessor</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1 环境准备"></a>1 环境准备</h2><p>首先，下载zk的新版本，最新的稳定版是3.4.10，由于已下载3.4.9.先直接使用。</p>
<h3 id="1-1-导入代码"><a href="#1-1-导入代码" class="headerlink" title="1.1 导入代码"></a>1.1 导入代码</h3><p>IDEA直接打开zk目录：<br><img src="https://ooo.0o0.ooo/2017/04/27/590166a796fb3.jpg" alt="enter description here" title="1493264040459"></p>
<p>项目设置为jdk1.7<br> 然后，将src/java下面的main和generated设置为源码目录，同时将lib目录添加为liabary。</p>
<h3 id="1-2-设置配置文件"><a href="#1-2-设置配置文件" class="headerlink" title="1.2 设置配置文件"></a>1.2 设置配置文件</h3><p>在conf目录，新建zoo.cfg，拷贝sample.cfg即可</p>
<p><img src="https://ooo.0o0.ooo/2017/04/27/5901674b5600d.jpg" alt="enter description here" title="1493264204261"></p>
<h3 id="1-3-调试配置"><a href="#1-3-调试配置" class="headerlink" title="1.3 调试配置"></a>1.3 调试配置</h3><p>查看bin/zkServer</p>
<pre><code>set ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain
....
endlocal
</code></pre>
<p>调用的是org.apache.zookeeper.server.quorum.QuorumPeerMain，因此QuorumPeerMain，配置调试程序，arguments设置conf/zoo.cfg</p>
<p><img src="https://ooo.0o0.ooo/2017/04/27/5901838aed112.jpg" alt="enter description here" title="1493271435981"></p>
<p>这样，就可以愉快的Debug代码了-😃</p>
<h2 id="2-启动分析"><a href="#2-启动分析" class="headerlink" title="2 启动分析"></a>2 启动分析</h2><h3 id="2-1-QuorumPeerMain"><a href="#2-1-QuorumPeerMain" class="headerlink" title="2.1 QuorumPeerMain"></a>2.1 QuorumPeerMain</h3><p>QuorumPeerMain的main里，调用initializeAndRun</p>
<pre><code>    protected void initializeAndRun(String[] args)
        throws ConfigException, IOException
    &#123;
        QuorumPeerConfig config = new QuorumPeerConfig();
        if (args.length == 1) &#123;
            config.parse(args[0]);
        &#125;

        // Start and schedule the the purge task 清理任务
        DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config
                .getDataDir(), config.getDataLogDir(), config
                .getSnapRetainCount(), config.getPurgeInterval());
        purgeMgr.start();

        // 集群模式
        if (args.length == 1 &amp;&amp; config.servers.size() &gt; 0) &#123;
            runFromConfig(config);
        &#125; else &#123;
            LOG.warn(&quot;Either no config or no quorum defined in config, running &quot;
                    + &quot; in standalone mode&quot;);
            // there is only server in the quorum -- run as standalone
            // 单机模式
            ZooKeeperServerMain.main(args);
        &#125;
    &#125;
</code></pre>
<p>主要执行了：</p>
<ul>
<li>加载解析配置文件到QuorumPeerConfig</li>
<li>执行清理任务</li>
<li>判断是集群模式还是单机模式，我们的配置文件未配置server，所以是单机模式，执行 ZooKeeperServerMain.main</li>
</ul>
<blockquote>
<p>本文重点分析单机模式下的zk，集群模式暂时不解读</p>
</blockquote>
<h3 id="2-2-ZooKeeperServerMain"><a href="#2-2-ZooKeeperServerMain" class="headerlink" title="2.2 ZooKeeperServerMain"></a>2.2 ZooKeeperServerMain</h3><p>ZooKeeperServerMain.main调用initializeAndRun</p>
<pre><code> protected void initializeAndRun(String[] args)
        throws ConfigException, IOException
    &#123;
        try &#123;
            ManagedUtil.registerLog4jMBeans();
        &#125; catch (JMException e) &#123;
            LOG.warn(&quot;Unable to register log4j JMX control&quot;, e);
        &#125;

        ServerConfig config = new ServerConfig();
        if (args.length == 1) &#123;
            config.parse(args[0]);
        &#125; else &#123;
            config.parse(args);
        &#125;

        runFromConfig(config);
    &#125;```

读取配置，然后runFromConfig：

``` java
 public void runFromConfig(ServerConfig config) throws IOException &#123;
        LOG.info(&quot;Starting server&quot;);
        FileTxnSnapLog txnLog = null;
        try &#123;
            // Note that this thread isn&#39;t going to be doing anything else,
            // so rather than spawning another thread, we will just call
            // run() in this thread.
            // create a file logger url from the command line args
            final ZooKeeperServer zkServer = new ZooKeeperServer();
            // Registers shutdown handler which will be used to know the
            // server error or shutdown state changes.
            final CountDownLatch shutdownLatch = new CountDownLatch(1);
            zkServer.registerServerShutdownHandler(
                    new ZooKeeperServerShutdownHandler(shutdownLatch));

            // 快照
            txnLog = new FileTxnSnapLog(new File(config.dataLogDir), new File(
                    config.dataDir));
            zkServer.setTxnLogFactory(txnLog);
            zkServer.setTickTime(config.tickTime);
            zkServer.setMinSessionTimeout(config.minSessionTimeout);
            zkServer.setMaxSessionTimeout(config.maxSessionTimeout);
            // socket工厂
            cnxnFactory = ServerCnxnFactory.createFactory();
            cnxnFactory.configure(config.getClientPortAddress(),
                    config.getMaxClientCnxns());
            cnxnFactory.startup(zkServer);

            // Watch status of ZooKeeper server. It will do a graceful shutdown
            // if the server is not running or hits an internal error.
            shutdownLatch.await();
            shutdown();

            cnxnFactory.join();
            if (zkServer.canShutdown()) &#123;
                zkServer.shutdown();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            // warn, but generally this is ok
            LOG.warn(&quot;Server interrupted&quot;, e);
        &#125; finally &#123;
            if (txnLog != null) &#123;
                txnLog.close();
            &#125;
        &#125;
    &#125;
</code></pre>
<p>几件事情：</p>
<ul>
<li>创建zkServer，对ZooKeeperServer设置一些配置参数，如tickTime、minSessionTimeout、maxSessionTimeout</li>
<li>创建CountDownLatch，注释里写了，用来watch zk的状态，当zk关闭或者出现内部错误的时候<strong>优雅</strong>的关闭服务</li>
<li>根据配置参数dataLogDir和dataDir创建FileTxnSnapLog，用来存储zk数据和日志快照</li>
<li>创建cnxnFactory，zk的 socket工厂，负责处理网络请求，zk里有netty和NIO两种实现</li>
<li>cnxnFactory.startup(zkServer)，启动zk服务器</li>
</ul>
<h3 id="2-3-ServerCnxnFactory"><a href="#2-3-ServerCnxnFactory" class="headerlink" title="2.3 ServerCnxnFactory"></a>2.3 ServerCnxnFactory</h3><p>cnxnFactory负责zk的网络请求，createFactory中，从系统配置中读取ZOOKEEPER_SERVER_CNXN_FACTORY，默认是没有这个配置的，因此默认是使用NIOServerCnxnFactory，基于java的NIO实现，</p>
<pre><code>    static public ServerCnxnFactory createFactory() throws IOException &#123;
        String serverCnxnFactoryName =
            System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);
        if (serverCnxnFactoryName == null) &#123;
            serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();
        &#125;
        try &#123;
            return (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)
                                                .newInstance();
        &#125; catch (Exception e) &#123;
            IOException ioe = new IOException(&quot;Couldn&#39;t instantiate &quot;
                    + serverCnxnFactoryName);
            ioe.initCause(e);
            throw ioe;
        &#125;
    &#125;
</code></pre>
<p>当然，我们可以很容易发现：<br><img src="https://ooo.0o0.ooo/2017/04/27/59018f04f17b9.jpg" alt="enter description here" title="1493274374075"></p>
<p>ServerCnxnFactory还有个NettyServerCnxnFactory实现，基于Netty实现NIO。ServerCnxnFactory里具体负责什么，后面再来看。</p>
<h3 id="2-4-ZooKeeperServer"><a href="#2-4-ZooKeeperServer" class="headerlink" title="2.4 ZooKeeperServer"></a>2.4 ZooKeeperServer</h3><p>现在，主角登场，我们来看ZooKeeperServer内部有什么玄妙。<br><img src="https://ooo.0o0.ooo/2017/04/27/59018cc60446f.jpg" alt="enter description here" title="1493273799033"></p>
<p>ZooKeeperServer是单机模式使用的类，在集群模式下使用的是它的子类。<br> 我们先来看ZooKeeperServer包含哪些内容：</p>
<pre><code>    public static final int DEFAULT_TICK_TIME = 3000;
    protected int tickTime = DEFAULT_TICK_TIME;
    /** value of -1 indicates unset, use default */
    protected int minSessionTimeout = -1;
    /** value of -1 indicates unset, use default */
    protected int maxSessionTimeout = -1;
    protected SessionTracker sessionTracker; //创建和管理session
    private FileTxnSnapLog txnLogFactory = null; //文件快照
    private ZKDatabase zkDb; // ZooKeeper树形数据的模型
    private final AtomicLong hzxid = new AtomicLong(0); //原子增长Long，用于分配事务编号
    public final static Exception ok = new Exception(&quot;No prob&quot;);
    protected RequestProcessor firstProcessor; // ZooKeeperServer请求处理器链中的第一个处理器
    protected volatile State state = State.INITIAL;

    protected enum State &#123;
        INITIAL, RUNNING, SHUTDOWN, ERROR;
    &#125;

    /**
     * This is the secret that we use to generate passwords, for the moment it
     * is more of a sanity check.
     */
    static final private long superSecret = 0XB3415C00L;

    private final AtomicInteger requestsInProcess = new AtomicInteger(0);
    final List&lt;ChangeRecord&gt; outstandingChanges = new ArrayList&lt;ChangeRecord&gt;();
    // this data structure must be accessed under the outstandingChanges lock
    final HashMap&lt;String, ChangeRecord&gt; outstandingChangesForPath =
        new HashMap&lt;String, ChangeRecord&gt;();
    
    private ServerCnxnFactory serverCnxnFactory; //ServerSocket工厂，接受客户端的socket连接

    private final ServerStats serverStats; //server的运行状态统计
    private final ZooKeeperServerListener listener; // ZK运行状态监听
    private ZooKeeperServerShutdownHandler zkShutdownHandler;
</code></pre>
<h3 id="2-5-服务启动"><a href="#2-5-服务启动" class="headerlink" title="2.5 服务启动"></a>2.5 服务启动</h3><p>前面有点跑偏，继续回归启动过程:</p>
<pre><code>            cnxnFactory = ServerCnxnFactory.createFactory();
            cnxnFactory.configure(config.getClientPortAddress(),
                    config.getMaxClientCnxns());
            cnxnFactory.startup(zkServer);
</code></pre>
<h4 id="2-5-1-配置cnxnFactory"><a href="#2-5-1-配置cnxnFactory" class="headerlink" title="2.5.1 配置cnxnFactory"></a>2.5.1 配置cnxnFactory</h4><p>进入configure：</p>
<pre><code>    @Override
    public void configure(InetSocketAddress addr, int maxcc) throws IOException &#123;
        configureSaslLogin();

        // ZK网络请求主线程
        thread = new ZooKeeperThread(this, &quot;NIOServerCxn.Factory:&quot; + addr);
        thread.setDaemon(true);

        maxClientCnxns = maxcc;
        this.ss = ServerSocketChannel.open();
        ss.socket().setReuseAddress(true);
        LOG.info(&quot;binding to port &quot; + addr);
        ss.socket().bind(addr);
        ss.configureBlocking(false);
        ss.register(selector, SelectionKey.OP_ACCEPT);
    &#125;
</code></pre>
<p>几件事情：</p>
<ul>
<li>configureSaslLogin，具体不细看，应该是处理鉴权</li>
<li>初始化ZooKeeperThread，这个ZooKeeperThread的作用是负责处理未处理异常：</li>
</ul>
<pre><code>public class ZooKeeperThread extends Thread &#123;

    private static final Logger LOG = LoggerFactory
            .getLogger(ZooKeeperThread.class);

    private UncaughtExceptionHandler uncaughtExceptionalHandler = new UncaughtExceptionHandler() &#123;

        @Override
        public void uncaughtException(Thread t, Throwable e) &#123;
            handleException(t.getName(), e);
        &#125;
    &#125;;

    public ZooKeeperThread(Runnable thread, String threadName) &#123;
        super(thread, threadName);
        setUncaughtExceptionHandler(uncaughtExceptionalHandler);
    &#125;

    protected void handleException(String thName, Throwable e) &#123;
        LOG.warn(&quot;Exception occured from thread &#123;&#125;&quot;, thName, e);
    &#125;
&#125;
</code></pre>
<ul>
<li>启动ServerSocketChannel，并绑定配置的addr，并且注册selector（可以搜索NIO了解细节）</li>
</ul>
<h4 id="2-5-2-启动cnxnFactory"><a href="#2-5-2-启动cnxnFactory" class="headerlink" title="2.5.2 启动cnxnFactory"></a>2.5.2 启动cnxnFactory</h4><p>继续分析，进入cnxnFactory.startup(zkServer)</p>
<pre><code>    @Override
    public void startup(ZooKeeperServer zks) throws IOException,
            InterruptedException &#123;
        start();
        setZooKeeperServer(zks);
        zks.startdata();
        zks.startup();
    &#125;
</code></pre>
<p>首先，start，判断线程状态，如果未启动则启动线程，注意只会启动一次。</p>
<pre><code>    @Override
    public void start() &#123;
        // ensure thread is started once and only once
        if (thread.getState() == Thread.State.NEW) &#123;
            thread.start();
        &#125;
    &#125;
</code></pre>
<h5 id="socket处理线程"><a href="#socket处理线程" class="headerlink" title="socket处理线程"></a>socket处理线程</h5><p>启动后，就会执行cnxnFactory.run</p>
<pre><code>    public void run() &#123;
        while (!ss.socket().isClosed()) &#123;
            try &#123;
                selector.select(1000);
                Set&lt;SelectionKey&gt; selected;
                synchronized (this) &#123;
                    selected = selector.selectedKeys();
                &#125;
                ArrayList&lt;SelectionKey&gt; selectedList = new ArrayList&lt;SelectionKey&gt;(
                        selected);
                Collections.shuffle(selectedList);
                for (SelectionKey k : selectedList) &#123;
                    if ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != 0) &#123;
                        SocketChannel sc = ((ServerSocketChannel) k
                                .channel()).accept();
                        InetAddress ia = sc.socket().getInetAddress();
                        int cnxncount = getClientCnxnCount(ia);
                        if (maxClientCnxns &gt; 0 &amp;&amp; cnxncount &gt;= maxClientCnxns)&#123;
                            LOG.warn(&quot;Too many connections from &quot; + ia
                                     + &quot; - max is &quot; + maxClientCnxns );
                            sc.close();
                        &#125; else &#123;
                            LOG.info(&quot;Accepted socket connection from &quot;
                                     + sc.socket().getRemoteSocketAddress());
                            sc.configureBlocking(false);
                            SelectionKey sk = sc.register(selector,
                                    SelectionKey.OP_READ);
                            NIOServerCnxn cnxn = createConnection(sc, sk);
                            sk.attach(cnxn);
                            addCnxn(cnxn);
                        &#125;
                    &#125; else if ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) &#123;
                        NIOServerCnxn c = (NIOServerCnxn) k.attachment();
                        c.doIO(k);
                    &#125; else &#123;
                        if (LOG.isDebugEnabled()) &#123;
                            LOG.debug(&quot;Unexpected ops in select &quot;
                                      + k.readyOps());
                        &#125;
                    &#125;
                &#125;
                selected.clear();
            &#125; catch (RuntimeException e) &#123;
                LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);
            &#125; catch (Exception e) &#123;
                LOG.warn(&quot;Ignoring exception&quot;, e);
            &#125;
        &#125;
        closeAll();
        LOG.info(&quot;NIOServerCnxn factory exited run method&quot;);
    &#125;
</code></pre>
<p>这里相当于一个独立线程来处理网络连接，通过selector.select(1000)来获取网络请求，一旦有连接就绪，则开始处理：</p>
<ul>
<li>首先打乱 Collections.shuffle(selectedList);</li>
<li>for循环处理<ul>
<li>如果SelectionKey.OP_ACCEPT，代表一个新连接请求，创建SocketChannel，创建NIOServerCnxn，然后addCnxn</li>
<li>如果可读写，则 NIOServerCnxn.doIO(k)，执行IO操作</li>
</ul>
</li>
</ul>
<h5 id="socket网络请求处理"><a href="#socket网络请求处理" class="headerlink" title="socket网络请求处理"></a>socket网络请求处理</h5><p>这里简单分析下doIO,摘录部分代码：</p>
<pre><code>void doIO(SelectionKey k) throws InterruptedException &#123;
        try &#123;
            if (isSocketOpen() == false) &#123;
                LOG.warn(&quot;trying to do i/o on a null socket for session:0x&quot;
                         + Long.toHexString(sessionId));

                return;
            &#125;
            if (k.isReadable()) &#123;
                // 读取4个字节
                int rc = sock.read(incomingBuffer);
                if (rc &lt; 0) &#123;
                    throw new EndOfStreamException(
                            &quot;Unable to read additional data from client sessionid 0x&quot;
                            + Long.toHexString(sessionId)
                            + &quot;, likely client has closed socket&quot;);
                &#125;
                // 读满了
                if (incomingBuffer.remaining() == 0) &#123;
                    boolean isPayload;
                    if (incomingBuffer == lenBuffer) &#123; // start of next request
                        incomingBuffer.flip(); // 复位
                        isPayload = readLength(k); // 读取载荷长度
                        incomingBuffer.clear();
                    &#125; else &#123;
                        // continuation
                        isPayload = true;
                    &#125;
                    if (isPayload) &#123; // not the case for 4letterword
                        readPayload();
                    &#125;
                    else &#123;
                        // four letter words take care
                        // need not do anything else
                        return;
                    &#125;
                &#125;
            &#125;
</code></pre>
<p>读取4个字节，获取到数据长度，然后读取载荷，也就是请求</p>
<pre><code>    private void readPayload() throws IOException, InterruptedException &#123;
        if (incomingBuffer.remaining() != 0) &#123; // have we read length bytes?
            int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok
            if (rc &lt; 0) &#123;
                throw new EndOfStreamException(
                        &quot;Unable to read additional data from client sessionid 0x&quot;
                        + Long.toHexString(sessionId)
                        + &quot;, likely client has closed socket&quot;);
            &#125;
        &#125;

        if (incomingBuffer.remaining() == 0) &#123; // have we read length bytes?
            packetReceived();
            incomingBuffer.flip(); // 复位
            if (!initialized) &#123;
                readConnectRequest(); // 读取连接请求
            &#125; else &#123;
                readRequest();
            &#125;
            lenBuffer.clear();
            incomingBuffer = lenBuffer;
        &#125;
    &#125;
</code></pre>
<p>先是读取数据，然后再读取请求，这里关注readConnectRequest</p>
<h5 id="读取连接请求"><a href="#读取连接请求" class="headerlink" title="读取连接请求"></a>读取连接请求</h5><pre><code>    private void readConnectRequest() throws IOException, InterruptedException &#123;
        if (zkServer == null) &#123;
            throw new IOException(&quot;ZooKeeperServer not running&quot;);
        &#125;
        zkServer.processConnectRequest(this, incomingBuffer);
        initialized = true;
    &#125;
</code></pre>
<p>继续，下面是处理连接请求：</p>
<pre><code>     public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;
        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));
        ConnectRequest connReq = new ConnectRequest();
        connReq.deserialize(bia, &quot;connect&quot;); // 反序列化请求
        ....
        // 客户端设置的超时时间
        int sessionTimeout = connReq.getTimeOut();
        byte passwd[] = connReq.getPasswd();
        int minSessionTimeout = getMinSessionTimeout();
        if (sessionTimeout &lt; minSessionTimeout) &#123;
            sessionTimeout = minSessionTimeout;
        &#125;
        // 服务端设置的最大超时时间
        int maxSessionTimeout = getMaxSessionTimeout();
        if (sessionTimeout &gt; maxSessionTimeout) &#123;
            sessionTimeout = maxSessionTimeout;
        &#125;
        cnxn.setSessionTimeout(sessionTimeout);
        // We don&#39;t want to receive any packets until we are sure that the
        // session is setup
        cnxn.disableRecv();
        // 请求是否带上sessionid
        long sessionId = connReq.getSessionId();
        if (sessionId != 0) &#123;
            // 请求带了sessionid
            long clientSessionId = connReq.getSessionId();
            LOG.info(&quot;Client attempting to renew session 0x&quot;
                    + Long.toHexString(clientSessionId)
                    + &quot; at &quot; + cnxn.getRemoteSocketAddress());
            // 关闭请求
            serverCnxnFactory.closeSession(sessionId);
            cnxn.setSessionId(sessionId);
            // 重新打开请求
            reopenSession(cnxn, sessionId, passwd, sessionTimeout);
        &#125; else &#123;
            LOG.info(&quot;Client attempting to establish new session at &quot;
                    + cnxn.getRemoteSocketAddress());
            // 创建新sesssion
            createSession(cnxn, passwd, sessionTimeout);
        &#125;
    &#125;
</code></pre>
<p>以上完成：</p>
<ul>
<li>将读取出来的incomingBuffer反序列化为ConnectRequest对象</li>
<li>然后设置超时时间，ServerCnxn接收到该申请后，根据客户端传递过来的sessionTimeout时间以及ZooKeeperServer本身的minSessionTimeout、maxSessionTimeout参数，确定最终的sessionTimeout时间</li>
<li>判断客户端的请求是否已经含有sessionId<ul>
<li>如果含有，则执行sessionId的是否过期、密码是否正确等检查</li>
<li>如果没有sessionId，则创建一个session</li>
</ul>
</li>
</ul>
<h5 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h5><p>所以，我们需要再看一下如何创建session：</p>
<pre><code>    long createSession(ServerCnxn cnxn, byte passwd[], int timeout) &#123;
        long sessionId = sessionTracker.createSession(timeout);
        Random r = new Random(sessionId ^ superSecret);
        r.nextBytes(passwd);
        ByteBuffer to = ByteBuffer.allocate(4);
        to.putInt(timeout);
        cnxn.setSessionId(sessionId);
        submitRequest(cnxn, sessionId, OpCode.createSession, 0, to, null);
        return sessionId;
    &#125;
</code></pre>
<ul>
<li>使用sessionTracker生成一个sessionId</li>
<li>submitRequest构建一个Request请求，请求的类型为OpCode.createSession</li>
</ul>
<pre><code>    private void submitRequest(ServerCnxn cnxn, long sessionId, int type,
            int xid, ByteBuffer bb, List&lt;Id&gt; authInfo) &#123;
        Request si = new Request(cnxn, sessionId, xid, type, bb, authInfo);
        submitRequest(si);
    &#125;
    
    public void submitRequest(Request si) &#123;
        if (firstProcessor == null) &#123;
            synchronized (this) &#123;
                try &#123;
                    // Since all requests are passed to the request
                    // processor it should wait for setting up the request
                    // processor chain. The state will be updated to RUNNING
                    // after the setup.
                    while (state == State.INITIAL) &#123;
                        wait(1000);
                    &#125;
                &#125; catch (InterruptedException e) &#123;
                    LOG.warn(&quot;Unexpected interruption&quot;, e);
                &#125;
                if (firstProcessor == null || state != State.RUNNING) &#123;
                    throw new RuntimeException(&quot;Not started&quot;);
                &#125;
            &#125;
        &#125;
        try &#123;
            touch(si.cnxn);
            boolean validpacket = Request.isValid(si.type);
            if (validpacket) &#123;
                firstProcessor.processRequest(si);
                if (si.cnxn != null) &#123;
                    incInProcess();
                &#125;
            &#125; else &#123;
                LOG.warn(&quot;Received packet at server of unknown type &quot; + si.type);
                new UnimplementedRequestProcessor().processRequest(si);
            &#125;
        &#125; catch (MissingSessionException e) &#123;
            if (LOG.isDebugEnabled()) &#123;
                LOG.debug(&quot;Dropping request: &quot; + e.getMessage());
            &#125;
        &#125; catch (RequestProcessorException e) &#123;
            LOG.error(&quot;Unable to process request:&quot; + e.getMessage(), e);
        &#125;
    &#125;
</code></pre>
<p>上面的代码：</p>
<ul>
<li>创建一个Request</li>
<li>等待firstProcessor创建完成，然后调用firstProcessor.processRequest</li>
</ul>
<blockquote>
<p>firstProcessor是什么东东，下面再揭晓</p>
</blockquote>
<h4 id="2-5-3-zk服务器启动"><a href="#2-5-3-zk服务器启动" class="headerlink" title="2.5.3 zk服务器启动"></a>2.5.3 zk服务器启动</h4><p>再次回到startup，  setZooKeeperServer(zks)，代码很简单</p>
<pre><code> final public void setZooKeeperServer(ZooKeeperServer zk) &#123;
        this.zkServer = zk;
        if (zk != null) &#123;
            zk.setServerCnxnFactory(this);
        &#125;
    &#125;
</code></pre>
<p>然后是zk服务器的startdata:</p>
<pre><code>    public void startdata() 
    throws IOException, InterruptedException &#123;
        //check to see if zkDb is not null
        if (zkDb == null) &#123;
            zkDb = new ZKDatabase(this.txnLogFactory);
        &#125;  
        if (!zkDb.isInitialized()) &#123;
            loadData();
        &#125;
    &#125;
</code></pre>
<p>初始化ZKDatabase，从txnLogFactory里读取快照数据。</p>
<p>最后是zk服务器的startup：</p>
<pre><code>    public synchronized void startup() &#123;
        if (sessionTracker == null) &#123;
            createSessionTracker();
        &#125;
        startSessionTracker();
        setupRequestProcessors();

        registerJMX();

        setState(State.RUNNING);
        notifyAll();
    &#125;
</code></pre>
<p>几件事情：</p>
<ul>
<li>createSessionTracker创建sessionTracker</li>
<li>startSessionTracker启动SessionTracker</li>
<li>setupRequestProcessors 创建请求处理器链</li>
<li>registerJMX 注册JMX</li>
<li>setState(State.RUNNING) 设置状态为运行中</li>
</ul>
<h5 id="SessionTracker"><a href="#SessionTracker" class="headerlink" title="SessionTracker"></a>SessionTracker</h5><p>看SessionTracker的注释：</p>
<blockquote>
<p>This is the basic interface that ZooKeeperServer uses to track sessions.<br> 负责追踪Session的</p>
</blockquote>
<p>在zk里的实现是SessionTrackerImpl：</p>
<pre><code>    protected void createSessionTracker() &#123;
        sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),
                tickTime, 1, getZooKeeperServerListener());
    &#125;
    
    protected void startSessionTracker() &#123;
        ((SessionTrackerImpl)sessionTracker).start();
    &#125;
</code></pre>
<p>SessionTrackerImpl后面再详细分析。</p>
<h4 id="2-5-4-ZooKeeperServer请求处理器链介绍"><a href="#2-5-4-ZooKeeperServer请求处理器链介绍" class="headerlink" title="2.5.4  ZooKeeperServer请求处理器链介绍"></a>2.5.4  ZooKeeperServer请求处理器链介绍</h4><p>这里是zk的核心部分之一，zk接收到的请求最终在这里进行处理。</p>
<pre><code> protected void setupRequestProcessors() &#123;
        RequestProcessor finalProcessor = new FinalRequestProcessor(this);
        RequestProcessor syncProcessor = new SyncRequestProcessor(this,
                finalProcessor);
        ((SyncRequestProcessor)syncProcessor).start();
        firstProcessor = new PrepRequestProcessor(this, syncProcessor);
        ((PrepRequestProcessor)firstProcessor).start();
    &#125;
</code></pre>
<p>请求处理链介绍</p>
<ul>
<li>首先是PrepRequestProcessor</li>
<li>然后是SyncRequestProcessor</li>
<li>最后是finalProcessor</li>
</ul>
<p>下面依次解读：</p>
<h5 id="RequestProcessor"><a href="#RequestProcessor" class="headerlink" title="RequestProcessor"></a>RequestProcessor</h5><blockquote>
<p>RequestProcessors are chained together to process transactions.<br> RequestProcessors都是链在一起的事务处理链</p>
</blockquote>
<pre><code>public interface RequestProcessor &#123;
    @SuppressWarnings(&quot;serial&quot;)
    public static class RequestProcessorException extends Exception &#123;
        public RequestProcessorException(String msg, Throwable t) &#123;
            super(msg, t);
        &#125;
    &#125;

    void processRequest(Request request) throws RequestProcessorException;

    void shutdown();
&#125;
</code></pre>
<p>包含下面这些实现：<br><img src="https://ooo.0o0.ooo/2017/04/27/5901abdf8ffaa.jpg" alt="enter description here" title="1493281760211"><br> 我们重点来看下面几个：</p>
<h5 id="PrepRequestProcessor"><a href="#PrepRequestProcessor" class="headerlink" title="PrepRequestProcessor"></a>PrepRequestProcessor</h5><p>为什么成为请求处理链，看下PrepRequestProcessor代码就知道了：</p>
<pre><code>    RequestProcessor nextProcessor;

    ZooKeeperServer zks;

    public PrepRequestProcessor(ZooKeeperServer zks,
            RequestProcessor nextProcessor) &#123;
        super(&quot;ProcessThread(sid:&quot; + zks.getServerId() + &quot; cport:&quot;
                + zks.getClientPort() + &quot;):&quot;, zks.getZooKeeperServerListener());
        this.nextProcessor = nextProcessor;
        this.zks = zks;
    &#125;protected void pRequest(Request request) throws RequestProcessorException &#123;
        ……
        nextProcessor.processRequest(request);
    &#125;
</code></pre>
<p>构造函数里包含nextProcessor，在pRequest完成后，执行nextProcessor.processRequest，相当于链式执行。</p>
<p>接着分析，再来看类的定义：</p>
<pre><code>public class PrepRequestProcessor extends ZooKeeperCriticalThread implements
            RequestProcessor &#123;

        LinkedBlockingQueue&lt;Request&gt; submittedRequests = new LinkedBlockingQueue&lt;Request&gt;();

        RequestProcessor nextProcessor;    
&#125;
</code></pre>
<p>几个要点</p>
<ul>
<li>继承自ZooKeeperCriticalThread，是一个Thread</li>
<li>重要属性submittedRequests 是一个LinkedBlockingQueue，LinkedBlockingQueue实现是线程安全的，实现了先进先出特性，是作为生产者消费者的首选。</li>
</ul>
<p>PrepRequestProcessor作为处理链的源头，对外提供processRequest方法收集请求，由于是单线程，所以需要将请求放入submittedRequests队列。</p>
<pre><code>    public void processRequest(Request request) &#123;
        // request.addRQRec(&quot;&gt;prep=&quot;+zks.outstandingChanges.size());
        submittedRequests.add(request);
    &#125;
</code></pre>
<p>放入队列后，PrepRequestProcessor本身就是一个Thread，所以start后执行run，在run方法中又会将用户提交的请求取出来进行处理：</p>
<pre><code>    public void run() &#123;
            while (true) &#123;
                // 取出一个请求
                Request request = submittedRequests.take();
                if (Request.requestOfDeath == request) &#123;
                    break;
                &#125;
                // 处理请求
                pRequest(request);
            &#125;
        &#125;
</code></pre>
<p>再来看pRequest：<br><img src="https://ooo.0o0.ooo/2017/04/27/5901af5b683c8.jpg" alt="enter description here" title="1493282652397"></p>
<p>根据request的type，构造对应的请求，对于增删改等影响数据状态的操作都被认为是事务（txn:transaction) ，需要创建出事务请求头(hdr)，调用pRequest2Txn，其他操作则不属于事务操作，需要验证下sessionId是否合法。</p>
<pre><code> //create/close session don&#39;t require request record
            case OpCode.createSession:
            case OpCode.closeSession:
                pRequest2Txn(request.type, zks.getNextZxid(), request, null, true);
                break;
 
            //All the rest don&#39;t need to create a Txn - just verify session
            case OpCode.sync:
            case OpCode.exists:
            case OpCode.getData:
            case OpCode.getACL:
            case OpCode.getChildren:
            case OpCode.getChildren2:
            case OpCode.ping:
            case OpCode.setWatches:
                zks.sessionTracker.checkSession(request.sessionId,
                        request.getOwner());
                break;
</code></pre>
<p>来看pRequest2Txn，以create为例</p>
<pre><code>  pRequest2Txn(request.type, zks.getNextZxid(), request, createRequest, true);
 
   protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize)
        throws KeeperException, IOException, RequestProcessorException
    &#123;
        request.hdr = new TxnHeader(request.sessionId, request.cxid, zxid,
                                    zks.getTime(), type);

        switch (type) &#123;
            case OpCode.create:                
                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                CreateRequest createRequest = (CreateRequest)record;   
                if(deserialize)
                    ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
                String path = createRequest.getPath();
                int lastSlash = path.lastIndexOf(&#39;/&#39;);
                if (lastSlash == -1 || path.indexOf(&#39;\0&#39;) != -1 || failCreate) &#123;
                    LOG.info(&quot;Invalid path &quot; + path + &quot; with session 0x&quot; +
                            Long.toHexString(request.sessionId));
                    throw new KeeperException.BadArgumentsException(path);
                &#125;
                List&lt;ACL&gt; listACL = removeDuplicates(createRequest.getAcl());
                if (!fixupACL(request.authInfo, listACL)) &#123;
                    throw new KeeperException.InvalidACLException(path);
                &#125;
                String parentPath = path.substring(0, lastSlash);
                ChangeRecord parentRecord = getRecordForPath(parentPath);

                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE,
                        request.authInfo);
                int parentCVersion = parentRecord.stat.getCversion();
                CreateMode createMode =
                    CreateMode.fromFlag(createRequest.getFlags());
                if (createMode.isSequential()) &#123;
                    path = path + String.format(Locale.ENGLISH, &quot;%010d&quot;, parentCVersion);
                &#125;
                validatePath(path, request.sessionId);
                try &#123;
                    if (getRecordForPath(path) != null) &#123;
                        throw new KeeperException.NodeExistsException(path);
                    &#125;
                &#125; catch (KeeperException.NoNodeException e) &#123;
                    // ignore this one
                &#125;
                boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
                if (ephemeralParent) &#123;
                    throw new KeeperException.NoChildrenForEphemeralsException(path);
                &#125;
                int newCversion = parentRecord.stat.getCversion()+1;
                request.txn = new CreateTxn(path, createRequest.getData(),
                        listACL,
                        createMode.isEphemeral(), newCversion);
                StatPersisted s = new StatPersisted();
                if (createMode.isEphemeral()) &#123;
                    s.setEphemeralOwner(request.sessionId);
                &#125;
                parentRecord = parentRecord.duplicate(request.hdr.getZxid());
                parentRecord.childCount++;
                parentRecord.stat.setCversion(newCversion);
                addChangeRecord(parentRecord);
                addChangeRecord(new ChangeRecord(request.hdr.getZxid(), path, s,
                        0, listACL));
                break;
</code></pre>
<ul>
<li>首先是 zks.getNextZxid()创建一个事务id，AtomicLong hzxid是自增长id，初始化为0，每次加一</li>
<li>在pRequest2Txn内部，先给request创建一个TxnHeader，这个header包含事务id</li>
<li>然后判断请求类型</li>
<li>zks.sessionTracker.checkSession(request.sessionId, request.getOwner()) 检查session</li>
<li>反序列化为CreateRequest</li>
</ul>
<h5 id="SyncRequestProcessor"><a href="#SyncRequestProcessor" class="headerlink" title="SyncRequestProcessor"></a>SyncRequestProcessor</h5><h5 id="FinalRequestProcessor"><a href="#FinalRequestProcessor" class="headerlink" title="FinalRequestProcessor"></a>FinalRequestProcessor</h5><p>未完待续</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/jadepeng/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/jadepeng/">1</a><span class="space">&hellip;</span><a class="page-number" href="/jadepeng/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/jadepeng/page/9/">9</a><a class="page-number" href="/jadepeng/page/10/">10</a><a class="extend next" rel="next" href="/jadepeng/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="JadePeng"
      src="/jadepeng/images/avatar.gif">
  <p class="site-author-name" itemprop="name">JadePeng</p>
  <div class="site-description" itemprop="description">JadePeng的技术笔记本</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/jadepeng/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/jadepeng/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/jadepeng/tags/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JadePeng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">642k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/jadepeng/lib/anime.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.min.js"></script>
  <script src="/jadepeng/lib/velocity/velocity.ui.min.js"></script>

<script src="/jadepeng/js/utils.js"></script>

<script src="/jadepeng/js/motion.js"></script>


<script src="/jadepeng/js/schemes/muse.js"></script>


<script src="/jadepeng/js/next-boot.js"></script>




  




  
<script src="/jadepeng/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/jadepeng/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
