<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>知识库必看</title>
    <url>/jadepeng/2021/04/27/%E7%9F%A5%E8%AF%86%E5%BA%93%E5%BF%85%E7%9C%8B/</url>
    <content><![CDATA[<h2 id="必读"><a href="#必读" class="headerlink" title="必读"></a>必读</h2><ul>
<li><a href="/team/">团队章程</a></li>
<li><a href="/share/">技术培训材料（培训后需要将材料放入）</a></li>
<li><a href="/help/">如何贡献内容(使用帮助)</a></li>
</ul>
]]></content>
      <tags>
        <tag>帮助</tag>
      </tags>
  </entry>
  <entry>
    <title>博客</title>
    <url>/jadepeng/2021/04/27/%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>这里放部门规范</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>团队章程</title>
    <url>/jadepeng/2021/04/27/%E5%9B%A2%E9%98%9F%E7%AB%A0%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="2021年目标"><a href="#2021年目标" class="headerlink" title="2021年目标"></a>2021年目标</h2><p>1、实施项目制，形成符合团队实际的项目管理最佳实践，提升研发效率30%<br>2、数据中台自运营之路走通，提供行业刚需数据解决方案，一站式自助式标注工具平台，私有化解决方案<br>3、通过信息化、智能标注，助力资源部效能提升10%<br>4、AIMind发展为成熟产品，深入支持医疗BU</p>
<h2 id="分工与职责"><a href="#分工与职责" class="headerlink" title="分工与职责"></a>分工与职责</h2><p>组长、副组长： 辅导组员与发展人才，关心组员成长与诉求，申请资源和争取荣誉，对小组员工负责</p>
<h2 id="虚拟团队角色与职责："><a href="#虚拟团队角色与职责：" class="headerlink" title="虚拟团队角色与职责："></a>虚拟团队角色与职责：</h2><p>项目经理：负责项目全生命周期管理，包含项目人力、内容、进度、质量、风险等管理，在项目期间对项目成员具有管理和考核权，项目的第一责任人。<br>产品经理：负责需求分析和收集，产品的调研和设计，实施跟踪以及验收等，对产品成功负责。<br>架构师：系统方案设计、识别重难点任务并组织调研和评审，代码review与查漏补缺、研发补位<br>开发经理：任务评估、任务分配、代码review与查漏补缺、研发补位<br>测试经理：负责组织测试工作开展及风险问题总结，引入提升团队工作效率质量方法及工具，对版本质量负责</p>
<p>开发组员：负责日常开发工作和项目的具体实施，主动发起设计和代码评审，遇问题及时向上反馈<br>测试组员：积极主动完成测试实施工作，发起上线评审、跟进客户问题验证</p>
<h2 id="应当"><a href="#应当" class="headerlink" title="应当"></a>应当</h2><p>1、高效工作，日事日毕，不能完成，需及时同步并协商一致<br>2、主动共享信息，积极分享观点<br>3、严格遵守团队代码规范，保证代码质量<br>4、自我学习提升专业能力，并与团队分享<br>5、以团队利益为先，主动查漏补缺，增加团队贡献<br>6、做事有始有终，确保工作做到位，有条理、有计划、有产物<br>7、积极乐观、永葆热情</p>
<h2 id="禁止"><a href="#禁止" class="headerlink" title="禁止"></a>禁止</h2><p>1、会议无故迟到或缺席、无效讨论<br>2、只顾及自己小组的利益，不注重部门利益<br>3、扯皮、甩锅<br>4、藏匿潜在问题，侥幸度过<br>5、事不关己，高高挂起<br>6、核心代码未进行代码review，直接上线<br>7、任务分配时挑三拣四</p>
<h2 id="运作规则"><a href="#运作规则" class="headerlink" title="运作规则"></a>运作规则</h2><h3 id="1、-会议类型："><a href="#1、-会议类型：" class="headerlink" title="1、 会议类型："></a>1、 会议类型：</h3><p>（1）月例会：每月第一周或第二周，由部门领导发起，全员参与<br>（2）小组周例会：每周一，由组长和项目经理发起，相关成员参与<br>（3）项目周会：每周一次，由项目经理发起<br>（4）项目晨会：项目经理发起，项目重点攻关时期每天一次<br>（5）临时会议：根据临时事项决定，如需求会、评审会、启动会等，成员需主动发起</p>
<h3 id="2、会议要求"><a href="#2、会议要求" class="headerlink" title="2、会议要求"></a>2、会议要求</h3><p>（1）发起人需至少提前半天发送会议邀请并确保通知到位，与会人员最好提前5分钟到达会议室<br>无故迟到缺席者，罚款100元，超过10分钟的罚款200元（罚款用于团队零食水果购买）<br>项目流程规范中的必要会议，在完成后需要进行评分，总分5分，平均分小于3.5分的，发起人需要总结会议不及预期原因，罚款100元；<br>（2）会议纪要由发起人负责记录整理，会议纪要需要包含出席和迟到情况、会议评分和原因分析，并及时通报与会人员和部门领导，最迟次日中午前发出，形成闭环；<br>未及时发出会议纪要，或者未形成闭环的扣100元，特殊情况可申请豁免<br>（3）重难点工作的方案设计必须发起评审，因未发起评审导致项目出现延期或者重大问题的，罚款200元，月度绩效D；</p>
<h3 id="3、日常工作规范要求"><a href="#3、日常工作规范要求" class="headerlink" title="3、日常工作规范要求"></a>3、日常工作规范要求</h3><p>（1）周报要求：周报最迟周一10点发出，推荐周日完成，超时罚款100元，周一24:00前未发送罚款200元（遇节假日按上班第一天计算）<br>（2）月度考核要求：须于每月10日前提交考核计划，30日前完成绩效自评，次月5日还未自评的，罚款200元，默认分档D</p>
<h3 id="4、团队建设："><a href="#4、团队建设：" class="headerlink" title="4、团队建设："></a>4、团队建设：</h3><p>（1）每季度1次团队座谈复盘会，瓜子花生到位<br>（2）不定期组织运动项目，诸如爬山、体育比赛，劳逸结合<br>（3）每季度一次团建，每年1~2次亲子会活动（可带家属参加）<br>（4）每周零食福利，由罚款和部门费用买单</p>
<h3 id="5、团队421克拉之星"><a href="#5、团队421克拉之星" class="headerlink" title="5、团队421克拉之星"></a>5、团队421克拉之星</h3><p>(1) 对团队行为准则遵循良好或者遵循不到位的，成员可以反馈到项目负责人或者部门负责人，考核时会进行加减分<br>（2）除主动反馈外，每月通过调查问卷内部调研<br>（3）每月度评选一个月度之星，考核B或A<br>每季度评选一次团队421之星，考核A</p>
]]></content>
      <categories>
        <category>部门规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
        <tag>管理规范</tag>
      </tags>
  </entry>
  <entry>
    <title>技术培训</title>
    <url>/jadepeng/2021/04/27/%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD/</url>
    <content><![CDATA[<p>部门培训材料</p>
<h2 id="前端培训"><a href="#前端培训" class="headerlink" title="前端培训"></a>前端培训</h2><blockquote>
<p>课程名称-讲师-时间</p>
</blockquote>
<h2 id="后端培训"><a href="#后端培训" class="headerlink" title="后端培训"></a>后端培训</h2><table>
<thead>
<tr>
<th>时间</th>
<th>课程名称</th>
<th>讲师</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><a href="/2021/04/29/TDD%E5%AE%9E%E8%B7%B5/">高效编码之TDD 实践</a></td>
<td>钟明星</td>
<td>外部</td>
</tr>
</tbody></table>
<blockquote>
<p>课程名称-讲师-时间</p>
</blockquote>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p><strong>分页网页的永久链接地址</strong></p>
<pre><code>:year/:month/:day/:title/    /2013/07/14/hello-world/
</code></pre>
<p>比如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: TDD实践</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> TDD</span><br><span class="line">categories: 技术分享</span><br><span class="line">date: 2021-04-29 10:00:56</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>对应的链接: <code>/2021/04/29/TDD实践/</code></p>
<pre><code>[高效编码之TDD 实践 - 钟明星 - 2021 年 4月 28 日](/2021/04/29/TDD%E5%AE%9E%E8%B7%B5/)
</code></pre>
<p><strong>附件保存</strong></p>
<p>如果有图片、附件，可以放到<code>source/images</code> 文件夹里</p>
<p><strong>在文章里插入pdf</strong></p>
<p>培训课程可以将ppt转为pdf，方便在线预览。</p>
<p>将pdf放到<code>source/images</code> 文件夹，然后在markdown中引用。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% pdf /images/your/file.pdf %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>培训材料</tag>
      </tags>
  </entry>
  <entry>
    <title>chemfig化学式转换为pdf</title>
    <url>/jadepeng/2021/04/25/jqpeng-chemfig%E5%8C%96%E5%AD%A6%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BApdf/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/chemfig.html">chemfig化学式转换为pdf</a></p>
<h2 id="SMILES-与-chemfig"><a href="#SMILES-与-chemfig" class="headerlink" title="SMILES 与 chemfig"></a>SMILES 与 chemfig</h2><p>针对化学分子结构，可以用<code>SMILES</code> （用ASCII字符串明确描述分子结构的规范）来定义。</p>
<blockquote>
<p>SMILES（Simplified molecular input line entry specification），简化分子线性输入规范，是一种用ASCII字符串明确描述分子结构的规范。SMILES由Arthur Weininger和David Weininger于20世纪80年代晚期开发，并由其他人，尤其是日光化学信息系统有限公司（Daylight Chemical Information Systems Inc.），修改和扩展</p>
</blockquote>
<p>但是<code>SMILES</code>需要一定的化学基础，而<code>chemfig</code>则是从图形层面定义了一套规范，方便定义和显示化学式。当然，<code>SMILES</code>可以方便的转换到<code>chemfig</code>.</p>
<p>比如:</p>
<pre><code>CN1C=NC2=C1C(=O)N(C(=O)N2C)C
</code></pre>
<p>可通过mol2chemfig进行转换：</p>
<pre><code>mol2chemfig -wz -i direct &#39;CN1C=NC2=C1C(=O)N(C(=O)N2C)C&#39; &gt; caffeine.tex
</code></pre>
<p>转换后：</p>
<pre><code>\chemfig&#123;-[:138]N-[:84]=^[:156]N-[:228]=[:300](-[:240](-[:180]N(-[:240]%
)-[:120](-[:60]N(-[:120])-)=[:180]O)=[:300]O)-[:12]\phantom&#123;N&#125;&#125;
</code></pre>
<h2 id="chemfig-转换为pdf"><a href="#chemfig-转换为pdf" class="headerlink" title="chemfig 转换为pdf"></a>chemfig 转换为pdf</h2><p>我们可以通过pdflatex（textlive的一个工具）来转换tex为pdf：</p>
<p>拉取txtlive镜像：</p>
<pre><code>docker pull listx/texlive:2020
docker run -it --rm -v `pwd`:/app listx/texlive:2020 bash
</code></pre>
<p>然后用pdflatex转换。首先，我们生成一个tex文件<code>test.tex</code>，一个空tex文件，使用<code>mol2chemfig</code>(可从mol2chemfig下载),中间放上<code>\chemfig&#123;H_3C-[:30]N**6(-(=O)-(**5(-N(-CH_3)--N-))--N(-CH_3)-(=O)-)&#125;</code>，</p>
<pre><code>\documentclass&#123;minimal&#125;
\usepackage&#123;xcolor, mol2chemfig&#125;
\usepackage[margin=(margin)spt,papersize=&#123;%(width)spt, %(height)spt&#125;]&#123;geometry&#125;

\usepackage[helvet]&#123;sfmath&#125;
\setcrambond&#123;2.5pt&#125;&#123;0.4pt&#125;&#123;1.0pt&#125;
\setbondoffset&#123;1pt&#125;
\setdoublesep&#123;2pt&#125;
\setatomsep&#123;%(atomsep)spt&#125;
\renewcommand&#123;\printatom&#125;[1]&#123;\fontsize&#123;8pt&#125;&#123;10pt&#125;\selectfont&#123;\ensuremath&#123;\mathsf&#123;#1&#125;&#125;&#125;&#125;

\setlength&#123;\parindent&#125;&#123;0pt&#125;
\setlength&#123;\fboxsep&#125;&#123;0pt&#125;
\begin&#123;document&#125;
\vspace*&#123;\fill&#125;
\vspace&#123;-8pt&#125;
\begin&#123;center&#125;

\chemfig&#123;H_3C-[:30]N**6(-(=O)-(**5(-N(-CH_3)--N-))--N(-CH_3)-(=O)-)&#125;

\end&#123;center&#125;
\vspace*&#123;\fill&#125;
\end&#123;document&#125;
</code></pre>
<p>然后执行转换：</p>
<pre><code>pdflatex -interaction=nonstopmode  test.tex
</code></pre>
<p>等待1~2s，可以看到生成的pdf，打开：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/4/25/1619350402339.png" alt="PDF"></p>
<p>如何返回给前端呢，可以读取文件，然后转换为base64，python代码：</p>
<pre><code>pdfstring = open(&#39;test.pdf&#39;).read()
encoded = base64.encodestring(pdfstring)
pdflink = &quot;data:application/pdf;base64,&#123;&#125;&quot;.format(encoded)
</code></pre>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>chemfig</tag>
      </tags>
  </entry>
  <entry>
    <title>从wav到Ogg Opus 以及使用java解码OPUS</title>
    <url>/jadepeng/2021/04/13/jqpeng-%E4%BB%8Ewav%E5%88%B0Ogg%20Opus%20%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8java%E8%A7%A3%E7%A0%81OPUS/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/ogg-opus.html">从wav到Ogg Opus 以及使用java解码OPUS</a></p>
<h2 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h2><p>自然界中的声音非常复杂，波形极其复杂，通常我们采用的是脉冲代码调制编码，即PCM编码。PCM通过抽样、量化、编码三个步骤将连续变化的模拟信号转换为数字编码。</p>
<p><strong>采样率</strong></p>
<p>采样频率，也称为采样速度或者采样率，定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。采样频率的倒数是采样周期或者叫作采样时间，它是采样之间的时间间隔。通俗的讲采样频率是指计算机每秒钟采集多少个信号样本。</p>
<p>工业界常用的16K，就是1s有16000个采样点。</p>
<h2 id="WAV"><a href="#WAV" class="headerlink" title="WAV"></a>WAV</h2><p>PCM是原始语音，依据采样率的定义，我们知道要播放PCM，需要知道采样率，因此需要一个文件格式可以封装PCM，<code>wav</code>就是微软公司专门为Windows开发的一种标准数字音频文件，该文件能记录各种单声道或立体声的声音信息。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/4/13/1618277649258.png" alt="WAV格式"></p>
<p>wav文件前44个字节，定义了采样率，channel等参数，播放器通过这个数据就可以播放PCM数据了。</p>
<h2 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h2><p><code>wav</code> 很好的解决了PCM播放的问题，但是PCM实在是太大了，因此出现了<code>mp3</code>等音频格式，通过一定的压缩算法压缩语音，以便于互联网传输分享。</p>
<h2 id="Ogg-与-Opus"><a href="#Ogg-与-Opus" class="headerlink" title="Ogg 与 Opus"></a>Ogg 与 Opus</h2><p>随着音视频应用的越来越广泛，工业界有了越来越多的编解码器，比如<code>Speek</code>,<code>Opus</code></p>
<p>Opus编解码器是专门设计用于互联网的交互式语音和音频传输。它是由IETF的编解码器工作组设计的，合并了Skype的SILK和Xiph. Org的CELT技术。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/4/13/1618278091526.png" alt="OPUS"></p>
<p>OPUS编解码</p>
<p><a href="https://github.com/lostromb/concentus">https://github.com/lostromb/concentus</a> 是一个纯java库，可以编解码OPUS。</p>
<p>OPUS一般是分帧编码，比如一个320采样点（640字节）的数据，编码后为70多个字节，和PCM一样，编码后的OPUS不能直接播放：</p>
<ul>
<li>无法从文件本身获取音频的元数据(采样率,声道数,码率等)</li>
<li>缺少帧分隔标识,无法从连续的文件流中分隔帧(尤其是vbr情况)</li>
</ul>
<p>伴随着HTML5的发展，出现了OGG媒体文件格式，Ogg是一个自由且开放标准的多媒体文件格式，由Xiph.Org基金会所维护。Ogg格式并不受到软件专利的限制，并设计用于有效率地流媒体和处理高质量的数字多媒体。“Ogg”意指一种文件格式，可以纳入各式各样自由和开放源代码的编解码器，包含音效、视频、文字（像字幕）与元数据的处理。</p>
<p>OGG音频</p>
<table>
<thead>
<tr>
<th>压缩类型</th>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>有损</td>
<td>Speek</td>
<td>以低比特率处理语音数据（〜2.1-32 kbit / s /通道）</td>
</tr>
<tr>
<td></td>
<td>Vorbis</td>
<td>处理中高级可变比特率（每通道≈16-500kbit / s）的一般音频数据</td>
</tr>
<tr>
<td></td>
<td>Opus：</td>
<td>以低和高可变比特率处理语音，音乐和通用音频（每通道≈6-510kbit / s）</td>
</tr>
<tr>
<td>无损</td>
<td>FLAC</td>
<td>处理文件和高保真音频数据</td>
</tr>
<tr>
<td>未压缩</td>
<td>OggPCM</td>
<td>处理未压缩的PCM音频,与WAV类似</td>
</tr>
</tbody></table>
<p>参考: <a href="https://juejin.cn/post/6844904016254599175">https://juejin.cn/post/6844904016254599175</a></p>
<p>借博主的图:</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/4/13/1618278801473.png" alt="OGG封装"></p>
<h2 id="java-解码OPUS文件"><a href="#java-解码OPUS文件" class="headerlink" title="java 解码OPUS文件"></a>java 解码OPUS文件</h2><p>通过ffmpeg可以轻松的将wav转换为opus文件，本质是一个ogg封装的opus，我们可以通过<code>vorbis-java</code> 来读取opus文件。</p>
<p>通过OpusInfoTool，可以打印OPUS文件信息：</p>
<pre><code>Processing file &quot;C:\Users\jqpeng\Downloads\opus\wav16k.opus&quot;

Opus Headers:
  Version: 1
  Vendor: Lavf58.27.103
  Channels: 1
  Rate: 16000Hz
  Pre-Skip: 104
  Playback Gain: 0dB

User Comments:
  encoder=Lavc58.53.100 libopus

Logical stream 81c1bbc0 (-2118009920) completed

Opus Audio:
  Total Data Packets: 579
  Total Data Length: 41406
  Audio Length Seconds: 11.564333333333334
  Audio Length: 00:00:11.56
  Packet duration:     20.0ms (max),     20.0ms (avg),     20.0ms (min)
  Page duration:     1000.0ms (max),    965.0ms (avg),    580.0ms (min)
  Total data length: 41406 (overhead: 2.34%)
  Playback length: 00:00:11.56
  Average bitrate: 28.70 kb/s, w/o overhead: 27.97 kb/s
</code></pre>
<p>再借助<code>concentus </code>，我们来解码OPUS文件为PCM文件。</p>
<pre><code>public void testDecode() throws IOException, OpusException &#123;
        FileInputStream fs = new FileInputStream(&quot;\\wav16k.opus&quot;);
        OggFile ogg = new OggFile(fs);
        OpusFile of = new OpusFile(ogg);
        OpusAudioData ad = null;

        System.out.println(of.getInfo().getSampleRate());
        System.out.println(of.getInfo().getNumChannels());

        OpusDecoder decoder = new OpusDecoder(of.getInfo().getSampleRate(),
                                              of.getInfo().getNumChannels());
        System.out.println(of.getTags());
        FileOutputStream fileOut = new FileOutputStream(&quot;wav16k.pcm&quot;);
        // 
        byte[] data_packet = new byte[of.getInfo().getSampleRate()];
        int samples = 0;
        while ((ad = of.getNextAudioPacket()) != null) &#123;
            // NOTE: samplesDecoded 是decode出来的short个数，byte需要*2
            int samplesDecoded =
                    decoder.decode(ad.getData(), 0, ad.getData().length
                            , data_packet, 0, of.getInfo().getSampleRate() / 2,
                                   false);

            fileOut.write(data_packet, 0, samplesDecoded * 2);
            samples += samplesDecoded;
        &#125;

        System.out.println(&quot;samples: &quot; + samples);
        System.out.println(&quot;durationSeconds: &quot; + (samples / 16000f));
        fileOut.close();
    &#125;
</code></pre>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>OPUS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jhipster 加速java web开发</title>
    <url>/jadepeng/2021/03/15/jqpeng-%E4%BD%BF%E7%94%A8jhipster%20%E5%8A%A0%E9%80%9Fjava%20web%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/jhipster.html">使用jhipster 加速java web开发</a></p>
<p>jhipster，中文释义： Java 热爱者!</p>
<blockquote>
<p>JHipster is a development platform to quickly generate, develop, &amp; deploy modern web applications &amp; microservice architectures.</p>
</blockquote>
<p>JHipster 可以通过代码生成，让你快速开发web应用和微服务。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>安装<a href="https://adoptopenjdk.net/">Java</a>,<a href="https://git-scm.com/">Git</a> <a href="https://nodejs.org/">Node.js</a></li>
<li>安装 JHipster <code>npm install -g generator-jhipster</code><ul>
<li>建议安装最新的<a href="https://github.com/jhipster/generator-jhipster/releases/">7.0版本</a>,</li>
</ul>
</li>
<li>创建应用目录 <code>mkdir myApp &amp;&amp; cd myApp</code></li>
<li>运行<code>jhipster</code>命令，根据提示设置应用</li>
<li>可以通过<a href="https://start.jhipster.tech/jdl-studio/">JDL Studio</a> 来生成<code>jhipster-jdl.jh</code>文件</li>
<li>然后通过<code>jhipster jdl jhipster-jdl.jh</code>来生成代码，<code>JDL</code> 后续会重点介绍</li>
</ol>
<h2 id="JDL-入门"><a href="#JDL-入门" class="headerlink" title="JDL 入门"></a>JDL 入门</h2><p>JDL 是jhipster的数据模型定义文件，通过这个文件我们可以定义数据结构，然后jhipster基于这个JDL，就可以生成实体类、服务类以及前端页面。</p>
<p>例如，我们要开发投诉建议，假如设计的数据表如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>comment</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>record_id</td>
<td>主键</td>
<td>Bigint</td>
<td>自增</td>
</tr>
<tr>
<td>feedback_type</td>
<td>反馈类型</td>
<td>unsigned tinyint</td>
<td>枚举值：[1:意见与建议;5:投诉]</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td>varchar(64)</td>
<td></td>
</tr>
<tr>
<td>content</td>
<td>问题描述</td>
<td>varchar(512)</td>
<td></td>
</tr>
<tr>
<td>feedback_status</td>
<td>反馈状态</td>
<td>unsigned tinyint</td>
<td>枚举值：[1:待提交;5:待回复;10:待确认;15:已解决;]</td>
</tr>
<tr>
<td>last_reply_time</td>
<td>最后回复时间</td>
<td>timestamp</td>
<td>与feedback_status联合使用，当状态为2的时候，更新此时间，用于超时判断</td>
</tr>
<tr>
<td>close_type</td>
<td>关闭类型</td>
<td>unsigned tinyint</td>
<td>枚举值：[1:正常关闭;5:超时关闭;]</td>
</tr>
<tr>
<td>created_date</td>
<td>创建时间</td>
<td>timestamp</td>
<td></td>
</tr>
<tr>
<td>created_by</td>
<td>创建者</td>
<td>char(32)</td>
<td></td>
</tr>
</tbody></table>
<p>使用<code>jhipster</code>,我们可以用<code>jdl</code>来定义：</p>
<pre><code>/**
 * 反馈记录表
 */
entity FeedbackRecord &#123;
    /** 反馈类型*/
    feedbackType FeedbackType,
    /** 问题描述 */
    title String,
    /** 反馈状态     */
    feedbackStatus FeedbackStatus,
     /** 是否已完成 */
    lastReplyTime Integer,
     /** 关闭类型     */
    closeType FeedbackCloseType,
     /** 创建时间 */
    createdDate Instant,
    /**     创建者 */
    createdBy String
&#125;
/** 反馈类型 */
enum FeedbackType &#123;
    ADVICE,
    COMPLAINTS
&#125;
/** 反馈状态 */
enum FeedbackStatus &#123;
    TO_BE_SUBMIT, TO_BE_REPLY, TO_BE_CONFIRMED
&#125;
/** 关闭类型 */
enum FeedbackCloseType &#123;
    NORMALLY, TIMEOUT
&#125;

dto * with mapstruct
service all with serviceImpl
paginate all with pagination
</code></pre>
<p>详细讲解：</p>
<h3 id="实体和字段"><a href="#实体和字段" class="headerlink" title="实体和字段"></a>实体和字段</h3><p>entity 表示一个实体，可以增加字段，注意，不用增加id</p>
<p>语法是：</p>
<pre><code>[&lt;entity javadoc&gt;]
[&lt;entity annotation&gt;*]
entity &lt;entity name&gt; [(&lt;table name&gt;)] &#123;
  [&lt;field javadoc&gt;]
  [&lt;field annotation&gt;*]
  &lt;field name&gt; &lt;field type&gt; [&lt;validation&gt;*]
&#125;
</code></pre>
<p>例如：</p>
<pre><code>entity A &#123;
  name String required
  age Integer min(42) max(42)
&#125;
</code></pre>
<p>可以增加<code>required</code>、<code>min</code>、<code>max</code>等验证</p>
<p>字段的注释:</p>
<pre><code>/**
 * This is a comment
 * about a class
 * @author Someone
 */
entity A &#123;
  /** 名称 */
   name String
   age Integer // this is yet another comment
&#125;
</code></pre>
<p>JHipster支持许多字段类型。这种支持取决于您的数据库后端，因此我们使用Java类型来描述它们：Java<code>String</code>将以不同的方式存储在Oracle或Cassandra中，这是JHipster的优势之一，可以为您生成正确的数据库访问代码。</p>
<ul>
<li><code>String</code>: Java字符串。它的默认大小取决于基础后端（如果使用JPA，默认情况下为255），但是您可以使用校验规则进行更改（例如，修改 <code>max</code>大小为1024）。</li>
<li><code>Integer</code>: Java整数。</li>
<li><code>Long</code>: Java长整数。</li>
<li><code>Float</code>: Java浮点数.</li>
<li><code>Double</code>: Java双精度浮点数.</li>
<li><code>BigDecimal</code>: <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">java.math.BigDecimal</a>对象, 当您需要精确的数学计算时使用（通常用于财务操作）。</li>
<li><code>LocalDate</code>: <a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">java.time.LocalDate</a>对象, 用于正确管理Java中的日期。</li>
<li><code>Instant</code>: <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html">java.time.Instant</a>对象, 用于表示时间戳，即时间线上的瞬时点。</li>
<li><code>ZonedDateTime</code>: <a href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html">java.time.ZonedDateTime</a>对象, 用于表示给定时区（通常是日历中会议、约定）中的本地日期时间。请注意，REST和持久层都不支持时区，因此您很可能应该使用<code>Instant</code>。</li>
<li><code>Duration</code>: <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html">java.time.Duration</a>对象, 用于表示时间量。</li>
<li><code>UUID</code>: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html">java.util.UUID</a>对象.</li>
<li><code>Boolean</code>: Java布尔型.</li>
<li><code>Enumeration</code>:Java枚举对象。选择此类型后，子生成器将询问您要在枚举中使用哪些值，并将创建一个特定的<code>enum</code>类来存储它们。</li>
<li><code>Blob</code>: Blob对象，用于存储一些二进制数据。选择此类型时，子生成器将询问您是否要存储通用二进制数据，图像对象或CLOB（长文本）。图像将专门在Angular侧进行优化处理，因此可以将其正常显示给最终用户。</li>
</ul>
<p>字段的数据类型及数据库支持：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/b8149b95c85096326712cb9228e7245ad86e778ae01e53f8cf59c3541aac229f.png" alt="数据类型"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>对于可枚举的状态，建议采用枚举值：</p>
<pre><code>enum [&lt;enum name&gt;] &#123;
  &lt;ENUM KEY&gt; ([&lt;enum value&gt;])
&#125;
</code></pre>
<p>例如：</p>
<pre><code>/** 反馈类型 */
enum FeedbackType &#123;
    ADVICE,
    COMPLAINTS
&#125;
</code></pre>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>SQL数据库支持表和表的关联：</p>
<ul>
<li><code>OneToOne</code></li>
<li><code>OneToMany</code></li>
<li><code>ManyToOne</code></li>
<li><code>ManyToMany</code></li>
</ul>
<p>如何定义关系呢？</p>
<pre><code>relationship (OneToMany | ManyToOne | OneToOne | ManyToMany) &#123;
  &lt;from entity&gt;[&#123;&lt;relationship name&gt;[(&lt;display field&gt;)]&#125;] to &lt;to entity&gt;[&#123;&lt;relationship name&gt;[(&lt;display field&gt;)]&#125;]+
&#125;
</code></pre>
<p>例如, 下面的例子里，我们定义两个对象，<code>File</code>和<code>Chunk</code>，1个<code>Chunk</code>属于一个<code>File</code>：</p>
<pre><code>/**
 * 文件
 */
entity File &#123;
    /** 文件名 */
    name String,
    /** 文件大小 */
    size Long,
    /** 文件路径 */
    path String,
    /** 分片数 */
    chunks Integer,
     /** 是否已完成 */
    complete Integer
&#125;

/**
 * 文件分片
 */
entity Chunk &#123;
    /** md5值 */
    md5 String,
    /** 分片序号 */
    number Integer,
    /** 分片名称 */
    name String
&#125;

relationship ManyToOne &#123;
    /** 所属文件 */
    Chunk&#123;file&#125; to File
&#125;
</code></pre>
<p>对应的关系图：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/5678aa9b0f1462f73e224f3a075fc3ebf7ebcb54f39f2fab44498e4cba7f0330.png" alt="关系图"></p>
<h3 id="生成代码配置"><a href="#生成代码配置" class="headerlink" title="生成代码配置"></a>生成代码配置</h3><p>JHipster提供了丰富的配置，可以用来指定生成代码时的策略，例如是否要生成<code>DTO对象</code>，是否需要支持分页，是否需要生成service类，如果生成service，是使用<code>serviceClass</code>还是<code>serviceImpl</code>。</p>
<p>示例如下：</p>
<pre><code>entity A &#123;
  name String required
&#125;
entity B
entity C

// 筛选实体
filter *

// 生成dto
dto A, B with mapstruct

// 分页
paginate A with infinite-scroll
paginate B with pagination
paginate C with pager  // pager is only available in AngularJS

// 生成service
service A with serviceClass
service C with serviceImpl
</code></pre>
<h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>首先定义<code>jdl</code>文件：</p>
<pre><code>/**
 * 反馈记录表
 */
entity FeedbackRecord &#123;
    /** 反馈类型*/
    feedbackType FeedbackType,
    /** 问题描述 */
    title String,
    /** 反馈状态     */
    feedbackStatus FeedbackStatus,
     /** 是否已完成 */
    lastReplyTime Integer,
     /** 关闭类型     */
    closeType FeedbackCloseType,
     /** 创建时间 */
    createdDate Instant,
    /**     创建者 */
    createdBy String
&#125;
/** 反馈类型 */
enum FeedbackType &#123;
    ADVICE,
    COMPLAINTS
&#125;
/** 反馈状态 */
enum FeedbackStatus &#123;
    TO_BE_SUBMIT, TO_BE_REPLY, TO_BE_CONFIRMED
&#125;
/** 关闭类型 */
enum FeedbackCloseType &#123;
    NORMALLY, TIMEOUT
&#125;
// 筛选实体
filter *
// 生成DTO
dto * with mapstruct
// 生成带接口和实现的service
service all with serviceImpl
// 支持分页
paginate all with pagination
</code></pre>
<p>然后生成代码：</p>
<pre><code>jhipster jdl feedback.jh --force
</code></pre>
<p>可以看到类似下面的输出</p>
<pre><code>D:\Project\jhipster-7&gt;jhipster jdl feedback.jh --force
INFO! Using JHipster version installed locally in current project&#39;s node_modules
INFO! Executing import-jdl feedback.jh
INFO! The JDL is being parsed.
info: The dto option is set for FeedbackRecord, the &#39;serviceClass&#39; value for the &#39;service&#39; is gonna be set for this entity if no other value has been set.
INFO! Found entities: FeedbackRecord.
INFO! The JDL has been successfully parsed
INFO! Generating 0 applications.
INFO! Generating 1 entity.
INFO! Generating entities for application undefined in a new parallel process

Found the D:\Project\jhipster-7\.jhipster\File.json configuration file, entity can be automatically generated!


Found the D:\Project\jhipster-7\.jhipster\Chunk.json configuration file, entity can be automatically generated!


Found the D:\Project\jhipster-7\.jhipster\FeedbackRecord.json configuration file, entity can be automatically generated!

     info Creating changelog for entities File,Chunk,FeedbackRecord
    force .yo-rc.json
    force .jhipster\FeedbackRecord.json
    force .jhipster\File.json
    force .jhipster\Chunk.json
    force src\main\java\com\company\blog\domain\File.java
    force src\main\java\com\company\blog\web\rest\FileResource.java
    force src\main\java\com\company\blog\repository\FileRepository.java
    force src\main\java\com\company\blog\service\FileService.java
    force src\main\java\com\company\blog\service\impl\FileServiceImpl.java
    force src\main\java\com\company\blog\service\dto\FileDTO.java
    force src\main\java\com\company\blog\service\mapper\EntityMapper.java
    force src\main\java\com\company\blog\service\mapper\FileMapper.java
    force src\test\java\com\company\blog\web\rest\FileResourceIT.java
    force src\test\java\com\company\blog\domain\FileTest.java
    force src\test\java\com\company\blog\service\dto\FileDTOTest.java
    force src\test\java\com\company\blog\service\mapper\FileMapperTest.java
    force src\main\webapp\app\shared\model\file.model.ts
    force src\main\webapp\app\entities\file\file-details.vue
    force src\main\webapp\app\entities\file\file-details.component.ts
    force src\main\webapp\app\entities\file\file.vue
    force src\main\webapp\app\entities\file\file.component.ts
    force src\main\webapp\app\entities\file\file.service.ts
    force src\main\webapp\app\entities\file\file-update.vue
    force src\main\webapp\app\entities\file\file-update.component.ts
    force src\test\javascript\spec\app\entities\file\file.component.spec.ts
    force src\test\javascript\spec\app\entities\file\file-details.component.spec.ts
    force src\test\javascript\spec\app\entities\file\file.service.spec.ts
    force src\test\javascript\spec\app\entities\file\file-update.component.spec.ts
    force src\main\webapp\app\router\entities.ts
    force src\main\webapp\app\main.ts
    force src\main\webapp\app\core\jhi-navbar\jhi-navbar.vue
    force src\main\webapp\i18n\zh-cn\file.json
    force src\main\webapp\i18n\zh-cn\global.json
    force src\main\webapp\i18n\en\file.json
    force src\main\webapp\i18n\en\global.json
    force src\main\java\com\company\blog\domain\Chunk.java
    force src\main\java\com\company\blog\web\rest\ChunkResource.java
    force src\main\java\com\company\blog\repository\ChunkRepository.java
    force src\main\java\com\company\blog\service\ChunkService.java
    force src\main\java\com\company\blog\service\impl\ChunkServiceImpl.java
    force src\main\java\com\company\blog\service\dto\ChunkDTO.java
    force src\main\java\com\company\blog\service\mapper\ChunkMapper.java
    force src\test\java\com\company\blog\web\rest\ChunkResourceIT.java
    force src\test\java\com\company\blog\domain\ChunkTest.java
    force src\test\java\com\company\blog\service\dto\ChunkDTOTest.java
    force src\test\java\com\company\blog\service\mapper\ChunkMapperTest.java
    force src\main\webapp\app\shared\model\chunk.model.ts
    force src\main\webapp\app\entities\chunk\chunk-details.vue
    force src\main\webapp\app\entities\chunk\chunk-details.component.ts
    force src\main\webapp\app\entities\chunk\chunk.vue
    force src\main\webapp\app\entities\chunk\chunk.component.ts
    force src\main\webapp\app\entities\chunk\chunk.service.ts
    force src\main\webapp\app\entities\chunk\chunk-update.vue
    force src\main\webapp\app\entities\chunk\chunk-update.component.ts
    force src\test\javascript\spec\app\entities\chunk\chunk.component.spec.ts
    force src\test\javascript\spec\app\entities\chunk\chunk-details.component.spec.ts
    force src\test\javascript\spec\app\entities\chunk\chunk.service.spec.ts
    force src\test\javascript\spec\app\entities\chunk\chunk-update.component.spec.ts
    force src\main\webapp\i18n\zh-cn\chunk.json
    force src\main\webapp\i18n\en\chunk.json
   create src\main\java\com\company\blog\domain\FeedbackRecord.java
   create src\main\java\com\company\blog\web\rest\FeedbackRecordResource.java
   create src\main\java\com\company\blog\repository\FeedbackRecordRepository.java
   create src\main\java\com\company\blog\service\FeedbackRecordService.java
   create src\main\java\com\company\blog\service\impl\FeedbackRecordServiceImpl.java
   create src\main\java\com\company\blog\service\dto\FeedbackRecordDTO.java
   create src\main\java\com\company\blog\service\mapper\FeedbackRecordMapper.java
   create src\test\java\com\company\blog\web\rest\FeedbackRecordResourceIT.java
   create src\test\java\com\company\blog\domain\FeedbackRecordTest.java
   create src\test\java\com\company\blog\service\dto\FeedbackRecordDTOTest.java
   create src\test\java\com\company\blog\service\mapper\FeedbackRecordMapperTest.java
   create src\main\java\com\company\blog\domain\enumeration\FeedbackType.java
   create src\main\java\com\company\blog\domain\enumeration\FeedbackStatus.java
   create src\main\java\com\company\blog\domain\enumeration\FeedbackCloseType.java
   create src\main\webapp\app\shared\model\feedback-record.model.ts
   create src\main\webapp\app\entities\feedback-record\feedback-record-details.vue
   create src\main\webapp\app\entities\feedback-record\feedback-record-details.component.ts
   create src\main\webapp\app\entities\feedback-record\feedback-record.vue
   create src\main\webapp\app\entities\feedback-record\feedback-record.component.ts
   create src\main\webapp\app\entities\feedback-record\feedback-record.service.ts
    force src\main\resources\config\liquibase\changelog\20210312045459_added_entity_File.xml
    force src\main\resources\config\liquibase\fake-data\file.csv
   create src\main\webapp\app\entities\feedback-record\feedback-record-update.vue
    force src\main\resources\config\liquibase\master.xml
    force src\main\resources\config\liquibase\changelog\20210312045500_added_entity_Chunk.xml
    force src\main\resources\config\liquibase\changelog\20210312045500_added_entity_constraints_Chunk.xml
    force src\main\resources\config\liquibase\fake-data\chunk.csv
   create src\main\resources\config\liquibase\changelog\20210312072243_added_entity_FeedbackRecord.xml
   create src\main\resources\config\liquibase\fake-data\feedback_record.csv
   create src\main\webapp\app\entities\feedback-record\feedback-record-update.component.ts
   create src\test\javascript\spec\app\entities\feedback-record\feedback-record.component.spec.ts
   create src\test\javascript\spec\app\entities\feedback-record\feedback-record-details.component.spec.ts
   create src\test\javascript\spec\app\entities\feedback-record\feedback-record.service.spec.ts
   create src\test\javascript\spec\app\entities\feedback-record\feedback-record-update.component.spec.ts
   create src\main\webapp\app\shared\model\enumerations\feedback-type.model.ts
   create src\main\webapp\app\shared\model\enumerations\feedback-status.model.ts
   create src\main\webapp\app\shared\model\enumerations\feedback-close-type.model.ts
   create src\main\webapp\i18n\zh-cn\feedbackType.json
   create src\main\webapp\i18n\en\feedbackType.json
   create src\main\webapp\i18n\zh-cn\feedbackStatus.json
   create src\main\webapp\i18n\en\feedbackStatus.json
   create src\main\webapp\i18n\zh-cn\feedbackCloseType.json
   create src\main\webapp\i18n\en\feedbackCloseType.json
   create src\main\webapp\i18n\zh-cn\feedbackRecord.json
   create src\main\webapp\i18n\en\feedbackRecord.json
Entity File generated successfully.
Entity Chunk generated successfully.
Entity FeedbackRecord generated successfully.

Running `webapp:build` to update client app
</code></pre>
<p>包含domain、service、controller等都有生成：</p>
<h2 id="测试生成程序"><a href="#测试生成程序" class="headerlink" title="测试生成程序"></a>测试生成程序</h2><p>运行程序，</p>
<p>列表页面：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/dfb9592f5a57bfd645ff822113534f78480cb8d52cd59b915f6dd8d017f22a46.png" alt="列表页面"></p>
<p>编辑页面：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/0dc5aa933e3186e0b3daf6c44637601204cecd894a66acfc38142fdda7713243.png" alt="编辑页面"></p>
<h2 id="生成代码介绍"><a href="#生成代码介绍" class="headerlink" title="生成代码介绍"></a>生成代码介绍</h2><h3 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h3><pre><code>package com.company.blog.domain;

import com.company.blog.domain.enumeration.FeedbackCloseType;
import com.company.blog.domain.enumeration.FeedbackStatus;
import com.company.blog.domain.enumeration.FeedbackType;
import java.io.Serializable;
import java.time.Instant;
import javax.persistence.*;

/**
 * 反馈记录表
 */
@Entity
@Table(name = &quot;feedback_record&quot;)
public class FeedbackRecord implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 反馈类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = &quot;feedback_type&quot;)
    private FeedbackType feedbackType;

    /**
     * 问题描述
     */
    @Column(name = &quot;title&quot;)
    private String title;

    /**
     * 反馈状态
     */
    @Enumerated(EnumType.STRING)
    @Column(name = &quot;feedback_status&quot;)
    private FeedbackStatus feedbackStatus;

    /**
     * 是否已完成
     */
    @Column(name = &quot;last_reply_time&quot;)
    private Integer lastReplyTime;

    /**
     * 关闭类型
     */
    @Enumerated(EnumType.STRING)
    @Column(name = &quot;close_type&quot;)
    private FeedbackCloseType closeType;

    /**
     * 创建时间
     */
    @Column(name = &quot;created_date&quot;)
    private Instant createdDate;

    /**
     * 创建者
     */
    @Column(name = &quot;created_by&quot;)
    private String createdBy;

    // jhipster-needle-entity-add-field - JHipster will add fields here
    public Long getId() &#123;
        return id;
    &#125;

    public void setId(Long id) &#123;
        this.id = id;
    &#125;

    public FeedbackRecord id(Long id) &#123;
        this.id = id;
        return this;
    &#125;

    public FeedbackType getFeedbackType() &#123;
        return this.feedbackType;
    &#125;

    public FeedbackRecord feedbackType(FeedbackType feedbackType) &#123;
        this.feedbackType = feedbackType;
        return this;
    &#125;

    public void setFeedbackType(FeedbackType feedbackType) &#123;
        this.feedbackType = feedbackType;
    &#125;

    public String getTitle() &#123;
        return this.title;
    &#125;

    public FeedbackRecord title(String title) &#123;
        this.title = title;
        return this;
    &#125;

    public void setTitle(String title) &#123;
        this.title = title;
    &#125;

    public FeedbackStatus getFeedbackStatus() &#123;
        return this.feedbackStatus;
    &#125;

    public FeedbackRecord feedbackStatus(FeedbackStatus feedbackStatus) &#123;
        this.feedbackStatus = feedbackStatus;
        return this;
    &#125;

    public void setFeedbackStatus(FeedbackStatus feedbackStatus) &#123;
        this.feedbackStatus = feedbackStatus;
    &#125;

    public Integer getLastReplyTime() &#123;
        return this.lastReplyTime;
    &#125;

    public FeedbackRecord lastReplyTime(Integer lastReplyTime) &#123;
        this.lastReplyTime = lastReplyTime;
        return this;
    &#125;

    public void setLastReplyTime(Integer lastReplyTime) &#123;
        this.lastReplyTime = lastReplyTime;
    &#125;

    public FeedbackCloseType getCloseType() &#123;
        return this.closeType;
    &#125;

    public FeedbackRecord closeType(FeedbackCloseType closeType) &#123;
        this.closeType = closeType;
        return this;
    &#125;

    public void setCloseType(FeedbackCloseType closeType) &#123;
        this.closeType = closeType;
    &#125;

    public Instant getCreatedDate() &#123;
        return this.createdDate;
    &#125;

    public FeedbackRecord createdDate(Instant createdDate) &#123;
        this.createdDate = createdDate;
        return this;
    &#125;

    public void setCreatedDate(Instant createdDate) &#123;
        this.createdDate = createdDate;
    &#125;

    public String getCreatedBy() &#123;
        return this.createdBy;
    &#125;

    public FeedbackRecord createdBy(String createdBy) &#123;
        this.createdBy = createdBy;
        return this;
    &#125;

    public void setCreatedBy(String createdBy) &#123;
        this.createdBy = createdBy;
    &#125;

    // jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here

    @Override
    public boolean equals(Object o) &#123;
        if (this == o) &#123;
            return true;
        &#125;
        if (!(o instanceof FeedbackRecord)) &#123;
            return false;
        &#125;
        return id != null &amp;&amp; id.equals(((FeedbackRecord) o).id);
    &#125;

    @Override
    public int hashCode() &#123;
        // see https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/
        return getClass().hashCode();
    &#125;

    // prettier-ignore
    @Override
    public String toString() &#123;
        return &quot;FeedbackRecord&#123;&quot; +
            &quot;id=&quot; + getId() +
            &quot;, feedbackType=&#39;&quot; + getFeedbackType() + &quot;&#39;&quot; +
            &quot;, title=&#39;&quot; + getTitle() + &quot;&#39;&quot; +
            &quot;, feedbackStatus=&#39;&quot; + getFeedbackStatus() + &quot;&#39;&quot; +
            &quot;, lastReplyTime=&quot; + getLastReplyTime() +
            &quot;, closeType=&#39;&quot; + getCloseType() + &quot;&#39;&quot; +
            &quot;, createdDate=&#39;&quot; + getCreatedDate() + &quot;&#39;&quot; +
            &quot;, createdBy=&#39;&quot; + getCreatedBy() + &quot;&#39;&quot; +
            &quot;&#125;&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><pre><code>@SuppressWarnings(&quot;unused&quot;)
@Repository
public interface FeedbackRecordRepository extends JpaRepository&lt;FeedbackRecord, Long&gt;, JpaSpecificationExecutor&lt;FeedbackRecord&gt; &#123;&#125;
</code></pre>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><pre><code>/**
 * Service Interface for managing &#123;@link com.company.blog.domain.FeedbackRecord&#125;.
 */
public interface FeedbackRecordService &#123;
    /**
     * Save a feedbackRecord.
     *
     * @param feedbackRecordDTO the entity to save.
     * @return the persisted entity.
     */
    FeedbackRecordDTO save(FeedbackRecordDTO feedbackRecordDTO);

    /**
     * Partially updates a feedbackRecord.
     *
     * @param feedbackRecordDTO the entity to update partially.
     * @return the persisted entity.
     */
    Optional&lt;FeedbackRecordDTO&gt; partialUpdate(FeedbackRecordDTO feedbackRecordDTO);

    /**
     * Get all the feedbackRecords.
     *
     * @param pageable the pagination information.
     * @return the list of entities.
     */
    Page&lt;FeedbackRecordDTO&gt; findAll(Pageable pageable);

    /**
     * Get the &quot;id&quot; feedbackRecord.
     *
     * @param id the id of the entity.
     * @return the entity.
     */
    Optional&lt;FeedbackRecordDTO&gt; findOne(Long id);

    /**
     * Delete the &quot;id&quot; feedbackRecord.
     *
     * @param id the id of the entity.
     */
    void delete(Long id);
&#125;
</code></pre>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><pre><code>/**
 * REST controller for managing &#123;@link com.company.blog.domain.FeedbackRecord&#125;.
 */
@RestController
@RequestMapping(&quot;/api&quot;)
public class FeedbackRecordResource &#123;

    private final Logger log = LoggerFactory.getLogger(FeedbackRecordResource.class);

    private static final String ENTITY_NAME = &quot;feedbackRecord&quot;;

    @Value(&quot;$&#123;jhipster.clientApp.name&#125;&quot;)
    private String applicationName;

    private final FeedbackRecordService feedbackRecordService;

    private final FeedbackRecordQueryService feedbackRecordQueryService;

    public FeedbackRecordResource(FeedbackRecordService feedbackRecordService, FeedbackRecordQueryService feedbackRecordQueryService) &#123;
        this.feedbackRecordService = feedbackRecordService;
        this.feedbackRecordQueryService = feedbackRecordQueryService;
    &#125;

    /**
     * &#123;@code POST  /feedback-records&#125; : Create a new feedbackRecord.
     *
     * @param feedbackRecordDTO the feedbackRecordDTO to create.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 201 (Created)&#125; and with body the new feedbackRecordDTO, or with status &#123;@code 400 (Bad Request)&#125; if the feedbackRecord has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping(&quot;/feedback-records&quot;)
    public ResponseEntity&lt;FeedbackRecordDTO&gt; createFeedbackRecord(@RequestBody FeedbackRecordDTO feedbackRecordDTO)
        throws URISyntaxException &#123;
        log.debug(&quot;REST request to save FeedbackRecord : &#123;&#125;&quot;, feedbackRecordDTO);
        if (feedbackRecordDTO.getId() != null) &#123;
            throw new BadRequestAlertException(&quot;A new feedbackRecord cannot already have an ID&quot;, ENTITY_NAME, &quot;idexists&quot;);
        &#125;
        FeedbackRecordDTO result = feedbackRecordService.save(feedbackRecordDTO);
        return ResponseEntity
            .created(new URI(&quot;/api/feedback-records/&quot; + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getId().toString()))
            .body(result);
    &#125;

    /**
     * &#123;@code PUT  /feedback-records&#125; : Updates an existing feedbackRecord.
     *
     * @param feedbackRecordDTO the feedbackRecordDTO to update.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and with body the updated feedbackRecordDTO,
     * or with status &#123;@code 400 (Bad Request)&#125; if the feedbackRecordDTO is not valid,
     * or with status &#123;@code 500 (Internal Server Error)&#125; if the feedbackRecordDTO couldn&#39;t be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PutMapping(&quot;/feedback-records&quot;)
    public ResponseEntity&lt;FeedbackRecordDTO&gt; updateFeedbackRecord(@RequestBody FeedbackRecordDTO feedbackRecordDTO)
        throws URISyntaxException &#123;
        log.debug(&quot;REST request to update FeedbackRecord : &#123;&#125;&quot;, feedbackRecordDTO);
        if (feedbackRecordDTO.getId() == null) &#123;
            throw new BadRequestAlertException(&quot;Invalid id&quot;, ENTITY_NAME, &quot;idnull&quot;);
        &#125;
        FeedbackRecordDTO result = feedbackRecordService.save(feedbackRecordDTO);
        return ResponseEntity
            .ok()
            .headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, feedbackRecordDTO.getId().toString()))
            .body(result);
    &#125;

    /**
     * &#123;@code PATCH  /feedback-records&#125; : Updates given fields of an existing feedbackRecord.
     *
     * @param feedbackRecordDTO the feedbackRecordDTO to update.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and with body the updated feedbackRecordDTO,
     * or with status &#123;@code 400 (Bad Request)&#125; if the feedbackRecordDTO is not valid,
     * or with status &#123;@code 404 (Not Found)&#125; if the feedbackRecordDTO is not found,
     * or with status &#123;@code 500 (Internal Server Error)&#125; if the feedbackRecordDTO couldn&#39;t be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PatchMapping(value = &quot;/feedback-records&quot;, consumes = &quot;application/merge-patch+json&quot;)
    public ResponseEntity&lt;FeedbackRecordDTO&gt; partialUpdateFeedbackRecord(@RequestBody FeedbackRecordDTO feedbackRecordDTO)
        throws URISyntaxException &#123;
        log.debug(&quot;REST request to update FeedbackRecord partially : &#123;&#125;&quot;, feedbackRecordDTO);
        if (feedbackRecordDTO.getId() == null) &#123;
            throw new BadRequestAlertException(&quot;Invalid id&quot;, ENTITY_NAME, &quot;idnull&quot;);
        &#125;

        Optional&lt;FeedbackRecordDTO&gt; result = feedbackRecordService.partialUpdate(feedbackRecordDTO);

        return ResponseUtil.wrapOrNotFound(
            result,
            HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, feedbackRecordDTO.getId().toString())
        );
    &#125;

    /**
     * &#123;@code GET  /feedback-records&#125; : get all the feedbackRecords.
     *
     * @param pageable the pagination information.
     * @param criteria the criteria which the requested entities should match.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and the list of feedbackRecords in body.
     */
    @GetMapping(&quot;/feedback-records&quot;)
    public ResponseEntity&lt;List&lt;FeedbackRecordDTO&gt;&gt; getAllFeedbackRecords(FeedbackRecordCriteria criteria, Pageable pageable) &#123;
        log.debug(&quot;REST request to get FeedbackRecords by criteria: &#123;&#125;&quot;, criteria);
        Page&lt;FeedbackRecordDTO&gt; page = feedbackRecordQueryService.findByCriteria(criteria, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return ResponseEntity.ok().headers(headers).body(page.getContent());
    &#125;

    /**
     * &#123;@code GET  /feedback-records/count&#125; : count all the feedbackRecords.
     *
     * @param criteria the criteria which the requested entities should match.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and the count in body.
     */
    @GetMapping(&quot;/feedback-records/count&quot;)
    public ResponseEntity&lt;Long&gt; countFeedbackRecords(FeedbackRecordCriteria criteria) &#123;
        log.debug(&quot;REST request to count FeedbackRecords by criteria: &#123;&#125;&quot;, criteria);
        return ResponseEntity.ok().body(feedbackRecordQueryService.countByCriteria(criteria));
    &#125;

    /**
     * &#123;@code GET  /feedback-records/:id&#125; : get the &quot;id&quot; feedbackRecord.
     *
     * @param id the id of the feedbackRecordDTO to retrieve.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 200 (OK)&#125; and with body the feedbackRecordDTO, or with status &#123;@code 404 (Not Found)&#125;.
     */
    @GetMapping(&quot;/feedback-records/&#123;id&#125;&quot;)
    public ResponseEntity&lt;FeedbackRecordDTO&gt; getFeedbackRecord(@PathVariable Long id) &#123;
        log.debug(&quot;REST request to get FeedbackRecord : &#123;&#125;&quot;, id);
        Optional&lt;FeedbackRecordDTO&gt; feedbackRecordDTO = feedbackRecordService.findOne(id);
        return ResponseUtil.wrapOrNotFound(feedbackRecordDTO);
    &#125;

    /**
     * &#123;@code DELETE  /feedback-records/:id&#125; : delete the &quot;id&quot; feedbackRecord.
     *
     * @param id the id of the feedbackRecordDTO to delete.
     * @return the &#123;@link ResponseEntity&#125; with status &#123;@code 204 (NO_CONTENT)&#125;.
     */
    @DeleteMapping(&quot;/feedback-records/&#123;id&#125;&quot;)
    public ResponseEntity&lt;Void&gt; deleteFeedbackRecord(@PathVariable Long id) &#123;
        log.debug(&quot;REST request to delete FeedbackRecord : &#123;&#125;&quot;, id);
        feedbackRecordService.delete(id);
        return ResponseEntity
            .noContent()
            .headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, ENTITY_NAME, id.toString()))
            .build();
    &#125;
&#125;
</code></pre>
<h3 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h3><p>获取数据</p>
<pre><code>    @GetMapping(&quot;/feedback-records&quot;)
    public ResponseEntity&lt;List&lt;FeedbackRecordDTO&gt;&gt; getAllFeedbackRecords(FeedbackRecordCriteria criteria, Pageable pageable) &#123;
        log.debug(&quot;REST request to get FeedbackRecords by criteria: &#123;&#125;&quot;, criteria);
        Page&lt;FeedbackRecordDTO&gt; page = feedbackRecordQueryService.findByCriteria(criteria, pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(ServletUriComponentsBuilder.fromCurrentRequest(), page);
        return ResponseEntity.ok().headers(headers).body(page.getContent());
    &#125;
</code></pre>
<p>这里有意思的是<code>FeedbackRecordCriteria</code>，可以针对实体中的每个字段进行过滤，不用单独写业务代码去过滤：</p>
<p>比如<code>feedbackStatus</code>是一个枚举，那么可以使用<code>equals</code>，<code>in</code> 等过过滤器。</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/1d9808d0eda2d85271774a65f23b896fccad85c64dd2809615ced2118f3cad4b.png" alt="feedbackStatus"></p>
<p>关于过滤器：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/d8bb64214258bdc59187a085495f9a07e5b94ae8de47490d23c8969a4a3fb43f.png" alt="过滤器"></p>
<p>我们测试下，比如查询<code>feedbackStatus</code> 为 <code>TO_BE_REPLY</code>的，那么可以使用<code>feedbackStatus.equals=TO_BE_REPLY</code></p>
<pre><code>GET http://localhost:8080/api/feedback-records?sort=id,asc&amp;page=0&amp;size=20&amp;feedbackStatus.equals=TO_BE_REPLY




[
    &#123;
        &quot;id&quot;: 1,
        &quot;feedbackType&quot;: &quot;COMPLAINTS&quot;,
        &quot;title&quot;: &quot;SMTP lavender Table&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 9391,
        &quot;closeType&quot;: &quot;NORMALLY&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T21:38:31Z&quot;,
        &quot;createdBy&quot;: &quot;新疆 Central Soft&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 2,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;上海市 haptic&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 53521,
        &quot;closeType&quot;: &quot;NORMALLY&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T18:04:14Z&quot;,
        &quot;createdBy&quot;: &quot;Rubber connect 桥&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 4,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;Senior index&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 67874,
        &quot;closeType&quot;: &quot;TIMEOUT&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T14:53:15Z&quot;,
        &quot;createdBy&quot;: &quot;Uganda&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 6,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;Expanded Sports compelling&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 8032,
        &quot;closeType&quot;: &quot;TIMEOUT&quot;,
        &quot;createdDate&quot;: &quot;2021-03-12T03:53:46Z&quot;,
        &quot;createdBy&quot;: &quot;deposit Chicken mesh&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 7,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;Division overriding&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 38000,
        &quot;closeType&quot;: &quot;NORMALLY&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T07:57:51Z&quot;,
        &quot;createdBy&quot;: &quot;Account stable&quot;
    &#125;,
    &#123;
        &quot;id&quot;: 9,
        &quot;feedbackType&quot;: &quot;ADVICE&quot;,
        &quot;title&quot;: &quot;Loan&quot;,
        &quot;feedbackStatus&quot;: &quot;TO_BE_REPLY&quot;,
        &quot;lastReplyTime&quot;: 99908,
        &quot;closeType&quot;: &quot;TIMEOUT&quot;,
        &quot;createdDate&quot;: &quot;2021-03-11T09:47:44Z&quot;,
        &quot;createdBy&quot;: &quot;Re-engineered&quot;
    &#125;
]
</code></pre>
<h2 id="JHipster-管理界面介绍"><a href="#JHipster-管理界面介绍" class="headerlink" title="JHipster 管理界面介绍"></a>JHipster 管理界面介绍</h2><p>JHipster 自动生成的前端代码里，包含了一些管理界面：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/1ae0597aba92bc958635fce65666676237a007614ad17227a6bb84a46af2f3ef.png" alt="管理界面"></p>
<p>资源监控：</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/cd050dc19d39a0a3171ea4e8d883e921a76b0bb768cd51c2535f0124dcbcff26.png" alt="资源监控"></p>
<h2 id="开发实践"><a href="#开发实践" class="headerlink" title="开发实践"></a>开发实践</h2><h3 id="更新实体增加字段"><a href="#更新实体增加字段" class="headerlink" title="更新实体增加字段"></a>更新实体增加字段</h3><p>在项目的工程目录下，有一个<code>.jhipster</code>文件夹，里面包含了已有的实体。</p>
<p><img src="http://ainotedoc.iflyresearch.com/images/ad9cdc11084c56f5f78ff6aed3647038a94199516d87c59bf5aac780d928f1cd.png" alt="已有实体"></p>
<p>要为实体增加字段，可以打开json文件，在fields里新增即可，比如我们增加一个content字段。</p>
<pre><code>&#123;
  &quot;name&quot;: &quot;FeedbackRecord&quot;,
  &quot;fields&quot;: [
    &#123;
      &quot;fieldName&quot;: &quot;feedbackType&quot;,
      &quot;fieldType&quot;: &quot;FeedbackType&quot;,
      &quot;javadoc&quot;: &quot;反馈类型&quot;,
      &quot;fieldValues&quot;: &quot;ADVICE,COMPLAINTS&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;title&quot;,
      &quot;fieldType&quot;: &quot;String&quot;,
      &quot;javadoc&quot;: &quot;问题描述&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;content&quot;,
      &quot;fieldType&quot;: &quot;String&quot;,
      &quot;javadoc&quot;: &quot;问题详情&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;feedbackStatus&quot;,
      &quot;fieldType&quot;: &quot;FeedbackStatus&quot;,
      &quot;javadoc&quot;: &quot;反馈状态&quot;,
      &quot;fieldValues&quot;: &quot;TO_BE_SUBMIT,TO_BE_REPLY,TO_BE_CONFIRMED&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;lastReplyTime&quot;,
      &quot;fieldType&quot;: &quot;Integer&quot;,
      &quot;javadoc&quot;: &quot;是否已完成&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;closeType&quot;,
      &quot;fieldType&quot;: &quot;FeedbackCloseType&quot;,
      &quot;javadoc&quot;: &quot;关闭类型&quot;,
      &quot;fieldValues&quot;: &quot;NORMALLY,TIMEOUT&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;createdDate&quot;,
      &quot;fieldType&quot;: &quot;Instant&quot;,
      &quot;javadoc&quot;: &quot;创建时间&quot;
    &#125;,
    &#123;
      &quot;fieldName&quot;: &quot;createdBy&quot;,
      &quot;fieldType&quot;: &quot;String&quot;,
      &quot;javadoc&quot;: &quot;创建者&quot;
    &#125;
  ],
  &quot;relationships&quot;: [],
  &quot;javadoc&quot;: &quot;反馈记录表&quot;,
  &quot;entityTableName&quot;: &quot;feedback_record&quot;,
  &quot;dto&quot;: &quot;mapstruct&quot;,
  &quot;pagination&quot;: &quot;pagination&quot;,
  &quot;service&quot;: &quot;serviceImpl&quot;,
  &quot;jpaMetamodelFiltering&quot;: true,
  &quot;fluentMethods&quot;: true,
  &quot;readOnly&quot;: false,
  &quot;embedded&quot;: false,
  &quot;applications&quot;: &quot;*&quot;,
  &quot;changelogDate&quot;: &quot;20210312072243&quot;
&#125;
</code></pre>
<p>再次运行实体生成器：</p>
<pre><code>jhipster entity FeedbackRecord
</code></pre>
<p>当您为现有实体运行实体子生成器时，系统会询问您“Do you want to update the entity? This will replace the existing files for this entity, all your custom code will be overwritten”(您确定需要更新实体吗？这将替换该实体的现有文件，所有自定义代码将被覆盖)，并具有以下选项：</p>
<ul>
<li><code>Yes, re generate the entity</code> - 这将重新生成您的实体。提示：这可以通过在运行子生成器时传递<code>--regenerate</code>标志来强制执行</li>
<li><code>Yes, add more fields and relationships</code> - 这将需要您回答一些问题，以添加更多字段和关系</li>
<li><code>Yes, remove fields and relationships</code> - 这将需要您回答一些问题，以便从实体中删除现有字段和关系</li>
<li><code>No, exit</code> - 这将存在子生成器而无需更改任何内容</li>
</ul>
<p>您可能由于以下原因而要更新您的实体：</p>
<p>提示：要立即重新生成所有实体，可以使用以下命令（不提供<code>--force</code>标识会在文件更改时询问覆盖选项）。</p>
<ul>
<li>Linux &amp; Mac: <code>for f in</code>ls .jhipster<code>; do jhipster entity $&#123;f%.*&#125; --force ; done</code></li>
<li>Windows: <code>for %f in (.jhipster/*) do jhipster entity %~nf --force</code></li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3>]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>从Spring框架看设计模式如何灵活使用</title>
    <url>/jadepeng/2021/02/08/jqpeng-%E4%BB%8ESpring%E6%A1%86%E6%9E%B6%E7%9C%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/spring-design-pattern.html">从Spring框架看设计模式如何灵活使用</a></p>
<h2 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h2><p>单例模式是确保每个应用程序只存在一个实例的机制。默认情况下，Spring将所有bean创建为单例。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/8/1612778162513.png" alt="单例模式"></p>
<p>你用@Autowired获取的bean，全局唯一。</p>
<pre><code>@RestController
public class LibraryController &#123;
    
    @Autowired
    private BookRepository repository;

    @GetMapping(&quot;/count&quot;)
    public Long findCount() &#123;
        System.out.println(repository);
        return repository.count();
    &#125;
&#125;
</code></pre>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>Spring 定义了BeanFactory接口，抽象对象容器：</p>
<pre><code>public interface BeanFactory &#123;

    getBean(Class&lt;T&gt; requiredType);
    getBean(Class&lt;T&gt; requiredType, Object... args);
    getBean(String name);

    // ...
]
</code></pre>
<p>每一个<code>getBean</code> 方法其实就是一个工厂方法。</p>
<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/8/1612778397869.png" alt="代理模式"></p>
<p>在Spring中，对于事务，我们可以加一个<code>@Transactional</code>注解，</p>
<pre><code>@Service
public class BookManager &#123;
    
    @Autowired
    private BookRepository repository;

    @Transactional
    public Book create(String author) &#123;
        System.out.println(repository.getClass().getName());
        return repository.create(author);
    &#125;
&#125;
</code></pre>
<p>Spring框架，通过AOP做Proxy。</p>
<h2 id="Decorator装饰器模式"><a href="#Decorator装饰器模式" class="headerlink" title="Decorator装饰器模式"></a>Decorator装饰器模式</h2><p><code>Spring</code> 中的<code>TransactionAwareCacheDecorator</code> 就做了对<code>Cache</code> 的包装：</p>
<pre><code>public interface Cache &#123;
    String getName();

    Object getNativeCache();

    @Nullable
    Cache.ValueWrapper get(Object var1);

    @Nullable
    &lt;T&gt; T get(Object var1, @Nullable Class&lt;T&gt; var2);

    @Nullable
    &lt;T&gt; T get(Object var1, Callable&lt;T&gt; var2);

    void put(Object var1, @Nullable Object var2);
&#125;
</code></pre>
<p><code>TransactionAwareCacheDecorator</code> 实现了<code>Cache</code>接口，构造时传入一个<code>targetCache</code>，在调用<code>put</code>等方法时，增加了自己装饰逻辑在里面。</p>
<pre><code>public class TransactionAwareCacheDecorator implements Cache &#123;
    private final Cache targetCache;

    public TransactionAwareCacheDecorator(Cache targetCache) &#123;
        Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);
        this.targetCache = targetCache;
    &#125;

    public void put(final Object key, @Nullable final Object value) &#123;
        if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
            TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;
                public void afterCommit() &#123;
                    TransactionAwareCacheDecorator.this.targetCache.put(key, value);
                &#125;
            &#125;);
        &#125; else &#123;
            this.targetCache.put(key, value);
        &#125;

    &#125;
</code></pre>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li>装饰模式是继承的有力补充。相比于继承，装饰模式可以增加代码的可维护性、扩展性、复用性。在一些情况下装饰模式可以替代继承，解决类膨胀问题。</li>
<li>装饰模式有利于程序的可扩展性。在一个项目中，有很多因素考虑不周，特别是业务的变更。通过装饰模式重新封装一个装饰类，可以避免修改继承体系中的中间类，而是使用装饰类修饰中间类，这样原有的程序没有变更，通过扩展完成了这次变更。</li>
</ul>
<h2 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式(Composite)"></a>组合模式(Composite)</h2><p>Spring actuate 提供<code>HealthIndicator</code>, 用于监控服务健康状态。</p>
<pre><code>@FunctionalInterface
public interface HealthIndicator &#123;

    /**
     * Return an indication of health.
     * @return the health for
     */
    Health health();

&#125;
</code></pre>
<p>实现类里，有一个<code>CompositeHealthIndicator</code>, 可以<code>add</code>多个<code>HealthIndicator</code>,放入<code>indicators</code>里，最后返回<code>health</code>时，聚合所有<code>indicators</code>的<code>Health</code>。</p>
<pre><code>public class CompositeHealthIndicator implements HealthIndicator &#123;

    private final Map&lt;String, HealthIndicator&gt; indicators;

    private final HealthAggregator healthAggregator;

    /**
     * Create a new &#123;@link CompositeHealthIndicator&#125;.
     * @param healthAggregator the health aggregator
     */
    public CompositeHealthIndicator(HealthAggregator healthAggregator) &#123;
        this(healthAggregator, new LinkedHashMap&lt;&gt;());
    &#125;

    /**
     * Create a new &#123;@link CompositeHealthIndicator&#125; from the specified indicators.
     * @param healthAggregator the health aggregator
     * @param indicators a map of &#123;@link HealthIndicator&#125;s with the key being used as an
     * indicator name.
     */
    public CompositeHealthIndicator(HealthAggregator healthAggregator,
            Map&lt;String, HealthIndicator&gt; indicators) &#123;
        Assert.notNull(healthAggregator, &quot;HealthAggregator must not be null&quot;);
        Assert.notNull(indicators, &quot;Indicators must not be null&quot;);
        this.indicators = new LinkedHashMap&lt;&gt;(indicators);
        this.healthAggregator = healthAggregator;
    &#125;

    public void addHealthIndicator(String name, HealthIndicator indicator) &#123;
        this.indicators.put(name, indicator);
    &#125;

    @Override
    public Health health() &#123;
        Map&lt;String, Health&gt; healths = new LinkedHashMap&lt;&gt;();
        for (Map.Entry&lt;String, HealthIndicator&gt; entry : this.indicators.entrySet()) &#123;
            healths.put(entry.getKey(), entry.getValue().health());
        &#125;
        return this.healthAggregator.aggregate(healths);
    &#125;

&#125;
</code></pre>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>提升NginxTLSSSL HTTPS 性能的7条优化建议</title>
    <url>/jadepeng/2021/02/04/jqpeng-%E6%8F%90%E5%8D%87NginxTLSSSL%20HTTPS%20%E6%80%A7%E8%83%BD%E7%9A%847%E6%9D%A1%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/nginx-tls.html">提升NginxTLSSSL HTTPS 性能的7条优化建议</a></p>
<p>自2018年7月起，谷歌浏览器开始将“ HTTP”网站标记为“不安全”。在过去的几年中，互联网已经迅速过渡到HTTPS，Chrome浏览器的流量超过70％，并且Web排名前100位的网站中有80多个现在默认使用HTTPS 当前Nginx作为最常见的服务器，广泛用于负载均衡（LB)、网关、反向代理。考虑到这一点，让我们看一下Nginx调优技巧，改善Nginx + HTTPS的性能以获得更好的TTFB和更少的延迟。</p>
<p><img src="https://p3-tt.byteimg.com/origin/dfic-imagehandler/0f5b86a5-a1d0-4d4e-a386-43fa9dbda992?from=pc" alt="提升Nginx SSL/HTTPS性能的7条建议"></p>
<p>HTTPS 优化</p>
<h1 id="1-开启-HTTP-2"><a href="#1-开启-HTTP-2" class="headerlink" title="1. 开启 HTTP/2"></a>1. 开启 HTTP/2</h1><p>HTTP/2最初是在Nginx版本1.9.5中实现的，以取代spdy。在Nginx上启用HTTP/2模块很简单。</p>
<p>原先的配置：</p>
<pre><code>listen 443 ssl;
</code></pre>
<p>修改为：</p>
<pre><code>listen 443 ssl http2;
</code></pre>
<p>可以通过curl来验证：</p>
<pre><code>curl --http2 -I https://domain.com/
</code></pre>
<h1 id="2-开启-SSL-session-缓存"><a href="#2-开启-SSL-session-缓存" class="headerlink" title="2. 开启 SSL session 缓存"></a>2. 开启 SSL session 缓存</h1><p>启用 SSL Session 缓存可以减少 TLS 的反复验证，减少 TLS 握手。 1M 的内存就可以缓存 4000 个连接，非常划算，现在内存便宜，尽量开启。</p>
<pre><code>ssl_session_cache shared:SSL:50m; # 1m 4000个，
ssl_session_timeout 1h; # 1小时过期 1 hour during which sessions can be re-used.
</code></pre>
<h1 id="3-禁用-SSL-session-tickets"><a href="#3-禁用-SSL-session-tickets" class="headerlink" title="3. 禁用 SSL session tickets"></a>3. 禁用 SSL session tickets</h1><p>由于Nginx中尚未实现SSL session tickets，可以关闭。</p>
<pre><code>ssl_session_tickets off;
</code></pre>
<h1 id="4-禁用-TLS-version-1-0"><a href="#4-禁用-TLS-version-1-0" class="headerlink" title="4. 禁用 TLS version 1.0"></a>4. 禁用 TLS version 1.0</h1><p>1.3已经出来。1.0可以丢进历史垃圾堆</p>
<pre><code>ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
</code></pre>
<p>修改为</p>
<pre><code>ssl_protocols TLSv1.2 TLSv1.3;
</code></pre>
<h1 id="5-启用OCSP-Stapling"><a href="#5-启用OCSP-Stapling" class="headerlink" title="5. 启用OCSP Stapling"></a>5. 启用OCSP Stapling</h1><p>如果不启用 OCSP Stapling 的话，在用户连接你的服务器的时候，需要去验证证书，这个验证证书的时间不可控，我们开启OCSP Stapling后，可以省掉这一步。</p>
<pre><code>ssl_stapling on;
ssl_stapling_verify on;
ssl_trusted_certificate /path/to/full_chain.pem;
resolver 8.8.8.8 8.8.4.4 valid=300s;
resolver_timeout 5s;
</code></pre>
<h1 id="6-减小ssl-buffer-size"><a href="#6-减小ssl-buffer-size" class="headerlink" title="6. 减小ssl buffer size"></a>6. 减小ssl buffer size</h1><p>ssl_buffer_size 控制在发送数据时的 buffer 大小，默认情况下，缓冲区设置为16k，为了最大程度地减少TTFB（至第一个字节的时间），最好使用较小的值，这样TTFB可以节省大约30 – 50ms。</p>
<pre><code>ssl_buffer_size 4k;
</code></pre>
<h1 id="7-调整-Cipher-优先级"><a href="#7-调整-Cipher-优先级" class="headerlink" title="7. 调整 Cipher 优先级"></a>7. 调整 Cipher 优先级</h1><p>更新更快的 Cipher放前面，这样延迟更小。</p>
<pre><code># 手动启用 cipher 列表
ssl_prefer_server_ciphers on;  # prefer a list of ciphers to prevent old and slow ciphers
ssl_ciphers &#39;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&#39;;
</code></pre>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>高效团队的gitlab flow最佳实践</title>
    <url>/jadepeng/2021/02/02/jqpeng-%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E7%9A%84gitlab%20flow%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/gitlab-flow.html">高效团队的gitlab flow最佳实践</a></p>
<p>当前git是大部分开发团队的首选版本管理工具，一个好的流程规范可以让大家有效地合作，像流水线一样有条不紊地进行团队协作。</p>
<p>业界包含三种flow：</p>
<ul>
<li>Git flow</li>
<li>Github flow</li>
<li>Gitlab flow</li>
</ul>
<p>下面我们先来分析，然后再基于gitlab flow来设计一个适合我们团队的git规范。</p>
<h2 id="从git-flow到gitlab-flow"><a href="#从git-flow到gitlab-flow" class="headerlink" title="从git flow到gitlab flow"></a>从git flow到gitlab flow</h2><h3 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h3><p>先说git flow，大概是这样的。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612267487337.png" alt="gitflow"></p>
<p>然后，我们老的git规范是参考git flow实现的。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612267545738.png" alt="当前git流程"></p>
<p>综合考虑了开发、测试、新功能开发、临时需求、热修复，理想很丰满，现实很骨干，这一套运行起来实在是太复杂了。那么如何精简流程呢？</p>
<p>我们来看业界的做法，首先是github flow。</p>
<h3 id="github-flow"><a href="#github-flow" class="headerlink" title="github flow"></a>github flow</h3><p>Github flow 是Git flow的简化版，专门配合”持续发布”。它是 Github.com 使用的工作流程。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612267831741.png" alt="github flow"></p>
<p>整个流程：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612267888369.png" alt="流程"></p>
<ul>
<li>第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。</li>
<li>第二步：新分支开发完成后，或者需要讨论的时候，就向master发起一个pull request（简称PR）。</li>
<li>第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。</li>
<li>第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</li>
</ul>
<p>github flow这种方式，要保证高质量，对于贡献者的素质要求很高，换句话说，如果代码贡献者素质不那么高，质量就无法得到保证。</p>
<blockquote>
<p>github flow这一套对于库、框架、工具这样并非最终应用的产品来说，没问题，但是，如果如果一个产品是“最终应用”，github flow可能就不合适了。</p>
</blockquote>
<h3 id="gitlab-flow"><a href="#gitlab-flow" class="headerlink" title="gitlab flow"></a>gitlab flow</h3><p>Gitlab flow 是 Git flow 与 Github flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。</p>
<p>Gitlab flow 的最大原则叫做”上游优先”（upsteam first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。</p>
<p>对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。比如，”开发环境”的分支是master，”预发环境”的分支是pre-production，”生产环境”的分支是production。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612268052916.png" alt="gitlab flow"></p>
<p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p>
<p>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612268111739.png" alt="版本发布"></p>
<p>gitlab flow 如何处理hotfix？ git flow之所以这么复杂，一大半原因就是把hotfix考虑得太周全了。hotfix的意思是，当代码部署到产品环境之后发现的问题，需要火速fix。gitlab flow 可以基于后续分支，修改后上线。</p>
<h2 id="团队git规范"><a href="#团队git规范" class="headerlink" title="团队git规范"></a>团队git规范</h2><p>综合上面的介绍，我们决定采用gitlab flow，按照版本发布的模式实施，具体来说：</p>
<ol>
<li>新的迭代开始，所有开发人员从主干master拉个人分支开发特性, 分支命名规范 feature-name</li>
<li>开发完成后，在迭代结束前，合入master分支</li>
<li>master分支合并后，自动cicd到dev环境</li>
<li>开发自测通过后，从master拉取要发布的分支，release-$version，将这个分支部署到测试环境进行测试</li>
<li>测出的bug，通过从release-$versio拉出分支进行修复，修复完成后，再合入release-$versio</li>
<li>正式发布版本，如果上线后，又有bug，根据5的方式处理</li>
<li>等发布版本稳定后，将release-$versio反合入主干</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="开发feature功能"><a href="#开发feature功能" class="headerlink" title="开发feature功能"></a>开发feature功能</h3><p>新建分支，比如<code>feat-test</code></p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612263756008.png" alt="新分支"></p>
<p>开发代码，增加新功能，提交：</p>
<pre><code>@GetMapping(path = &quot;/test&quot;, produces = &quot;application/json&quot;)@ResponseBodypublic Map&lt;String, Object&gt; test() &#123;    return singletonMap(&quot;test&quot;, &quot;test&quot;);&#125;



git commit -m &quot;feat: add test code&quot;
git push origin feat-test
</code></pre>
<h3 id="提交MR"><a href="#提交MR" class="headerlink" title="提交MR"></a>提交MR</h3><p>提交代码后，可以提交<code>mr</code>到<code>master</code>，申请合并代码</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612264109605.png" alt="mr"></p>
<p><strong>Note</strong>：</p>
<ul>
<li>这里可以增加自动代码审查,</li>
</ul>
<h3 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h3><p>研发组长，打开mr，review代码，可以添加建议：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612264544465.png" alt="添加评论"></p>
<p>开发同学根据建议修复代码，或者线下修改后commit代码。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612264598028.png" alt="应用建议"></p>
<p>研发组长确认没有问题后，可以合并到master。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2021/2/2/1612264745987.png" alt="合并"></p>
<p>合并完成，可以删除feat分支。</p>
<p>新功能开发好，可以进行提测。</p>
<h3 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h3><h4 id="语义化版本号"><a href="#语义化版本号" class="headerlink" title="语义化版本号"></a>语义化版本号</h4><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>
<p>主版本号：当你做了不兼容的 API 修改，<br> 次版本号：当你做了向下兼容的功能性新增，<br> 修订号：当你做了向下兼容的问题修正。<br> 先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>
<p>主版本号为0，代表还未发布正式版本。</p>
<h4 id="测试发布"><a href="#测试发布" class="headerlink" title="测试发布"></a>测试发布</h4><p>master分支，自动部署到开发环境（dev）</p>
<p>功能开发完成，并自测通过后，代码合并到待发布版本，</p>
<p>分支规则：</p>
<pre><code>release-version
</code></pre>
<p>版本规则</p>
<pre><code>主版本号.次版本号
</code></pre>
<p>构建时，自动增加修订号：</p>
<pre><code>主版本号.次版本号.修订号
</code></pre>
<p>从最新的master新拉一个分支<code>release-$version</code>，比如<code>release-0.1</code></p>
<pre><code>git checkout -b release-0.1
</code></pre>
<p><code>release-$version</code>会自动构建，版本号为<code>$version.$buildNumber</code></p>
<p>设定<code>release-$version</code> 分支为保护分支，不允许直接推送，只能通过merge不允许直接提交代码，接受<code>MR</code>。</p>
<h4 id="bug修复"><a href="#bug修复" class="headerlink" title="bug修复"></a>bug修复</h4><p>需要修改bug时，从<code>release-$version</code>新拉分支，修改完成后再合并到<code>release-$version</code>分支.</p>
<ul>
<li>Q: 从<code>release-$version</code>拉的分支，如何测试？</li>
<li>A:  这个节点定义为bug修复节点，建议开发同学优先本地测试验证，严重通过再合并到release分支。</li>
<li>Q: <code>release-$version</code>太多怎么办？</li>
<li>A:  可以保留最近的10个版本。历史的打tag后，删除分支。</li>
</ul>
<hr>
<p>感谢您的认真阅读。</p>
<p>如果你觉得有帮助，欢迎点赞支持！</p>
<p>不定期分享软件开发经验，欢迎关注作者, 一起交流软件开发：</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的@Valid 和 @Validated注解你用对了吗</title>
    <url>/jadepeng/2021/01/14/jqpeng-Spring%E4%B8%AD%E7%9A%84@Valid%20%E5%92%8C%20@Validated%E6%B3%A8%E8%A7%A3%E4%BD%A0%E7%94%A8%E5%AF%B9%E4%BA%86%E5%90%97/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/spring-valid.html">Spring中的@Valid 和 @Validated注解你用对了吗</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>本文我们将重点介绍Spring中 <a href="https://docs.oracle.com/javaee/7/api/javax/validation/Valid.html">@Valid</a>和<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/annotation/Validated.html">@Validated</a>注解的区别 。</p>
<p>验证用户输入是否正确是我们应用程序中的常见功能。Spring提供了<code>@Valid</code>和@<code>Validated</code>两个注解来实现验证功能，下面我们来详细介绍它们。</p>
<h2 id="2-Valid和-Validate注解"><a href="#2-Valid和-Validate注解" class="headerlink" title="2. @Valid和@Validate注解"></a>2. @Valid和@Validate注解</h2><p>在Spring中，我们使用<code>@Valid</code> 注解进行方法级别验证，同时还能用它来标记成员属性以进行验证。</p>
<p>但是，此注释不支持分组验证。<code>@Validated</code>则支持分组验证。</p>
<h2 id="3-例子"><a href="#3-例子" class="headerlink" title="3.例子"></a>3.例子</h2><p>让我们考虑一个使用Spring Boot开发的简单用户注册表单。首先，我们只有<code>名称</code>和<code>密码</code>属性：</p>
<pre><code>public class UserAccount &#123;

    @NotNull
    @Size(min = 4, max = 15)
    private String password;

    @NotBlank
    private String name;

    // standard constructors / setters / getters / toString

&#125;
</code></pre>
<p>接下来，让我们看一下控制器。在这里，我们将使用带有<code>@Valid</code>批注的<code>saveBasicInfo</code>方法来验证用户输入：</p>
<pre><code>@RequestMapping(value = &quot;/saveBasicInfo&quot;, method = RequestMethod.POST)
public String saveBasicInfo(
  @Valid @ModelAttribute(&quot;useraccount&quot;) UserAccount useraccount, 
  BindingResult result, 
  ModelMap model) &#123;
    if (result.hasErrors()) &#123;
        return &quot;error&quot;;
    &#125;
    return &quot;success&quot;;
&#125;
</code></pre>
<p>现在让我们测试一下这个方法：</p>
<pre><code>@Test
public void givenSaveBasicInfo_whenCorrectInput`thenSuccess() throws Exception &#123;
    this.mockMvc.perform(MockMvcRequestBuilders.post(&quot;/saveBasicInfo&quot;)
      .accept(MediaType.TEXT_HTML)
      .param(&quot;name&quot;, &quot;test123&quot;)
      .param(&quot;password&quot;, &quot;pass&quot;))
      .andExpect(view().name(&quot;success&quot;))
      .andExpect(status().isOk())
      .andDo(print());
&#125;
</code></pre>
<p>在确认测试成功运行之后，现在让我们扩展功能。下一步的逻辑步骤是将其转换为多步骤注册表格，就像大多数向导一样。第一步，<code>名称</code>和<code>密码</code>保持不变。在第二步中，我们将获取其他信息，例如<code>age</code> 和 <code>phone</code>。因此，我们将使用以下其他字段更新域对象：</p>
<pre><code>public class UserAccount &#123;

    @NotNull
    @Size(min = 4, max = 15)
    private String password;

    @NotBlank
    private String name;

    @Min(value = 18, message = &quot;Age should not be less than 18&quot;)
    private int age;

    @NotBlank
    private String phone;

    // standard constructors / setters / getters / toString   

&#125;
</code></pre>
<p>但是，这一次，我们将注意到先前的测试失败。这是因为我们没有传递<code>年龄</code>和<code>电话</code>字段。</p>
<p>为了支持此行为，我们引入支持分组验证的<code>@Validated</code>批注。</p>
<p><code>分组验证</code>,就是将字段分组，分别验证，比如我们将用户信息分为两组：<code>BasicInfo</code>和<code>AdvanceInfo</code></p>
<p>可以建立两个空接口：</p>
<pre><code>public interface BasicInfo &#123;
&#125;



public interface AdvanceInfo &#123;
&#125;
</code></pre>
<p>第一步将具有<code>BasicInfo</code>接口，第二步 将具有<code>AdvanceInfo</code>  。此外，我们将更新<code>UserAccount</code>类以使用这些标记接口，如下所示：</p>
<pre><code>public class UserAccount &#123;

    @NotNull(groups = BasicInfo.class)
    @Size(min = 4, max = 15, groups = BasicInfo.class)
    private String password;

    @NotBlank(groups = BasicInfo.class)
    private String name;

    @Min(value = 18, message = &quot;Age should not be less than 18&quot;, groups = AdvanceInfo.class)
    private int age;

    @NotBlank(groups = AdvanceInfo.class)
    private String phone;

    // standard constructors / setters / getters / toString   

&#125;
</code></pre>
<p>另外，我们现在将更新控制器以使用<code>@Validated</code>注释而不是<code>@Valid</code>：</p>
<pre><code>@RequestMapping(value = &quot;/saveBasicInfoStep1&quot;, method = RequestMethod.POST)
public String saveBasicInfoStep1(
  @Validated(BasicInfo.class) 
  @ModelAttribute(&quot;useraccount&quot;) UserAccount useraccount, 
  BindingResult result, ModelMap model) &#123;
    if (result.hasErrors()) &#123;
        return &quot;error&quot;;
    &#125;
    return &quot;success&quot;;
&#125;
</code></pre>
<p>更新后，再次执行测试，现在可以成功运行。现在，我们还要测试这个新方法：</p>
<pre><code>@Test
public void givenSaveBasicInfoStep1`whenCorrectInput`thenSuccess() throws Exception &#123;
    this.mockMvc.perform(MockMvcRequestBuilders.post(&quot;/saveBasicInfoStep1&quot;)
      .accept(MediaType.TEXT_HTML)
      .param(&quot;name&quot;, &quot;test123&quot;)
      .param(&quot;password&quot;, &quot;pass&quot;))
      .andExpect(view().name(&quot;success&quot;))
      .andExpect(status().isOk())
      .andDo(print());
&#125;
</code></pre>
<p>也成功运行！</p>
<p>接下来，让我们看看<code>@Valid</code>对于触发嵌套属性验证是必不可少的。</p>
<h2 id="4-使用-Valid批注标记嵌套对象"><a href="#4-使用-Valid批注标记嵌套对象" class="headerlink" title="4.使用@Valid批注标记嵌套对象"></a>4.使用<code>@Valid</code>批注标记嵌套对象</h2><p>@Valid 可以用于嵌套对象。例如，在我们当前的场景中，让我们创建一个 <code>UserAddress </code>对象：</p>
<pre><code>public class UserAddress &#123;

    @NotBlank
    private String countryCode;

    // standard constructors / setters / getters / toString
&#125;
</code></pre>
<p>为了确保验证此嵌套对象，我们将使用<code>@Valid</code>批注装饰属性：</p>
<pre><code>public class UserAccount &#123;

    //...

    @Valid
    @NotNull(groups = AdvanceInfo.class)
    private UserAddress useraddress;

    // standard constructors / setters / getters / toString 
&#125;
</code></pre>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><code>@Valid</code>保证了整个对象的验证, 但是它是对整个对象进行验证，当仅需要部分验证的时候就会出现问题。 这时候，可以使用<code>@Validated</code> 进行分组验证。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.baeldung.com/spring-valid-vs-validated">https://www.baeldung.com/spring-valid-vs-validated</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>hugegraph 存取数据解析</title>
    <url>/jadepeng/2020/12/09/jqpeng-hugegraph%20%E5%AD%98%E5%8F%96%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/hugegraph-storage.html">hugegraph 存取数据解析</a></p>
<p>hugegraph 是百度开源的图数据库，支持hbase，mysql，rocksdb等作为存储后端。本文以EDGE 存储，hbase为存储后端，来探索hugegraph是如何存取数据的。</p>
<h2 id="存数据"><a href="#存数据" class="headerlink" title="存数据"></a>存数据</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/12/9/1607480289186.png" alt="Edge"></p>
<p>首先需要序列化，<code>hbase</code> 使用BinarySerializer:</p>
<ul>
<li>keyWithIdPrefix 和indexWithIdPrefix都是false</li>
</ul>
<p>这个后面会用到。</p>
<pre><code>public class HbaseSerializer extends BinarySerializer &#123;

    public HbaseSerializer() &#123;
        super(false, true);
    &#125;
&#125;
</code></pre>
<p>要存到db，首先需要序列化为BackendEntry，<code>BackendEntry</code> 是图数据库和后端存储的传输对象，Hbase对应的是<code>BinaryBackendEntry</code>:</p>
<pre><code>public class BinaryBackendEntry implements BackendEntry &#123;

    private static final byte[] EMPTY_BYTES = new byte[]&#123;&#125;;

    private final HugeType type;
    private final BinaryId id;
    private Id subId;
    private final List&lt;BackendColumn&gt; columns;
    private long ttl;

    public BinaryBackendEntry(HugeType type, byte[] bytes) &#123;
        this(type, BytesBuffer.wrap(bytes).parseId(type));
    &#125;

    public BinaryBackendEntry(HugeType type, BinaryId id) &#123;
        this.type = type;
        this.id = id;
        this.subId = null;
        this.columns = new ArrayList&lt;&gt;();
        this.ttl = 0L;
    &#125;
</code></pre>
<p>我们来看序列化，序列化，其实就是要将数据放到entry的column列里。</p>
<ul>
<li><code>hbase</code> 的<code>keyWithIdPrefix</code>是false，因此<code>name</code>不包含ownerVertexId（参考下面的EdgeId，去掉ownerVertexId）</li>
</ul>
<pre><code> public BackendEntry writeEdge(HugeEdge edge) &#123;
        BinaryBackendEntry entry = newBackendEntry(edge);
        byte[] name = this.keyWithIdPrefix ?
                      this.formatEdgeName(edge) : EMPTY_BYTES;
        byte[] value = this.formatEdgeValue(edge);
        entry.column(name, value);

        if (edge.hasTtl()) &#123;
            entry.ttl(edge.ttl());
        &#125;

        return entry;
    &#125;
</code></pre>
<p>EdgeId：</p>
<pre><code>    private final Id ownerVertexId;
    private final Directions direction;
    private final Id edgeLabelId;
    private final String sortValues;
    private final Id otherVertexId;

    private final boolean directed;
    private String cache;
</code></pre>
<h3 id="backend-存储"><a href="#backend-存储" class="headerlink" title="backend 存储"></a>backend 存储</h3><p>生成BackendEntry后，通过store机制，交给后端的backend存储。</p>
<p>EDGE的保存，对应HbaseTables.Edge:</p>
<pre><code>public static class Edge extends HbaseTable &#123;

        @Override
        public void insert(Session session, BackendEntry entry) &#123;
            long ttl = entry.ttl();
            if (ttl == 0L) &#123;
                session.put(this.table(), CF, entry.id().asBytes(),
                            entry.columns());
            &#125; else &#123;
                session.put(this.table(), CF, entry.id().asBytes(),
                            entry.columns(), ttl);
            &#125;
        &#125;
&#125;
</code></pre>
<p>CF 是固定的f：</p>
<pre><code>    protected static final byte[] CF = &quot;f&quot;.getBytes();
</code></pre>
<p><code>session.put</code> 对应：</p>
<pre><code> @Override
        public void put(String table, byte[] family, byte[] rowkey,
                        Collection&lt;BackendColumn&gt; columns) &#123;
            Put put = new Put(rowkey);
            for (BackendColumn column : columns) &#123;
                put.addColumn(family, column.name, column.value);
            &#125;
            this.batch(table, put);
        &#125;
</code></pre>
<p>可以看出，存储时，edgeid作为<code>rowkey</code>，然后把去除<code>ownerVertexId</code>后的<code>edgeid</code>作为<code>column.name</code></p>
<h2 id="EDGE-读取"><a href="#EDGE-读取" class="headerlink" title="EDGE 读取"></a>EDGE 读取</h2><h3 id="从backend读取BackendEntry"><a href="#从backend读取BackendEntry" class="headerlink" title="从backend读取BackendEntry"></a>从backend读取BackendEntry</h3><p>读取就是从hbase读取result，转换为BinaryBackendEntry，再转成Edge。</p>
<p>读取，是scan的过程：</p>
<pre><code> /**
         * Inner scan: send scan request to HBase and get iterator
         */
        @Override
        public RowIterator scan(String table, Scan scan) &#123;
            assert !this.hasChanges();

            try (Table htable = table(table)) &#123;
                return new RowIterator(htable.getScanner(scan));
            &#125; catch (IOException e) &#123;
                throw new BackendException(e);
            &#125;
        &#125;
</code></pre>
<p>scan后，返回<code>BackendEntryIterator</code></p>
<pre><code>protected BackendEntryIterator newEntryIterator(Query query,
                                                    RowIterator rows) &#123;
        return new BinaryEntryIterator&lt;&gt;(rows, query, (entry, row) -&gt; &#123;
            E.checkState(!row.isEmpty(), &quot;Can&#39;t parse empty HBase result&quot;);
            byte[] id = row.getRow();
            if (entry == null || !Bytes.prefixWith(id, entry.id().asBytes())) &#123;
                HugeType type = query.resultType();
                // NOTE: only support BinaryBackendEntry currently
                entry = new BinaryBackendEntry(type, id);
            &#125;
            try &#123;
                this.parseRowColumns(row, entry, query);
            &#125; catch (IOException e) &#123;
                throw new BackendException(&quot;Failed to read HBase columns&quot;, e);
            &#125;
            return entry;
        &#125;);
    &#125;
</code></pre>
<p>注意，<code>new BinaryBackendEntry(type, id)</code> 时，BinaryBackendEntry的id并不是<code>rowkey</code>，而是对rowkey做了处理：</p>
<pre><code>public BinaryId parseId(HugeType type) &#123;
        if (type.isIndex()) &#123;
            return this.readIndexId(type);
        &#125;
        // Parse id from bytes
        int start = this.buffer.position();
        /*
         * Since edge id in edges table doesn&#39;t prefix with leading 0x7e,
         * so readId() will return the source vertex id instead of edge id,
         * can&#39;t call: type.isEdge() ? this.readEdgeId() : this.readId();
         */
        Id id = this.readId();
        int end = this.buffer.position();
        int len = end - start;
        byte[] bytes = new byte[len];
        System.arraycopy(this.array(), start, bytes, 0, len);
        return new BinaryId(bytes, id);
    &#125;
</code></pre>
<p>这里是先读取ownervertexId作为Id部分, 然后将剩余的直接放入bytes，组合成BinaryId，和序列化的时候有差别，为什么这么设计呢？原来不管是vertex还是edge，都是当成Vertex来读取的。</p>
<pre><code>protected final BinaryBackendEntry newBackendEntry(HugeEdge edge) &#123;
        BinaryId id = new BinaryId(formatEdgeName(edge),
                                   edge.idWithDirection());
        return newBackendEntry(edge.type(), id);
    &#125;

public EdgeId directed(boolean directed) &#123;
    return new EdgeId(this.ownerVertexId, this.direction, this.edgeLabelId,
                      this.sortValues, this.otherVertexId, directed);
&#125;
</code></pre>
<p>序列化的时候是<code>EdgeId</code>。</p>
<p><code>BackendEntryIterator</code>迭代器支持对结果进行merge, 上面代码里的<code>!Bytes.prefixWith(id, entry.id().asBytes()))</code> 就是对比是否是同一个ownervertex，如果是同一个，则放到同一个BackendEntry的Columns里。</p>
<pre><code>     public BinaryEntryIterator(BackendIterator&lt;Elem&gt; results, Query query,
                               BiFunction&lt;BackendEntry, Elem, BackendEntry&gt; m)

    @Override
    protected final boolean fetch() &#123;
        assert this.current == null;
        if (this.next != null) &#123;
            this.current = this.next;
            this.next = null;
        &#125;

        while (this.results.hasNext()) &#123;
            Elem elem = this.results.next();
            BackendEntry merged = this.merger.apply(this.current, elem);
            E.checkState(merged != null, &quot;Error when merging entry&quot;);
            if (this.current == null) &#123;
                // The first time to read
                this.current = merged;
            &#125; else if (merged == this.current) &#123;
                // The next entry belongs to the current entry
                assert this.current != null;
                if (this.sizeOf(this.current) &gt;= INLINE_BATCH_SIZE) &#123;
                    break;
                &#125;
            &#125; else &#123;
                // New entry
                assert this.next == null;
                this.next = merged;
                break;
            &#125;

            // When limit exceed, stop fetching
            if (this.reachLimit(this.fetched() - 1)) &#123;
                // Need remove last one because fetched limit + 1 records
                this.removeLastRecord();
                this.results.close();
                break;
            &#125;
        &#125;

        return this.current != null;
    &#125;
</code></pre>
<h3 id="从BackendEntry转换为edge"><a href="#从BackendEntry转换为edge" class="headerlink" title="从BackendEntry转换为edge"></a>从BackendEntry转换为edge</h3><p>然后再来看读取数据<code>readVertex</code>，前面说了，就算是edge，其实也是当vertex来读取的：</p>
<pre><code> @Override
    public HugeVertex readVertex(HugeGraph graph, BackendEntry bytesEntry) &#123;
        if (bytesEntry == null) &#123;
            return null;
        &#125;
        BinaryBackendEntry entry = this.convertEntry(bytesEntry);

        // Parse id
        Id id = entry.id().origin();
        Id vid = id.edge() ? ((EdgeId) id).ownerVertexId() : id;
        HugeVertex vertex = new HugeVertex(graph, vid, VertexLabel.NONE);

        // Parse all properties and edges of a Vertex
        for (BackendColumn col : entry.columns()) &#123;
            if (entry.type().isEdge()) &#123;
                // NOTE: the entry id type is vertex even if entry type is edge
                // Parse vertex edges
                this.parseColumn(col, vertex);
            &#125; else &#123;
                assert entry.type().isVertex();
                // Parse vertex properties
                assert entry.columnsSize() == 1 : entry.columnsSize();
                this.parseVertex(col.value, vertex);
            &#125;
        &#125;

        return vertex;
    &#125;
</code></pre>
<p>逻辑：</p>
<ul>
<li>先读取ownervertexid，生成HugeVertex，这个时候只知道id，不知道vertexlabel，所以设置为VertexLabel.NONE</li>
<li>然后，读取BackendColumn，一个edge，一个Column（name是edgeid去除ownervertexid后的部分，value是边数据）</li>
</ul>
<p>读取是在<code>parseColumn</code>:</p>
<pre><code>protected void parseColumn(BackendColumn col, HugeVertex vertex) &#123;
        BytesBuffer buffer = BytesBuffer.wrap(col.name);
        Id id = this.keyWithIdPrefix ? buffer.readId() : vertex.id();
        E.checkState(buffer.remaining() &gt; 0, &quot;Missing column type&quot;);
        byte type = buffer.read();
        // Parse property
        if (type == HugeType.PROPERTY.code()) &#123;
            Id pkeyId = buffer.readId();
            this.parseProperty(pkeyId, BytesBuffer.wrap(col.value), vertex);
        &#125;
        // Parse edge
        else if (type == HugeType.EDGE_IN.code() ||
                 type == HugeType.EDGE_OUT.code()) &#123;
            this.parseEdge(col, vertex, vertex.graph());
        &#125;
        // Parse system property
        else if (type == HugeType.SYS_PROPERTY.code()) &#123;
            // pass
        &#125;
        // Invalid entry
        else &#123;
            E.checkState(false, &quot;Invalid entry(%s) with unknown type(%s): 0x%s&quot;,
                         id, type &amp; 0xff, Bytes.toHex(col.name));
        &#125;
    &#125;
</code></pre>
<p>从``col.name`读取type，如果是edge，则parseEdge:</p>
<pre><code>protected void parseEdge(BackendColumn col, HugeVertex vertex,
                             HugeGraph graph) &#123;
        // owner-vertex + dir + edge-label + sort-values + other-vertex

        BytesBuffer buffer = BytesBuffer.wrap(col.name);
        if (this.keyWithIdPrefix) &#123;
            // Consume owner-vertex id
            buffer.readId();
        &#125;
        byte type = buffer.read();
        Id labelId = buffer.readId();
        String sortValues = buffer.readStringWithEnding();
        Id otherVertexId = buffer.readId();

        boolean direction = EdgeId.isOutDirectionFromCode(type);
        EdgeLabel edgeLabel = graph.edgeLabelOrNone(labelId);

        // Construct edge
        HugeEdge edge = HugeEdge.constructEdge(vertex, direction, edgeLabel,
                                               sortValues, otherVertexId);

        // Parse edge-id + edge-properties
        buffer = BytesBuffer.wrap(col.value);

        //Id id = buffer.readId();

        // Parse edge properties
        this.parseProperties(buffer, edge);

        // Parse edge expired time if needed
        if (edge.hasTtl()) &#123;
            this.parseExpiredTime(buffer, edge);
        &#125;
    &#125;
</code></pre>
<p>从col.name依次读取出type,labelId,sortValues和otherVertexId：</p>
<pre><code>        byte type = buffer.read();
        Id labelId = buffer.readId();
        String sortValues = buffer.readStringWithEnding();
        Id otherVertexId = buffer.readId();
</code></pre>
<p>然后根据labelid找到  <code>EdgeLabel edgeLabel = graph.edgeLabelOrNone(labelId);</code></p>
<p>创建<code>edge</code>, 解析边属性<code>parseProperties</code></p>
<p>最后读取<code>Ttl</code>, 处理结果的时候，会过滤过期数据。</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>hugegraph</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot实现超轻量级网关（反向代理、转发）</title>
    <url>/jadepeng/2020/11/18/jqpeng-spring%20boot%E5%AE%9E%E7%8E%B0%E8%B6%85%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%BD%91%E5%85%B3%EF%BC%88%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E3%80%81%E8%BD%AC%E5%8F%91%EF%BC%89/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/spring-boot-route.html">spring boot实现超轻量级网关（反向代理、转发）</a></p>
<p>在我们的rest服务中，需要暴露一个中间件的接口给用户，但是需要经过rest服务的认证，这是典型的网关使用场景。可以引入网关组件来搞定，但是引入zuul等中间件会增加系统复杂性，这里实现一个超轻量级的网关，只实现请求转发，认证等由rest服务的spring security来搞定。</p>
<p>如何进行请求转发呢？ 熟悉网络请求的同学应该很清楚，请求无非就是请求方式、HTTP header，以及请求body，我们将这些信息取出来，透传给转发的url即可。</p>
<p>举例：</p>
<p>/graphdb/**   转发到 Graph_Server/**</p>
<h2 id="获取转发目的地址："><a href="#获取转发目的地址：" class="headerlink" title="获取转发目的地址："></a>获取转发目的地址：</h2><pre><code>private String createRedictUrl(HttpServletRequest request, String routeUrl, String prefix) &#123;
        String queryString = request.getQueryString();
        return routeUrl + request.getRequestURI().replace(prefix, &quot;&quot;) +
                (queryString != null ? &quot;?&quot; + queryString : &quot;&quot;);
    &#125;
</code></pre>
<h2 id="解析请求头和内容"><a href="#解析请求头和内容" class="headerlink" title="解析请求头和内容"></a>解析请求头和内容</h2><p>然后从request中提取出header、body等内容，构造一个<code>RequestEntity</code>，后续可以用<code>RestTemplate</code>来请求。</p>
<pre><code>private RequestEntity createRequestEntity(HttpServletRequest request, String url) throws URISyntaxException, IOException &#123;
        String method = request.getMethod();
        HttpMethod httpMethod = HttpMethod.resolve(method);
        MultiValueMap&lt;String, String&gt; headers = parseRequestHeader(request);
        byte[] body = parseRequestBody(request);
        return new RequestEntity&lt;&gt;(body, headers, httpMethod, new URI(url));
    &#125;


    private byte[] parseRequestBody(HttpServletRequest request) throws IOException &#123;
        InputStream inputStream = request.getInputStream();
        return StreamUtils.copyToByteArray(inputStream);
    &#125;

    private MultiValueMap&lt;String, String&gt; parseRequestHeader(HttpServletRequest request) &#123;
        HttpHeaders headers = new HttpHeaders();
        List&lt;String&gt; headerNames = Collections.list(request.getHeaderNames());
        for (String headerName : headerNames) &#123;
            List&lt;String&gt; headerValues = Collections.list(request.getHeaders(headerName));
            for (String headerValue : headerValues) &#123;
                headers.add(headerName, headerValue);
            &#125;
        &#125;
        return headers;
    &#125;
</code></pre>
<h2 id="透明转发"><a href="#透明转发" class="headerlink" title="透明转发"></a>透明转发</h2><p>最后用<code>RestTemplate</code>来实现请求：</p>
<pre><code> private ResponseEntity&lt;String&gt; route(RequestEntity requestEntity) &#123;
        RestTemplate restTemplate = new RestTemplate();
        return restTemplate.exchange(requestEntity, String.class);
    &#125;
</code></pre>
<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><p>以下是轻量级转发全部代码：</p>
<pre><code>import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StreamUtils;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collections;
import java.util.List;

@Service
public class RoutingDelegate &#123;


    public ResponseEntity&lt;String&gt; redirect(HttpServletRequest request, HttpServletResponse response,String routeUrl, String prefix) &#123;
        try &#123;
            // build up the redirect URL
            String redirectUrl = createRedictUrl(request,routeUrl, prefix);
            RequestEntity requestEntity = createRequestEntity(request, redirectUrl);
            return route(requestEntity);
        &#125; catch (Exception e) &#123;
            return new ResponseEntity(&quot;REDIRECT ERROR&quot;, HttpStatus.INTERNAL_SERVER_ERROR);
        &#125;
    &#125;

    private String createRedictUrl(HttpServletRequest request, String routeUrl, String prefix) &#123;
        String queryString = request.getQueryString();
        return routeUrl + request.getRequestURI().replace(prefix, &quot;&quot;) +
                (queryString != null ? &quot;?&quot; + queryString : &quot;&quot;);
    &#125;


    private RequestEntity createRequestEntity(HttpServletRequest request, String url) throws URISyntaxException, IOException &#123;
        String method = request.getMethod();
        HttpMethod httpMethod = HttpMethod.resolve(method);
        MultiValueMap&lt;String, String&gt; headers = parseRequestHeader(request);
        byte[] body = parseRequestBody(request);
        return new RequestEntity&lt;&gt;(body, headers, httpMethod, new URI(url));
    &#125;
    private ResponseEntity&lt;String&gt; route(RequestEntity requestEntity) &#123;
        RestTemplate restTemplate = new RestTemplate();
        return restTemplate.exchange(requestEntity, String.class);
    &#125;


    private byte[] parseRequestBody(HttpServletRequest request) throws IOException &#123;
        InputStream inputStream = request.getInputStream();
        return StreamUtils.copyToByteArray(inputStream);
    &#125;

    private MultiValueMap&lt;String, String&gt; parseRequestHeader(HttpServletRequest request) &#123;
        HttpHeaders headers = new HttpHeaders();
        List&lt;String&gt; headerNames = Collections.list(request.getHeaderNames());
        for (String headerName : headerNames) &#123;
            List&lt;String&gt; headerValues = Collections.list(request.getHeaders(headerName));
            for (String headerValue : headerValues) &#123;
                headers.add(headerName, headerValue);
            &#125;
        &#125;
        return headers;
    &#125;
&#125;
</code></pre>
<h2 id="Spring-集成"><a href="#Spring-集成" class="headerlink" title="Spring 集成"></a>Spring 集成</h2><p>Spring Controller,RequestMapping里把GET \ POST\PUT\DELETE 支持的请求带上，就能实现转发了。</p>
<pre><code>@RestController
@RequestMapping(GraphDBController.DELEGATE_PREFIX)
@Api(value = &quot;GraphDB&quot;, tags = &#123;
        &quot;graphdb-Api&quot;
&#125;)
public class GraphDBController &#123;

    @Autowired
    GraphProperties graphProperties;

    public final static String DELEGATE_PREFIX = &quot;/graphdb&quot;;

    @Autowired
    private RoutingDelegate routingDelegate;

    @RequestMapping(value = &quot;/**&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE&#125;, produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity catchAll(HttpServletRequest request, HttpServletResponse response) &#123;
        return routingDelegate.redirect(request, response, graphProperties.getGraphServer(), DELEGATE_PREFIX);
    &#125;
&#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hugegraph 支持sparql 与cypher</title>
    <url>/jadepeng/2020/11/17/jqpeng-hugegraph%20%E6%94%AF%E6%8C%81sparql%20%E4%B8%8Ecypher/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/hugegraph-cypher.html">hugegraph 支持sparql 与cypher</a></p>
<p>hugegraph 是百度开源的基于tinkerpop的图数据库，支持通过gremlin进行查询。</p>
<p>这里，我们来扩展支持sparql 与cypher。</p>
<h2 id="sparql支持"><a href="#sparql支持" class="headerlink" title="sparql支持"></a>sparql支持</h2><p>github上有<code>SparqlToGremlinCompiler</code>，可以支持将sparql转GraphTraversal，集成该工具库即可：</p>
<pre><code>@Path(&quot;graphs/&#123;graph&#125;/sparql&quot;)
@Singleton
public class SparqlAPI extends API &#123;

    private static final Logger LOG = Log.logger(SparqlAPI.class);

    @GET
    @Timed
    @CompressInterceptor.Compress
    @Produces(APPLICATION_JSON_WITH_CHARSET)
    public String query(@Context GraphManager manager,
                        @PathParam(&quot;graph&quot;) String graph,
                        @QueryParam(&quot;sparql&quot;) String sparql) &#123;
        LOG.debug(&quot;Graph [&#123;&#125;] query by sparql: &#123;&#125;&quot;, graph, sparql);

        E.checkArgument(sparql != null &amp;&amp; !sparql.isEmpty(),
                &quot;The sparql parameter can&#39;t be null or empty&quot;);

        HugeGraph g = graph(manager, graph);
        GraphTraversal&lt;Vertex, ?&gt; traversal = SparqlToGremlinCompiler.convertToGremlinTraversal(g, sparql);
        List&lt;?&gt; result = traversal.toList();
        if (result.size() &gt; 0) &#123;
            Object item = result.get(0);
            if (item instanceof Vertex) &#123;
                return manager.serializer(g).writeVertices((Iterator&lt;Vertex&gt;) result.iterator(), false);
            &#125;
            if (item instanceof Map) &#123;
                return manager.serializer(g).writeMap((Map) item);
            &#125;
        &#125;

        return result.toString();
    &#125;
&#125;
</code></pre>
<h2 id="cypher-支持"><a href="#cypher-支持" class="headerlink" title="cypher 支持"></a>cypher 支持</h2><p>opencypher 提供了<code>translation</code>包，支持将cypher转为gremlin：</p>
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.opencypher.gremlin&lt;/groupId&gt;
            &lt;artifactId&gt;translation&lt;/artifactId&gt;
            &lt;version&gt;1.0.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>转换代码：</p>
<pre><code> TranslationFacade cfog = new TranslationFacade();
 String gremlin = cfog.toGremlinGroovy(cypher);
</code></pre>
<p>增加api代码</p>
<pre><code>     @GET
    @Timed
    @CompressInterceptor.Compress
    @Produces(APPLICATION_JSON_WITH_CHARSET)
    public Response query(@Context GraphManager manager,
                          @PathParam(&quot;graph&quot;) String graph,
                          @Context HugeConfig conf,
                          @Context HttpHeaders headers,
                          @QueryParam(&quot;cypher&quot;) String cypher) &#123;
        LOG.debug(&quot;Graph [&#123;&#125;] query by cypher: &#123;&#125;&quot;, graph, cypher);

        return getResponse(graph, headers, cypher);
    &#125;

    private Response getResponse(@PathParam(&quot;graph&quot;) String graph, @Context HttpHeaders headers, @QueryParam(&quot;cypher&quot;) String cypher) &#123;
        E.checkArgument(cypher != null &amp;&amp; !cypher.isEmpty(),
                &quot;The cypher parameter can&#39;t be null or empty&quot;);

        TranslationFacade cfog = new TranslationFacade();
        String gremlin = cfog.toGremlinGroovy(cypher);
        gremlin = &quot;g = &quot; + graph + &quot;.traversal()\n&quot; + gremlin;
        String auth = headers.getHeaderString(HttpHeaders.AUTHORIZATION);
        MultivaluedMap&lt;String, String&gt; params = new MultivaluedHashMap&lt;&gt;();
        params.put(&quot;gremlin&quot;, Arrays.asList(gremlin));
        Response response = this.client().doGetRequest(auth, params);
        return transformResponseIfNeeded(response);
    &#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>hugegraph</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>图数据库查询语言</title>
    <url>/jadepeng/2020/11/17/jqpeng-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/graph-query-lang.html">图数据库查询语言</a></p>
<p>本文介绍图数据库支持的gremlin和Cypher查询语言。</p>
<h2 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h2><p>可使用gremlin api执行</p>
<h2 id="gremlin-api"><a href="#gremlin-api" class="headerlink" title="gremlin api"></a>gremlin api</h2><p>POST <a href="http://localhost:8080/gremlin">http://localhost:8080/gremlin</a></p>
<pre><code>&#123;&quot;gremlin&quot;:&quot;这里是语句&quot;,
 &quot;bindings&quot;: &#123;&#125;,
&quot;language&quot;: &quot;gremlin-groovy&quot;,
&quot;aliases&quot;: &#123;    &quot;graph&quot;: &quot;graphname&quot;,     &quot;g&quot;: &quot;__g_graphname&quot;&#125;
&#125;
</code></pre>
<h3 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h3><pre><code>schema = hugegraph.schema()

schema.propertyKey(&quot;name&quot;).asText().ifNotExist().create()
schema.propertyKey(&quot;age&quot;).asInt().ifNotExist().create()
schema.propertyKey(&quot;time&quot;).asInt().ifNotExist().create()
schema.propertyKey(&quot;reason&quot;).asText().ifNotExist().create()
schema.propertyKey(&quot;type&quot;).asText().ifNotExist().create()

schema.vertexLabel(&quot;character&quot;).properties(&quot;name&quot;, &quot;age&quot;, &quot;type&quot;).primaryKeys(&quot;name&quot;).nullableKeys(&quot;age&quot;).ifNotExist().create()
schema.vertexLabel(&quot;location&quot;).properties(&quot;name&quot;).primaryKeys(&quot;name&quot;).ifNotExist().create()

schema.edgeLabel(&quot;father&quot;).link(&quot;character&quot;, &quot;character&quot;).ifNotExist().create()
schema.edgeLabel(&quot;mother&quot;).link(&quot;character&quot;, &quot;character&quot;).ifNotExist().create()
schema.edgeLabel(&quot;battled&quot;).link(&quot;character&quot;, &quot;character&quot;).properties(&quot;time&quot;).ifNotExist().create()
schema.edgeLabel(&quot;lives&quot;).link(&quot;character&quot;, &quot;location&quot;).properties(&quot;reason&quot;).nullableKeys(&quot;reason&quot;).ifNotExist().create()
schema.edgeLabel(&quot;pet&quot;).link(&quot;character&quot;, &quot;character&quot;).ifNotExist().create()
schema.edgeLabel(&quot;brother&quot;).link(&quot;character&quot;, &quot;character&quot;).ifNotExist().create()
</code></pre>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><pre><code>// add vertices
Vertex saturn = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;saturn&quot;, &quot;age&quot;, 10000, &quot;type&quot;, &quot;titan&quot;)
Vertex sky = graph.addVertex(T.label, &quot;location&quot;, &quot;name&quot;, &quot;sky&quot;)
Vertex sea = graph.addVertex(T.label, &quot;location&quot;, &quot;name&quot;, &quot;sea&quot;)
Vertex jupiter = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;jupiter&quot;, &quot;age&quot;, 5000, &quot;type&quot;, &quot;god&quot;)
Vertex neptune = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;neptune&quot;, &quot;age&quot;, 4500, &quot;type&quot;, &quot;god&quot;)
Vertex hercules = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;hercules&quot;, &quot;age&quot;, 30, &quot;type&quot;, &quot;demigod&quot;)
Vertex alcmene = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;alcmene&quot;, &quot;age&quot;, 45, &quot;type&quot;, &quot;human&quot;)
Vertex pluto = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;pluto&quot;, &quot;age&quot;, 4000, &quot;type&quot;, &quot;god&quot;)
Vertex nemean = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;nemean&quot;, &quot;type&quot;, &quot;monster&quot;)
Vertex hydra = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;hydra&quot;, &quot;type&quot;, &quot;monster&quot;)
Vertex cerberus = graph.addVertex(T.label, &quot;character&quot;, &quot;name&quot;, &quot;cerberus&quot;, &quot;type&quot;, &quot;monster&quot;)
Vertex tartarus = graph.addVertex(T.label, &quot;location&quot;, &quot;name&quot;, &quot;tartarus&quot;)

// add edges
jupiter.addEdge(&quot;father&quot;, saturn)
jupiter.addEdge(&quot;lives&quot;, sky, &quot;reason&quot;, &quot;loves fresh breezes&quot;)
jupiter.addEdge(&quot;brother&quot;, neptune)
jupiter.addEdge(&quot;brother&quot;, pluto)
neptune.addEdge(&quot;lives&quot;, sea, &quot;reason&quot;, &quot;loves waves&quot;)
neptune.addEdge(&quot;brother&quot;, jupiter)
neptune.addEdge(&quot;brother&quot;, pluto)
hercules.addEdge(&quot;father&quot;, jupiter)
hercules.addEdge(&quot;mother&quot;, alcmene)
hercules.addEdge(&quot;battled&quot;, nemean, &quot;time&quot;, 1)
hercules.addEdge(&quot;battled&quot;, hydra, &quot;time&quot;, 2)
hercules.addEdge(&quot;battled&quot;, cerberus, &quot;time&quot;, 12)
pluto.addEdge(&quot;brother&quot;, jupiter)
pluto.addEdge(&quot;brother&quot;, neptune)
pluto.addEdge(&quot;lives&quot;, tartarus, &quot;reason&quot;, &quot;no fear of death&quot;)
pluto.addEdge(&quot;pet&quot;, cerberus)
cerberus.addEdge(&quot;lives&quot;, tartarus)
</code></pre>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/11/17/1605595541783.png" alt="可视化"></p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>创建索引，使用REST API：</p>
<p>POST <a href="http://localhost:8080/graphs/hugegraph/schema/indexlabels">http://localhost:8080/graphs/hugegraph/schema/indexlabels</a></p>
<pre><code>&#123;&quot;name&quot;: &quot;characterAge&quot;,&quot;base_type&quot;: &quot;VERTEX_LABEL&quot;,&quot;base_value&quot;: &quot;character&quot;,&quot;index_type&quot;: &quot;RANGE&quot;,&quot;fields&quot;: [    &quot;age&quot;]
&#125;
</code></pre>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="API-说明"><a href="#API-说明" class="headerlink" title="API 说明"></a>API 说明</h3><p>支持<code>gremlin</code>、<code>sparql</code>和<code>Cypher</code> api，推荐gremlin和Cypher</p>
<h4 id="cypher-api"><a href="#cypher-api" class="headerlink" title="cypher api"></a>cypher api</h4><pre><code>http://127.0.0.1:8080/graphs/hugegraph/cypher?cypher=
</code></pre>
<p>eg:</p>
<pre><code>curl http://127.0.0.1:8080/graphs/hugegraph/cypher?cypher=MATCH%20(n:character)-[:lives]-%3E(location)-[:lives]-(cohabitants)%20where%20n.name=%27pluto%27%20return%20cohabitants.name
</code></pre>
<h4 id="gremlin-api-1"><a href="#gremlin-api-1" class="headerlink" title="gremlin api"></a>gremlin api</h4><p>POST <a href="http://localhost:8080/gremlin">http://localhost:8080/gremlin</a></p>
<pre><code>&#123;&quot;gremlin&quot;:&quot;这里是语句&quot;,
 &quot;bindings&quot;: &#123;&#125;,
&quot;language&quot;: &quot;gremlin-groovy&quot;,
&quot;aliases&quot;: &#123;    &quot;graph&quot;: &quot;graphname&quot;,     &quot;g&quot;: &quot;__g_graphname&quot;&#125;
&#125;
</code></pre>
<h4 id="sparql-api"><a href="#sparql-api" class="headerlink" title="sparql api"></a>sparql api</h4><pre><code>GET http://127.0.0.1:8080/graphs/hugegraph/sparql?sparql=SELECT%20*%20WHERE%20&#123;%20&#125;
</code></pre>
<p><strong>1. 查询hercules的祖父</strong></p>
<pre><code>g.V().hasLabel(&#39;character&#39;).has(&#39;name&#39;,&#39;hercules&#39;).out(&#39;father&#39;).out(&#39;father&#39;)
</code></pre>
<p>也可以通过<code>repeat</code>方式：</p>
<pre><code>g.V().hasLabel(&#39;character&#39;).has(&#39;name&#39;,&#39;hercules&#39;).repeat(__.out(&#39;father&#39;)).times(2)
</code></pre>
<p><strong>cypher</strong></p>
<pre><code>MATCH (n:character)-[:father]-&gt;()-[:father]-&gt;(grandfather) where n.name=&#39;hercules&#39; return grandfather
</code></pre>
<p><strong>2. Find the name of hercules’s father</strong></p>
<pre><code>g.V().hasLabel(&#39;character&#39;).has(&#39;name&#39;,&#39;hercules&#39;).out(&#39;father&#39;).value(&#39;name&#39;)
</code></pre>
<p><strong>cypher</strong></p>
<pre><code>MATCH (n:character)-[:father]-&gt;(father) where n.name=&#39;hercules&#39; return father.name
</code></pre>
<p><strong>3. Find the characters with age &gt; 100</strong></p>
<pre><code>g.V().hasLabel(&#39;character&#39;).has(&#39;age&#39;,gt(100))
</code></pre>
<p><strong>cypher</strong></p>
<pre><code>MATCH (n:character) where n.age &gt; 10 return n
</code></pre>
<p><strong>4. Find who are pluto’s cohabitants</strong></p>
<pre><code>g.V().hasLabel(&#39;character&#39;).has(&#39;name&#39;,&#39;pluto&#39;).out(&#39;lives&#39;).in(&#39;lives&#39;).values(&#39;name&#39;)
</code></pre>
<p><strong>cypher</strong></p>
<pre><code>MATCH (n:character)-[:lives]-&gt;(location)-[:lives]-(cohabitants) where n.name=&#39;pluto&#39; return cohabitants.name
</code></pre>
<p><strong>5. Find pluto can’t be his own cohabitant</strong></p>
<pre><code>pluto = g.V().hasLabel(&#39;character&#39;).has(&#39;name&#39;, &#39;pluto&#39;)
g.V(pluto).out(&#39;lives&#39;).in(&#39;lives&#39;).where(is(neq(pluto)).values(&#39;name&#39;)

// use &#39;as&#39;
g.V().hasLabel(&#39;character&#39;).has(&#39;name&#39;, &#39;pluto&#39;).as(&#39;x&#39;).out(&#39;lives&#39;).in(&#39;lives&#39;).where(neq(&#39;x&#39;)).values(&#39;name&#39;)




cypher&gt; MATCH (src:character&#123;name:&quot;pluto&quot;&#125;)-[:lives]-&gt;()&lt;-[:lives]-(dst:character) RETURN dst.name
</code></pre>
<p><strong>6. Pluto’s Brothers</strong></p>
<pre><code>pluto = g.V().hasLabel(&#39;character&#39;).has(&#39;name&#39;, &#39;pluto&#39;).next()
// where do pluto&#39;s brothers live?
g.V(pluto).out(&#39;brother&#39;).out(&#39;lives&#39;).values(&#39;name&#39;)

// which brother lives in which place?
g.V(pluto).out(&#39;brother&#39;).as(&#39;god&#39;).out(&#39;lives&#39;).as(&#39;place&#39;).select(&#39;god&#39;,&#39;place&#39;)

// what is the name of the brother and the name of the place?
g.V(pluto).out(&#39;brother&#39;).as(&#39;god&#39;).out(&#39;lives&#39;).as(&#39;place&#39;).select(&#39;god&#39;,&#39;place&#39;).by(&#39;name&#39;)



MATCH (src:Character&#123;name:&quot;pluto&quot;&#125;)-[:brother]-&gt;(bro:Character)-[:lives]-&gt;(dst)
RETURN bro.name, dst.name
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>axios 浏览器内存泄露问题解决</title>
    <url>/jadepeng/2020/11/04/jqpeng-axios%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/axios-memory-leaks.html">axios 浏览器内存泄露问题解决</a></p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>业务页面，频繁切换下一条，内存飙涨，导致卡顿，之前怀疑是音频播放器的锅，修改后问题依旧，于是排查网络请求。</p>
<p>到axios issues搜索，发现<code>memory leaks</code>帖子不少，典型的在这里<a href="https://github.com/axios/axios/issues/3217">Axios doesn’t address memory leaks?</a>:</p>
<p>这里提到<code>0.19.2 </code>版本没有问题，但是升级到<code>0.20.0</code>后，出现问题。</p>
<h2 id="两种解决方案："><a href="#两种解决方案：" class="headerlink" title="两种解决方案："></a>两种解决方案：</h2><ul>
<li>降级到<code>0.19.2 </code></li>
<li>在新版本里，不要直接使用axios，而是先创建一个instance</li>
</ul>
<pre><code>const axios = axios.create(&#123;...&#125;) // instead of axios.get(), post(), put() etc.
</code></pre>
<p>排查业务代码，发现每次请求都是创建一个 instance，抛开版本问题，每次创建实例肯定会存在内存问题，最好还是先创建个single instance，后面复用：</p>
<pre><code>import axios, &#123; AxiosRequestConfig, AxiosResponse &#125; from &#39;axios&#39;

// 创建一个实例
const axiosInstance = axios.create() 

  save(parameters: &#123;
    &#39;data&#39;: ResultSaveParam,
    $queryParameters?: any,
    $domain?: string
  &#125;): Promise&lt;AxiosResponse&lt;ApiResult&gt;&gt; &#123;
     .... // 使用axiosInstance
    return axiosInstance.request(config)
  &#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>给Swagger换一套皮肤 Knife4j集成记录</title>
    <url>/jadepeng/2020/11/02/jqpeng-%E7%BB%99Swagger%E6%8D%A2%E4%B8%80%E5%A5%97%E7%9A%AE%E8%82%A4%20Knife4j%E9%9B%86%E6%88%90%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/Knife4j.html">给Swagger换一套皮肤 Knife4j集成记录</a></p>
<p>Swagger有一套经典的UI，但是并不是很好用，之前有看到Knife4j，界面美观、功能完善，因此尝试集成。</p>
<p>demo参考示例地址：<a href="https://gitee.com/xiaoym/swagger-bootstrap-ui-demo/tree/master/knife4j-spring-boot-demo">knife4j-spring-boot-demo</a></p>
<p>Knife4j前身是swagger-bootstrap-ui,是一个为Swagger接口文档赋能的工具</p>
<p>根据官方文档，集成非常方便。</p>
<h2 id="maven引用"><a href="#maven引用" class="headerlink" title="maven引用"></a>maven引用</h2><p>第一步,是在项目的<code>pom.xml</code>文件中引入<code>knife4j</code>的依赖,如下：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
        &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.0.6&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>当前最新版是2.0.6</p>
<p>如果你想使用bom的方式引入,请参考<a href="https://doc.xiaominfo.com/knife4j/mavenbom.html">Maven Bom方式引用</a></p>
<h2 id="创建Swagger配置文件"><a href="#创建Swagger配置文件" class="headerlink" title="创建Swagger配置文件"></a>创建Swagger配置文件</h2><p>新建Swagger的配置文件<code>SwaggerConfiguration.java</code>文件,创建springfox提供的Docket分组对象,代码如下：</p>
<pre><code>@Configuration
@EnableSwagger2
@EnableKnife4j
@Import(BeanValidatorPluginsConfiguration.class)
public class SwaggerConfiguration &#123;

    @Bean(value = &quot;defaultApi2&quot;)
    public Docket defaultApi2() &#123;
        Docket docket=new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                //分组名称
                .groupName(&quot;2.X版本&quot;)
                .select()
                //这里指定Controller扫描包路径
                .apis(RequestHandlerSelectors.basePackage(&quot;com.swagger.bootstrap.ui.demo.new2&quot;))
                .paths(PathSelectors.any())
                .build();
        return docket;
    &#125;

&#125;
</code></pre>
<p>以上有两个注解需要特别说明，如下表：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@EnableSwagger2</code></td>
<td>该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加</td>
</tr>
<tr>
<td><code>@EnableKnife4j</code></td>
<td>该注解是<code>knife4j</code>提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加</td>
</tr>
</tbody></table>
<h2 id="spring-security-免认证"><a href="#spring-security-免认证" class="headerlink" title="spring-security 免认证"></a>spring-security 免认证</h2><p>将<code>/**/doc.html/**</code> 加入：</p>
<pre><code>    private String[] getSwaggerUrl() &#123;
        List&lt;String&gt; urls = new ArrayList&lt;String&gt;();
        urls.add(&quot;/**/swagger-resources/**&quot;);
        urls.add(&quot;/**/webjars/**&quot;);
        urls.add(&quot;/**/doc.html/**&quot;);
        urls.add(&quot;/**/v2/**&quot;);
        urls.add(&quot;/**/swagger-ui.html/**&quot;);
        return urls.toArray(new String[urls.size()]);
    &#125;http.authorizeRequests() .antMatchers(getSwaggerUrl()).permitAll()
</code></pre>
<h2 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h2><p>在浏览器输入地址：<code>http://host:port/doc.html</code></p>
<p>可以设置全局参数：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/11/2/1604286718931.png" alt="全局参数"></p>
<p>支持在线调试</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/11/2/1604286643402.png" alt="在线调试"></p>
<p>离线文档支持导出md、pdf等</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/11/2/1604286760474.png" alt="导出文档"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>前端如何更优雅的调用api呢？参考：</p>
<p><a href="https://www.cnblogs.com/xiaoqi/p/generator-swagger-2-ts-2.html">Vue 使用typescript， 优雅的调用swagger API</a></p>
<p>后面有空，可以将这个集成到knife4j</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>swagger</tag>
        <tag>Knife4j</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐算法之： DeepFM及使用DeepCTR测试</title>
    <url>/jadepeng/2020/10/16/jqpeng-%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%EF%BC%9A%20DeepFM%E5%8F%8A%E4%BD%BF%E7%94%A8DeepCTR%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/deepfm.html">推荐算法之： DeepFM及使用DeepCTR测试</a></p>
<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>左边deep network，右边FM，所以叫deepFM</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/15/1602764397990.png" alt="DeepFm"></p>
<p>包含两个部分：</p>
<ul>
<li>Part1： FM(Factorization machines)，因子分解机部分</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/15/1602764448337.png" alt="FM"></p>
<p>在传统的一阶线性回归之上，加了一个二次项，可以表达两两特征的相互关系。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/15/1602764632765.png" alt="特征相互关系"></p>
<p>这里的公式可以简化，减少计算量，下图来至于网络。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/15/1602765047458.png" alt="FM"></p>
<ul>
<li>Part2： Deep部分</li>
</ul>
<p>deep部分是多层dnn网络。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>实现部分，<a href="https://blog.csdn.net/songbinxu/article/details/80151814">用Keras实现一个DeepFM</a> 和<a href="https://blog.csdn.net/u012969412/article/details/88684723">·清尘·《FM、FMM、DeepFM整理（pytorch）》</a></p>
<p>讲的比较清楚，这里引用keras实现来说明。</p>
<p>整体的网络结构：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/15/1602764969628.png" alt="网络结构"></p>
<h3 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a>特征编码</h3><p>特征可以分为3类：</p>
<ul>
<li>连续型field，比如数字类型特征</li>
<li>单值离散型特征，比如gender，可选为male、female</li>
<li>多值离散型，比如tag，可以有多个</li>
</ul>
<p>连续型field，可以拼接到一起，dense数据。</p>
<p>单值，多值field进行Onehot后，可见单值离散field对应的独热向量只有一位取1，而多值离散field对应的独热向量有多于一位取1，表示该field可以同时取多个特征值。</p>
<table>
<thead>
<tr>
<th>label</th>
<th>shop_score</th>
<th>gender=m</th>
<th>gender=f</th>
<th>interest=f</th>
<th>interest=c</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0.2</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0.8</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="FM-部分"><a href="#FM-部分" class="headerlink" title="FM 部分"></a>FM 部分</h3><p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/15/1602765456508.png" alt="FM"></p>
<p>看公式：<br><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/15/1602764448337.png" alt="FM"></p>
<p>先算 FM一次项：</p>
<ul>
<li>连续型field 可以用Dense(1)层实现</li>
<li>单值离散型field 用Embedding(n,1), n是分类中值的个数</li>
<li>多值离散型field可以同时取多个特征值，为了batch training，必须对样本进行补零padding。同样可以用Embedding实现，因为有多个Embedding，可以取下平均值。</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/15/1602765746903.png" alt="1次项"></p>
<p>然后计算FM二次项，这里理解比较费劲一点。</p>
<p><a href="https://blog.csdn.net/u012969412/article/details/88684723">·清尘·《FM、FMM、DeepFM整理（pytorch）》</a> 深入浅出的讲明白了这个过程，大家可以参见。</p>
<p>我们来看具体实现方面，这里的<a href="http://fancyerii.github.io/2019/12/19/deepfm/#fm-layer">DeepFM模型CTR预估理论与实战</a> 讲解更容易理解。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/16/1602819038585.png" alt="FM公式"></p>
<p>假设只有前面的C1和C2两个Category的特征，词典大小还是3和2。假设输入还是C1=2，C2=2(下标从1开始)，则Embedding之后为V2=[e21,e22,e23,e24]和V5=[e51,e52,e53,e54]。</p>
<p>因为xi和xj同时不为零才需要计算，所以上面的公式里需要计算的只有i=2和j=5的情况。因此：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/16/1602819112460.png" alt="FM"></p>
<p>扩展到多个，比如C1,C2,C3，需要算内积</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/16/1602819135487.png"></p>
<p>怎么用用矩阵乘法一次计算出来呢？我们可以看看这个</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/16/1602819176970.png"></p>
<p>对应的代码就是</p>
<pre><code>       square_of_sum = tf.square(reduce_sum(        concated_embeds_value, axis=1, keep_dims=True))    sum_of_square = reduce_sum(        concated_embeds_value * concated_embeds_value, axis=1, keep_dims=True)    cross_term = square_of_sum - sum_of_square    cross_term = 0.5 * reduce_sum(cross_term, axis=2, keep_dims=False)
</code></pre>
<p>其中concated_embeds_value是拼接起来的embeds_value。</p>
<h3 id="Deep部分"><a href="#Deep部分" class="headerlink" title="Deep部分"></a>Deep部分</h3><p>DNN比较简单，FM的输入和DNN的输入都是同一个group_embedding_dict。</p>
<h2 id="使用movielens-来测试"><a href="#使用movielens-来测试" class="headerlink" title="使用movielens 来测试"></a>使用movielens 来测试</h2><p>下载<code>ml-100k</code> 数据集</p>
<pre><code>wget http://files.grouplens.org/datasets/movielens/ml-100k.zip
unzip ml-100k.zip
</code></pre>
<p>安装相关软件包，sklearn，deepctr</p>
<p>导入包：</p>
<pre><code>import pandas
import pandas as pd
import sklearn
from sklearn.metrics import log_loss, roc_auc_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from tensorflow.python.keras.preprocessing.sequence import pad_sequences
import tensorflow as tf
from tqdm import tqdm

from deepctr.models import DeepFM
from deepctr.feature_column import SparseFeat, VarLenSparseFeat, get_feature_names
import numpy as np
</code></pre>
<p>读取评分数据：</p>
<pre><code>u_data = pd.read_csv(&quot;ml-100k/u.data&quot;, sep=&#39;\t&#39;, header=None)
u_data.columns = [&#39;user_id&#39;, &#39;movie_id&#39;, &#39;rating&#39;, &#39;timestamp&#39;]
</code></pre>
<p>有评分的设置为1，随机采用未评分的</p>
<pre><code>def neg_sample(u_data, neg_rate=1):
    # 全局随机采样
    item_ids = u_data[&#39;movie_id&#39;].unique()
    print(&#39;start neg sample&#39;)
    neg_data = []
    # 负采样
    for user_id, hist in tqdm(u_data.groupby(&#39;user_id&#39;)):
        # 当前用户movie
        rated_movie_list = hist[&#39;movie_id&#39;].tolist()
        candidate_set = list(set(item_ids) - set(rated_movie_list))
        neg_list_id = np.random.choice(candidate_set, size=len(rated_movie_list) * neg_rate, replace=True)
        for id in neg_list_id:
            neg_data.append([user_id, id, -1, 0])
    u_data_neg = pd.DataFrame(neg_data)
    u_data_neg.columns = [&#39;user_id&#39;, &#39;movie_id&#39;, &#39;rating&#39;, &#39;timestamp&#39;]
    u_data = pandas.concat([u_data, u_data_neg])
    print(&#39;end neg sample&#39;)
    return u_data
</code></pre>
<p>读取item数据</p>
<pre><code>u_item = pd.read_csv(&quot;ml-100k/u.item&quot;, sep=&#39;|&#39;, header=None, error_bad_lines=False)
    genres_columns = [&#39;Action&#39;, &#39;Adventure&#39;,
                      &#39;Animation&#39;,
                      &#39;Children&#39;, &#39;Comedy&#39;, &#39;Crime&#39;, &#39;Documentary&#39;, &#39;Drama&#39;, &#39;Fantasy&#39;,
                      &#39;Film_Noir&#39;, &#39;Horror&#39;, &#39;Musical&#39;, &#39;Mystery&#39;, &#39;Romance&#39;, &#39;Sci-Fi&#39;,
                      &#39;Thriller&#39;, &#39;War&#39;, &#39;Western&#39;]

    u_item.columns = [&#39;movie_id&#39;, &#39;title&#39;, &#39;release_date&#39;, &#39;video_date&#39;, &#39;url&#39;, &#39;unknown&#39;] + genres_columns
</code></pre>
<p>处理genres并删除单独的genres列</p>
<pre><code>     genres_list = []
    for index, row in u_item.iterrows():
        genres = []
        for item in genres_columns:
            if row[item]:
                genres.append(item)
        genres_list.append(&#39;|&#39;.join(genres))

    u_item[&#39;genres&#39;] = genres_list
    for item in genres_columns:
        del u_item[item]
</code></pre>
<p>读取用户信息：</p>
<pre><code>  # user id | age | gender | occupation(职业) | zip code（邮编，地区)
    u_user = pd.read_csv(&quot;ml-100k/u.user&quot;, sep=&#39;|&#39;, header=None)
    u_user.columns = [&#39;user_id&#39;, &#39;age&#39;, &#39;gender&#39;, &#39;occupation&#39;, &#39;zip&#39;]
</code></pre>
<p>join到一起：</p>
<pre><code> data = pandas.merge(u_data, u_item, on=&quot;movie_id&quot;, how=&#39;left&#39;)
 data = pandas.merge(data, u_user, on=&quot;user_id&quot;, how=&#39;left&#39;)
 data.to_csv(&#39;ml-100k/data.csv&#39;, index=False)
</code></pre>
<p>处理特征：</p>
<pre><code>sparse_features = [&quot;movie_id&quot;, &quot;user_id&quot;,
                   &quot;gender&quot;, &quot;age&quot;, &quot;occupation&quot;, &quot;zip&quot;, ]

data[sparse_features] = data[sparse_features].astype(str)
target = [&#39;rating&#39;]

# 评分
data[&#39;rating&#39;] = [1 if int(x) &gt;= 0 else 0 for x in data[&#39;rating&#39;]]
</code></pre>
<p>先特征编码：</p>
<pre><code>for feat in sparse_features:    lbe = LabelEncoder()    data[feat] = lbe.fit_transform(data[feat])
</code></pre>
<p>处理genres特征，一个movie有多个genres，先拆分，然后编码为数字，注意是从1开始；由于每个movie的genres长度不一样，可以计算最大长度，位数不足的后面补零（pad_sequences，在post补0）</p>
<pre><code>     def split(x):        key_ans = x.split(&#39;|&#39;)        for key in key_ans:            if key not in key2index:                # Notice : input value 0 is a special &quot;padding&quot;,so we do not use 0 to encode valid feature for sequence input                key2index[key] = len(key2index) + 1        return list(map(lambda x: key2index[x], key_ans))

    key2index = &#123;&#125;    genres_list = list(map(split, data[&#39;genres&#39;].values))    genres_length = np.array(list(map(len, genres_list)))    max_len = max(genres_length)    # Notice : padding=`post`    genres_list = pad_sequences(genres_list, maxlen=max_len, padding=&#39;post&#39;, )
</code></pre>
<p>构建deepctr的特征列，主要分为两类特征，一是定长的SparseFeat，稀疏的类别特征，二是可变长度的VarLenSparseFeat，像genres这样的包含多个的。</p>
<pre><code>       fixlen_feature_columns = [SparseFeat(feat, data[feat].nunique(), embedding_dim=4)                              for feat in sparse_features]
    use_weighted_sequence = False    if use_weighted_sequence:        varlen_feature_columns = [VarLenSparseFeat(SparseFeat(&#39;genres&#39;, vocabulary_size=len(            key2index) + 1, embedding_dim=4), maxlen=max_len, combiner=&#39;mean&#39;,                                                   weight_name=&#39;genres_weight&#39;)]  # Notice : value 0 is for padding for sequence input feature    else:        varlen_feature_columns = [VarLenSparseFeat(SparseFeat(&#39;genres&#39;, vocabulary_size=len(            key2index) + 1, embedding_dim=4), maxlen=max_len, combiner=&#39;mean&#39;,                                                   weight_name=None)]  # Notice : value 0 is for padding for sequence input feature
    linear_feature_columns = fixlen_feature_columns + varlen_feature_columns    dnn_feature_columns = fixlen_feature_columns + varlen_feature_columns
    feature_names = get_feature_names(linear_feature_columns + dnn_feature_columns)
</code></pre>
<p>封装训练数据，先shuffle（乱排）数据，然后生成dict input数据。</p>
<pre><code>data = sklearn.utils.shuffle(data)
train_model_input = &#123;name: data[name] for name in sparse_features&#125;  #
train_model_input[&quot;genres&quot;] = genres_list
</code></pre>
<p>构建DeepFM模型，由于目标值是0,1，因此采用binary，损失函数用binary_crossentropy</p>
<pre><code>model = DeepFM(linear_feature_columns, dnn_feature_columns, task=&#39;binary&#39;)

model.compile(optimizer=tf.keras.optimizers.Adam(), loss=&#39;binary_crossentropy&#39;,
              metrics=[&#39;AUC&#39;, &#39;Precision&#39;, &#39;Recall&#39;])
model.summary()
</code></pre>
<p>训练模型：</p>
<pre><code>model.fit(train_model_input, data[target].values,                    batch_size=256, epochs=20, verbose=2,                    validation_split=0.2            )
</code></pre>
<p>开始训练：</p>
<pre><code>Epoch 1/20
625/625 - 3s - loss: 0.5081 - auc: 0.8279 - precision: 0.7419 - recall: 0.7695 - val_loss: 0.4745 - val_auc: 0.8513 - val_precision: 0.7563 - val_recall: 0.7936
Epoch 2/20
625/625 - 2s - loss: 0.4695 - auc: 0.8538 - precision: 0.7494 - recall: 0.8105 - val_loss: 0.4708 - val_auc: 0.8539 - val_precision: 0.7498 - val_recall: 0.8127
Epoch 3/20
625/625 - 2s - loss: 0.4652 - auc: 0.8564 - precision: 0.7513 - recall: 0.8139 - val_loss: 0.4704 - val_auc: 0.8545 - val_precision: 0.7561 - val_recall: 0.8017
Epoch 4/20
625/625 - 2s - loss: 0.4624 - auc: 0.8579 - precision: 0.7516 - recall: 0.8146 - val_loss: 0.4724 - val_auc: 0.8542 - val_precision: 0.7296 - val_recall: 0.8526
Epoch 5/20
625/625 - 2s - loss: 0.4607 - auc: 0.8590 - precision: 0.7521 - recall: 0.8173 - val_loss: 0.4699 - val_auc: 0.8550 - val_precision: 0.7511 - val_recall: 0.8141
Epoch 6/20
625/625 - 2s - loss: 0.4588 - auc: 0.8602 - precision: 0.7545 - recall: 0.8165 - val_loss: 0.4717 - val_auc: 0.8542 - val_precision: 0.7421 - val_recall: 0.8265
Epoch 7/20
625/625 - 2s - loss: 0.4574 - auc: 0.8610 - precision: 0.7535 - recall: 0.8192 - val_loss: 0.4722 - val_auc: 0.8547 - val_precision: 0.7549 - val_recall: 0.8023
Epoch 8/20
625/625 - 2s - loss: 0.4561 - auc: 0.8619 - precision: 0.7543 - recall: 0.8201 - val_loss: 0.4717 - val_auc: 0.8548 - val_precision: 0.7480 - val_recall: 0.8185
Epoch 9/20
625/625 - 2s - loss: 0.4531 - auc: 0.8643 - precision: 0.7573 - recall: 0.8210 - val_loss: 0.4696 - val_auc: 0.8583 - val_precision: 0.7598 - val_recall: 0.8103
Epoch 10/20
625/625 - 2s - loss: 0.4355 - auc: 0.8768 - precision: 0.7787 - recall: 0.8166 - val_loss: 0.4435 - val_auc: 0.8769 - val_precision: 0.7756 - val_recall: 0.8293
Epoch 11/20
625/625 - 2s - loss: 0.4093 - auc: 0.8923 - precision: 0.7915 - recall: 0.8373 - val_loss: 0.4301 - val_auc: 0.8840 - val_precision: 0.7806 - val_recall: 0.8390
Epoch 12/20
625/625 - 2s - loss: 0.3970 - auc: 0.8988 - precision: 0.7953 - recall: 0.8497 - val_loss: 0.4286 - val_auc: 0.8867 - val_precision: 0.7903 - val_recall: 0.8299
Epoch 13/20
625/625 - 2s - loss: 0.3896 - auc: 0.9029 - precision: 0.8001 - recall: 0.8542 - val_loss: 0.4253 - val_auc: 0.8888 - val_precision: 0.7913 - val_recall: 0.8322
Epoch 14/20
625/625 - 2s - loss: 0.3825 - auc: 0.9067 - precision: 0.8038 - recall: 0.8584 - val_loss: 0.4205 - val_auc: 0.8917 - val_precision: 0.7885 - val_recall: 0.8506
Epoch 15/20
625/625 - 2s - loss: 0.3755 - auc: 0.9102 - precision: 0.8074 - recall: 0.8624 - val_loss: 0.4204 - val_auc: 0.8940 - val_precision: 0.7868 - val_recall: 0.8607
Epoch 16/20
625/625 - 2s - loss: 0.3687 - auc: 0.9136 - precision: 0.8117 - recall: 0.8653 - val_loss: 0.4176 - val_auc: 0.8956 - val_precision: 0.8097 - val_recall: 0.8236
Epoch 17/20
625/625 - 2s - loss: 0.3617 - auc: 0.9170 - precision: 0.8155 - recall: 0.8682 - val_loss: 0.4166 - val_auc: 0.8966 - val_precision: 0.8056 - val_recall: 0.8354
Epoch 18/20
625/625 - 2s - loss: 0.3553 - auc: 0.9201 - precision: 0.8188 - recall: 0.8716 - val_loss: 0.4168 - val_auc: 0.8977 - val_precision: 0.7996 - val_recall: 0.8492
Epoch 19/20
625/625 - 2s - loss: 0.3497 - auc: 0.9227 - precision: 0.8214 - recall: 0.8741 - val_loss: 0.4187 - val_auc: 0.8973 - val_precision: 0.8079 - val_recall: 0.8358
Epoch 20/20
625/625 - 2s - loss: 0.3451 - auc: 0.9248 - precision: 0.8244 - recall: 0.8753 - val_loss: 0.4210 - val_auc: 0.8982 - val_precision: 0.7945 - val_recall: 0.8617
</code></pre>
<p>最后我们测试下数据：</p>
<pre><code> pred_ans = model.predict(train_model_input, batch_size=256)
 count = 0
    for (i, j) in zip(pred_ans, data[&#39;rating&#39;].values):
        print(i, j)
        count += 1
        if count &gt; 10:
            break
</code></pre>
<p>输出如下：</p>
<pre><code>[0.20468083] 0
[0.1988303] 0
[7.7236204e-05] 0
[0.9439401] 1
[0.76648283] 0
[0.80082995] 1
[0.7689271] 0
[0.8515004] 1
[0.93311656] 1
[0.40019292] 0
[0.60735244] 0
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/w55100/article/details/90295932">deepFM in pytorch</a></li>
<li><a href="https://blog.csdn.net/itplus/article/details/40534923">皮果提《Factorization Machines 学习笔记（二）模型方程》</a></li>
<li><a href="https://blog.csdn.net/u012969412/article/details/88684723">·清尘·《FM、FMM、DeepFM整理（pytorch）》</a></li>
<li><a href="https://blog.csdn.net/songbinxu/article/details/80151814">用Keras实现一个DeepFM</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>算法</tag>
        <tag>DeepFM</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐算法之： LFM 推荐算法</title>
    <url>/jadepeng/2020/10/12/jqpeng-%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E4%B9%8B%EF%BC%9A%20LFM%20%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/13805530.html">推荐算法之： LFM 推荐算法</a></p>
<h2 id="LFM介绍"><a href="#LFM介绍" class="headerlink" title="LFM介绍"></a>LFM介绍</h2><p>LFM(Funk SVD) 是利用 矩阵分解的推荐算法：</p>
<pre><code>R  = P * Q
</code></pre>
<p>其中：</p>
<ul>
<li>P矩阵是User-LF矩阵，即用户和隐含特征矩阵</li>
<li>Q矩阵是LF-Item矩阵，即隐含特征和物品的矩阵</li>
<li>R：R矩阵是User-Item矩阵，由P*Q得来</li>
</ul>
<p>见下图：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/10/12/1602505053626.png" alt="LFM"></p>
<p>R评分举证由于物品和用户数量巨大，且稀疏，因此利用矩阵乘法，转换为 P（n_user * dim) 和 Q （dim*n_count) 两个矩阵，dim 是隐含特征数量。</p>
<h2 id="Tensorflow实现"><a href="#Tensorflow实现" class="headerlink" title="Tensorflow实现"></a>Tensorflow实现</h2><p>下载<code>ml-100k</code> 数据集</p>
<pre><code>!wget http://files.grouplens.org/datasets/movielens/ml-100k.zip
!unzip ml-100k.zip



Resolving files.grouplens.org (files.grouplens.org)... 128.101.65.152
Connecting to files.grouplens.org (files.grouplens.org)|128.101.65.152|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 4924029 (4.7M) [application/zip]
Saving to: ‘ml-100k.zip’

ml-100k.zip         100%[===================&gt;]   4.70M  16.2MB/s    in 0.3s    

2020-10-12 12:25:07 (16.2 MB/s) - ‘ml-100k.zip’ saved [4924029/4924029]

/bin/bash: uzip: command not found
</code></pre>
<p>评分数据在u.data里，分别是 user_id, movie_id, rating, timestamp</p>
<pre><code>!head ml-100k/u.data



186    302    3    891717742
22    377    1    878887116
244    51    2    880606923
166    346    1    886397596
298    474    4    884182806
115    265    2    881171488
253    465    5    891628467
305    451    3    886324817
6    86    3    883603013
</code></pre>
<p>读取数据</p>
<pre><code>import os
def read_data(path: str, separator: str):
    data = []
    with open(path, &#39;r&#39;) as f:
        for line in f.readlines():
            values = line.strip().split(separator)
            user_id, movie_id, rating, timestamp = int(values[0]), int(values[1]), int(values[2]), int(values[3])
            data.append((user_id, movie_id, rating, timestamp))
    return data

data = read_data(&#39;ml-100k/u.data&#39;, &#39;\t&#39;)

print(data[0])



(0, 0, 0.6)
</code></pre>
<p>拆分训练集和测试集，test_ratio比例为0.3：</p>
<pre><code>data = [(d[0], d[1], d[2]/5.0) for d in data]

# 拆分
test_ratio = 0.3
n_test = int(len(data) * test_ratio)
test_data, train_data = data[:n_test], data[n_test:]
</code></pre>
<p>id规整化，从0开始增长</p>
<pre><code>#id 规整
def normalize_id(data):
    new_data = []
    n_user, n_item = 0, 0
    user_id_old2new, item_id_old2new = &#123;&#125;, &#123;&#125;
    for user_id_old, item_id_old, label in data:
        if user_id_old not in user_id_old2new:
            user_id_old2new[user_id_old] = n_user
            n_user += 1
        if item_id_old not in item_id_old2new:
            item_id_old2new[item_id_old] = n_item
            n_item += 1
        new_data.append((user_id_old2new[user_id_old], item_id_old2new[item_id_old], label))
    return new_data, n_user, n_item, user_id_old2new, item_id_old2new

data, n_user, n_item, user_id_old2new, item_id_old2new = normalize_id(data)
</code></pre>
<p>查看数据</p>
<pre><code>print(train_data[0:10])
print(test_data[0])
print(&#39;n_user&#39;,n_user)
print(&#39;n_item&#39;,n_item)



(196, 242, 0.6)
n_user 943
n_item 1682
</code></pre>
<p>准备数据集</p>
<pre><code>import tensorflow as tf

def xy(data):
        user_ids = tf.constant([d[0] for d in data], dtype=tf.int32)
        item_ids = tf.constant([d[1] for d in data], dtype=tf.int32)
        labels = tf.constant([d[2] for d in data], dtype=tf.keras.backend.floatx())
        return &#123;&#39;user_id&#39;: user_ids, &#39;item_id&#39;: item_ids&#125;, labels

batch = 128
train_ds = tf.data.Dataset.from_tensor_slices(xy(train_data)).shuffle(len(train_data)).batch(batch)
test_ds = tf.data.Dataset.from_tensor_slices(xy(test_data)).batch(batch)
</code></pre>
<p>TF模型</p>
<pre><code>def LFM_model(n_user: int, n_item: int, dim=100, l2=1e-6) -&gt; tf.keras.Model:
    l2 = tf.keras.regularizers.l2(l2)
    user_id = tf.keras.Input(shape=(), name=&#39;user_id&#39;, dtype=tf.int32)

    user_embedding = tf.keras.layers.Embedding(n_user, dim, embeddings_regularizer=l2)(user_id)
    # (None,dim)
    item_id = tf.keras.Input(shape=(), name=&#39;item_id&#39;, dtype=tf.int32)
    item_embedding = tf.keras.layers.Embedding(n_item, dim, embeddings_regularizer=l2)(item_id)
    # (None,dim)
    r = user_embedding * item_embedding
    y = tf.reduce_sum(r, axis=1)
    y = tf.where(y &lt; 0., 0., y)
    y = tf.where(y &gt; 1., 1., y)
    y = tf.expand_dims(y, axis=1)
    return tf.keras.Model(inputs=[user_id, item_id], outputs=y)

model = LFM_model(n_user + 1, n_item + 1, 64)
</code></pre>
<p>编译模型</p>
<pre><code>model.compile(optimizer=&quot;adam&quot;, loss=tf.losses.MeanSquaredError(), metrics=[&#39;AUC&#39;, &#39;Precision&#39;, &#39;Recall&#39;])
model.summary()




__________________________________________________________________________________________________
Layer (type)                    Output Shape         Param #     Connected to                     
==================================================================================================
user_id (InputLayer)            [(None,)]            0                                            
__________________________________________________________________________________________________
item_id (InputLayer)            [(None,)]            0                                            
__________________________________________________________________________________________________
embedding_12 (Embedding)        (None, 64)           60416       user_id[0][0]                    
__________________________________________________________________________________________________
embedding_13 (Embedding)        (None, 64)           107712      item_id[0][0]                    
__________________________________________________________________________________________________
tf_op_layer_Mul_6 (TensorFlowOp [(None, 64)]         0           embedding_12[0][0]               
                                                                 embedding_13[0][0]               
__________________________________________________________________________________________________
tf_op_layer_Sum_6 (TensorFlowOp [(None,)]            0           tf_op_layer_Mul_6[0][0]          
__________________________________________________________________________________________________
tf_op_layer_Less_6 (TensorFlowO [(None,)]            0           tf_op_layer_Sum_6[0][0]          
__________________________________________________________________________________________________
tf_op_layer_SelectV2_12 (Tensor [(None,)]            0           tf_op_layer_Less_6[0][0]         
                                                                 tf_op_layer_Sum_6[0][0]          
__________________________________________________________________________________________________
tf_op_layer_Greater_6 (TensorFl [(None,)]            0           tf_op_layer_SelectV2_12[0][0]    
__________________________________________________________________________________________________
tf_op_layer_SelectV2_13 (Tensor [(None,)]            0           tf_op_layer_Greater_6[0][0]      
                                                                 tf_op_layer_SelectV2_12[0][0]    
__________________________________________________________________________________________________
tf_op_layer_ExpandDims_6 (Tenso [(None, 1)]          0           tf_op_layer_SelectV2_13[0][0]    
==================================================================================================
Total params: 168,128
Trainable params: 168,128
Non-trainable params: 0
__________________________________________________________________________________________________
</code></pre>
<p>下面开始训练10次epochs</p>
<pre><code>model.fit(train_ds,validation_data=test_ds,epochs=10)



Epoch 1/10

/usr/local/lib/python3.6/dist-packages/tensorflow/python/framework/indexed_slices.py:432: UserWarning: Converting sparse IndexedSlices to a dense Tensor of unknown shape. This may consume a large amount of memory.
  &quot;Converting sparse IndexedSlices to a dense Tensor of unknown shape. &quot;
547/547 [==============================] - 2s 4ms/step - loss: 0.4388 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.0594 - val_loss: 0.1439 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.4180
Epoch 2/10
547/547 [==============================] - 2s 4ms/step - loss: 0.0585 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.8171 - val_loss: 0.0486 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8655
Epoch 3/10
547/547 [==============================] - 2s 3ms/step - loss: 0.0393 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.9053 - val_loss: 0.0433 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8982
Epoch 4/10
547/547 [==============================] - 2s 3ms/step - loss: 0.0346 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.9107 - val_loss: 0.0415 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8947
Epoch 5/10
547/547 [==============================] - 2s 4ms/step - loss: 0.0301 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.9071 - val_loss: 0.0410 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8869
Epoch 6/10
547/547 [==============================] - 2s 4ms/step - loss: 0.0257 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.8958 - val_loss: 0.0410 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8849
Epoch 7/10
547/547 [==============================] - 2s 4ms/step - loss: 0.0218 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.8844 - val_loss: 0.0414 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8753
Epoch 8/10
547/547 [==============================] - 2s 4ms/step - loss: 0.0183 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.8719 - val_loss: 0.0425 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8659
Epoch 9/10
547/547 [==============================] - 2s 4ms/step - loss: 0.0153 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.8624 - val_loss: 0.0435 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8620
Epoch 10/10
547/547 [==============================] - 2s 4ms/step - loss: 0.0132 - auc: 0.0000e+00 - precision: 1.0000 - recall: 0.8535 - val_loss: 0.0449 - val_auc: 0.0000e+00 - val_precision: 1.0000 - val_recall: 0.8531
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 由于iptables导致无法正常启动问题临时解决方案</title>
    <url>/jadepeng/2020/10/11/jqpeng-docker%20%E7%94%B1%E4%BA%8Eiptables%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E4%B8%B4%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/13800447.html">docker 由于iptables导致无法正常启动问题临时解决方案</a></p>
<p>docker安装新的ca证书后无法正常启动，<br> 表现为<code>/sbin/iptables --wait -t filter -N DOCKER-ISOLATION-STAGE-2</code> hang住，<br> 日志有报错 <code>xtables contention detected while running ..</code></p>
<p>解决历程：</p>
<ol>
<li>重启大法，先stop再start无果</li>
<li>iptables 重装大法，无果</li>
<li>docker升级到最新版本无果</li>
<li>确定还是iptables的问题，暂时没时间详细排查，于是docker禁用iptables，先卸载iptables，docker启动设置iptables false</li>
</ol>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里开源JDK dragonwell8在容器环境使用</title>
    <url>/jadepeng/2020/09/29/jqpeng-%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90JDK%20dragonwell8%E5%9C%A8%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/dragonwell8-docker.html">阿里开源JDK dragonwell8在容器环境使用</a></p>
<p>Alibaba Dragonwell 是阿里巴巴的Open JDK 发行版，提供长期支持。 阿里宣传称在阿里生产环境实现了应用。Alibaba Dragonwell兼容 Java SE 标准，因此可以方便切换。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可以到<a href="https://github.com/alibaba/dragonwell8/releases?spm=5176.cndragonwell.0.0.4c5a7568DpYPsp">https://github.com/alibaba/dragonwell8/releases?spm=5176.cndragonwell.0.0.4c5a7568DpYPsp</a> 下载，当前的最新版是8.4.4 GA</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/9/29/1601363568094.png" alt="ali jdk8"></p>
<p>阿里也提供了镜像下载地址，可以加速下载：</p>
<blockquote>
<p>8.4.4GA</p>
</blockquote>
<table>
<thead>
<tr>
<th>File name</th>
<th>中国大陆</th>
<th>United States</th>
</tr>
</thead>
<tbody><tr>
<td>Alibaba_Dragonwell_8.4.4-GA_Linux_x64.tar.gz</td>
<td><a href="https://dragonwell.oss-cn-shanghai.aliyuncs.com/8/8.4.4-GA/Alibaba_Dragonwell_8.4.4-GA_Linux_x64.tar.gz">download</a></td>
<td><a href="https://github.com/alibaba/dragonwell8/releases/download/dragonwell-8.4.4_jdk8u262-ga/Alibaba_Dragonwell_8.4.4-GA_Linux_x64.tar.gz">download</a></td>
</tr>
<tr>
<td>Alibaba_Dragonwell_8.4.4-GA_source.tar.gz</td>
<td><a href="https://dragonwell.oss-cn-shanghai.aliyuncs.com/8/8.4.4-GA/Alibaba_Dragonwell_8.4.4-GA_source.tar.gz">download</a></td>
<td><a href="https://github.com/alibaba/dragonwell8/releases/download/dragonwell-8.4.4_jdk8u262-ga/Alibaba_Dragonwell_8.4.4-GA_source.tar.gz">download</a></td>
</tr>
<tr>
<td>Alibaba_Dragonwell_8.4.4-Experimental_Windows_x64.tar.gz</td>
<td><a href="https://dragonwell.oss-cn-shanghai.aliyuncs.com/8/8.4.4-GA/Alibaba_Dragonwell_8.4.4-Experimental_Windows_x64.tar.gz">download</a></td>
<td><a href="https://github.com/alibaba/dragonwell8/releases/download/dragonwell-8.4.4_jdk8u262-ga/Alibaba_Dragonwell_8.4.4-Experimental_Windows_x64.tar.gz">download</a></td>
</tr>
<tr>
<td>java8-api-8.4.4-javadoc.jar</td>
<td><a href="https://dragonwell.oss-cn-shanghai.aliyuncs.com/8/8.4.4-GA/java8-api-8.4.4-javadoc.jar">download</a></td>
<td><a href="https://github.com/alibaba/dragonwell8/releases/download/dragonwell-8.4.4_jdk8u262-ga/java8-api-8.4.4-javadoc.jar">download</a></td>
</tr>
<tr>
<td>java8-api-8.4.4-sources.jar</td>
<td><a href="https://dragonwell.oss-cn-shanghai.aliyuncs.com/8/8.4.4-GA/java8-api-8.4.4-sources.jar">download</a></td>
<td><a href="https://github.com/alibaba/dragonwell8/releases/download/dragonwell-8.4.4_jdk8u262-ga/java8-api-8.4.4-sources.jar">download</a></td>
</tr>
<tr>
<td>java8-api-8.4.4.jar</td>
<td><a href="https://dragonwell.oss-cn-shanghai.aliyuncs.com/8/8.4.4-GA/java8-api-8.4.4.jar">download</a></td>
<td><a href="https://github.com/alibaba/dragonwell8/releases/download/dragonwell-8.4.4_jdk8u262-ga/java8-api-8.4.4.jar">download</a></td>
</tr>
</tbody></table>
<blockquote>
<p><a href="https://github.com/alibaba/dragonwell8/releases/tag/dragonwell-8.4.4_jdk8u262-ga">SHA256 checksum</a></p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>wget https://dragonwell.oss-cn-shanghai.aliyuncs.com/8/8.4.4-GA/Alibaba_Dragonwell_8.4.4-GA_Linux_x64.tar.gz
tar zxvf Alibaba_Dragonwell_8.4.4-GA_Linux_x64.tar.gz 
cd jdk8u262-b10/
 bin/java -version
</code></pre>
<p>输出：</p>
<pre><code>openjdk version &quot;1.8.0_262&quot;
OpenJDK Runtime Environment (Alibaba Dragonwell 8.4.4) (build 1.8.0_262-b10)
OpenJDK 64-Bit Server VM (Alibaba Dragonwell 8.4.4) (build 25.262-b10, mixed mode)
</code></pre>
<h2 id="容器环境使用"><a href="#容器环境使用" class="headerlink" title="容器环境使用"></a>容器环境使用</h2><p>我们需要准备一个基础镜像包，我们以openjdk:8-jdk-slim为基础包，把jdk替换为dragonwell8</p>
<pre><code> FROM openjdk:8-jdk-slim
 MAINTAINER jadepeng
 
 RUN sed -i &#39;s#http://deb.debian.org#https://mirrors.163.com#g&#39; /etc/apt/sources.list \
     &amp;&amp; apt-get update\
     &amp;&amp; apt-get install -y procps unzip curl bash tzdata ttf-dejavu \
     &amp;&amp; rm -rf /var/cache/apt/ \
     &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \
     &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone
 
 RUN rm -r -f /usr/local/openjdk-8
 
 ADD jdk8u262-b10  /usr/local/openjdk-8
</code></pre>
<p>构建：</p>
<pre><code>docker build -t dragonwell8:8.4.4 .
</code></pre>
<p>java应用就可以用<code>dragonwell8:8.4.4 </code>为底包执行了。</p>
<h2 id="dragonwell8-协程使用"><a href="#dragonwell8-协程使用" class="headerlink" title="dragonwell8 协程使用"></a>dragonwell8 协程使用</h2><p>dragonwell8的一大特色就是协程（Coroutine ）</p>
<p>官方有一个demo：</p>
<p>以一个pingpong 1,000,000次的程序为例，这是一个需要阻塞，切换密集型的应用。</p>
<pre><code>           o      .   _______ _______
              \_ 0     /______//______/|   @_o
                /\_,  /______//______/     /\
               | \    |      ||      |     / |

static final ExecutorService THREAD_POOL = Executors.newCachedThreadPool();

public static void main(String[] args) throws Exception &#123;
    BlockingQueue&lt;Byte&gt; q1 = new LinkedBlockingQueue&lt;&gt;(), q2 = new LinkedBlockingQueue&lt;&gt;();
    THREAD_POOL.submit(() -&gt; pingpong(q2, q1)); // thread A
    Future&lt;?&gt; f = THREAD_POOL.submit(() -&gt; pingpong(q1, q2)); // thread B
    q1.put((byte) 1);
    System.out.println(f.get() + &quot; ms&quot;);
&#125;

private static long pingpong(BlockingQueue&lt;Byte&gt; in, BlockingQueue&lt;Byte&gt; out) throws Exception &#123;
    long start = System.currentTimeMillis();
    for (int i = 0; i &lt; 1_000_000; i++) out.put(in.take());
    return System.currentTimeMillis() - start;
&#125;
</code></pre>
<p>运行，查看执行时间:</p>
<pre><code>$java PingPong
13212 ms

// 开启Wisp2
$java -XX:+UseWisp2 -XX:ActiveProcessorCount=1 PingPong
882 ms
</code></pre>
<p>开启Wisp2后整体运行效率提升了近十多倍，只需要启动时增加参数<code>-XX:+UseWisp2</code>即可。不用修改一行代码，即可享受协程带来的优势。</p>
<p>随后可以通过jstack观察到起来的线程都以协程的方式在运行了。</p>
<pre><code> - Coroutine [0x7f6d6d60fb20] &quot;Thread-978&quot; #1076 active=1 steal=0 steal_fail=0 preempt=0 park=0/-1
        at java.dyn.CoroutineSupport.unsafeSymmetricYieldTo(CoroutineSupport.java:138)
--
 - Coroutine [0x7f6d6d60f880] &quot;Thread-912&quot; #1009 active=1 steal=0 steal_fail=0 preempt=0 park=0/-1
        at java.dyn.CoroutineSupport.unsafeSymmetricYieldTo(CoroutineSupport.java:138)

...
</code></pre>
<p>可以看到最上方的frame上的方法是协程切换，因为线程调用了sleep，yield出了执行权。</p>
<p>开启Wisp2后，Java线程不再简单地映射到内核级线程，而是对应到一个协程，JVM在少量内核线上调度大量协程执行，以减少内核的调度开销，提高web服务器的性能。</p>
<p>在阿里的生产环境，性能指标：</p>
<ul>
<li>在复杂的业务应用中(tomcat + 大量基于netty的中间件)我们获得了大约10%的性能提升。</li>
<li>在中间件应用(数据库代理，MQ)中我们获得大约20%的性能提升。</li>
</ul>
<p>更多Wisp的设计实现与API相关信息，请参考<a href="https://github.com/alibaba/dragonwell8/wiki/Wisp%E6%96%87%E6%A1%A3">Wisp文档</a>。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>dragonwell8</tag>
      </tags>
  </entry>
  <entry>
    <title>来，我们一起打造一款代码命名工具</title>
    <url>/jadepeng/2020/08/31/jqpeng-%E6%9D%A5%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/code-naming-tool.html">来，我们一起打造一款代码命名工具</a></p>
<p>你是否还在为代码命名而纠结不已？</p>
<blockquote>
<p>here are only two hard things in Computer Science: cache invalidation and naming things.– Phil Karlton</p>
</blockquote>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/31/1598875275591.png" alt="代码命名"></p>
<p>那么如何更好的命名呢？ 是否有好的工具可以支持我们命名呢？网上搜索一圈没有发现满意的，于是自己动手丰衣足食，<a href="https://jadepeng.gitee.io/code-naming-tool/">https://jadepeng.gitee.io/code-naming-tool/</a>。</p>
<p>使用方法： 打开网页后，在中文输入框中输入 中文命名，然后回车即可。也可以直接在英文输入框输入英文，搜索候选。</p>
<h2 id="现有的工具"><a href="#现有的工具" class="headerlink" title="现有的工具"></a>现有的工具</h2><p>unbug.github.io/codelf/ 提供了一个选择，作者先调用有道、百度等翻译，然后调用searchcode搜索代码，从搜索的代码中提取变量名。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/31/1598875386957.png" alt="codeif"></p>
<p>界面做的很酷，但是推荐出来的变量名称质量参差不齐，失去了参考意义。</p>
<h2 id="新的思路"><a href="#新的思路" class="headerlink" title="新的思路"></a>新的思路</h2><p>我们常说以史为鉴，换一个思路，我们可以从优秀的开源库中去吸收他们命名的经验，看看他们是如何命名的，来供我们参考。</p>
<p>实现思路：  </p>
<ol>
<li>从spring、apache等代码库，读取变量、方法、类名称  </li>
<li>根据关键词匹配出候选命名  </li>
<li>候选结果排序</li>
</ol>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/31/1598875225454.png" alt="工具"></p>
<h2 id="获取优秀命名"><a href="#获取优秀命名" class="headerlink" title="获取优秀命名"></a>获取优秀命名</h2><p>要获取命名，首先想到的是读取代码库，需要先下载代码，然后解析  ———— 工作量巨大，PASS。</p>
<p>那怎么做呢，换个角度，可以通过java的反射来实现。</p>
<p>首先添加一个辅助库：</p>
<pre><code>&lt;dependency&gt;
            &lt;groupId&gt;org.reflections&lt;/groupId&gt;
            &lt;artifactId&gt;reflections&lt;/artifactId&gt;
            &lt;version&gt;0.9.12&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>然后初始化Reflections,FilterBuilder可以用来过滤类库，我们设置”org”,”javax”,”com”,”io”, 基本上囊库了主要的开源类库，比如spring，apache等.</p>
<pre><code> List&lt;ClassLoader&gt; classLoadersList = new LinkedList&lt;ClassLoader&gt;();
        classLoadersList.add(ClasspathHelper.contextClassLoader());
        classLoadersList.add(ClasspathHelper.staticClassLoader());

        Reflections reflections = new Reflections(new ConfigurationBuilder()
                .setScanners(new SubTypesScanner(false), new ResourcesScanner())
                .setUrls(ClasspathHelper.forClassLoader(classLoadersList.toArray(new ClassLoader[0])))
                .filterInputsBy(new FilterBuilder().includePackage(&quot;org&quot;,&quot;javax&quot;,&quot;com&quot;,&quot;io&quot;)));
</code></pre>
<p>然后，可以通过<code>reflections.getSubTypesOf(Object.class);</code>来获取相关的class了,注意，我们初始化一个<code> Map&lt;String, Integer&gt; name2count = new HashMap&lt;String, Integer&gt;();</code>用来存储代码命名以及对应的出现次数。</p>
<pre><code>Set&lt;Class&lt;? extends Object&gt;&gt; allClasses =
                reflections.getSubTypesOf(Object.class);
        Map&lt;String, Integer&gt; name2count = new HashMap&lt;String, Integer&gt;();
        for (Class&lt;?&gt; clazz : allClasses) &#123;
            System.out.println(clazz.getName());
            try &#123;
                appendToNameMap(name2count, clazz.getSimpleName());

                Field[] fields = clazz.getDeclaredFields();
                for (Field field : fields) &#123;
                    String name = field.getName();
                    appendToNameMap(name2count, name);
                &#125;
                Method[] methods = clazz.getMethods();
                for (Method method : methods) &#123;
                    String name = method.getName();
                    appendToNameMap(name2count, name);
                    // parameters
                    Parameter[] parameters =  method.getParameters();
                    for (Parameter param : parameters) &#123;
                        name = param.getName();
                        appendToNameMap(name2count, name);
                    &#125;
                &#125;
            &#125;catch(Throwable t)
            &#123; &#125;
</code></pre>
<p>其中<code>appendToNameMap</code>:</p>
<pre><code> private static void appendToNameMap(Map&lt;String, Integer&gt; name2count, String name) &#123;
        // filter
        if(name.contains(&quot;-&quot;) || name.contains(&quot;_&quot;)|| name.contains(&quot;$&quot;))&#123;
            return;
        &#125;

        if (!name2count.containsKey(name)) &#123;
            name2count.put(name, 1);
        &#125; else &#123;
            name2count.put(name, name2count.get(name) +1);
        &#125;
    &#125;
</code></pre>
<p>最后把结果存储到文件，作为我们的资源。</p>
<pre><code>FileUtils.writeAllText(JSON.toJSONString(name2count), new File(&quot;name2count.txt&quot;));
</code></pre>
<p>可以到<code>https://gitee.com/jadepeng/code-naming-tool/blob/master/vars.js</code>查看结果。</p>
<h2 id="命名推荐"><a href="#命名推荐" class="headerlink" title="命名推荐"></a>命名推荐</h2><p>命名推荐，还是遵循，先翻译，然后根据翻译结果搜索并召回。</p>
<p>其中翻译直接调用网易有道的，但是搜索如何搞定呢？</p>
<p>最简单的方法，肯定是分词，然后建立索引，lucene是标配。但是上lucene就要上服务器，PASS!</p>
<p>我们来找一个浏览器端的lucene，google 后选定<code>flexsearch</code>.</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/31/1598876259412.png" alt="flexsearch"></p>
<p>flexsearch github上有6.5k star，因此优先选择。</p>
<p>下面来看具体的实现。</p>
<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>初始化FlexSearch，然后将之前获取的代码命名建立索引。</p>
<pre><code> var index = new FlexSearch(&#123;
            encode: &quot;advanced&quot;,
            tokenize: &quot;reverse&quot;,
            suggest: true,
            cache: true
        &#125;)
        var data = []
        var i = 0
        for (var name in names) &#123;
            var indexName = name.replace(/([A-Z])/g, &quot; $1&quot;)
            data[i] = &#123;
                &quot;name&quot;: name,
                &quot;count&quot;: names[name]
            &#125;
            index.add(i++, indexName)
        &#125;
</code></pre>
<p>这里有个小技巧，<code>name.replace(/([A-Z])/g, &quot; $1&quot;)</code> 可以将驼峰命名拆分成单词。<br> 同时data数组会保存所有的命名和响应的出现次数。</p>
<h3 id="搜索候选"><a href="#搜索候选" class="headerlink" title="搜索候选"></a>搜索候选</h3><p>先翻译，然后将翻译结果给FlexSearch搜索。</p>
<pre><code>function searchFromIndex(value) &#123;
        var results = index.search(value, 25)
    
        results = results.map(function (i) &#123;
            return data[i]
        &#125;)
    
        results = results.sort(function (a, b) &#123;
            return b.count - a.count
        &#125;)
        return results
    &#125;
</code></pre>
<p>先搜索，出来的结果是data中的index序号，转换为list对象，然后按照count倒排。</p>
<p>tips： 理论上，翻译的结果可以去除一些停用词，搜索效果应该更好，这里先放着。</p>
<h3 id="显示结果"><a href="#显示结果" class="headerlink" title="显示结果"></a>显示结果</h3><p>对结果进行格式化：</p>
<pre><code>function formatSuggestion(item)&#123;
    return `$&#123;item.name&#125; &lt;span class=&#39;tips&#39;&gt;代码库共出现$&#123;item.count&#125;次 (相关搜索： &lt;a target=&#39;_blank&#39; href=&#39;https://unbug.github.io/codelf/#$&#123;item.name&#125;&#39;&gt;codelf&lt;/a&gt; &amp;nbsp; &lt;a target=&#39;_blank&#39; href=&#39;https://searchcode.com/?q=$&#123;item.name&#125;&amp;lan=23&#39;&gt;searchcode&lt;/a&gt;)&lt;/span&gt;`;
&#125;
</code></pre>
<p>增加到codelf 和 searchcode的链接，显示结果如下：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/31/1598877282579.png" alt="搜索结果"></p>
<h2 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h2><ul>
<li>github:  <a href="https://github.com/jadepeng/code-naming-tool">https://github.com/jadepeng/code-naming-tool</a></li>
<li>gitee:  <a href="https://gitee.com/jadepeng/code-naming-tool">https://gitee.com/jadepeng/code-naming-tool</a></li>
</ul>
<p>命名工具地址： <a href="https://jadepeng.gitee.io/code-naming-tool/">https://jadepeng.gitee.io/code-naming-tool/</a></p>
<p>欢迎大家体验使用，欢迎fork并贡献代码。</p>
<h2 id="后续展望"><a href="#后续展望" class="headerlink" title="后续展望"></a>后续展望</h2><p>当前仅仅用到了翻译+搜索，还有很多可以优化的地方：</p>
<ul>
<li>搜索去停用词</li>
<li>从文本语义相似度层面去推荐</li>
<li>专业术语支持</li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>代码命名</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次keepalived和VIP导致的故障</title>
    <url>/jadepeng/2020/08/27/jqpeng-%E8%AE%B0%E4%B8%80%E6%AC%A1keepalived%E5%92%8CVIP%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%85%E9%9A%9C/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/keepalived.html">记一次keepalived和VIP导致的故障</a></p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>nginx服务器采用的keepalived+vip实现的双活，最近由于一台服务器有问题，更换了一台nginx：</p>
<p>操作：</p>
<ul>
<li>停止有问题服务器keepalived和nginx</li>
<li>新服务器部署keepalived和nginx</li>
</ul>
<p>更换后一切正常，但是过了几个小时，出现大面积的不能访问。</p>
<h2 id="keepalived-升级"><a href="#keepalived-升级" class="headerlink" title="keepalived 升级"></a>keepalived 升级</h2><p>检查nginx正常，重启keepalived后OK，怀疑可能是keepalived的问题，于是编译安装最新的keepalived：</p>
<pre><code>curl --progress http://keepalived.org/software/keepalived-1.2.15.tar.gz | tar xz
cd keepalived-1.2.15
./configure --prefix=/usr/local/keepalived-1.2.15
make
sudo make install
</code></pre>
<p>升级后，一切正常,。</p>
<h2 id="再出故障，最终定位"><a href="#再出故障，最终定位" class="headerlink" title="再出故障，最终定位"></a>再出故障，最终定位</h2><p>一晚过去无异常，第二天又出现部分域名不能访问，检查服务一切正常，因此怀疑是VIP导致的问题，检查之前有问题服务器的ip：</p>
<pre><code>ip addr
</code></pre>
<p>果不其然：</p>
<pre><code>2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 90:b1:1c:2a:92:e4 brd ff:ff:ff:ff:ff:ff
    inet 172.31.161.42/32 scope global eno1
       valid_lft forever preferred_lft forever
    inet 172.31.161.41/32 scope global eno1
       valid_lft forever preferred_lft forever
    inet 172.31.161.38/24 brd 172.31.161.255 scope global eno1
       valid_lft forever preferred_lft forever
    inet 172.31.161.42/0 scope global eno1::1
       valid_lft forever preferred_lft forever
3: eno2: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu
</code></pre>
<p>41,42 是我们设置的VIP，竟然还在这个有问题服务器的网卡上，这就导致一个机房内，有2台服务器绑定相同的vip。</p>
<p>解决方案, 通过<code>ip addr delete</code>删除绑定的vip</p>
<pre><code>ip addr delete 172.31.161.42/32 dev eno1
ip addr delete 172.31.161.41/32 dev eno1
ip addr delete 172.31.161.41/0 dev eno1
</code></pre>
<p>顺道介绍如何给网卡绑定vip：</p>
<pre><code>ip addr add 172.31.161.41/32 dev eno1
</code></pre>
<h2 id="溯源与问题总结"><a href="#溯源与问题总结" class="headerlink" title="溯源与问题总结"></a>溯源与问题总结</h2><p>问题的根源在于，keepalived为网卡停止后，keepalived为网卡绑定的VIP并没有移除，导致多台机器出现同样的ip。</p>
<p>切记： <code>停止keepalived，vip不会自动删除，需要手动清理</code></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>网易云音乐无版权音乐补全工具</title>
    <url>/jadepeng/2020/08/25/jqpeng-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%97%A0%E7%89%88%E6%9D%83%E9%9F%B3%E4%B9%90%E8%A1%A5%E5%85%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/music163tool.html">网易云音乐无版权音乐补全工具</a></p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>网易云音乐的不少歌曲因为版权下架了，或者变成收费的，导致无法收听，因此需要一个小工具，希望可以从其他来源补全歌曲。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/25/1598352099450.png"></p>
<p>如图所示，不能听的显示为灰色。</p>
<p>之前写的小工具XMusicDownloader(<a href="https://github.com/jadepeng/XMusicDownloader">https://github.com/jadepeng/XMusicDownloader</a>) 可以从多个来源搜索歌曲并下载，因此以这个为基础，可以很快实现需求。</p>
<p>查看本文之前，建议查看<a href="https://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html#4277262913">开源工具软件XMusicDownloader——音乐下载神器</a>.</p>
<h2 id="歌曲版权声明"><a href="#歌曲版权声明" class="headerlink" title="歌曲版权声明"></a>歌曲版权声明</h2><ul>
<li>该工具本质是<strong>歌曲聚合搜索</strong>，API来自公开网络，<code>非破解版</code>，只能下载<strong>各家公开的音乐</strong>，<strong>付费歌曲不能下载</strong>，例如QQ、网易等的收费歌曲不能从QQ\网易源下载，工具的原理是基于聚合实现补全</li>
<li><strong>工具和代码仅供技术研究使用</strong>，禁止将本工具用于商业用途，<strong>如产生法律纠纷与本人无关，如有侵权，请联系删除</strong>。</li>
</ul>
<h2 id="工具原理"><a href="#工具原理" class="headerlink" title="工具原理"></a>工具原理</h2><ol>
<li>获取用户歌单，找出无版权和收费歌曲</li>
<li>从QQ、咪咕、百度等源搜索这些歌曲，匹配成功的可以下载</li>
<li>下载后可以手动上传到云盘</li>
</ol>
<h3 id="获取用户歌单"><a href="#获取用户歌单" class="headerlink" title="获取用户歌单"></a>获取用户歌单</h3><p>借助<a href="https://github.com/wwh1004/NeteaseCloudMusicApi">NeteaseCloudMusicApi</a>，可以方便调用云音乐的api。</p>
<p>分析获取到的json，可以发现，包含<code>noCopyrightRcmd</code>的是没有版权的，包含<code>fee</code>的是收费的，我们可以将这些歌曲提取出来，变为song对象。</p>
<pre><code>private static List&lt;Song&gt; FetchNoCopyrightSongs(JObject json)
        &#123;
            List&lt;Song&gt; noCopyrightsSongs = new List&lt;Song&gt;();
            foreach (JObject songObj in json[&quot;songs&quot;])
            &#123;
                int id = 0;
               
                if (songObj[&quot;noCopyrightRcmd&quot;].HasValues || songObj[&quot;fee&quot;].Value&lt;int&gt;() == 1)
                &#123;
                    noCopyrightsSongs.Add(NeteaseProvider.extractSong(ref id, songObj));
                &#125;
            &#125;

            return noCopyrightsSongs;
        &#125;        public static Song extractSong(ref int index, JToken songItem)
        &#123;
            var song = new Song
            &#123;
                id = (string)songItem[&quot;id&quot;],
                name = (string)songItem[&quot;name&quot;],

                album = (string)songItem[&quot;al&quot;][&quot;name&quot;],
                //rate = 128,
                index = index++,
                //size = (double)songItem[&quot;FileSize&quot;],
                source = &quot;网易&quot;,
                duration = (double)songItem[&quot;dt&quot;] / 1000
            &#125;;

            song.singer = &quot;&quot;;
            foreach (var ar in songItem[&quot;ar&quot;])
            &#123;
                song.singer += ar[&quot;name&quot;] + &quot; &quot;;
            &#125;

            if (songItem.Contains(&quot;privilege&quot;) &amp;&amp; songItem[&quot;privilege&quot;].HasValues)
            &#123;
                song.rate = ((int)songItem[&quot;privilege&quot;][&quot;fl&quot;]) / 1000;
                var fl = (int)songItem[&quot;privilege&quot;][&quot;fl&quot;];
                if (songItem[&quot;h&quot;] != null &amp;&amp; fl &gt;= 320000)
                &#123;
                    song.size = (double)songItem[&quot;h&quot;][&quot;size&quot;];
                &#125;
                else if (songItem[&quot;m&quot;] != null &amp;&amp; fl &gt;= 192000)
                &#123;
                    song.size = (double)songItem[&quot;m&quot;][&quot;size&quot;];
                &#125;
                else if (songItem[&quot;l&quot;] != null)
                &#123;
                    song.size = (double)songItem[&quot;l&quot;][&quot;size&quot;];
                &#125;
            &#125;
            else
            &#123;
                song.rate = 128;
                song.size = 0;
            &#125;

            return song;
        &#125;
</code></pre>
<h3 id="从其他来源获取歌曲"><a href="#从其他来源获取歌曲" class="headerlink" title="从其他来源获取歌曲"></a>从其他来源获取歌曲</h3><p>在之前的博文<a href="https://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html#4277262913">开源工具软件XMusicDownloader——音乐下载神器</a>里，我们有一个聚合的搜索歌曲的方法：</p>
<pre><code> public List&lt;MergedSong&gt; SearchSongs(string keyword, int page, int pageSize)
        &#123;
            var songs = new List&lt;Song&gt;();
            Providers.AsParallel().ForAll(provider =&gt;
            &#123;
                var currentSongs = provider.SearchSongs(keyword, page, pageSize);
                songs.AddRange(currentSongs);
            &#125;);

            // merge

            return songs.GroupBy(s =&gt; s.getMergedKey()).Select(g =&gt; new MergedSong(g.ToList())).OrderByDescending(s =&gt; s.score).ToList();
        &#125;
</code></pre>
<p>类似的，匹配也是先搜索，但是要排除网易源，然后根据搜索结果去匹配。搜索的时候，可以将 “歌曲名称 + 歌手名称” 组合用来搜索。</p>
<pre><code>  public MergedSong SearchSong(string singer, string songName, string exceptProvider)
        &#123;      // search
            var songs = new List&lt;Song&gt;();
            Providers.AsParallel().ForAll(provider =&gt;
            &#123;
                try
                &#123;
                    if (provider.Name != exceptProvider)
                    &#123;
                        var currentSongs = provider.SearchSongs(singer + &quot; &quot; + songName, 1, 10);
                        songs.AddRange(currentSongs);
                    &#125;
                &#125;
                catch (Exception e)
                &#123;

                &#125;
            &#125;);

            // merge

            List&lt;MergedSong&gt; mergedSongs = songs.GroupBy(s =&gt; s.getMergedKey()).Select(g =&gt; new MergedSong(g.ToList())).OrderByDescending(s =&gt; s.score).ToList();         // match
            foreach (MergedSong song in mergedSongs)
            &#123;
                if (song.singer == singer &amp;&amp; song.name == songName)
                &#123;
                    return song;
                &#125;
            &#125;

            return null;
        &#125;
</code></pre>
<h2 id="软件界面"><a href="#软件界面" class="headerlink" title="软件界面"></a>软件界面</h2><p>软件界面，增加用户、密码输入</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/25/1598352954630.png" alt="界面"></p>
<p>搜索结果，设置为默认选中：</p>
<pre><code> List&lt;ListViewItem&gt; listViewItems = new List&lt;ListViewItem&gt;();
            mergedSongs.ForEach(item =&gt;
            &#123;
                ListViewItem lvi = new ListViewItem();
                lvi.Text = item.name;
                lvi.SubItems.Add(item.singer);
                lvi.SubItems.Add(item.rate + &quot;kb&quot;);
                lvi.SubItems.Add((item.size / (1024 * 1024)).ToString(&quot;F2&quot;) + &quot;MB&quot;);  //将文件大小装换成MB的单位
                TimeSpan ts = new TimeSpan(0, 0, (int)item.duration); //把秒数换算成分钟数
                lvi.SubItems.Add(ts.Minutes + &quot;:&quot; + ts.Seconds.ToString(&quot;00&quot;));
                lvi.SubItems.Add(item.source);
                lvi.Tag = item;
                lvi.Checked = true; // 默认选中
                listViewItems.Add(lvi);
            &#125;);
</code></pre>
<p>搜索出来后，下载可以完全复用之前逻辑。</p>
<h2 id="下载歌曲使用"><a href="#下载歌曲使用" class="headerlink" title="下载歌曲使用"></a>下载歌曲使用</h2><p>下载后的歌曲，可以通过网易云音乐客户端，上传到云盘，然后批量选中，添加到我喜欢的音乐</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/25/1598353051852.png" alt="上传"></p>
<p>批量选中后收藏到歌单：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/25/1598353082913.png" alt="批量收藏"></p>
<h2 id="工具下载地址"><a href="#工具下载地址" class="headerlink" title="工具下载地址"></a>工具下载地址</h2><ul>
<li>可以从github下载<br><a href="https://github.com/jadepeng/music163tool">https://github.com/jadepeng/music163tool</a></li>
<li>国内gitee地址：<br><a href="https://gitee.com/jadepeng/music163tool">https://gitee.com/jadepeng/music163tool</a></li>
</ul>
<p>欢迎关注作者微信公众号, 一起交流软件开发。</p>
<p><img src="https://img2020.cnblogs.com/38465/202101/38465-20210118185019928-1475690632.png" alt="欢迎关注作者微信公众号"></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>XMusicDownloader</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot引入swagger-ui 后swagger-ui.html无法访问404</title>
    <url>/jadepeng/2020/08/22/jqpeng-Spring%20Boot%E5%BC%95%E5%85%A5swagger-ui%20%E5%90%8Eswagger-ui.html%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE404/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/swagger-ui-404.html">Spring Boot引入swagger-ui 后swagger-ui.html无法访问404</a></p>
<p>最近给graphserver增加swagger，记录下过程与问题解决。</p>
<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务，后端集成下Swagger，然后就可以提供一个在线文档地址给前端同学。</p>
<h2 id="引入-Swagger"><a href="#引入-Swagger" class="headerlink" title="引入 Swagger"></a>引入 Swagger</h2><p>pom中加入相关配置：</p>
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>增加<code>Swagger2Config</code>, 添加<code>@EnableSwagger2</code>,可以通过定义Docket bean实现自定义。</p>
<pre><code>@Configuration
@EnableSwagger2
@Profile(&quot;swagger&quot;)
@ComponentScan(&quot;xxx.controller&quot;)
public class Swagger2Config &#123;

    @Bean
    public Docket createRestApi() &#123;
        return new Docket(DocumentationType.SWAGGER_2)
            .apiInfo(apiInfo())
            .enable(true)
            .select()
            .apis(RequestHandlerSelectors.basePackage(&quot;xxx.controller&quot;))
            .paths(PathSelectors.any())
            .build();
    &#125;

    private ApiInfo apiInfo() &#123;
        return new ApiInfoBuilder()
            .title(&quot;XXX Rest Server&quot;)
            .description(&quot;XXXRest接口&quot;)
            .contact(new Contact(&quot;contract&quot;, &quot;url&quot;, &quot;email&quot;))
            .version(&quot;1.0&quot;)
            .build();
    &#125;
&#125;
</code></pre>
<h2 id="swagger-ui-html-404问题"><a href="#swagger-ui-html-404问题" class="headerlink" title="swagger-ui.html 404问题"></a>swagger-ui.html 404问题</h2><p>项目中有web配置，因此怀疑是这些配置影响了，搜索下发现这位仁兄有类似经历：<code>https://www.cnblogs.com/pangguoming/p/10551895.html</code></p>
<p>于是在WebMvcConfig 配置中，override <code>addResourceHandlers</code></p>
<pre><code>@Configuration
public class WebMvcConfig implements WebMvcConfigurer &#123;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);
        registry.addResourceHandler(&quot;swagger-ui.html&quot;)
            .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);
        registry.addResourceHandler(&quot;/webjars/**&quot;)
            .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
    &#125;
</code></pre>
<p>搞定收工。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>server端有了swagger，前端如何更优先的调用？</p>
<p>参见：<a href="https://www.cnblogs.com/xiaoqi/p/generator-swagger-2-ts-2.html">Vue 使用typescript， 优雅的调用swagger API</a>,笔者提供了一个开源npm库，可以为前端生成调用axios调用代码。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/pangguoming/p/10551895.html">https://www.cnblogs.com/pangguoming/p/10551895.html</a></li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>图数据库之TinkerPop Provider</title>
    <url>/jadepeng/2020/08/13/jqpeng-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BTinkerPop%20Provider/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/tinkerPop-Provider.html">图数据库之TinkerPop Provider</a></p>
<p>Apache TinkerPop 提供了图数据库的抽象接口，方便第三方实现自己的图数据库以接入TinkerPop 技术栈，享受TinkerPop 的Gremlin、算法等福利。TinkerPop将这些第三方称为“Provider ”，知名的Provider包含janusGraph、neo4j、hugegraph等。</p>
<p>Provider包含：</p>
<ul>
<li><p>Graph System Provider</p>
<ul>
<li>Graph Database Provider</li>
<li>Graph Processor Provider</li>
</ul>
</li>
<li><p>Graph Driver Provider</p>
</li>
<li><p>Graph Language Provider</p>
</li>
<li><p>Graph Plugin Provider</p>
</li>
</ul>
<h2 id="Graph-Structure-API（图谱数据结构）"><a href="#Graph-Structure-API（图谱数据结构）" class="headerlink" title="Graph Structure API（图谱数据结构）"></a>Graph Structure API（图谱数据结构）</h2><p>Graph最高层的抽象数据结构包含 Graph（图）, Vertex（顶点）, Edge（边）, VertexProperty（属性） and Property.</p>
<p>基于这些基础数据结构，就可以对进行基本的图谱操作。</p>
<pre><code>Graph graph = TinkerGraph.open(); //1
Vertex marko = graph.addVertex(T.label, &quot;person&quot;, T.id, 1, &quot;name&quot;, &quot;marko&quot;, &quot;age&quot;, 29); //2
Vertex vadas = graph.addVertex(T.label, &quot;person&quot;, T.id, 2, &quot;name&quot;, &quot;vadas&quot;, &quot;age&quot;, 27);
Vertex lop = graph.addVertex(T.label, &quot;software&quot;, T.id, 3, &quot;name&quot;, &quot;lop&quot;, &quot;lang&quot;, &quot;java&quot;);
Vertex josh = graph.addVertex(T.label, &quot;person&quot;, T.id, 4, &quot;name&quot;, &quot;josh&quot;, &quot;age&quot;, 32);
Vertex ripple = graph.addVertex(T.label, &quot;software&quot;, T.id, 5, &quot;name&quot;, &quot;ripple&quot;, &quot;lang&quot;, &quot;java&quot;);
Vertex peter = graph.addVertex(T.label, &quot;person&quot;, T.id, 6, &quot;name&quot;, &quot;peter&quot;, &quot;age&quot;, 35);
marko.addEdge(&quot;knows&quot;, vadas, T.id, 7, &quot;weight&quot;, 0.5f); //3
marko.addEdge(&quot;knows&quot;, josh, T.id, 8, &quot;weight&quot;, 1.0f);
marko.addEdge(&quot;created&quot;, lop, T.id, 9, &quot;weight&quot;, 0.4f);
josh.addEdge(&quot;created&quot;, ripple, T.id, 10, &quot;weight&quot;, 1.0f);
josh.addEdge(&quot;created&quot;, lop, T.id, 11, &quot;weight&quot;, 0.4f);
peter.addEdge(&quot;created&quot;, lop, T.id, 12, &quot;weight&quot;, 0.2f);
</code></pre>
<ol>
<li>创建一个基于内存存储的TinkerGraph 实例（TinkerGraph是官方实现的，基于内存的Graph）</li>
</ol>
<p>2 .创建一个顶点</p>
<ol>
<li>创建边</li>
</ol>
<p>上面的代码构建了一个基本的图，下面的代码演示如何进行图谱的操作。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/13/1597305698157.png" alt="图谱操作"></p>
<h2 id="实现-Gremlin-Core"><a href="#实现-Gremlin-Core" class="headerlink" title="实现 Gremlin-Core"></a>实现 Gremlin-Core</h2><p>一个标准的Graph Provider需要实现OLTP 和OLAP两类接口，官方推荐学习TinkerGraph(in-memory OLTP and OLAP in tinkergraph-gremlin)，以及 Neo4jGraph (OLTP w/ transactions in neo4j-gremlin) ，还有<br> Neo4jGraph (OLTP w/ transactions in neo4j-gremlin) ，还有 HadoopGraph (OLAP in hadoop-gremlin) 。</p>
<ol>
<li>在线事务处理 Graph Systems (<strong>OLTP</strong>)</li>
</ol>
<pre><code>1.  数据结构 API: `Graph`, `Element`, `Vertex`, `Edge`, `Property` and `Transaction` (if transactions are supported).

2.  处理API : `TraversalStrategy` instances for optimizing Gremlin traversals to the provider’s graph system (i.e. `TinkerGraphStepStrategy`).
</code></pre>
<ol>
<li><p>在线分析 图系统 (<strong>OLAP</strong>)</p>
<ol>
<li>Everything required of OLTP is required of OLAP (but not vice versa).</li>
<li>GraphComputer API: <code>GraphComputer</code>, <code>Messenger</code>, <code>Memory</code>.</li>
</ol>
</li>
</ol>
<h3 id="OLTP-实现"><a href="#OLTP-实现" class="headerlink" title="OLTP 实现"></a>OLTP 实现</h3><p>需要实现structure包下的interface，包含<code>Graph</code>, <code>Vertex</code>, <code>Edge</code>, <code>Property</code>, <code>Transaction</code>等等。</p>
<ul>
<li><code>Graph</code>实现时，需要命名为<code>XXXGraph</code> (举例： TinkerGraph, Neo4jGraph, HadoopGraph, etc.).<ul>
<li>需要兼容<code>GraphFactory</code> ，也就是提供一个静态的 <code>Graph open(Configuration)</code> 方法。</li>
</ul>
</li>
</ul>
<h3 id="OLAP-实现"><a href="#OLAP-实现" class="headerlink" title="OLAP 实现"></a>OLAP 实现</h3><p>需要实现：</p>
<ol>
<li><code>GraphComputer</code>: 图计算器，提供隔离环境，执行VertexProgram,和MapReduce任务.</li>
<li><code>Memory</code>: A global blackboard for ANDing, ORing, INCRing, and SETing values for specified keys.</li>
<li><code>Messenger</code>: The system that collects and distributes messages being propagated by vertices executing the VertexProgram application.</li>
<li><code>MapReduce.MapEmitter</code>: The system that collects key/value pairs being emitted by the MapReduce applications map-phase.</li>
<li><code>MapReduce.ReduceEmitter</code>: The system that collects key/value pairs being emitted by the MapReduce applications combine- and reduce-phases.</li>
</ol>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>知识图谱</tag>
        <tag>图数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>图数据库HugeGraph源码解读 （1） ——  入门介绍</title>
    <url>/jadepeng/2020/08/10/jqpeng-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93HugeGraph%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%20%EF%BC%881%EF%BC%89%20%E2%80%94%E2%80%94%20%20%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/hugegraph-summary.html">图数据库HugeGraph源码解读 （1） ——  入门介绍</a></p>
<h2 id="HugeGraph介绍"><a href="#HugeGraph介绍" class="headerlink" title="HugeGraph介绍"></a>HugeGraph介绍</h2><p>以下引自官方文档：</p>
<pre><code>HugeGraph是一款易用、高效、通用的开源图数据库系统（Graph Database，GitHub项目地址）， 实现了Apache TinkerPop3框架及完全兼容Gremlin查询语言， 具备完善的工具链组件，助力用户轻松构建基于图数据库之上的应用和产品。HugeGraph支持百亿以上的顶点和边快速导入，并提供毫秒级的关联关系查询能力（OLTP）， 并可与Hadoop、Spark等大数据平台集成以进行离线分析（OLAP）。

HugeGraph典型应用场景包括深度关系探索、关联分析、路径搜索、特征抽取、数据聚类、社区检测、 知识图谱等，适用业务领域有如网络安全、电信诈骗、金融风控、广告推荐、社交网络和智能机器人等。
</code></pre>
<p>划重点：  </p>
<ul>
<li>基于TinkerPop3框架，兼容Gremlin查询语言  </li>
<li>OLTP（开源） 与 OLAP(商业版）  </li>
<li>常用图应用支持—— 路径搜索、推荐等</li>
</ul>
<h2 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>HugeGraph包括三个层次的功能，分别是存储层、计算层和用户接口层。 HugeGraph支持OLTP和OLAP两种图计算类型</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/10/1597055013416.png" alt="HugeGraph架构"></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>HugeGraph的主要功能分为HugeCore、ApiServer、HugeGraph-Client、HugeGraph-Loader和HugeGraph-Studio等组件构成，各组件之间的通信关系如下图所示。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/10/1597055066287.png" alt="组件"></p>
<p>其中核心组件：</p>
<ul>
<li>HugeCore ：HugeGraph的核心模块，TinkerPop的接口主要在该模块中实现。</li>
<li>ApiServer ：提供RESTFul Api接口，对外提供Graph Api、Schema Api和Gremlin Api等接口服务。</li>
<li>HugeGraph-Client：基于Java客户端驱动程序</li>
</ul>
<p>生态组件：</p>
<ul>
<li>HugeGraph-Loader：数据导入模块。HugeGraph-Loader可以扫描并分析现有数据，自动生成Graph Schema创建语言，通过批量方式快速导入数据。</li>
<li>HugeGraph-Studio：基于Web的可视化IDE环境。以Notebook方式记录Gremlin查询，可视化展示Graph的关联关系。HugeGraph-Studio也是本系统推荐的工具。</li>
</ul>
<p><code>HugeGraph-Studio</code>  看起来已经被抛弃了，研发团队正开发一个名为’hugegraph-hubble’ 的新项目：</p>
<pre><code>hugegraph-hubble is a graph management and analysis platform that provides features: graph data load, schema management, graph relationship analysis and graphical display.
</code></pre>
<p>根据官方的说明，<code>hubble</code>定义为图谱管理和分析平台，提供图谱数据加载、schema管理、图分析和可视化展示，目前正在研发中，预计2020年9月份会发布首个版本。</p>
<h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><p>常见的图数据表示模型有两种：</p>
<ul>
<li>RDF（Resource Description Framework）模型： 学术界的选择，通过sparql来进行查询，<code>jena</code>，<code>gStore</code>等等</li>
<li>属性图（Property Graph）模型，工业界的选择，<code>neo4j</code>和<code>janusgraph</code>都是这种方案。</li>
</ul>
<p>RDF是W3C标准，而Property Graph是工业标准，受到广大图数据库厂商的广泛支持。HugeGraph采用Property Graph，遵循工业标准。</p>
<p>HugeGraph存储概念模型详见下图：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/10/1597055603962.png" alt="HugeGraph概念模型"></p>
<p>主要包含几个部分：</p>
<ul>
<li>Vertex（顶点），对应一个实体（Entity）</li>
<li>Vertex Label(顶点的类型），对应一个概念（Concept）</li>
<li>属性（图里的name、age），PropertyKey</li>
<li>Edge边（图里的lives），对应RDF里的Relation</li>
</ul>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>HugeGraph提供了丰富的插件扩展机制，包含几个维度的扩展项：</p>
<ul>
<li>后端存储</li>
<li>序列化器</li>
<li>自定义配置项</li>
<li>分词器</li>
</ul>
<p>插件实现机制</p>
<ol>
<li>HugeGraph提供插件接口HugeGraphPlugin，通过Java SPI机制支持插件化</li>
<li>HugeGraph提供了4个扩展项注册函数：<code>registerOptions()</code>、<code>registerBackend()</code>、<code>registerSerializer()</code>、<code>registerAnalyzer()</code></li>
<li>插件实现者实现相应的Options、Backend、Serializer或Analyzer的接口</li>
<li>插件实现者实现HugeGraphPlugin接口的<code>register()</code>方法，在该方法中注册上述第3点所列的具体实现类，并打成jar包</li>
<li>插件使用者将jar包放在HugeGraph Server安装目录的<code>plugins</code>目录下，修改相关配置项为插件自定义值，重启即可生效</li>
</ol>
<h3 id="从案例深入源码"><a href="#从案例深入源码" class="headerlink" title="从案例深入源码"></a>从案例深入源码</h3><p>想要深入的理解一个系统的源码，先从具体的应用入手。先查看example代码：</p>
<p><code>https://github.com/hugegraph/hugegraph/blob/master/hugegraph-example/src/main/java/com/baidu/hugegraph/example/Example1.java</code></p>
<pre><code> public static void main(String[] args) throws Exception &#123;
        LOG.info(&quot;Example1 start!&quot;);

        HugeGraph graph = ExampleUtil.loadGraph();

        Example1.showFeatures(graph);

        Example1.loadSchema(graph);
        Example1.loadData(graph);
        Example1.testQuery(graph);
        Example1.testRemove(graph);
        Example1.testVariables(graph);
        Example1.testLeftIndexProcess(graph);

        Example1.thread(graph);

        graph.close();

        HugeFactory.shutdown(30L);
    &#125;
</code></pre>
<h4 id="1-loadGraph"><a href="#1-loadGraph" class="headerlink" title="1. loadGraph"></a>1. loadGraph</h4><p>要使用hugegraph，需要先初始化一个<code>HugeGraph</code>对象，而<code>LoadGraph</code> 正是做这个的。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/8/10/1597056461542.png" alt="loadGraph"></p>
<pre><code>public static HugeGraph loadGraph(boolean needClear, boolean needProfile) &#123;
        if (needProfile) &#123;
            profile();
        &#125;

        registerPlugins();

        String conf = &quot;hugegraph.properties&quot;;
        try &#123;
            String path = ExampleUtil.class.getClassLoader()
                                     .getResource(conf).getPath();
            File file = new File(path);
            if (file.exists() &amp;&amp; file.isFile()) &#123;
                conf = path;
            &#125;
        &#125; catch (Exception ignored) &#123;
        &#125;

        HugeGraph graph = HugeFactory.open(conf);

        if (needClear) &#123;
            graph.clearBackend();
        &#125;
        graph.initBackend();

        return graph;
    &#125;
</code></pre>
<h5 id="1-1-registerPlugins"><a href="#1-1-registerPlugins" class="headerlink" title="1.1 registerPlugins"></a>1.1 registerPlugins</h5><p>其中 <code>registerPlugins</code> 注册插件，注意上面介绍的扩展机制。hugegraph所有的后端存储都需要通过插件注册。</p>
<pre><code> public static void registerPlugins() &#123;
        if (registered) &#123;
            return;
        &#125;
        registered = true;

        RegisterUtil.registerCassandra();
        RegisterUtil.registerScyllaDB();
        RegisterUtil.registerHBase();
        RegisterUtil.registerRocksDB();
        RegisterUtil.registerMysql();
        RegisterUtil.registerPalo();
    &#125;
</code></pre>
<p>注册主要是register配置、序列化器和backend，比如下面是mysql的。</p>
<pre><code>public static void registerMysql() &#123;
        // Register config
        OptionSpace.register(&quot;mysql&quot;,
                &quot;com.baidu.hugegraph.backend.store.mysql.MysqlOptions&quot;);
        // Register serializer
        SerializerFactory.register(&quot;mysql&quot;,
                &quot;com.baidu.hugegraph.backend.store.mysql.MysqlSerializer&quot;);
        // Register backend
        BackendProviderFactory.register(&quot;mysql&quot;,
                &quot;com.baidu.hugegraph.backend.store.mysql.MysqlStoreProvider&quot;);
    &#125;
</code></pre>
<h5 id="1-2-HugeFactory-open"><a href="#1-2-HugeFactory-open" class="headerlink" title="1.2 HugeFactory.open"></a>1.2 HugeFactory.open</h5><p>HugeFactory 是Hugraph的工厂类，支持传入Configuraion配置信息，构建一个HugeGraph实例，注意这里为了线程安全，签名采用<code>synchronized</code></p>
<pre><code> public static synchronized HugeGraph open(Configuration config) &#123;
        HugeConfig conf = config instanceof HugeConfig ?
                          (HugeConfig) config : new HugeConfig(config);
        String name = conf.get(CoreOptions.STORE);
        checkGraphName(name, &quot;graph config(like hugegraph.properties)&quot;);
        name = name.toLowerCase();
        HugeGraph graph = graphs.get(name);
        if (graph == null || graph.closed()) &#123;
            graph = new StandardHugeGraph(conf);
            graphs.put(name, graph);
        &#125; else &#123;
            String backend = conf.get(CoreOptions.BACKEND);
            E.checkState(backend.equalsIgnoreCase(graph.backend()),
                         &quot;Graph name &#39;%s&#39; has been used by backend &#39;%s&#39;&quot;,
                         name, graph.backend());
        &#125;
        return graph;
    &#125;
</code></pre>
<p>这里顺带提下配置文件，通过代码看到，默认是读取<code>hugegraph.properties</code>.</p>
<h5 id="1-3-HugeGraph-对象"><a href="#1-3-HugeGraph-对象" class="headerlink" title="1.3 HugeGraph 对象"></a>1.3 HugeGraph 对象</h5><p>HugeGraph是一个interface，继承gremlin的Graph接口，定义了图谱的Schema定义、数据存储、查询等API方法。从上面1.2可以看到，默认的实现是<code>StandardHugeGraph</code>。</p>
<pre><code>public interface HugeGraph extends Graph &#123;

    public HugeGraph hugegraph();

    public SchemaManager schema();

    public Id getNextId(HugeType type);

    public void addPropertyKey(PropertyKey key);
    public void removePropertyKey(Id key);
    public Collection&lt;PropertyKey&gt; propertyKeys();
    public PropertyKey propertyKey(String key);
    public PropertyKey propertyKey(Id key);
    public boolean existsPropertyKey(String key);

...
   
</code></pre>
<h5 id="1-4-graph-clearBackend-与initBackend"><a href="#1-4-graph-clearBackend-与initBackend" class="headerlink" title="1.4 graph.clearBackend 与initBackend"></a>1.4 graph.clearBackend 与initBackend</h5><p>clearBackend将后端数据清理，initBackend初始化基本的数据结构。</p>
<h4 id="2-loadSchema"><a href="#2-loadSchema" class="headerlink" title="2. loadSchema"></a>2. loadSchema</h4><p>该方法，用来定义schema：</p>
<pre><code>public static void loadSchema(final HugeGraph graph) &#123;

        SchemaManager schema = graph.schema();

        // Schema changes will be commit directly into the back-end
        LOG.info(&quot;===============  propertyKey  ================&quot;);
        schema.propertyKey(&quot;id&quot;).asInt().create();
        schema.propertyKey(&quot;name&quot;).asText().create();
        schema.propertyKey(&quot;gender&quot;).asText().create();
        schema.propertyKey(&quot;instructions&quot;).asText().create();
        schema.propertyKey(&quot;category&quot;).asText().create();
        schema.propertyKey(&quot;year&quot;).asInt().create();
        schema.propertyKey(&quot;time&quot;).asText().create();
        schema.propertyKey(&quot;timestamp&quot;).asDate().create();
        schema.propertyKey(&quot;ISBN&quot;).asText().create();
        schema.propertyKey(&quot;calories&quot;).asInt().create();
        schema.propertyKey(&quot;amount&quot;).asText().create();
        schema.propertyKey(&quot;stars&quot;).asInt().create();
        schema.propertyKey(&quot;age&quot;).asInt().valueSingle().create();
        schema.propertyKey(&quot;comment&quot;).asText().valueSet().create();
        schema.propertyKey(&quot;contribution&quot;).asText().valueSet().create();
        schema.propertyKey(&quot;nickname&quot;).asText().valueList().create();
        schema.propertyKey(&quot;lived&quot;).asText().create();
        schema.propertyKey(&quot;country&quot;).asText().valueSet().create();
        schema.propertyKey(&quot;city&quot;).asText().create();
        schema.propertyKey(&quot;sensor_id&quot;).asUUID().create();
        schema.propertyKey(&quot;versions&quot;).asInt().valueList().create();

        LOG.info(&quot;===============  vertexLabel  ================&quot;);

        schema.vertexLabel(&quot;person&quot;)
              .properties(&quot;name&quot;, &quot;age&quot;, &quot;city&quot;)
              .primaryKeys(&quot;name&quot;)
              .create();
        schema.vertexLabel(&quot;author&quot;)
              .properties(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;lived&quot;)
              .primaryKeys(&quot;id&quot;).create();
        schema.vertexLabel(&quot;language&quot;).properties(&quot;name&quot;, &quot;versions&quot;)
              .primaryKeys(&quot;name&quot;).create();
        schema.vertexLabel(&quot;recipe&quot;).properties(&quot;name&quot;, &quot;instructions&quot;)
              .primaryKeys(&quot;name&quot;).create();
        schema.vertexLabel(&quot;book&quot;).properties(&quot;name&quot;)
              .primaryKeys(&quot;name&quot;).create();
        schema.vertexLabel(&quot;reviewer&quot;).properties(&quot;name&quot;, &quot;timestamp&quot;)
              .primaryKeys(&quot;name&quot;).create();

        // vertex label must have the properties that specified in primary key
        schema.vertexLabel(&quot;FridgeSensor&quot;).properties(&quot;city&quot;)
              .primaryKeys(&quot;city&quot;).create();

        LOG.info(&quot;===============  vertexLabel &amp; index  ================&quot;);
        schema.indexLabel(&quot;personByCity&quot;)
              .onV(&quot;person&quot;).secondary().by(&quot;city&quot;).create();
        schema.indexLabel(&quot;personByAge&quot;)
              .onV(&quot;person&quot;).range().by(&quot;age&quot;).create();

        schema.indexLabel(&quot;authorByLived&quot;)
              .onV(&quot;author&quot;).search().by(&quot;lived&quot;).create();

        // schemaManager.getVertexLabel(&quot;author&quot;).index(&quot;byName&quot;).secondary().by(&quot;name&quot;).add();
        // schemaManager.getVertexLabel(&quot;recipe&quot;).index(&quot;byRecipe&quot;).materialized().by(&quot;name&quot;).add();
        // schemaManager.getVertexLabel(&quot;meal&quot;).index(&quot;byMeal&quot;).materialized().by(&quot;name&quot;).add();
        // schemaManager.getVertexLabel(&quot;ingredient&quot;).index(&quot;byIngredient&quot;).materialized().by(&quot;name&quot;).add();
        // schemaManager.getVertexLabel(&quot;reviewer&quot;).index(&quot;byReviewer&quot;).materialized().by(&quot;name&quot;).add();

        LOG.info(&quot;===============  edgeLabel  ================&quot;);

        schema.edgeLabel(&quot;authored&quot;).singleTime()
              .sourceLabel(&quot;author&quot;).targetLabel(&quot;book&quot;)
              .properties(&quot;contribution&quot;, &quot;comment&quot;)
              .nullableKeys(&quot;comment&quot;)
              .create();

        schema.edgeLabel(&quot;write&quot;).multiTimes().properties(&quot;time&quot;)
              .sourceLabel(&quot;author&quot;).targetLabel(&quot;book&quot;)
              .sortKeys(&quot;time&quot;)
              .create();

        schema.edgeLabel(&quot;look&quot;).multiTimes().properties(&quot;timestamp&quot;)
              .sourceLabel(&quot;person&quot;).targetLabel(&quot;book&quot;)
              .sortKeys(&quot;timestamp&quot;)
              .create();

        schema.edgeLabel(&quot;created&quot;).singleTime()
              .sourceLabel(&quot;author&quot;).targetLabel(&quot;language&quot;)
              .create();

        schema.edgeLabel(&quot;rated&quot;)
              .sourceLabel(&quot;reviewer&quot;).targetLabel(&quot;recipe&quot;)
              .create();
    &#125;
</code></pre>
<p>划重点：  </p>
<ul>
<li>SchemaManager schema = graph.schema() 获取SchemaManager  </li>
<li>schema.propertyKey(NAME).asXXType().create() 创建属性  </li>
<li>schema.vertexLabel(“person”) // 定义概念<br>.properties(“name”, “age”, “city”)  // 定义概念的属性<br>.primaryKeys(“name”)  // 定义primary Keys，primary Key组合后可以唯一确定一个实体<br>.create();  </li>
<li> schema.indexLabel(“personByCity”).onV(“person”).secondary().by(“city”).create();  定义索引  </li>
<li>schema.edgeLabel(“authored”).singleTime()<br>.sourceLabel(“author”).targetLabel(“book”)<br>.properties(“contribution”, “comment”)<br>.nullableKeys(“comment”)<br>.create();  // 定义关系</li>
</ul>
<h4 id="3-loadData"><a href="#3-loadData" class="headerlink" title="3. loadData"></a>3. loadData</h4><p>创建实体，注意格式，K-V成对出现：</p>
<pre><code>graph.addVertex(T.label, &quot;book&quot;, &quot;name&quot;, &quot;java-3&quot;);
</code></pre>
<p>创建关系，Vertex的addEdge方法：</p>
<pre><code>    Vertex james = tx.addVertex(T.label, &quot;author&quot;, &quot;id&quot;, 1,
                                &quot;name&quot;, &quot;James Gosling&quot;,  &quot;age&quot;, 62,
                                &quot;lived&quot;, &quot;San Francisco Bay Area&quot;);

    Vertex java = tx.addVertex(T.label, &quot;language&quot;, &quot;name&quot;, &quot;java&quot;,
                               &quot;versions&quot;, Arrays.asList(6, 7, 8));
    Vertex book1 = tx.addVertex(T.label, &quot;book&quot;, &quot;name&quot;, &quot;java-1&quot;);
    Vertex book2 = tx.addVertex(T.label, &quot;book&quot;, &quot;name&quot;, &quot;java-2&quot;);
    Vertex book3 = tx.addVertex(T.label, &quot;book&quot;, &quot;name&quot;, &quot;java-3&quot;);

    james.addEdge(&quot;created&quot;, java);
    james.addEdge(&quot;authored&quot;, book1,
                  &quot;contribution&quot;, &quot;1990-1-1&quot;,
                  &quot;comment&quot;, &quot;it&#39;s a good book&quot;,
                  &quot;comment&quot;, &quot;it&#39;s a good book&quot;,
                  &quot;comment&quot;, &quot;it&#39;s a good book too&quot;);
    james.addEdge(&quot;authored&quot;, book2, &quot;contribution&quot;, &quot;2017-4-28&quot;);

    james.addEdge(&quot;write&quot;, book2, &quot;time&quot;, &quot;2017-4-28&quot;);
    james.addEdge(&quot;write&quot;, book3, &quot;time&quot;, &quot;2016-1-1&quot;);
    james.addEdge(&quot;write&quot;, book3, &quot;time&quot;, &quot;2017-4-28&quot;);    
</code></pre>
<p>添加后，需要commit</p>
<h4 id="4-testQuery-测试查询"><a href="#4-testQuery-测试查询" class="headerlink" title="4. testQuery 测试查询"></a>4. testQuery 测试查询</h4><p>查询主要通过<code>GraphTraversal</code>, 可以通过<code>graph.traversal()</code>获得：</p>
<pre><code>public static void testQuery(final HugeGraph graph) &#123;
        // query all
        GraphTraversal&lt;Vertex, Vertex&gt; vertices = graph.traversal().V();
        int size = vertices.toList().size();
        assert size == 12;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query all vertices: size=&quot; + size);

        // query by label
        vertices = graph.traversal().V().hasLabel(&quot;person&quot;);
        size = vertices.toList().size();
        assert size == 5;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query all persons: size=&quot; + size);

        // query vertex by primary-values
        vertices = graph.traversal().V().hasLabel(&quot;author&quot;).has(&quot;id&quot;, 1);
        List&lt;Vertex&gt; vertexList = vertices.toList();
        assert vertexList.size() == 1;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query vertices by primary-values: &quot; +
                           vertexList);

        VertexLabel author = graph.schema().getVertexLabel(&quot;author&quot;);
        String authorId = String.format(&quot;%s:%s&quot;, author.id().asString(), &quot;11&quot;);

        // query vertex by id and query out edges
        vertices = graph.traversal().V(authorId);
        GraphTraversal&lt;Vertex, Edge&gt; edgesOfVertex = vertices.outE(&quot;created&quot;);
        List&lt;Edge&gt; edgeList = edgesOfVertex.toList();
        assert edgeList.size() == 1;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query edges of vertex: &quot; + edgeList);

        vertices = graph.traversal().V(authorId);
        vertexList = vertices.out(&quot;created&quot;).toList();
        assert vertexList.size() == 1;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query vertices of vertex: &quot; + vertexList);

        // query edge by sort-values
        vertices = graph.traversal().V(authorId);
        edgesOfVertex = vertices.outE(&quot;write&quot;).has(&quot;time&quot;, &quot;2017-4-28&quot;);
        edgeList = edgesOfVertex.toList();
        assert edgeList.size() == 2;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query edges of vertex by sort-values: &quot; +
                           edgeList);

        // query vertex by condition (filter by property name)
        ConditionQuery q = new ConditionQuery(HugeType.VERTEX);
        PropertyKey age = graph.propertyKey(&quot;age&quot;);
        q.key(HugeKeys.PROPERTIES, age.id());
        if (graph.backendStoreFeatures()
                 .supportsQueryWithContainsKey()) &#123;
            Iterator&lt;Vertex&gt; iter = graph.vertices(q);
            assert iter.hasNext();
            System.out.println(&quot;&gt;&gt;&gt;&gt; queryVertices(age): &quot; + iter.hasNext());
            while (iter.hasNext()) &#123;
                System.out.println(&quot;&gt;&gt;&gt;&gt; queryVertices(age): &quot; + iter.next());
            &#125;
        &#125;

        // query all edges
        GraphTraversal&lt;Edge, Edge&gt; edges = graph.traversal().E().limit(2);
        size = edges.toList().size();
        assert size == 2;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query all edges with limit 2: size=&quot; + size);

        // query edge by id
        EdgeLabel authored = graph.edgeLabel(&quot;authored&quot;);
        VertexLabel book = graph.schema().getVertexLabel(&quot;book&quot;);
        String book1Id = String.format(&quot;%s:%s&quot;, book.id().asString(), &quot;java-1&quot;);
        String book2Id = String.format(&quot;%s:%s&quot;, book.id().asString(), &quot;java-2&quot;);

        String edgeId = String.format(&quot;S%s&gt;%s&gt;%s&gt;S%s&quot;,
                                      authorId, authored.id(), &quot;&quot;, book2Id);
        edges = graph.traversal().E(edgeId);
        edgeList = edges.toList();
        assert edgeList.size() == 1;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query edge by id: &quot; + edgeList);

        Edge edge = edgeList.get(0);
        edges = graph.traversal().E(edge.id());
        edgeList = edges.toList();
        assert edgeList.size() == 1;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query edge by id: &quot; + edgeList);

        // query edge by condition
        q = new ConditionQuery(HugeType.EDGE);
        q.eq(HugeKeys.OWNER_VERTEX, IdGenerator.of(authorId));
        q.eq(HugeKeys.DIRECTION, Directions.OUT);
        q.eq(HugeKeys.LABEL, authored.id());
        q.eq(HugeKeys.SORT_VALUES, &quot;&quot;);
        q.eq(HugeKeys.OTHER_VERTEX, IdGenerator.of(book1Id));

        Iterator&lt;Edge&gt; edges2 = graph.edges(q);
        assert edges2.hasNext();
        System.out.println(&quot;&gt;&gt;&gt;&gt; queryEdges(id-condition): &quot; +
                           edges2.hasNext());
        while (edges2.hasNext()) &#123;
            System.out.println(&quot;&gt;&gt;&gt;&gt; queryEdges(id-condition): &quot; +
                               edges2.next());
        &#125;

        // NOTE: query edge by has-key just supported by Cassandra
        if (graph.backendStoreFeatures().supportsQueryWithContainsKey()) &#123;
            PropertyKey contribution = graph.propertyKey(&quot;contribution&quot;);
            q.key(HugeKeys.PROPERTIES, contribution.id());
            Iterator&lt;Edge&gt; edges3 = graph.edges(q);
            assert edges3.hasNext();
            System.out.println(&quot;&gt;&gt;&gt;&gt; queryEdges(contribution): &quot; +
                               edges3.hasNext());
            while (edges3.hasNext()) &#123;
                System.out.println(&quot;&gt;&gt;&gt;&gt; queryEdges(contribution): &quot; +
                                   edges3.next());
            &#125;
        &#125;

        // query by vertex label
        vertices = graph.traversal().V().hasLabel(&quot;book&quot;);
        size = vertices.toList().size();
        assert size == 5;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query all books: size=&quot; + size);

        // query by vertex label and key-name
        vertices = graph.traversal().V().hasLabel(&quot;person&quot;).has(&quot;age&quot;);
        size = vertices.toList().size();
        assert size == 5;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query all persons with age: size=&quot; + size);

        // query by vertex props
        vertices = graph.traversal().V().hasLabel(&quot;person&quot;)
                        .has(&quot;city&quot;, &quot;Taipei&quot;);
        vertexList = vertices.toList();
        assert vertexList.size() == 1;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query all persons in Taipei: &quot; + vertexList);

        vertices = graph.traversal().V().hasLabel(&quot;person&quot;).has(&quot;age&quot;, 19);
        vertexList = vertices.toList();
        assert vertexList.size() == 1;
        System.out.println(&quot;&gt;&gt;&gt;&gt; query all persons age==19: &quot; + vertexList);

        vertices = graph.traversal().V().hasLabel(&quot;person&quot;)
                        .has(&quot;age&quot;, P.lt(19));
        vertexList = vertices.toList();
        assert vertexList.size() == 1;
        assert vertexList.get(0).property(&quot;age&quot;).value().equals(3);
        System.out.println(&quot;&gt;&gt;&gt;&gt; query all persons age&lt;19: &quot; + vertexList);

        String addr = &quot;Bay Area&quot;;
        vertices = graph.traversal().V().hasLabel(&quot;author&quot;)
                        .has(&quot;lived&quot;, Text.contains(addr));
        vertexList = vertices.toList();
        assert vertexList.size() == 1;
        System.out.println(String.format(&quot;&gt;&gt;&gt;&gt; query all authors lived %s: %s&quot;,
                           addr, vertexList));
    &#125;
</code></pre>
<p>划重点</p>
<h5 id="查询指定label的实体："><a href="#查询指定label的实体：" class="headerlink" title="查询指定label的实体："></a>查询指定label的实体：</h5><pre><code> vertices = graph.traversal().V().hasLabel(&quot;person&quot;);
 size = vertices.toList().size();
</code></pre>
<h5 id="根据primary-values查询实体："><a href="#根据primary-values查询实体：" class="headerlink" title="根据primary-values查询实体："></a>根据primary-values查询实体：</h5><pre><code> vertices = graph.traversal().V().hasLabel(&quot;author&quot;).has(&quot;id&quot;, 1);
        List&lt;Vertex&gt; vertexList = vertices.toList();
</code></pre>
<h5 id="查询edge："><a href="#查询edge：" class="headerlink" title="查询edge："></a>查询edge：</h5><p>查询所有edge：</p>
<pre><code>GraphTraversal&lt;Edge, Edge&gt; edges = graph.traversal().E().limit(2);
</code></pre>
<p>根据ID查询edge：</p>
<pre><code>    EdgeLabel authored = graph.edgeLabel(&quot;authored&quot;);
    VertexLabel book = graph.schema().getVertexLabel(&quot;book&quot;);
    String book1Id = String.format(&quot;%s:%s&quot;, book.id().asString(), &quot;java-1&quot;);
    String book2Id = String.format(&quot;%s:%s&quot;, book.id().asString(), &quot;java-2&quot;);

    String edgeId = String.format(&quot;S%s&gt;%s&gt;%s&gt;S%s&quot;,
                                  authorId, authored.id(), &quot;&quot;, book2Id);
    edges = graph.traversal().E(edgeId);
</code></pre>
<p>注意，edge的id由几个字段拼接起来的：  “S%s&gt;%s&gt;%s&gt;S%s”,authorId, authored.id(), “”, book2Id)</p>
<p>根据条件查询edge：</p>
<pre><code> q = new ConditionQuery(HugeType.EDGE);
        q.eq(HugeKeys.OWNER_VERTEX, IdGenerator.of(authorId));
        q.eq(HugeKeys.DIRECTION, Directions.OUT);
        q.eq(HugeKeys.LABEL, authored.id());
        q.eq(HugeKeys.SORT_VALUES, &quot;&quot;);
        q.eq(HugeKeys.OTHER_VERTEX, IdGenerator.of(book1Id));

        Iterator&lt;Edge&gt; edges2 = graph.edges(q);
        assert edges2.hasNext();
        System.out.println(&quot;&gt;&gt;&gt;&gt; queryEdges(id-condition): &quot; +
                           edges2.hasNext());
        while (edges2.hasNext()) &#123;
            System.out.println(&quot;&gt;&gt;&gt;&gt; queryEdges(id-condition): &quot; +
                               edges2.next());
        &#125;
</code></pre>
<p>可以指定DIRECTION，</p>
<h4 id="5-删除"><a href="#5-删除" class="headerlink" title="5. 删除"></a>5. 删除</h4><p>删除Vetex，调用vetex自带的remove方法</p>
<pre><code>       // remove vertex (and its edges)
        List&lt;Vertex&gt; vertices = graph.traversal().V().hasLabel(&quot;person&quot;)
                                     .has(&quot;age&quot;, 19).toList();
        assert vertices.size() == 1;
        Vertex james = vertices.get(0);
        Vertex book6 = graph.addVertex(T.label, &quot;book&quot;, &quot;name&quot;, &quot;java-6&quot;);
        james.addEdge(&quot;look&quot;, book6, &quot;timestamp&quot;, &quot;2017-5-2 12:00:08.0&quot;);
        james.addEdge(&quot;look&quot;, book6, &quot;timestamp&quot;, &quot;2017-5-3 12:00:08.0&quot;);
        graph.tx().commit();
        assert graph.traversal().V(book6.id()).bothE().hasNext();
        System.out.println(&quot;&gt;&gt;&gt;&gt; removing vertex: &quot; + james);
        james.remove();
        graph.tx().commit();
        assert !graph.traversal().V(james.id()).hasNext();
        assert !graph.traversal().V(book6.id()).bothE().hasNext();

    
</code></pre>
<p>删除关系，也类似：</p>
<pre><code>    // remove edge
        VertexLabel author = graph.schema().getVertexLabel(&quot;author&quot;);
        String authorId = String.format(&quot;%s:%s&quot;, author.id().asString(), &quot;11&quot;);
        EdgeLabel authored = graph.edgeLabel(&quot;authored&quot;);
        VertexLabel book = graph.schema().getVertexLabel(&quot;book&quot;);
        String book2Id = String.format(&quot;%s:%s&quot;, book.id().asString(), &quot;java-2&quot;);

        String edgeId = String.format(&quot;S%s&gt;%s&gt;%s&gt;S%s&quot;,
                                      authorId, authored.id(), &quot;&quot;, book2Id);

        List &lt;Edge&gt; edges = graph.traversal().E(edgeId).toList();
        assert edges.size() == 1;
        Edge edge = edges.get(0);
        System.out.println(&quot;&gt;&gt;&gt;&gt; removing edge: &quot; + edge);
        edge.remove();
        graph.tx().commit();
        assert !graph.traversal().E(edgeId).hasNext();
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文初步介绍了hugegraph设计理念、基本使用等。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>hugegraph</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>使用科大讯飞TTS自定义彩虹屁语音包</title>
    <url>/jadepeng/2020/06/29/jqpeng-%E4%BD%BF%E7%94%A8%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9ETTS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A9%E8%99%B9%E5%B1%81%E8%AF%AD%E9%9F%B3%E5%8C%85/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/rainbow-fart-tts.html">使用科大讯飞TTS自定义彩虹屁语音包</a></p>
<h1 id="rainbow-fart-tts"><a href="#rainbow-fart-tts" class="headerlink" title="rainbow-fart-tts"></a>rainbow-fart-tts</h1><p>彩虹屁插件红了后，你是否想生成定义语音包呢？本文给出一个解决方案，使用科大讯飞的TTS生成彩虹屁语音包，你可以完全自定义文本，自定义发音人哦！</p>
<p>开源地址： <a href="https://github.com/jadepeng/rainbow-fart-tts">https://github.com/jadepeng/rainbow-fart-tts</a></p>
<h2 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本"></a>修改文本</h2><p>打开<code>manifest.json</code>, 修改text，可以按需增加keyword和对应text</p>
<pre><code> &#123;
      &quot;keywords&quot;: [
        &quot;if&quot;,
        &quot;else&quot;
      ],
      &quot;text&quot;: [
        &quot;你就是因为想太多如果，所以才交不到女朋友吧？&quot;,
        &quot; 别试了，我的可爱不需要用 if 来判断！&quot;,
        &quot; 人生没有那么多如果，有没有比编程更容易呢？&quot;
      ]
 &#125;
</code></pre>
<h2 id="获取开发者账号"><a href="#获取开发者账号" class="headerlink" title="获取开发者账号"></a>获取开发者账号</h2><p>到<code>https://www.xfyun.cn/</code> 注册账号，创建应用，然后开通语音合成,可以开通免费包,好使的话可以购买套餐哦。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/6/29/1593406803680.png" alt="讯飞tts免费包"></p>
<p>然后到控制面板，查看appid等信息：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/6/29/1593406879615.png" alt="appid"></p>
<p>然后打开VoicePackageMakerApp，将对应的信息填入:</p>
<pre><code>public class VoicePackageMakerApp &#123;
    private static final String hostUrl = &quot;https://tts-api.xfyun.cn/v2/tts&quot;;

    // 到控制台-语音合成页面获取
    private static final String APPID = &quot;&quot;;

    // 到控制台-语音合成页面获取
    private static final String API_SECRET = &quot;&quot;;

    //到控制台-语音合成页面获取
    private static final String API_KEY = &quot;&quot;;
</code></pre>
<h2 id="选取发音人"><a href="#选取发音人" class="headerlink" title="选取发音人"></a>选取发音人</h2><p>讯飞开放平台的在线语音合成有很多发音人，可以到<a href="https://www.xfyun.cn/services/online_tts">https://www.xfyun.cn/services/online_tts</a> 查看：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/6/29/1593407032570.png" alt="发音人"></p>
<p>选择自己心仪的，然后到控制面板开通权限：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/6/29/1593407082655.png" alt="开通发音人"></p>
<p>比如我选择的讯飞玲姐姐（志林姐姐），发音人是<code>x_xiaoling</code>，修改代码：</p>
<pre><code>public class VoicePackageMakerApp &#123;


    // 默认发音人
    private static final String DEFAULT_VCN = &quot;x_xiaoling&quot;;
</code></pre>
<h2 id="生成和使用语音包"><a href="#生成和使用语音包" class="headerlink" title="生成和使用语音包"></a>生成和使用语音包</h2><p>上面步骤做完后，直接运行<code>VoicePackageMakerApp</code>即可，然后在<code>voicePackages</code>目录下会生成<code>x_xiaoling</code>文件夹，里面是合成的语音包，可以给各个版本的彩虹屁插件使用。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/6/29/1593407303218.png" alt="使用语音包"></p>
<p>本文开源地址： <a href="https://github.com/jadepeng/rainbow-fart-tts">https://github.com/jadepeng/rainbow-fart-tts</a></p>
<p>IDE版本的语音包请参见：<a href="https://github.com/jadepeng/idea-rainbow-fart">https://github.com/jadepeng/idea-rainbow-fart</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>rainbow-fart-tts</tag>
        <tag>idea-rainbow-fart</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack升级到4.x 不完全指南</title>
    <url>/jadepeng/2020/06/08/jqpeng-webpack%E5%8D%87%E7%BA%A7%E5%88%B04.x%20%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/webpack-upgrade-to-4.html">webpack升级到4.x 不完全指南</a></p>
<p>最近在团队推行ts，顺便将webpack做了升级，升级到最新的4.X版本，下面记录一些迁移指南。</p>
<h2 id="VueLoader"><a href="#VueLoader" class="headerlink" title="VueLoader"></a>VueLoader</h2><h3 id="VueLoaderPlugin，显示的引用："><a href="#VueLoaderPlugin，显示的引用：" class="headerlink" title="VueLoaderPlugin，显示的引用："></a>VueLoaderPlugin，显示的引用：</h3><pre><code>const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;)

module.exports = &#123;
  module: &#123;
    rules: [
      // ... other rules
      &#123;
        test: /\.vue$/,
        loader: &#39;vue-loader&#39;
      &#125;
    ]
  &#125;,
  plugins: [
    // make sure to include the plugin!
    new VueLoaderPlugin()
  ]
&#125;
</code></pre>
<h3 id="less问题"><a href="#less问题" class="headerlink" title="less问题"></a>less问题</h3><p>less需要单独的配置规则,注意一定要加上vue-style-loader，否则样式不生效</p>
<pre><code>&#123;
  module: &#123;
    rules: [
      // ... other rules
      &#123;
        test: /\.less$/,
        use: [
          &#39;vue-style-loader&#39;,
          &#39;css-loader&#39;,
          &#39;less-loader&#39;
        ]
      &#125;
    ]
  &#125;
&#125;
</code></pre>
<h2 id="ts-支持"><a href="#ts-支持" class="headerlink" title="ts 支持"></a>ts 支持</h2><p>加上ts-loader</p>
<pre><code> &#123;
            test: /\.tsx?$/,
            loader: &#39;ts-loader&#39;,
            exclude: /node_modules/,
            options: &#123;
                appendTsSuffixTo: [/\.vue$/],
            &#125;
        &#125;,
</code></pre>
<h2 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h2><p>UglifyJsPlugin 配置位置发生了变化，放到<code>optimization</code>里，如果不想开启<code>minimize</code>，可以配置<code>minimize：false</code>,开启优化的话，可以配置minimizer：</p>
<pre><code>// webpack.optimize.UglifyJsPlugin
    optimization: &#123;
        // minimize: false,
        minimizer: [
            new UglifyJsPlugin(&#123;
                cache: true,
                parallel: true,
                uglifyOptions: &#123;
                    compress: false
                &#125;,
                sourceMap: false
            &#125;)
        ]
    &#125;
</code></pre>
<h2 id="CopyWebpackPlugin"><a href="#CopyWebpackPlugin" class="headerlink" title="CopyWebpackPlugin"></a>CopyWebpackPlugin</h2><p>配置发生了变化：</p>
<pre><code>        // copy custom static assets
        new CopyWebpackPlugin(&#123;
            patterns: [&#123;
                from: path.resolve(__dirname, &#39;../static&#39;),
                to: config.dev.assetsSubDirectory
            &#125;]
        &#125;)
</code></pre>
<h2 id="ExtractTextPlugin"><a href="#ExtractTextPlugin" class="headerlink" title="ExtractTextPlugin"></a>ExtractTextPlugin</h2><p>之前：</p>
<pre><code> new ExtractTextPlugin(&#123;
      filename: utils.assetsPath(&#39;css/[name].[contenthash].css&#39;),
      allChunks: true,
    &#125;),
</code></pre>
<p>contenthash已不能使用，换成hash即可</p>
<pre><code>    new ExtractTextPlugin(&#123;
      filename: utils.assetsPath(&#39;css/[name].[hash].css&#39;),
      allChunks: true,
    &#125;),
</code></pre>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>npm 更新package.json中依赖包版本</title>
    <url>/jadepeng/2020/05/28/jqpeng-npm%20%E6%9B%B4%E6%96%B0package.json%E4%B8%AD%E4%BE%9D%E8%B5%96%E5%8C%85%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/npm-package-update.html">npm 更新package.json中依赖包版本</a></p>
<p>NPM可以使用npm-check-updates库更新版本</p>
<p>1、安装：<br> cnpm install -g npm-check-updates</p>
<p>2、使用：</p>
<pre><code>  ncu --timeout=10000000 -u
</code></pre>
<p>指定–timeout参数防止超时</p>
<ol>
<li>更新全部到最新版本：<br> cnpm install</li>
</ol>
<p>为了防止版本冲突，可以先讲node_modules删掉</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 使用typescript， 优雅的调用swagger API</title>
    <url>/jadepeng/2020/05/22/jqpeng-Vue%20%E4%BD%BF%E7%94%A8typescript%EF%BC%8C%20%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%83%E7%94%A8swagger%20API/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/generator-swagger-2-ts-2.html">Vue 使用typescript， 优雅的调用swagger API</a></p>
<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务，后端集成下Swagger，然后就可以提供一个在线文档地址给前端同学。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/5/22/1590142373032.png" alt="swagger"></p>
<p>前端如何优雅的调用呢？</p>
<h2 id="入门版"><a href="#入门版" class="headerlink" title="入门版"></a>入门版</h2><p>根据文档，用axios自动来调用</p>
<pre><code>// 应用管理相关接口
import axios from &#39;../interceptors.js&#39;

// 获取应用列表
export const getList = (data) =&gt; &#123;
  return axios(&#123;
    url: &#39;/app/list?sort=createdDate,desc&#39;,
    method: &#39;get&#39;,
    params: data
  &#125;)
&#125;
</code></pre>
<p>这里的问题是，有多少个接口，你就要编写多少个函数，且数据结构需要查看文档获取。</p>
<h2 id="进阶版本"><a href="#进阶版本" class="headerlink" title="进阶版本"></a>进阶版本</h2><p>使用typescript，编写API，通过Type定义数据结构，进行约束。</p>
<p>问题： 还是需要手写</p>
<h2 id="优雅版本"><a href="#优雅版本" class="headerlink" title="优雅版本"></a>优雅版本</h2><p>swagger 其实是一个json-schema描述文档，我们可以基于此，自动生成。</p>
<p>很早之前，写过一个插件 <a href="https://www.npmjs.com/package/generator-swagger-2-ts">generator-swagger-2-t</a>, 简单的实现了将swagger生成typescript api。</p>
<p>今天，笔者对这个做了升级，方便支持后端返回的泛型数据结构。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>需要同时安装 <a href="http://yeoman.io/">Yeoman</a> 和 -swagger-2-ts</p>
<pre><code>npm install -g generator-swagger-2-ts
</code></pre>
<p>然后cd到你的工作目录，执行:</p>
<pre><code>yo swagger-2-ts
</code></pre>
<p>按提示</p>
<ul>
<li>输入swagger-ui 地址，例如<a href="http://192.168.86.8:8051/swagger-ui.html">http://192.168.86.8:8051/swagger-ui.html</a></li>
<li>可选生成js 或者 typescript</li>
<li>可以自定义生成的api class名称、api文件名</li>
<li>API 支持泛型</li>
</ul>
<p>也可以通过命令行直接传递参数</p>
<pre><code> yo swagger-2-ts --swaggerUrl=http://localhost:8080/swagger-ui.html --className=API --type=typescript --outputFile=api.ts
</code></pre>
<ul>
<li>swaggerUrl: swagger ui url swaggerui地址</li>
<li>className： API class name 类名</li>
<li>type： typescript or javascipt</li>
<li>outputFile: api 文件保存路径</li>
</ul>
<h3 id="生成代码demo："><a href="#生成代码demo：" class="headerlink" title="生成代码demo："></a>生成代码demo：</h3><pre><code>export type AccountUserInfo = &#123;
  disableTime?: string
  isDisable?: number
  lastLoginIp?: string
  lastLoginPlace?: string
  lastLoginTime?: string
  openId?: string
&#125;


export type BasePayloadResponse = &#123;
  data?: object
  desc?: string
  retcode?: string

&#125;

/**
 * User Account Controller
 * @class UserAccountAPI
 */
export class UserAccountAPI &#123;
/**
  * changeUserState
  * @method
  * @name UserAccountAPI#changeUserState
  
  * @param  accountUserInfo - accountUserInfo 
  
  * @param $domain API域名,没有指定则使用构造函数指定的
  */
  changeUserState(parameters: &#123;
    &#39;accountUserInfo&#39;: AccountUserInfo,
    $queryParameters?: any,
    $domain?: string
  &#125;): Promise&lt;AxiosResponse&lt;BasePayloadResponse&gt;&gt; &#123;

    let config: AxiosRequestConfig = &#123;
      baseURL: parameters.$domain || this.$defaultDomain,
      url: &#39;/userAccount/changeUserState&#39;,
      method: &#39;PUT&#39;
    &#125;

    config.headers = &#123;&#125;
    config.params = &#123;&#125;

    config.headers[ &#39;Accept&#39; ] = &#39;*/*&#39;
    config.headers[ &#39;Content-Type&#39; ] = &#39;application/json&#39;

    config.data = parameters.accountUserInfo
    return axios.request(config)
  &#125;

  _UserAccountAPI: UserAccountAPI = null;

  /**
  * 获取 User Account Controller API
  * return @class UserAccountAPI
  */
  getUserAccountAPI(): UserAccountAPI &#123;
    if (!this._UserAccountAPI) &#123;
      this._UserAccountAPI = new UserAccountAPI(this.$defaultDomain)
    &#125;
    return this._UserAccountAPI
  &#125;
&#125;


/**
 * 管理系统接口描述
 * @class API
 */
export class API &#123;
  /**
   *  API构造函数
   * @param domain API域名
   */
  constructor(domain?: string) &#123;
    this.$defaultDomain = domain || &#39;http://localhost:8080&#39;
  &#125;
&#125;
</code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>import &#123; API &#125; from &#39;./http/api/manageApi&#39;
// in main.ts
let api = new API(&quot;/api/&quot;)
api.getUserAccountAPI().changeUserState(&#123;
  isDisable: 1
  openId: &#39;open id&#39;
&#125;)
</code></pre>
<h2 id="Vue中最佳实践"><a href="#Vue中最佳实践" class="headerlink" title="Vue中最佳实践"></a>Vue中最佳实践</h2><h3 id="main-ts-全局定义"><a href="#main-ts-全局定义" class="headerlink" title="main.ts 全局定义"></a>main.ts 全局定义</h3><pre><code>import &#123; API &#125; from &#39;./http/api/manageApi&#39;

Vue.prototype.$manageApi = new API(&#39;/api/&#39;)
</code></pre>
<h3 id="增加-d-ts"><a href="#增加-d-ts" class="headerlink" title="增加.d.ts"></a>增加.d.ts</h3><p>增加types文件，方便使用智能提示</p>
<pre><code>import &#123; API &#125; from &#39;@/http/api/manageApi&#39;
import &#123; MarkAPI &#125; from &#39;@/http/api/mark-center-api&#39;
declare module &quot;vue/types/vue&quot; &#123;
  interface Vue &#123;
    $manageApi: API
    $markApi: MarkAPI
  &#125;
&#125;
</code></pre>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>现在可以在vue里直接调用了。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/5/22/1590143121653.png" alt="vscode调用"></p>
<pre><code>this.$manageApi
      .getUserAccountAPI().changeUserState(&#123;isDisable: 1， openId: &#39;open id&#39;&#125;)
</code></pre>
<h2 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h2><p><a href="https://github.com/jadepeng/generator-swagger-2-ts">https://github.com/jadepeng/generator-swagger-2-ts</a></p>
<p>欢迎star！</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Mongodb 乐观锁</title>
    <url>/jadepeng/2020/04/16/jqpeng-Spring%20Data%20Mongodb%20%E4%B9%90%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/spring-data-optimistic-lock.html">Spring Data Mongodb 乐观锁</a></p>
<p>Spring Data 针对mongodb提供了乐观锁实现：</p>
<pre><code>The @Version annotation provides syntax similar to that of JPA in the context of MongoDB and makes sure updates are only applied to documents with a matching version. Therefore, the actual value of the version property is added to the update query in such a way that the update does not have any effect if another operation altered the document in the meantime. In that case, an OptimisticLockingFailureException is thrown. The following example shows these features:
</code></pre>
<p>提供@Version注解，用来标识版本，保存、删除等操作会验证version，不一致会抛出<code>OptimisticLockingFailureException</code></p>
<p>来看一个例子：</p>
<pre><code>@Document
class Person &#123;

  @Id String id;
  String firstname;
  String lastname;
  @Version Long version;
&#125;

Person daenerys = template.insert(new Person(&quot;Daenerys&quot;));                            (1)

Person tmp = template.findOne(query(where(&quot;id&quot;).is(daenerys.getId())), Person.class); (2)

daenerys.setLastname(&quot;Targaryen&quot;);
template.save(daenerys);                                                              (3)

template.save(tmp); // throws OptimisticLockingFailureException                       (4)
</code></pre>
<ol>
<li>最初插入一个<code>person</code> <code>daenerys</code>，<code>version</code>为<code>0</code>。</li>
<li>加载刚插入的数据，<code>tmp</code>。<code>version</code>还是<code>0</code>。</li>
<li>更新<code>version = 0</code>的<code>daenerys</code>，更新<code>lastname</code>，save后<code>version</code>变为<code>1</code>。</li>
<li>现在来更新，会抛出<code>OptimisticLockingFailureException</code>， 提示操作失败。</li>
</ol>
<p>注意：</p>
<table>
<thead>
<tr>
<th>Important</th>
<th>Optimistic Locking requires to set the <code>WriteConcern</code> to <code>ACKNOWLEDGED</code>. Otherwise <code>OptimisticLockingFailureException</code> can be silently swallowed.</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>Note</th>
<th>As of Version 2.2 <code>MongoOperations</code> also includes the <code>@Version</code> property when removing an entity from the database. To remove a <code>Document</code> without version check use <code>MongoOperations#remove(Query,…​)</code> instead of <code>MongoOperations#remove(Object)</code>.</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>Note</th>
<th>As of Version 2.2 repositories check for the outcome of acknowledged deletes when removing versioned entities. An <code>OptimisticLockingFailureException</code> is raised if a versioned entity cannot be deleted through <code>CrudRepository.delete(Object)</code>. In such case, the version was changed or the object was deleted in the meantime. Use <code>CrudRepository.deleteById(ID)</code> to bypass optimistic locking functionality and delete objects regardless of their version.</th>
</tr>
</thead>
</table>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>Spring Boot</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>java应用诊断和在线debug利器bistoury介绍与在K8S环境使用</title>
    <url>/jadepeng/2020/04/09/jqpeng-java%E5%BA%94%E7%94%A8%E8%AF%8A%E6%96%AD%E5%92%8C%E5%9C%A8%E7%BA%BFdebug%E5%88%A9%E5%99%A8bistoury%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9C%A8K8S%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/Bistoury.html">java应用诊断和在线debug利器bistoury介绍与在K8S环境使用</a></p>
<hr>
<h2 id="Bistoury介绍"><a href="#Bistoury介绍" class="headerlink" title="Bistoury介绍"></a>Bistoury介绍</h2><p><code>Bistoury</code> 是去哪儿网开源的一个对应用透明，无侵入的java应用诊断工具，用于提升开发人员的诊断效率和能力，可以让开发人员无需登录机器或修改系统，就可以从日志、内存、线程、类信息、调试、机器和系统属性等各个方面对应用进行诊断，提升开发人员诊断问题的效率和能力。</p>
<p><code>Bistoury</code> 集成了Alibaba开源的<a href="https://github.com/alibaba/arthas">arthas</a>和唯品会开源的<a href="https://github.com/vipshop/vjtools">vjtools</a>，因此arthas和vjtools相关功能都可以在<code>Bistoury</code>中使用。<br> Arthas和vjtools通过命令行或类似的方式使用，Bistoury在保留命令行界面的基础上，还对很多命令提供了图形化界面，方面用户使用。</p>
<p><code>Bistoury</code> 英文解释是外科手术刀，含义也就不言而喻了。</p>
<h2 id="Screenshots"><a href="#Screenshots" class="headerlink" title="Screenshots"></a>Screenshots</h2><p>通过命令行界面查看日志，使用arthas和vjtools的各项功能<br><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/console.png" alt="console"></p>
<p>在线debug，在线应用调试神器<br><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/debug_panel.png" alt="debug"></p>
<p>线程级cpu监控，帮助你掌握线程级cpu使用率<br><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/jstack.png" alt="jstack_dump"></p>
<p>在web界面查看JVM运行信息，以及各种其它信息<br><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/jvm.png" alt="jvm"></p>
<p>动态给方法添加监控<br><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/monitor.png" alt="monitor"></p>
<p>线程dump<br><img src="https://gitee.com/jadepeng/bistoury/raw/master/docs/image/thread_dump.png" alt="thread_dump"></p>
<h2 id="Bistoury架构分析"><a href="#Bistoury架构分析" class="headerlink" title="Bistoury架构分析"></a>Bistoury架构分析</h2><p>Bistoury核心组件包含agent，proxy，ui：</p>
<ul>
<li>agent ： 与需要诊断的应用部署到一起，负责具体的诊断命令执行，通过域名连接proxy</li>
<li>proxy：agent的代理，agent启动时会通过ws和proxy连接注册，proxy可以部署多个，推荐使用域名负载</li>
<li>ui：ui提供图形化和命令行界面，接收从用户传来的命令，传递命令给proxy，接收从proxy传来的结果并展示给用户。</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586431812716.png"></p>
<p>一次命令执行的数据流向为 ui -&gt; proxy -&gt; agent -&gt; proxy -&gt; ui</p>
<p>具体分析一下：</p>
<ul>
<li>proxy 先启动，将自己地址注册到zk</li>
<li>agent通过域名访问proxy，随机分配到一个proxy，在proxy注册自己</li>
<li>UI 访问一个具体的应用时，通过zk拿到所有的proxy，然后依次检查app对应的agent是否在该proxy，如果在，web网页连接这个proxy</li>
<li>web上输入一个命令:web-&gt;proxy-&gt;agent-&gt;proxy-&gt;ui</li>
</ul>
<p>具体参见 <a href="https://github.com/qunarcorp/bistoury/blob/master/docs/cn/design/design.md">https://github.com/qunarcorp/bistoury/blob/master/docs/cn/design/design.md</a></p>
<p>bistoury原理分析： <a href="https://www.jianshu.com/p/f7202e490156">https://www.jianshu.com/p/f7202e490156</a></p>
<p>总结下就是使用类似skywalking那样的agent技术，来监测和协助运行在JVM上的程序。</p>
<h2 id="Bistoury快速开始"><a href="#Bistoury快速开始" class="headerlink" title="Bistoury快速开始"></a>Bistoury快速开始</h2><p>官方有一个快速开始文档： <a href="https://github.com/qunarcorp/bistoury/blob/master/docs/cn/quick_start.md">https://github.com/qunarcorp/bistoury/blob/master/docs/cn/quick_start.md</a></p>
<p>可以下载release包快速启动，就可以体验了。</p>
<p>首先我们将快速启动包 bistoury-quick-start.tar.gz 拷贝到想要安装的位置。</p>
<p>然后解压启动包：</p>
<pre><code>tar -zxvf bistoury-quick-start.tar.gz
cd bistoury
</code></pre>
<p>最后是启动 Bistoury，因为 Bistoury 会用到 jstack 等操作，为了保证所有功能可用，需要使用和待诊断 JAVA 应用相同的用户启动。</p>
<p>假设应用进程 id 为 1024</p>
<ul>
<li>如果应用以本人用户启动，可以直接运行</li>
</ul>
<pre><code>./quick_start.sh -p 1024 start
</code></pre>
<ul>
<li>如果应用以其它帐号启动，比如 tomcat，需要指定一下用户然后运行</li>
</ul>
<pre><code>sudo -u tomcat ./quick_start.sh -p 1024 start
</code></pre>
<ul>
<li>停止运行</li>
</ul>
<pre><code>./quick_start.sh stop
</code></pre>
<h2 id="Bistoury-在docker运行"><a href="#Bistoury-在docker运行" class="headerlink" title="Bistoury 在docker运行"></a>Bistoury 在docker运行</h2><p>官方的git仓库里，有一个docker分支，翻阅后找到相关文档。</p>
<p>官方的快速启动命令：</p>
<pre><code>#!/bin/bash
#创建网络
echo &quot;start create network&quot;
docker network create --subnet=172.19.0.0/16 bistoury
#mysql 镜像
echo &quot;start run mysql image&quot;
docker run --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root -d -i --net bistoury --ip 172.19.0.7  registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-db
#zk 镜像
echo &quot;start run zk image&quot;
docker run -d -p 2181:2181 -it --net bistoury --ip 172.19.0.2 registry.cn-hangzhou.aliyuncs.com/bistoury/zk:latest
sleep 30
#proxy 镜像
echo &quot;start run proxy module&quot;
docker run -d -p 9880:9880 -p 9881:9881 -p 9090:9090 -i --net bistoury --ip 172.19.0.3 registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-proxy --real-ip $1 --zk-address 172.19.0.2:2181 --proxy-jdbc-url jdbc:mysql://172.19.0.7:3306/bistoury
#ui 镜像
echo &quot;start run ui module&quot;
docker run -p 9091:9091  -it -d --net bistoury --ip 172.19.0.4 registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-ui --zk-address 172.19.0.2:2181 --ui-jdbc-url jdbc:mysql://172.19.0.7:3306/bistoury
#boot 镜像
echo &quot;start run demo application&quot;
docker  run -it -d  -p 8686:8686 -i --net bistoury --ip 172.19.0.5 registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-demo --proxy-host $1:9090
docker  run -it -d  -p 8687:8686 -i --net bistoury --ip 172.19.0.6 registry.cn-hangzhou.aliyuncs.com/bistoury/bistoury-demo --proxy-host $1:9090
</code></pre>
<p>上面的命令不能直接运行，<code>$1</code>是需要替换成当前服务器IP，然后再运行就OK了。</p>
<h2 id="Bistoury-在生产环境运行"><a href="#Bistoury-在生产环境运行" class="headerlink" title="Bistoury 在生产环境运行"></a>Bistoury 在生产环境运行</h2><p>官方推荐部署方式：</p>
<ul>
<li>ui 独立部署，推荐部署在多台机器，并提供独立的域名</li>
<li>proxy 独立部署，推荐部署在多台机器，并提供独立的域名</li>
<li>agent 需要和应用部署在同一台机器上。推荐在测试环境全环境自动部署，线上环境提供单机一键部署，以及应用下所有机器一键部署</li>
<li>独立的应用中心，管理所有功能内部应用和机器信息，这是一个和 Bistoury 相独立的系统，Bistoury 从中拿到不断更新的应用和机器信息</li>
</ul>
<p>这里有个关键的点，应用中心，Bistoury内置了一个简单的应用中心，Bistoury里代码对应bistoury-application，ui和proxy都通过这个工程获取应用信息，官方默认实现了一个mysql版本的：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586433126733.png" alt="application"></p>
<p>使用mysql的缺点是，你需要ui界面里手动维护应用以及应用的服务器，做个demo还OK，生产环境肯定不行。更优雅的方式是，用户系统应该在启动时自动注册到注册中心上，汇报自己的应用、机器信息（ip、域名等）、端口等信息。当然这个对大部分微服务架构来说，注册中心是标配的，因此实现一套bistoury-application-api接口即可。</p>
<h2 id="bistoury-application-k8s-Bistoury-on-K8S"><a href="#bistoury-application-k8s-Bistoury-on-K8S" class="headerlink" title="bistoury-application-k8s(Bistoury on K8S)"></a>bistoury-application-k8s(Bistoury on K8S)</h2><p>我们项目组所有的应用都部署在K8S环境，因此要实现一个<code>bistoury-application-k8s</code>。</p>
<p>拷贝<code>bistoury-application-mysql</code>项目，建立<code>bistoury-application-k8s</code></p>
<p>简单对应下：</p>
<ul>
<li>一个应用对应一个deployment，对应一个application</li>
<li>一个deployment里有n个pod，对应applicationServer</li>
</ul>
<p>所以，我们只需要调用调用K8S API 获取deployment和pod即可。</p>
<p>首先引入相关jar包：</p>
<pre><code>   &lt;dependency&gt;
            &lt;groupId&gt;io.kubernetes&lt;/groupId&gt;
            &lt;artifactId&gt;client-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.0&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<p>初始化ApiClient</p>
<pre><code>            ApiClient defaultClient = Configuration.getDefaultApiClient();
            defaultClient.setBasePath(k8sApiServer);
            ApiKeyAuth BearerToken = (ApiKeyAuth) defaultClient.getAuthentication(&quot;BearerToken&quot;);
            BearerToken.setApiKey(k8sToken);
            BearerToken.setApiKeyPrefix(&quot;Bearer&quot;);
            defaultClient.setVerifyingSsl(false);
</code></pre>
<h3 id="获取deployment"><a href="#获取deployment" class="headerlink" title="获取deployment"></a>获取deployment</h3><p>区分下是获取所有namespace，还是获取指定的namespace</p>
<pre><code>   private List&lt;V1Deployment&gt; getDeployments() throws ApiException &#123;
        AppsV1Api appsV1Api = new AppsV1Api(k8SConfiguration.getApiClient());
        return k8SConfiguration.isAllNamespace()
                ? appsV1Api.listDeploymentForAllNamespaces(false, null, null, null, 0, null, null, 120, false).getItems()
                : getNamespacesDeployments(k8SConfiguration.getAllowedNamespace());
    &#125;

    List&lt;V1Deployment&gt; getNamespacesDeployments(List&lt;String&gt; namespaces) &#123;
        AppsV1Api appsV1Api = new AppsV1Api(k8SConfiguration.getApiClient());
        List&lt;V1Deployment&gt; deploymentList = new ArrayList&lt;&gt;();
        for (String nameSpace : namespaces) &#123;
            try &#123;
                deploymentList.addAll(appsV1Api.listNamespacedDeployment(nameSpace, null, null, null, null, null, 0, null, 120, false).getItems());
            &#125; catch (ApiException e) &#123;
                logger.error(&quot;get &quot; + nameSpace + &quot;&#39;s deployment error&quot;, e);
            &#125;
        &#125;
        return deploymentList;
    &#125;
</code></pre>
<p>转换为application：</p>
<pre><code>    private List&lt;Application&gt; getApplications(List&lt;V1Deployment&gt; applist) &#123;
        return applist.stream().map(this::getApplication).collect(Collectors.toList());
    &#125;

    private Application getApplication(V1Deployment deployment) &#123;
        Application application = new Application();
        application.setCreateTime(deployment.getMetadata().getCreationTimestamp().toDate());
        application.setCreator(deployment.getMetadata().getName());
        application.setGroupCode(deployment.getMetadata().getNamespace());
        application.setName(deployment.getMetadata().getName());
        application.setStatus(1);
        application.setCode(getAppCode(deployment.getMetadata().getNamespace(), deployment.getMetadata().getName()));
        return application;
    &#125;
</code></pre>
<h3 id="获取pod"><a href="#获取pod" class="headerlink" title="获取pod"></a>获取pod</h3><p>获取pod相对麻烦点，需要先获取到V1Deployment，拿到部署的lableSelector，然后根据lableSelector选择pod：</p>
<pre><code> public List&lt;AppServer&gt; getAppServerByAppCode(final String appCode) &#123;
        Preconditions.checkArgument(!Strings.isNullOrEmpty(appCode), &quot;app code cannot be null or empty&quot;);

        try &#123;
            V1Deployment deployment = getDeployMent(appCode);
            String nameSpace = appCode.split(APPCODE_SPLITTER)[0];
            Map&lt;String, String&gt; labelMap = Objects.requireNonNull(deployment.getSpec()).getSelector().getMatchLabels();
            StringBuilder lableSelector = new StringBuilder();
            labelMap.entrySet().stream().forEach(e -&gt; &#123;
                if (lableSelector.length() &gt; 0) &#123;
                    lableSelector.append(&quot;,&quot;);
                &#125;
                lableSelector.append(e.getKey()).append(&quot;=&quot;).append(e.getValue());
            &#125;);

            CoreV1Api coreV1Api = new CoreV1Api(k8SConfiguration.getApiClient());
            V1PodList podList = coreV1Api.listNamespacedPod(nameSpace, null, false, null,
                    null, lableSelector.toString(), 200, null, 600, false);

            return podList.getItems().stream().map(pod -&gt; &#123;
                AppServer server = new AppServer();
                server.setAppCode(appCode);
                server.setHost(pod.getMetadata().getName());
                server.setIp(pod.getStatus().getPodIP());
                server.setLogDir(k8SConfiguration.getAppLogPath());
                server.setAutoJMapHistoEnable(true);
                server.setAutoJStackEnable(true);
                server.setPort(8080);
                return server;
            &#125;).collect(Collectors.toList());

        &#125; catch (ApiException e) &#123;
            logger.error(&quot;get deployment&#39;s pod  error&quot;, e);
        &#125;

        return null;

    &#125;
</code></pre>
<p>最后，修改ui和proxy工程，将原来的mysql替换为k8s：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586434230879.png" alt="修改pom"></p>
<h2 id="应用引入bistoury-agent"><a href="#应用引入bistoury-agent" class="headerlink" title="应用引入bistoury agent"></a>应用引入bistoury agent</h2><p>这块相对比较容易：</p>
<p>在需要调试的应用的Dockerfile里增加：</p>
<pre><code>COPY  --from=hub.xfyun.cn/abkdev/bistoury-agent:2.0.11  /home/q/bistoury  /opt/bistoury
</code></pre>
<p>然后修改应用的启动脚本，在最前面增加：</p>
<pre><code>BISTOURY_APP_LIB_CLASS=&quot;org.springframework.web.servlet.DispatcherServlet&quot;

# default proxy
PROXY=&quot;bistoury-bistoury-proxy.incubation:9090&quot;
AGENT_JAVA_HOME=&quot;/usr/local/openjdk-8/&quot;

# env
if [[ -n $PROXY_HOST ]]; then
    PROXY=$PROXY_HOST
fi

TEMP=`getopt -o : --long proxy-host:,app-class:,agent-java-home: -- &quot;$@&quot;`

eval set -- &quot;$TEMP&quot;

while true; do
  case &quot;$1&quot; in
    --proxy-host )
      PROXY=&quot;$2&quot;; shift 2 ;;
    --app-class )
      BISTOURY_APP_LIB_CLASS=&quot;$2&quot;; shift 2 ;;
    --agent-java-home )
      AGENT_JAVA_HOME=&quot;$2&quot;; shift 2 ;;
    * ) break ;;
  esac
done


echo &quot;proxy host: &quot;$PROXY_HOST
echo &quot;app class: &quot;$BISTOURY_APP_LIB_CLASS
echo &quot;agent java home: &quot;$AGENT_JAVA_HOME
</code></pre>
<p>在最后面增加：</p>
<pre><code>APP_PID=`$AGENT_JAVA_HOME/bin/jps -l|awk &#39;&#123;if($2!=&quot;sun.tools.jps.Jps&quot;)&#123;print $1 ;&#123;exit&#125;&#125; &#125;&#39;`

echo &quot;app pid: &quot;$APP_PID

/opt/bistoury/agent/bin/bistoury-agent.sh -j $AGENT_JAVA_HOME -p $APP_PID -c $BISTOURY_APP_LIB_CLASS -s $PROXY -f start
</code></pre>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>部署一个测试应用 agent-debug-demo，部署到jx namespace：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586434610449.png" alt=" agent-debug-demo"></p>
<pre><code>&#123;
  &quot;kind&quot;: &quot;Deployment&quot;,
  &quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;,
  &quot;metadata&quot;: &#123;
    &quot;name&quot;: &quot;agent-debug-demo&quot;,
    &quot;namespace&quot;: &quot;jx&quot;,
    &quot;annotations&quot;: &#123;
      &quot;deployment.kubernetes.io/revision&quot;: &quot;2&quot;
    &#125;
  &#125;,
  &quot;spec&quot;: &#123;
    &quot;replicas&quot;: 1,
    &quot;selector&quot;: &#123;
      &quot;matchLabels&quot;: &#123;
        &quot;app&quot;: &quot;agent-debug-demo&quot;,
        &quot;draft&quot;: &quot;draft-app&quot;
      &#125;
    &#125;,
    &quot;template&quot;: &#123;
      &quot;metadata&quot;: &#123;
        &quot;creationTimestamp&quot;: null,
        &quot;labels&quot;: &#123;
          &quot;app&quot;: &quot;agent-debug-demo&quot;,
          &quot;draft&quot;: &quot;draft-app&quot;
        &#125;
      &#125;,
      &quot;spec&quot;: &#123;
        &quot;containers&quot;: [
          &#123;
            &quot;name&quot;: &quot;springboot-rest-demo&quot;,
            &quot;image&quot;: &quot;hub.xxx.cn/abkdev/springboot-rest-demo:dev-113&quot;,
            &quot;ports&quot;: [
              &#123;
                &quot;containerPort&quot;: 8080,
                &quot;protocol&quot;: &quot;TCP&quot;
              &#125;
            ],
            &quot;env&quot;: [
              &#123;
                &quot;name&quot;: &quot;SPRING_PROFILES_ACTIVE&quot;,
                &quot;value&quot;: &quot;dev&quot;
              &#125;,
              &#123;
                &quot;name&quot;: &quot;PROXY_HOST&quot;,
                &quot;value&quot;: &quot;$PROXY_HOST:9090&quot;
              &#125;
            ],
            &quot;resources&quot;: &#123;&#125;,
            &quot;terminationMessagePath&quot;: &quot;/dev/termination-log&quot;,
            &quot;terminationMessagePolicy&quot;: &quot;File&quot;,
            &quot;imagePullPolicy&quot;: &quot;IfNotPresent&quot;
          &#125;
        ],
        &quot;restartPolicy&quot;: &quot;Always&quot;,
        &quot;terminationGracePeriodSeconds&quot;: 10,
        &quot;dnsPolicy&quot;: &quot;ClusterFirst&quot;,
        &quot;securityContext&quot;: &#123;&#125;,
        &quot;schedulerName&quot;: &quot;default-scheduler&quot;
      &#125;
    &#125;,
    &quot;strategy&quot;: &#123;
      &quot;type&quot;: &quot;RollingUpdate&quot;,
      &quot;rollingUpdate&quot;: &#123;
        &quot;maxUnavailable&quot;: 1,
        &quot;maxSurge&quot;: 1
      &#125;
    &#125;,
    &quot;revisionHistoryLimit&quot;: 2147483647,
    &quot;progressDeadlineSeconds&quot;: 2147483647
  &#125;,
  &quot;status&quot;: &#123;
    &quot;observedGeneration&quot;: 2,
    &quot;replicas&quot;: 1,
    &quot;updatedReplicas&quot;: 1,
    &quot;unavailableReplicas&quot;: 1,
    &quot;conditions&quot;: [
      &#123;
        &quot;type&quot;: &quot;Available&quot;,
        &quot;status&quot;: &quot;True&quot;,
        &quot;lastUpdateTime&quot;: &quot;2020-04-09T01:32:42Z&quot;,
        &quot;lastTransitionTime&quot;: &quot;2020-04-09T01:32:42Z&quot;,
        &quot;reason&quot;: &quot;MinimumReplicasAvailable&quot;,
        &quot;message&quot;: &quot;Deployment has minimum availability.&quot;
      &#125;
    ]
  &#125;
&#125;
</code></pre>
<p>部署后：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586434889358.png" alt="K8S Dashboard"></p>
<p>打开ui，查看：</p>
<p>应用名称显示为： namespace名称-部署名称</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586434848921.png" alt="bistoury"></p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586434991429.png" alt="ThreadDump"></p>
<p>在线调试：</p>
<p>先选择应用：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586435034455.png" alt="选择应用"></p>
<p>点击Debug，然后选择需要调试的类，</p>
<p>测试工程源代码为：</p>
<pre><code>@SpringBootApplication
@Controller
public class RestPrometheusApplication &#123;
@Autowiredprivate MeterRegistry registry;
@Autowiredprivate Environment env;
@GetMapping(path = &quot;/&quot;, produces = &quot;application/json&quot;)@ResponseBodypublic Map&lt;String, Object&gt; landingPage() &#123;    Counter.builder(&quot;mymetric&quot;).tag(&quot;foo&quot;, &quot;bar&quot;).register(registry).increment();    String profile = &quot;default&quot;;    if(env.getActiveProfiles().length &gt; 0)&#123;        profile = env.getActiveProfiles()[0];    &#125;
    return singletonMap(&quot;hello&quot;, &quot;&quot;+ profile);&#125;
public static void main(String[] args) &#123;    SpringApplication.run(RestPrometheusApplication.class, args);&#125;

&#125;
</code></pre>
<p>因此，我们输入RestPrometheusApplication筛选：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586435105776.png" alt="选择Class"></p>
<p>然后点击调试，可以看到，反编译出来了源代码：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586435149849.png" alt="在线debug1"></p>
<p>在landingPage最后一行加一个端点，然后点击添加端点，最后访问该POD对应的服务,该pod对应的ip是170.22.149.37，因此我们访问：</p>
<pre><code>curl http://170.22.149.37:8080
&#123;&quot;hello&quot;:&quot;dev&quot;&#125;
</code></pre>
<p>再回到UI，可以看到成员变量，局部变量和调用堆栈等信息。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/4/9/1586435287216.png" alt="在线debug2"></p>
<p>well down！</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>Bistoury</tag>
      </tags>
  </entry>
  <entry>
    <title>获取free-ss账号并导入SSR</title>
    <url>/jadepeng/2020/03/10/jqpeng-%E8%8E%B7%E5%8F%96free-ss%E8%B4%A6%E5%8F%B7%E5%B9%B6%E5%AF%BC%E5%85%A5SSR/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/free-ss.html">获取free-ss账号并导入SSR</a></p>
<h2 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h2><ul>
<li>如果不知道SSR，请略过</li>
<li>下载SSR</li>
<li>电脑配置host： 104.18.36.36 free-ss.site</li>
</ul>
<h2 id="获取账号"><a href="#获取账号" class="headerlink" title="获取账号"></a>获取账号</h2><ul>
<li>打开free-ss.site，等待账号出现</li>
<li>F12打开开发者工具，console写入脚本,会自动解析账号，然后提示保存文件</li>
</ul>
<pre><code>function download(filename, text) &#123;
  var element = document.createElement(&#39;a&#39;);
  element.setAttribute(&#39;href&#39;, &#39;data:text/plain;charset=utf-8,&#39; + encodeURIComponent(text));
  element.setAttribute(&#39;download&#39;, filename);
 
  element.style.display = &#39;none&#39;;
  document.body.appendChild(element);
 
  element.click();
 
  document.body.removeChild(element);
&#125;

var trList = $(&quot;#tbss tr&quot;)
ssList = []
for (let i = 1; i &lt; trList.length; i++) &#123;
      const tdList = trList.eq(i).find(&#39;td&#39;);
      ssList.push(&#123;
        server: tdList.eq(1).text(),
        server_port: tdList.eq(2).text(),
        password: tdList.eq(4).text(),
        method: tdList.eq(3).text() || &#39;aes-256-cfb&#39;,
        group:&quot;crawl&quot;,
        enable: true,
        remarks: tdList.eq(6).text() + &#39; &#39; + (Math.ceil(Math.random() * 10000)),
        timeout: 5
      &#125;);
    &#125;
download(&quot;ssr-list.txt&quot;,JSON.stringify(&#123;&quot;configs&quot; : ssList&#125;))
</code></pre>
<h2 id="导入SSR"><a href="#导入SSR" class="headerlink" title="导入SSR"></a>导入SSR</h2><ul>
<li>打开SSR软件，服务器-从文件导入服务器，选择刚生成那个文件</li>
<li>服务器选择crawl分组的服务器</li>
<li>启用服务器负载均衡</li>
</ul>
<p>搞定！</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>容器环境的JVM内存设置最佳实践</title>
    <url>/jadepeng/2020/01/18/jqpeng-%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E7%9A%84JVM%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/container-jvm.html">容器环境的JVM内存设置最佳实践</a></p>
<p>Docker和K8S的兴起，很多服务已经运行在容器环境，对于java程序，JVM设置是一个重要的环节。这里总结下我们项目里的最佳实践。</p>
<h2 id="Java-Heap基础知识"><a href="#Java-Heap基础知识" class="headerlink" title="Java Heap基础知识"></a>Java Heap基础知识</h2><p>默认情况下，jvm自动分配的heap大小取决于机器配置，比如我们到一台64G内存服务器：</p>
<pre><code>java -XX:+PrintFlagsFinal -version | grep -Ei &quot;maxheapsize|maxram&quot;
    uintx DefaultMaxRAMFraction                     = 4                                   &#123;product&#125;
    uintx MaxHeapSize                              := 16875782144                         &#123;product&#125;
 uint64_t MaxRAM                                    = 137438953472                        &#123;pd product&#125;
    uintx MaxRAMFraction                            = 4                                   &#123;product&#125;
   double MaxRAMPercentage                          = 25.000000                           &#123;product&#125;
java version &quot;1.8.0_192&quot;
Java(TM) SE Runtime Environment (build 1.8.0_192-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.192-b12, mixed mode)
</code></pre>
<p>可以看到，JVM 分配的最大MaxHeapSize为 16G，计算公式如下：</p>
<pre><code>MaxHeapSize = MaxRAM * 1 / MaxRAMFraction
</code></pre>
<p>MaxRAMFraction 默认是4，意味着，每个jvm最多使用25%的机器内存。</p>
<p>但是需要注意的是，JVM实际使用的内存会比heap内存大：</p>
<pre><code>JVM内存  = heap 内存 + 线程stack内存 (XSS) * 线程数 + 启动开销（constant overhead）
</code></pre>
<p>默认的XSS通常在256KB到1MB，也就是说每个线程会分配最少256K额外的内存，constant overhead是JVM分配的其他内存。</p>
<p>我们可以通过<code>-Xmx</code> 指定最大堆大小。</p>
<pre><code>java -XX:+PrintFlagsFinal -Xmx1g -version | grep -Ei &quot;maxheapsize|maxram&quot;
    uintx DefaultMaxRAMFraction                     = 4                                   &#123;product&#125;
    uintx MaxHeapSize                              := 1073741824                          &#123;product&#125;
 uint64_t MaxRAM                                    = 137438953472                        &#123;pd product&#125;
    uintx MaxRAMFraction                            = 4                                   &#123;product&#125;
   double MaxRAMPercentage                          = 25.000000                           &#123;product&#125;
java version &quot;1.8.0_192&quot;
Java(TM) SE Runtime Environment (build 1.8.0_192-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.192-b12, mixed mode)
</code></pre>
<p>此外，还可以使用<code>XX:MaxRAM</code>来指定。</p>
<pre><code>java -XX:+PrintFlagsFinal -XX:MaxRAM=1g -version | grep -Ei 
</code></pre>
<p>但是指定-Xmx或者MaxRAM需要了解机器的内存，更好的方式是设置<code>MaxRAMFraction</code>，以下是不同的Fraction对应的可用内存比例：</p>
<pre><code>+----------------+-------------------+
| MaxRAMFraction | % of RAM for heap |
|----------------+-------------------|
|              1 |              100% |
|              2 |               50% |
|              3 |               33% |
|              4 |               25% |
+----------------+-------------------+
</code></pre>
<h2 id="容器环境的Java-Heap"><a href="#容器环境的Java-Heap" class="headerlink" title="容器环境的Java Heap"></a>容器环境的Java Heap</h2><p>容器环境，由于java获取不到容器的内存限制，只能获取到服务器的配置：</p>
<pre><code>$ docker run --rm alpine free -m
             total     used     free   shared  buffers   cached
Mem:          1998     1565      432        0        8     1244
$ docker run --rm -m 256m alpine free -m
             total     used     free   shared  buffers   cached
Mem:          1998     1552      445        1        8     1244
</code></pre>
<p>这样容易引起不必要问题，例如限制容器使用100M内存，但是jvm根据服务器配置来分配初始化内存，导致java进程超过容器限制被kill掉。为了解决这个问题，可以设置-Xmx或者MaxRAM来解决，但就想第一部分描述的一样，这样太不优雅了！</p>
<p>为了解决这个问题，Java 10 引入了 +<code>UseContainerSupport</code>（默认情况下启用），通过这个特性，可以使得JVM在容器环境分配合理的堆内存。 并且，在JDK8U191版本之后，这个功能引入到了JDK 8，而JDK 8是广为使用的JDK版本。</p>
<h3 id="UseContainerSupport"><a href="#UseContainerSupport" class="headerlink" title="UseContainerSupport"></a>UseContainerSupport</h3><p>-XX:+UseContainerSupport允许JVM 从主机读取cgroup限制，例如可用的CPU和RAM，并进行相应的配置。这样当容器超过内存限制时，会抛出OOM异常，而不是杀死容器。<br> 该特性在Java 8u191 +，10及更高版本上可用。</p>
<p>注意，在191版本后，-XX:{Min|Max}RAMFraction 被弃用，引入了<code>-XX:MaxRAMPercentage</code>，其值介于0.0到100.0之间，默认值为25.0。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>拉取最新的openjdk:8-jre-alpine作为底包，截止这篇博客，最新的版本是212，&gt;191</p>
<pre><code>docker run -it --rm openjdk:8-jre-alpine java -version
openjdk version &quot;1.8.0_212&quot;
OpenJDK Runtime Environment (IcedTea 3.12.0) (Alpine 8.212.04-r0)
OpenJDK 64-Bit Server VM (build 25.212-b04, mixed mode)
</code></pre>
<p>我们构建一个基础镜像，dockerfile如下：</p>
<pre><code>FROM openjdk:8-jre-alpine
MAINTAINER jadepeng

RUN echo &quot;http://mirrors.aliyun.com/alpine/v3.6/main&quot; &gt; /etc/apk/repositories \
    &amp;&amp; echo &quot;http://mirrors.aliyun.com/alpine/v3.6/community&quot; &gt;&gt; /etc/apk/repositories \
    &amp;&amp; apk update upgrade \
    &amp;&amp; apk add --no-cache procps unzip curl bash tzdata \
    &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \
    &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone

RUN apk add --update ttf-dejavu &amp;&amp; rm -rf /var/cache/apk/*
</code></pre>
<p>在应用的启动参数，设置 -XX:+UseContainerSupport，设置-XX:MaxRAMPercentage=75.0，这样为其他进程（debug、监控）留下足够的内存空间，又不会太浪费RAM。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S基于ingress-nginx实现灰度发布</title>
    <url>/jadepeng/2020/01/17/jqpeng-K8S%E5%9F%BA%E4%BA%8Eingress-nginx%E5%AE%9E%E7%8E%B0%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/ingress-nginx-canary.html">K8S基于ingress-nginx实现灰度发布</a></p>
<p>之前介绍过<a href="https://www.cnblogs.com/xiaoqi/p/ambassador.html">使用ambassador实现灰度发布</a>，今天介绍如何使用ingre-nginx实现。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Ingress-Nginx  是一个K8S ingress工具，支持配置 Ingress Annotations 来实现不同场景下的灰度发布和测试。 <a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#canary">Nginx Annotations</a> 支持以下 4 种 Canary 规则：</p>
<ul>
<li><code>nginx.ingress.kubernetes.io/canary-by-header</code>：基于 Request Header 的流量切分，适用于灰度发布以及 A/B 测试。当 Request Header 设置为 <code>always</code>时，请求将会被一直发送到 Canary 版本；当 Request Header 设置为 <code>never</code>时，请求不会被发送到 Canary 入口；对于任何其他 Header 值，将忽略 Header，并通过优先级将请求与其他金丝雀规则进行优先级的比较。</li>
<li><code>nginx.ingress.kubernetes.io/canary-by-header-value</code>：要匹配的 Request Header 的值，用于通知 Ingress 将请求路由到 Canary Ingress 中指定的服务。当 Request Header 设置为此值时，它将被路由到 Canary 入口。该规则允许用户自定义 Request Header 的值，必须与上一个 annotation (即：canary-by-header）一起使用。</li>
<li><code>nginx.ingress.kubernetes.io/canary-weight</code>：基于服务权重的流量切分，适用于蓝绿部署，权重范围 0 - 100 按百分比将请求路由到 Canary Ingress 中指定的服务。权重为 0 意味着该金丝雀规则不会向 Canary 入口的服务发送任何请求。权重为 100 意味着所有请求都将被发送到 Canary 入口。</li>
<li><code>nginx.ingress.kubernetes.io/canary-by-cookie</code>：基于 Cookie 的流量切分，适用于灰度发布与 A/B 测试。用于通知 Ingress 将请求路由到 Canary Ingress 中指定的服务的cookie。当 cookie 值设置为 <code>always</code>时，它将被路由到 Canary 入口；当 cookie 值设置为 <code>never</code>时，请求不会被发送到 Canary 入口；对于任何其他值，将忽略 cookie 并将请求与其他金丝雀规则进行优先级的比较。</li>
</ul>
<p>注意：金丝雀规则按优先顺序进行如下排序：</p>
<blockquote>
<p><code>canary-by-header - &gt; canary-by-cookie - &gt; canary-weight</code></p>
</blockquote>
<p>我们可以把以上的四个 annotation 规则可以总体划分为以下两类：</p>
<ul>
<li>基于权重的 Canary 规则</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/1/17/1579246552422.png" alt="基于权重"></p>
<ul>
<li>基于用户请求的 Canary 规则</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/1/17/1579246569310.png" alt="基于规则"></p>
<p>注意： Ingress-Nginx 实在0.21.0 版本 中，引入的Canary 功能，因此要确保ingress版本OK</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="应用准备"><a href="#应用准备" class="headerlink" title="应用准备"></a>应用准备</h3><p>两个版本的服务，正常版本：</p>
<pre><code>import static java.util.Collections.singletonMap;

@SpringBootApplication
@Controller
public class RestPrometheusApplication &#123;
@Autowiredprivate MeterRegistry registry;
@GetMapping(path = &quot;/&quot;, produces = &quot;application/json&quot;)@ResponseBodypublic Map&lt;String, Object&gt; landingPage() &#123;    Counter.builder(&quot;mymetric&quot;).tag(&quot;foo&quot;, &quot;bar&quot;).register(registry).increment();    return singletonMap(&quot;hello&quot;, &quot;ambassador&quot;);&#125;
public static void main(String[] args) &#123;    SpringApplication.run(RestPrometheusApplication.class, args);&#125;

&#125;
</code></pre>
<p>访问会输出：</p>
<pre><code>&#123;&quot;hello&quot;:&quot;ambassador&quot;&#125;    
</code></pre>
<p>灰度版本：</p>
<pre><code>import static java.util.Collections.singletonMap;

@SpringBootApplication
@Controller
public class RestPrometheusApplication &#123;
@Autowiredprivate MeterRegistry registry;
@GetMapping(path = &quot;/&quot;, produces = &quot;application/json&quot;)@ResponseBodypublic Map&lt;String, Object&gt; landingPage() &#123;    Counter.builder(&quot;mymetric&quot;).tag(&quot;foo&quot;, &quot;bar&quot;).register(registry).increment();    return singletonMap(&quot;hello&quot;, &quot;ambassador, this is a gray version&quot;);&#125;
public static void main(String[] args) &#123;    SpringApplication.run(RestPrometheusApplication.class, args);&#125;

&#125;
</code></pre>
<p>访问会输出：</p>
<pre><code>&#123;&quot;hello&quot;:&quot;ambassador, this is a gray version&quot;&#125;    
</code></pre>
<h3 id="ingress-配置"><a href="#ingress-配置" class="headerlink" title="ingress 配置"></a>ingress 配置</h3><p>我们部署好两个服务，springboot-rest-demo是正常的服务，springboot-rest-demo-gray是灰度服务，我们来配置ingress，通过canary-by-header来实现：</p>
<p>正常服务的：</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: springboot-rest-demo
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: springboot-rest.jadepeng.com
    http:
      paths:
      - backend:
          serviceName: springboot-rest-demo
          servicePort: 80
</code></pre>
<p>canary 的：</p>
<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: springboot-rest-demo-gray
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/canary: &quot;true&quot;
    nginx.ingress.kubernetes.io/canary-by-header: &quot;canary&quot;nginx.ingress.kubernetes.io/canary-by-header-value: &quot;true&quot;
spec:
  rules:
  - host: springboot-rest.jadepeng.com
    http:
      paths:
      - backend:
          serviceName: springboot-rest-demo-gray
          servicePort: 80
</code></pre>
<p>将上面的文件执行：</p>
<pre><code>kubectl -n=default apply -f ingress-test.yml 
ingress.extensions/springboot-rest-demo created
ingress.extensions/springboot-rest-demo-gray created
</code></pre>
<p>执行测试，不添加header，访问的默认是正式版本：</p>
<pre><code># curl http://springboot-rest.jadepeng.com; echo
&#123;&quot;hello&quot;:&quot;ambassador&quot;&#125;
# curl http://springboot-rest.jadepeng.com; echo
&#123;&quot;hello&quot;:&quot;ambassador&quot;&#125;
</code></pre>
<p>添加header，可以看到，访问的已经是灰度版本了</p>
<pre><code># curl -H &quot;canary: true&quot; http://springboot-rest.jadepeng.com; echo
&#123;&quot;hello&quot;:&quot;ambassador, this is a gray version&quot;&#125;
</code></pre>
<h2 id="多实例Ingress-controllers"><a href="#多实例Ingress-controllers" class="headerlink" title="多实例Ingress controllers"></a>多实例Ingress controllers</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://kubesphere.com.cn/docs/v2.0/zh-CN/quick-start/ingress-canary/#ingress-nginx-annotation-%E7%AE%80%E4%BB%8B">https://kubesphere.com.cn/docs/v2.0/zh-CN/quick-start/ingress-canary/#ingress-nginx-annotation-简介</a></li>
<li><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#canary">https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#canary</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>ingress-nginx</tag>
        <tag>灰度发布</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ambassador实现K8S灰度发布</title>
    <url>/jadepeng/2020/01/02/jqpeng-%E5%9F%BA%E4%BA%8Eambassador%E5%AE%9E%E7%8E%B0K8S%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/ambassador.html">基于ambassador实现K8S灰度发布</a></p>
<h2 id="为什么需要灰度发布"><a href="#为什么需要灰度发布" class="headerlink" title="为什么需要灰度发布"></a>为什么需要灰度发布</h2><p>灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p>
<p>总结下一些应用场景：</p>
<ul>
<li>微服务依赖很多组件，需要在实际环境验证</li>
<li>部署新功能有风险，然后可以通过导流一小部分用户实际使用，来减小风险</li>
<li>让特定的用户访问新版本，比如部署一个版本，只让测试使用</li>
<li>A/B Testing，部署两个版本，进行版本对比，比如验证两个推荐服务的推荐效果</li>
</ul>
<p>灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p>
<h2 id="ambassador介绍"><a href="#ambassador介绍" class="headerlink" title="ambassador介绍"></a>ambassador介绍</h2><p>ambassador[æmˈbæsədər]，是Kubernetes微服务 API gateway,基于Envoy Proxy。</p>
<blockquote>
<p>Open Source Kubernetes-Native API Gateway built on the Envoy Proxy</p>
</blockquote>
<p>官方地址：</p>
<p><a href="https://www.getambassador.io/">https://www.getambassador.io/</a></p>
<h2 id="部署ambassador"><a href="#部署ambassador" class="headerlink" title="部署ambassador"></a>部署ambassador</h2><p>按官网提示部署ambassador</p>
<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
---
apiVersion: v1
kind: Service
metadata:
  labels:
    service: ambassador-admin
  name: ambassador-admin
spec:
  type: NodePort
  ports:
  - name: ambassador-admin
    port: 8877
    targetPort: 8877
  selector:
    service: ambassador
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  name: ambassador
rules:
- apiGroups: [&quot;&quot;]
  resources: [ &quot;endpoints&quot;, &quot;namespaces&quot;, &quot;secrets&quot;, &quot;services&quot; ]
  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
- apiGroups: [ &quot;getambassador.io&quot; ]
  resources: [ &quot;*&quot; ]
  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
- apiGroups: [ &quot;apiextensions.k8s.io&quot; ]
  resources: [ &quot;customresourcedefinitions&quot; ]
  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
- apiGroups: [ &quot;networking.internal.knative.dev&quot; ]
  resources: [ &quot;clusteringresses&quot;, &quot;ingresses&quot; ]
  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
- apiGroups: [ &quot;networking.internal.knative.dev&quot; ]
  resources: [ &quot;ingresses/status&quot;, &quot;clusteringresses/status&quot; ]
  verbs: [&quot;update&quot;]
- apiGroups: [ &quot;extensions&quot; ]
  resources: [ &quot;ingresses&quot; ]
  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
- apiGroups: [ &quot;extensions&quot; ]
  resources: [ &quot;ingresses/status&quot; ]
  verbs: [&quot;update&quot;]
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ambassador
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: ambassador
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ambassador
subjects:
- kind: ServiceAccount
  name: ambassador
  namespace: kube-system
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: authservices.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: authservices
    singular: authservice
    kind: AuthService
    categories:
    - ambassador-crds
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: consulresolvers.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: consulresolvers
    singular: consulresolver
    kind: ConsulResolver
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: kubernetesendpointresolvers.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: kubernetesendpointresolvers
    singular: kubernetesendpointresolver
    kind: KubernetesEndpointResolver
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: kubernetesserviceresolvers.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: kubernetesserviceresolvers
    singular: kubernetesserviceresolver
    kind: KubernetesServiceResolver
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: mappings.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: mappings
    singular: mapping
    kind: Mapping
    categories:
    - ambassador-crds
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: modules.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: modules
    singular: module
    kind: Module
    categories:
    - ambassador-crds
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: ratelimitservices.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: ratelimitservices
    singular: ratelimitservice
    kind: RateLimitService
    categories:
    - ambassador-crds
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: tcpmappings.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: tcpmappings
    singular: tcpmapping
    kind: TCPMapping
    categories:
    - ambassador-crds
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: tlscontexts.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: tlscontexts
    singular: tlscontext
    kind: TLSContext
    categories:
    - ambassador-crds
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: tracingservices.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: tracingservices
    singular: tracingservice
    kind: TracingService
    categories:
    - ambassador-crds
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: logservices.getambassador.io
spec:
  group: getambassador.io
  version: v1
  versions:
  - name: v1
    served: true
    storage: true
  scope: Namespaced
  names:
    plural: logservices
    singular: logservice
    kind: LogService
    categories:
    - ambassador-crds
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ambassador
spec:
  replicas: 3
  selector:
    matchLabels:
      service: ambassador
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: &quot;false&quot;
        &quot;consul.hashicorp.com/connect-inject&quot;: &quot;false&quot;
      labels:
        service: ambassador
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  service: ambassador
              topologyKey: kubernetes.io/hostname
      serviceAccountName: ambassador
      containers:
      - name: ambassador
        image: quay.azk8s.cn/datawire/ambassador:0.86.1
        resources:
          limits:
            cpu: 1
            memory: 400Mi
          requests:
            cpu: 200m
            memory: 100Mi
        env:
        - name: AMBASSADOR_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        ports:
        - name: http
          containerPort: 8080
        - name: https
          containerPort: 8443
        - name: admin
          containerPort: 8877
        livenessProbe:
          httpGet:
            path: /ambassador/v0/check_alive
            port: 8877
          initialDelaySeconds: 30
          periodSeconds: 3
        readinessProbe:
          httpGet:
            path: /ambassador/v0/check_ready
            port: 8877
          initialDelaySeconds: 30
          periodSeconds: 3
        volumeMounts:
        - name: ambassador-pod-info
          mountPath: /tmp/ambassador-pod-info
      volumes:
      - name: ambassador-pod-info
        downwardAPI:
          items:
          - path: &quot;labels&quot;
            fieldRef:
              fieldPath: metadata.labels
      restartPolicy: Always
      securityContext:
        runAsUser: 8888
---
apiVersion: v1
kind: Service
metadata:
  name: ambassador
spec:
  type: NodePort
  externalTrafficPolicy: Local
  ports:
   - port: 80
     targetPort: 8080
  selector:
    service: ambassador


EOF
</code></pre>
<p>为了方便访问网关，生成一个ingress：</p>
<hr>
<pre><code>apiVersion: extensions/v1beta1
kind: Ingress
metadata:
 annotations:
   nginx.ingress.kubernetes.io/proxy-body-size: &quot;0&quot;
   nginx.ingress.kubernetes.io/proxy-read-timeout: &quot;600&quot;
   nginx.ingress.kubernetes.io/proxy-send-timeout: &quot;600&quot;
   kubernetes.io/tls-acme: &#39;true&#39;
 name: ambassador
spec:
 rules:
 - host: ambassador.iflyresearch.com
   http:
     paths:
     - backend:
         serviceName: ambassador
         servicePort: 80
       path: /
</code></pre>
<h2 id="ambassador-配置"><a href="#ambassador-配置" class="headerlink" title="ambassador 配置"></a>ambassador 配置</h2><p>ambassador 使用envoy来实现相关的负载，而envoy类似nginx。ambassador的原理大概是读取service里的配置，然后自动生成envoy的配置，当service变更时，动态更新envoy的配置并重启，所以ambassador需要可以访问服务API。</p>
<p>ambassador  的配置是放到metadata的annotations,以<code>getambassador.io/config</code>开头：</p>
<pre><code>  annotations:
    getambassador.io/config: |
      ---
      apiVersion: ambassador/v0
      kind:  Mapping
      name:  &#123;&#123; .Values.service.name &#125;&#125;_mapping
      prefix: /&#123;&#123; .Values.service.prefix &#125;&#125;
      service: &#123;&#123; .Values.service.name &#125;&#125;.&#123;&#123; .Release.Namespace &#125;&#125;
</code></pre>
<p>profix指定如何访问服务，service指定指向那个服务。注意，需要加上namespace名称，否则容易报找不到后端。</p>
<h2 id="ambassador-灰度"><a href="#ambassador-灰度" class="headerlink" title="ambassador 灰度"></a>ambassador 灰度</h2><p>ambassador实现灰度可以根据weight权重，或者指定匹配特定的header来实现。</p>
<h3 id="根据weight进行灰度"><a href="#根据weight进行灰度" class="headerlink" title="根据weight进行灰度"></a>根据weight进行灰度</h3><p>用法：</p>
<p>部署一个新版本的service，prefix和之前老服务保持一致，但是配置weight，比如20，这样20%的流量会流转到新服务，这样实现A/B Test</p>
<pre><code>---
apiVersion: v1
kind: Service
metadata:
  name: svc-gray
  namespace: default
  annotations:
    getambassador.io/config: |
      ---
      apiVersion: ambassador/v0
      kind:  Mapping
      name:  svc1_mapping
      prefix: /svc/
      service: service-gray  weight: 20
spec:
  selector:
    app: testservice
  ports:
  - port: 8080
    name: service-gray
    targetPort: http-api
</code></pre>
<h3 id="根据请求头-header-进行灰度-regex-headers-正则匹配"><a href="#根据请求头-header-进行灰度-regex-headers-正则匹配" class="headerlink" title="根据请求头 header 进行灰度 (regex_headers 正则匹配)"></a>根据请求头 header 进行灰度 (regex_headers 正则匹配)</h3><p>部署一个新版本，只需要特定的用户才能访问，可以通过该方案来实现。</p>
<p>例如：</p>
<pre><code>---
apiVersion: v1
kind: Service
metadata:
  name: svc-gray
  namespace: default
  annotations:
    getambassador.io/config: |
      ---
      apiVersion: ambassador/v0
      kind:  Mapping
      name:  svc1_mapping
      prefix: /svc/
      service: service-gray  headers:
        gray: true
spec:
  selector:
    app: testservice
  ports:
  - port: 8080
    name: service-gray
    targetPort: http-api
</code></pre>
<p>访问时，当指定gray: true时，访问灰度版本，可以用postman来测试：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2020/1/2/1577967795378.png" alt="POSTMAN"></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>灰度发布</tag>
        <tag>ambassador</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 使用jgit管理git仓库</title>
    <url>/jadepeng/2019/12/20/jqpeng-JAVA%20%E4%BD%BF%E7%94%A8jgit%E7%AE%A1%E7%90%86git%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/jgit.html">JAVA 使用jgit管理git仓库</a></p>
<p>最近设计基于gitops新的CICD方案,需要通过java读写git仓库，这里简单记录下。</p>
<p>JGit是一款pure java的软件包，可以读写git仓库，下面介绍基本使用。</p>
<h2 id="引入jgit"><a href="#引入jgit" class="headerlink" title="引入jgit"></a>引入jgit</h2><p>maven引入：</p>
<pre><code>        &lt;!-- https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;
            &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;
            &lt;version&gt;5.6.0.201912101111-r&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>jgit 有一个Git类，可以用来执行常规的git操作</p>
<h2 id="凭证管理"><a href="#凭证管理" class="headerlink" title="凭证管理"></a>凭证管理</h2><p>通过<code>CredentialsProvider</code>管理凭证，常用的是<code>UsernamePasswordCredentialsProvider</code></p>
<p>通过下面代码初始化：</p>
<pre><code>public static CredentialsProvider createCredential(String userName, String password) &#123;
        return new UsernamePasswordCredentialsProvider(userName, password);
    &#125;
</code></pre>
<h2 id="clone远程仓库"><a href="#clone远程仓库" class="headerlink" title="clone远程仓库"></a>clone远程仓库</h2><p>git 命令：</p>
<pre><code>git clone &#123;repoUrl&#125;
</code></pre>
<p>通过Git.cloneRepository 来clone远程仓库，如果需要凭证，则需要指定<code>credentialsProvider</code></p>
<pre><code> public static Git fromCloneRepository(String repoUrl, String cloneDir, CredentialsProvider provider) throws GitAPIException &#123;
        Git git = Git.cloneRepository()
            .setCredentialsProvider(provider)
            .setURI(repoUrl)
            .setDirectory(new File(cloneDir)).call();
        return git;
    &#125;
</code></pre>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>git 命令：</p>
<pre><code>git commit -a -m &#39;&#123;msg&#125;&#39;
</code></pre>
<p>commit比较简单，对应commit方法, 注意需要先add</p>
<pre><code>    public static void commit(Git git, String message, CredentialsProvider provider) throws GitAPIException &#123;
        git.add().addFilepattern(&quot;.&quot;).call();
        git.commit()
            .setMessage(message)
            .call();
    &#125;
</code></pre>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>git 命令：</p>
<pre><code>git push origin branchName
</code></pre>
<p>push直接调用push即可, 需要指定<code>credentialsProvider</code></p>
<pre><code>   public static void push(Git git, CredentialsProvider provider) throws GitAPIException, IOException &#123;
        push(git,null,provider);
    &#125;

    public static void push(Git git, String branch, CredentialsProvider provider) throws GitAPIException, IOException &#123;
        if (branch == null) &#123;
            branch = git.getRepository().getBranch();
        &#125;
        git.push()
            .setCredentialsProvider(provider)
            .setRemote(&quot;origin&quot;).setRefSpecs(new RefSpec(branch)).call();
    &#125;
</code></pre>
<h2 id="读取已有仓库"><a href="#读取已有仓库" class="headerlink" title="读取已有仓库"></a>读取已有仓库</h2><p>如果git已经clone了，想直接读取，怎么办？</p>
<pre><code> public static Repository getRepositoryFromDir(String dir) throws IOException &#123;
        return new FileRepositoryBuilder()
            .setGitDir(Paths.get(dir, &quot;.git&quot;).toFile())
            .build();
    &#125;
</code></pre>
<h2 id="读取仓库日志"><a href="#读取仓库日志" class="headerlink" title="读取仓库日志"></a>读取仓库日志</h2><p>可以通过RevWalk读取仓库日志。</p>
<ul>
<li>revWalk.parseCommit 可读取一条commit</li>
<li>遍历revWalk，可读取所有日志</li>
</ul>
<pre><code> public static List&lt;String&gt; getLogs(Repository repository) throws IOException &#123;
        return getLogsSinceCommit(repository, null, null);
    &#125;

    public static List&lt;String&gt; getLogsSinceCommit(Repository repository, String commit) throws IOException &#123;
        return getLogsSinceCommit(repository, null, commit);
    &#125;

    public static List&lt;String&gt; getLogsSinceCommit(Repository repository, String branch, String commit) throws IOException &#123;
        if (branch == null) &#123;
            branch = repository.getBranch();
        &#125;
        Ref head = repository.findRef(&quot;refs/heads/&quot; + branch);
        List&lt;String&gt; commits = new ArrayList&lt;&gt;();
        if (head != null) &#123;
            try (RevWalk revWalk = new RevWalk(repository)) &#123;
                revWalk.markStart(revWalk.parseCommit(head.getObjectId()));
                for (RevCommit revCommit : revWalk) &#123;
                    if (revCommit.getId().getName().equals(commit)) &#123;
                        break;
                    &#125;
                    commits.add(revCommit.getFullMessage());
                    System.out.println(&quot;\nCommit-Message: &quot; + revCommit.getFullMessage());
                &#125;
                revWalk.dispose();
            &#125;
        &#125;

        return commits;
    &#125;
</code></pre>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们来先clone仓库，然后修改，最后push</p>
<pre><code> String yaml = &quot;dependencies:\n&quot; +
            &quot;- name: springboot-rest-demo\n&quot; +
            &quot;  version: 0.0.5\n&quot; +
            &quot;  repository: http://hub.hubHOST.com/chartrepo/ainote\n&quot; +
            &quot;  alias: demo\n&quot; +
            &quot;- name: exposecontroller\n&quot; +
            &quot;  version: 2.3.82\n&quot; +
            &quot;  repository: http://chartmuseum.jenkins-x.io\n&quot; +
            &quot;  alias: cleanup\n&quot;;
        CredentialsProvider provider = createCredential(&quot;USR_NAME&quot;, &quot;PASSWORD&quot;);

        String cloneDir = &quot;/tmp/test&quot;;

        Git git = fromCloneRepository(&quot;http://gitlab.GITHOST.cn/env-test.git&quot;, cloneDir, provider);

        // 修改文件

        FileUtils.writeStringToFile(Paths.get(cloneDir, &quot;env&quot;, &quot;requirements.yaml&quot;).toFile(), yaml, &quot;utf-8&quot;);      // 提交
        commit(git, &quot;deploy(app): deploy  springboot-rest-demo:0.0.5 to env test&quot;, provider);
        // push 到远程仓库
        push(git, &quot;master&quot;, provider);

        git.clean().call();
        git.close();

        FileUtils.deleteDirectory(new File(cloneDir));
</code></pre>
<p>读取已有仓库的日志：</p>
<pre><code>        Repository repository = getRepositoryFromDir(&quot;GIT_DIR&quot;);
        List&lt;String&gt; logs = getLogs(repository);
        System.out.println(logs);

        RevCommit head = getLastCommit(repository);
        System.out.println(head.getFullMessage());
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文讲述了如何通过jgit完成常规的git操作。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>jgit</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA使用SnakeYAML解析与序列化YAML</title>
    <url>/jadepeng/2019/12/19/jqpeng-JAVA%E4%BD%BF%E7%94%A8SnakeYAML%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96YAML/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/SnakeYAML.html">JAVA使用SnakeYAML解析与序列化YAML</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a><strong>1.概述</strong></h2><p>本文，我们将学习如何使用<a href="https://bitbucket.org/asomov/snakeyaml/overview">SnakeYAML</a>库将<br><strong>YAML文档转换为Java对象，以及JAVA对象如何序列化为YAML文档</strong>。</p>
<h2 id="2-项目设置"><a href="#2-项目设置" class="headerlink" title="2.项目设置"></a><strong>2.项目设置</strong></h2><p>要在项目中使用SnakeYAML，需要添加Maven依赖项（可在<a href="https://search.maven.org/classic/#search%7Cgav%7C1%7Cg%3A%22org.yaml%22%20AND%20a%3A%22snakeyaml%22">此处</a>找到最新版本）：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.yaml&lt;/groupId&gt;
    &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;
    &lt;version&gt;1.25&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="3-入口点"><a href="#3-入口点" class="headerlink" title="3.入口点"></a><strong>3.入口点</strong></h2><p>该<code>YAML</code>类是API的入口点：</p>
<pre><code>Yaml yaml = new Yaml()
</code></pre>
<p>由于实现不是线程安全的，因此不同的线程必须具有自己的<code>Yaml</code>实例。</p>
<h2 id="4-加载YAML文档"><a href="#4-加载YAML文档" class="headerlink" title="4.加载YAML文档"></a><strong>4.加载YAML文档</strong></h2><p><code>SnakeYAML</code>支持从<code>String</code>或<code>InputStream</code>加载文档，我们从定义一个简单的YAML文档开始，然后将文件命名为<code>customer.yaml</code>：</p>
<pre><code>firstName: &quot;John&quot;
lastName: &quot;Doe&quot;
age: 20
</code></pre>
<h3 id="4-1。基本用法"><a href="#4-1。基本用法" class="headerlink" title="4.1。基本用法"></a><strong>4.1。基本用法</strong></h3><p>现在，我们将使用<code>Yaml</code>类来解析上述YAML文档：</p>
<pre><code>Yaml yaml = new Yaml();
InputStream inputStream = this.getClass()
  .getClassLoader()
  .getResourceAsStream(&quot;customer.yaml&quot;);
Map&lt;String, Object&gt; obj = yaml.load(inputStream);
System.out.println(obj);
</code></pre>
<p>上面的代码生成以下输出：</p>
<pre><code>&#123;firstName=John, lastName=Doe, age=20&#125;
</code></pre>
<p>默认情况下，<code>load（）</code>方法返回一个<code>Map</code>对象。查询<code>Map</code>对象时，我们需要事先知道属性键的名称，否则容易出错。更好的办法是自定义类型。</p>
<h3 id="4-2自定义类型解析"><a href="#4-2自定义类型解析" class="headerlink" title="4.2自定义类型解析"></a><strong>4.2自定义类型解析</strong></h3><p><code>SnakeYAML</code><strong>提供了一种将文档解析为自定义类型的方法</strong></p>
<p>让我们定义一个<code>Customer</code>类，然后尝试再次加载该文档：</p>
<pre><code>public class Customer &#123;
 
    private String firstName;
    private String lastName;
    private int age;
 
    // getters and setters
&#125;
</code></pre>
<p>现在我么来加载：</p>
<pre><code>Yaml yaml = new Yaml();
InputStream inputStream = this.getClass()
 .getClassLoader()
 .getResourceAsStream(&quot;customer.yaml&quot;);
Customer customer = yaml.load(inputStream);
</code></pre>
<p>还有一种方法是使用Constructor：</p>
<pre><code>Yaml yaml = new Yaml(new Constructor(Customer.class));
</code></pre>
<h3 id="4-3。隐式类型"><a href="#4-3。隐式类型" class="headerlink" title="4.3。隐式类型"></a><strong>4.3。隐式类型</strong></h3><p><strong>如果没有为给定属性定义类型，则库会自动将值转换为隐式type</strong>。</p>
<p>例如：</p>
<pre><code>1.0 -&gt; Float
42 -&gt; Integer
2009-03-30 -&gt; Date
</code></pre>
<p>让我们使用一个TestCase来测试这种隐式类型转换：</p>
<pre><code>@Test
public void whenLoadYAML_thenLoadCorrectImplicitTypes() &#123;
   Yaml yaml = new Yaml();
   Map&lt;Object, Object&gt; document = yaml.load(&quot;3.0: 2018-07-22&quot;);
  
   assertNotNull(document);
   assertEquals(1, document.size());
   assertTrue(document.containsKey(3.0d));   
&#125;
</code></pre>
<h3 id="4-4-嵌套对象"><a href="#4-4-嵌套对象" class="headerlink" title="4.4 嵌套对象"></a><strong>4.4 嵌套对象</strong></h3><p><code>SnakeYAML</code> 支持嵌套的复杂类型。</p>
<p>让我们向“ <code>customer.yaml”</code>添加“ <code>联系方式”</code>  和“ <code>地址” </code>详细信息<code>，</code>并将新文件另存为<code>customer_with_contact_details_and_address.yaml. </code>。</p>
<p>现在，我们将分析新的YAML文档：</p>
<pre><code>firstName: &quot;John&quot;
lastName: &quot;Doe&quot;
age: 31
contactDetails:
   - type: &quot;mobile&quot;
     number: 123456789
   - type: &quot;landline&quot;
     number: 456786868
homeAddress:
   line: &quot;Xyz, DEF Street&quot;
   city: &quot;City Y&quot;
   state: &quot;State Y&quot;
   zip: 345657
</code></pre>
<p>我们来更新java类：</p>
<pre><code>public class Customer &#123;
    private String firstName;
    private String lastName;
    private int age;
    private List&lt;Contact&gt; contactDetails;
    private Address homeAddress;    
    // getters and setters
&#125;

public class Contact &#123;
    private String type;
    private int number;
    // getters and setters
&#125;

public class Address &#123;
    private String line;
    private String city;
    private String state;
    private Integer zip;
    // getters and setters
&#125;
</code></pre>
<p>现在，我们来测试下<code>Yaml</code>＃<code>load（）</code>：</p>
<pre><code>@Test
public void
  whenLoadYAMLDocumentWithTopLevelClass_thenLoadCorrectJavaObjectWithNestedObjects() &#123;
  
    Yaml yaml = new Yaml(new Constructor(Customer.class));
    InputStream inputStream = this.getClass()
      .getClassLoader()
      .getResourceAsStream(&quot;yaml/customer_with_contact_details_and_address.yaml&quot;);
    Customer customer = yaml.load(inputStream);
  
    assertNotNull(customer);
    assertEquals(&quot;John&quot;, customer.getFirstName());
    assertEquals(&quot;Doe&quot;, customer.getLastName());
    assertEquals(31, customer.getAge());
    assertNotNull(customer.getContactDetails());
    assertEquals(2, customer.getContactDetails().size());
     
    assertEquals(&quot;mobile&quot;, customer.getContactDetails()
      .get(0)
      .getType());
    assertEquals(123456789, customer.getContactDetails()
      .get(0)
      .getNumber());
    assertEquals(&quot;landline&quot;, customer.getContactDetails()
      .get(1)
      .getType());
    assertEquals(456786868, customer.getContactDetails()
      .get(1)
      .getNumber());
    assertNotNull(customer.getHomeAddress());
    assertEquals(&quot;Xyz, DEF Street&quot;, customer.getHomeAddress()
      .getLine());
&#125;
</code></pre>
<h3 id="4-5。类型安全的集合"><a href="#4-5。类型安全的集合" class="headerlink" title="4.5。类型安全的集合"></a><strong>4.5。类型安全的集合</strong></h3><p>当给定Java类的一个或多个属性是泛型集合类时，需要通过<code>TypeDescription</code>来指定泛型类型，以以便可以正确解析。</p>
<p>让我们假设一个 一个<code>Customer</code>拥有多个<code>Contact</code>：</p>
<pre><code>firstName: &quot;John&quot;
lastName: &quot;Doe&quot;
age: 31
contactDetails:
   - &#123; type: &quot;mobile&quot;, number: 123456789&#125;
   - &#123; type: &quot;landline&quot;, number: 123456789&#125;
</code></pre>
<p>为了能正确解析，**我们可以在顶级类上为给定属性指定<code>TypeDescription </code>**：</p>
<pre><code>Constructor constructor = new Constructor(Customer.class);
TypeDescription customTypeDescription = new TypeDescription(Customer.class);
customTypeDescription.addPropertyParameters(&quot;contactDetails&quot;, Contact.class);
constructor.addTypeDescription(customTypeDescription);
Yaml yaml = new Yaml(constructor);
</code></pre>
<h3 id="4-6。载入多个文件"><a href="#4-6。载入多个文件" class="headerlink" title="4.6。载入多个文件"></a><strong>4.6。载入多个文件</strong></h3><p>在某些情况下，单个<code>文件中</code>可能有多个YAML文档，而我们想解析所有文档。所述<code>YAML</code>类提供了一个<code>LOADALL（）</code>方法来完成这种类型的解析。</p>
<p>假设下面的内容在一个文件中：</p>
<pre><code>---
firstName: &quot;John&quot;
lastName: &quot;Doe&quot;
age: 20
---
firstName: &quot;Jack&quot;
lastName: &quot;Jones&quot;
age: 25
</code></pre>
<p>我们可以使用<code>loadAll（）</code>方法解析以上内容，如以下代码示例所示：</p>
<pre><code>@Test
public void whenLoadMultipleYAMLDocuments_thenLoadCorrectJavaObjects() &#123;
    Yaml yaml = new Yaml(new Constructor(Customer.class));
    InputStream inputStream = this.getClass()
      .getClassLoader()
      .getResourceAsStream(&quot;yaml/customers.yaml&quot;);
 
    int count = 0;
    for (Object object : yaml.loadAll(inputStream)) &#123;
        count++;
        assertTrue(object instanceof Customer);
    &#125;
    assertEquals(2,count);
&#125;
</code></pre>
<h2 id="5-生成YAML文件"><a href="#5-生成YAML文件" class="headerlink" title="5.生成YAML文件"></a><strong>5.生成YAML文件</strong></h2><p><code>SnakeYAML</code> 支持 将java对象序列化为yml。</p>
<h3 id="5-1。基本用法"><a href="#5-1。基本用法" class="headerlink" title="5.1。基本用法"></a><strong>5.1。基本用法</strong></h3><p>我们将从一个将<code>Map &lt;String，Object&gt;</code>的实例转储到YAML文档（<code>String</code>）的简单示例开始：</p>
<pre><code>@Test
public void whenDumpMap_thenGenerateCorrectYAML() &#123;
    Map&lt;String, Object&gt; data = new LinkedHashMap&lt;String, Object&gt;();
    data.put(&quot;name&quot;, &quot;Silenthand Olleander&quot;);
    data.put(&quot;race&quot;, &quot;Human&quot;);
    data.put(&quot;traits&quot;, new String[] &#123; &quot;ONE_HAND&quot;, &quot;ONE_EYE&quot; &#125;);
    Yaml yaml = new Yaml();
    StringWriter writer = new StringWriter();
    yaml.dump(data, writer);
    String expectedYaml = &quot;name: Silenthand Olleander\nrace: Human\ntraits: [ONE_HAND, ONE_EYE]\n&quot;;
 
    assertEquals(expectedYaml, writer.toString());
&#125;
</code></pre>
<p>上面的代码产生以下输出（请注意，使用<code>LinkedHashMap</code>的实例将保留输出数据的顺序）：</p>
<pre><code>name: Silenthand Olleander
race: Human
traits: [ONE_HAND, ONE_EYE]
</code></pre>
<h3 id="5-2。自定义Java对象"><a href="#5-2。自定义Java对象" class="headerlink" title="5.2。自定义Java对象"></a><strong>5.2。自定义Java对象</strong></h3><p>我们还可以选择<strong>将自定义Java类型转储到输出流中</strong>。</p>
<pre><code>@Test
public void whenDumpACustomType_thenGenerateCorrectYAML() &#123;
    Customer customer = new Customer();
    customer.setAge(45);
    customer.setFirstName(&quot;Greg&quot;);
    customer.setLastName(&quot;McDowell&quot;);
    Yaml yaml = new Yaml();
    StringWriter writer = new StringWriter();
    yaml.dump(customer, writer);        
    String expectedYaml = &quot;!!com.baeldung.snakeyaml.Customer &#123;age: 45, contactDetails: null, firstName: Greg,\n  homeAddress: null, lastName: McDowell&#125;\n&quot;;
 
    assertEquals(expectedYaml, writer.toString());
&#125;
</code></pre>
<p>生成内容会包含!!com.baeldung.snakeyaml.Customer，为了避免在输出文件中使用标签名，我们可以使用库提供的  <code>dumpAs（）</code>方法。</p>
<p>因此，在上面的代码中，我们可以进行以下调整以删除标记：</p>
<pre><code>yaml.dumpAs(customer, Tag.MAP, null);
</code></pre>
<h2 id="六-结语"><a href="#六-结语" class="headerlink" title="六 结语"></a><strong>六 结语</strong></h2><p>本文说明了SnakeYAML库解析和序列化YAML文档。</p>
<p>所有示例都可以在<a href="https://github.com/eugenp/tutorials/tree/master/libraries-data-io" title="Java 8-Lambda表达式比较示例">GitHub项目中</a>找到。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li>英文原文： <a href="https://www.baeldung.com/java-snake-yaml">Parsing YAML with SnakeYAML</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>SnakeYAML</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 Drone Rest API 获取构建记录日志</title>
    <url>/jadepeng/2019/12/18/jqpeng-%E9%80%9A%E8%BF%87%20Drone%20Rest%20API%20%E8%8E%B7%E5%8F%96%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/drone-logs-api.html">通过 Drone Rest API 获取构建记录日志</a></p>
<hr>
<p>Drone是一款CICD工具，提供rest API，简单介绍下如何使用API 获取构建日志。</p>
<h2 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h2><p>登录进入drone，点头像，在菜单里选择token</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/12/18/1576655214876.png" alt="enter description here"></p>
<p>复制token即可</p>
<h2 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h2><p>Drone的api分为几大类</p>
<ul>
<li>Builds 构建</li>
<li>Cron 定时任务</li>
<li>Repos 仓库</li>
<li>Secrets</li>
<li>User 用户</li>
<li>Users</li>
</ul>
<p>调用举例：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/12/18/1576655383949.png" alt="enter description here"></p>
<h2 id="Build-API"><a href="#Build-API" class="headerlink" title="Build API"></a>Build API</h2><h3 id="构建列表（Build-List）"><a href="#构建列表（Build-List）" class="headerlink" title="构建列表（Build List）"></a>构建列表（Build List）</h3><p>获取仓库的最新构建：</p>
<pre><code>GET /api/repos/&#123;owner&#125;/&#123;repo&#125;/builds

curl -i http://drone.YOUR_HOST.cn/api/repos/jqpeng/springboot-rest-demo/builds -H &quot;Authorization: Bearer TOKEN&quot;
</code></pre>
<p>响应正文示例：</p>
<pre><code>[
  &#123;
      &quot;id&quot;: 100207,
      &quot;repo_id&quot;: 296163,
      &quot;number&quot;: 42,
      &quot;status&quot;: &quot;success&quot;,
      &quot;event&quot;: &quot;pull_request&quot;,
      &quot;action&quot;: &quot;sync&quot;,
      &quot;link&quot;: &quot;https://github.com/octoat/hello-world/compare/e3320539a4c0...9fc1ad6ebf12&quot;,
      &quot;message&quot;: &quot;updated README&quot;,
      &quot;before&quot;: &quot;e3320539a4c03ccfda992641646deb67d8bf98f3&quot;,
      &quot;after&quot;: &quot;9fc1ad6ebf12462f3f9773003e26b4c6f54a772e&quot;,
      &quot;ref&quot;: &quot;refs/heads/master&quot;,
      &quot;source_repo&quot;: &quot;spaceghost/hello-world&quot;,
      &quot;source&quot;: &quot;develop&quot;,
      &quot;target&quot;: &quot;master&quot;,
      &quot;author_login&quot;: &quot;octocat&quot;,
      &quot;author_name&quot;: &quot;The Octocat&quot;,
      &quot;author_email&quot;: &quot;octocat@github.com&quot;,
      &quot;author_avatar&quot;: &quot;http://www.gravatar.com/avatar/7194e8d48fa1d2b689f99443b767316c&quot;,
      &quot;sender&quot;: &quot;bradrydzewski&quot;,
      &quot;started&quot;: 1564085874,
      &quot;finished&quot;: 1564086343,
      &quot;created&quot;: 1564085874,
      &quot;updated&quot;: 1564085874,
      &quot;version&quot;: 3
  &#125;
]
</code></pre>
<h3 id="构建详情"><a href="#构建详情" class="headerlink" title="构建详情"></a>构建详情</h3><p>通过该接口获取构建详情，返回构建状态等信息，{build} 为上面列表里的number，既构建序号。</p>
<pre><code>GET /api/repos/&#123;owner&#125;/&#123;repo&#125;/builds/&#123;build&#125;
</code></pre>
<p>Example Response Body:</p>
<pre><code>&#123;
    &quot;id&quot;: 39862,
    &quot;number&quot;: 20,
    &quot;parent&quot;: 0,
    &quot;event&quot;: &quot;push&quot;,
    &quot;status&quot;: &quot;success&quot;,
    &quot;error&quot;: &quot;&quot;,
    &quot;enqueued_at&quot;: 1576636849,
    &quot;created_at&quot;: 1576636849,
    &quot;started_at&quot;: 1576636850,
    &quot;finished_at&quot;: 1576639053,
    &quot;deploy_to&quot;: &quot;&quot;,
    &quot;commit&quot;: &quot;7729006bfe11933da6c564101acaf8c7f78c5f62&quot;,
    &quot;branch&quot;: &quot;master&quot;,
    &quot;ref&quot;: &quot;refs/heads/master&quot;,
    &quot;refspec&quot;: &quot;&quot;,
    &quot;remote&quot;: &quot;&quot;,
    &quot;title&quot;: &quot;&quot;,
    &quot;message&quot;: &quot;通过update更新\n&quot;,
    &quot;timestamp&quot;: 0,
    &quot;sender&quot;: &quot;&quot;,
    &quot;author&quot;: &quot;jqpeng&quot;,
    &quot;author_avatar&quot;: &quot;https://www.gravatar.com/avatar/4ab53b564545f18efc4079c30a2d35cf.jpg?s=128&quot;,
    &quot;link_url&quot;: &quot;&quot;,
    &quot;signed&quot;: false,
    &quot;verified&quot;: true,
    &quot;reviewed_by&quot;: &quot;&quot;,
    &quot;reviewed_at&quot;: 0,
    &quot;procs&quot;: [
        &#123;
            &quot;id&quot;: 247912,
            &quot;build_id&quot;: 39862,
            &quot;pid&quot;: 1,
            &quot;ppid&quot;: 0,
            &quot;pgid&quot;: 1,
            &quot;name&quot;: &quot;&quot;,
            &quot;state&quot;: &quot;success&quot;,
            &quot;exit_code&quot;: 0,
            &quot;start_time&quot;: 1576636850,
            &quot;end_time&quot;: 1576639053,
            &quot;machine&quot;: &quot;21e73ce43038&quot;,
            &quot;children&quot;: [
                &#123;
                    &quot;id&quot;: 247913,
                    &quot;build_id&quot;: 39862,
                    &quot;pid&quot;: 2,
                    &quot;ppid&quot;: 1,
                    &quot;pgid&quot;: 2,
                    &quot;name&quot;: &quot;clone&quot;,
                    &quot;state&quot;: &quot;success&quot;,
                    &quot;exit_code&quot;: 0,
                    &quot;start_time&quot;: 1576636853,
                    &quot;end_time&quot;: 1576636933,
                    &quot;machine&quot;: &quot;21e73ce43038&quot;
&#125;,
                &#123;
                    &quot;id&quot;: 247914,
                    &quot;build_id&quot;: 39862,
                    &quot;pid&quot;: 3,
                    &quot;ppid&quot;: 1,
                    &quot;pgid&quot;: 3,
                    &quot;name&quot;: &quot;build&quot;,
                    &quot;state&quot;: &quot;success&quot;,
                    &quot;exit_code&quot;: 0,
                    &quot;start_time&quot;: 1576636933,
                    &quot;end_time&quot;: 1576636998,
                    &quot;machine&quot;: &quot;21e73ce43038&quot;
&#125;
]
&#125;
]
&#125;
</code></pre>
<p>procs 是构建的步骤，记住pid，获取构建日志有用</p>
<h3 id="构建日志"><a href="#构建日志" class="headerlink" title="构建日志"></a>构建日志</h3><p>获取构建日志，需要传入{log} 和 {pid}, log是上面的{build}，{pid}是上一步返回的pid</p>
<pre><code>GET /api/repos/&#123;owner&#125;/&#123;repo&#125;/logs/&#123;log&#125;/&#123;pid&#125;
</code></pre>
<p>响应正文示例：</p>
<pre><code>[
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 0,
    &quot;out&quot;: &quot;+ git init\n&quot;
  &#125;,
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 1,
    &quot;out&quot;: &quot;Initialized empty Git repository in /drone/src/github.com/octocat/hello-world/.git/\n&quot;
  &#125;,
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 2,
    &quot;out&quot;: &quot;+ git remote add origin https://github.com/octocat/hello-world.git\n&quot;
  &#125;,
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 3,
    &quot;out&quot;: &quot;+ git fetch --no-tags origin +refs/heads/master:\n&quot;
  &#125;,
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 4,
    &quot;out&quot;: &quot;From https://github.com/octocat/hello-world\n&quot;
  &#125;,
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 5,
    &quot;out&quot;: &quot; * branch            master     -&gt; FETCH_HEAD\n&quot;
  &#125;,
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 6,
    &quot;out&quot;: &quot; * [new branch]      master     -&gt; origin/master\n&quot;
  &#125;,
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 7,
    &quot;out&quot;: &quot;+ git reset --hard -q 62126a02ffea3dabd7789e5c5407553490973665\n&quot;
  &#125;,
  &#123;
    &quot;proc&quot;: &quot;clone&quot;,
    &quot;pos&quot;: 8,
    &quot;out&quot;: &quot;+ git submodule update --init --recursive\n&quot;
  &#125;
]
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>drone</tag>
      </tags>
  </entry>
  <entry>
    <title>fastText训练word2vec并用于训练任务</title>
    <url>/jadepeng/2019/11/22/jqpeng-fastText%E8%AE%AD%E7%BB%83word2vec%E5%B9%B6%E7%94%A8%E4%BA%8E%E8%AE%AD%E7%BB%83%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/fastText.html">fastText训练word2vec并用于训练任务</a></p>
<p>最近测试OpenNRE，没有GPU服务器，bert的跑不动，于是考虑用word2vec，捡起fasttext</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>先clone代码</p>
<pre><code>git clone https://github.com/facebookresearch/fastText.git
</code></pre>
<p>然后make编译：</p>
<pre><code>make
</code></pre>
<p>编译后，将生成的fastText移到bin</p>
<pre><code>cp fasttext /usr/local/bin/
</code></pre>
<h2 id="训练word2vec"><a href="#训练word2vec" class="headerlink" title="训练word2vec"></a>训练word2vec</h2><p>先讲语料分好词，比如保存到sent_train.txt，文件内容是中文分词后的内容:</p>
<pre><code>楚穆王 十二年 : （ 丁未 ， 公元前 614 年 ） ， 在位 12 年 的 楚穆王 死 ， 死后 葬 在 楚 郢 之西 。
</code></pre>
<p>开始调用fasttext训练：</p>
<pre><code>fasttext skipgram -input sent_train.txt -output ./result
</code></pre>
<p>很快就跑完了，跑完后，可以看到生成两个文件：</p>
<pre><code># ll result.*
-rw-r--r-- 1 root root 876945058 Nov 21 09:29 result.bin
-rw-r--r-- 1 root root  82656362 Nov 21 09:29 result.vec
</code></pre>
<p>来看下vec文件，可以看到是100维的向量</p>
<pre><code># head result.vec 
94161 100
， 0.030437 0.12177 -0.1367 0.11101 -0.49543 0.49908 0.033441 -0.025445 -0.036312 -0.081132 -0.082666 0.27204 -0.2367 -0.23424 -0.30124 -0.029666 -0.23803 -0.083255 -0.03177 -0.23129 0.33953 -0.095728 0.023824 -0.33981 -0.048715 -0.22876 0.24215 -0.094075 -0.077224 0.097473 -0.012714 -0.16661 -0.5156 -0.12635 -0.34265 -0.13444 -0.25535 -0.29832 0.14624 -0.24779 0.25403 0.17662 0.070345 -0.15927 0.3449 0.11372 0.22504 0.15652 0.19013 -0.029641 -0.1761 0.018512 -0.19782 -0.15607 0.39958 0.31343 0.30654 0.062457 -0.045659 -0.008893 0.11445 0.035771 0.048592 0.17336 0.15742 -0.085562 -0.12398 0.25767 -0.087141 -0.10011 -0.14832 0.11072 0.0037114 0.18156 -0.32666 -0.081212 0.1102 -0.035646 0.09467 0.014385 0.11191 -0.14713 -0.0052515 -0.006049 0.3735 -0.13804 0.12271 -0.050977 -0.019325 -0.034865 0.019665 -0.16755 0.034194 0.074825 0.16173 -0.20006 -0.03904 -0.18061 0.040119 -0.22622 
&lt;/s&gt; -0.23353 0.071758 -0.26913 -0.14217 -0.1736 0.22807 -0.11152 -0.047725 0.19557 0.13388 -0.21704 0.39025 -0.30286 0.16748 -0.18748 0.11423 -0.19393 -0.10635 -0.12826 -0.3244 0.27615 -0.25832 -0.17595 -0.12634 -0.094196 -0.19782 0.14435 -0.059313 -0.24001 -0.13996 -0.09501 -0.26155 -0.35677 0.059324 -0.23963 -0.20722 -0.37483 -0.11253 0.021369 -0.15571 0.059181 0.33843 -0.058266 -0.12393 0.17777 -0.032558 0.17864 0.28223 0.058037 0.13108 -0.31817 0.081199 -0.05605 -0.029366 0.30827 0.3208 0.070286 0.062643 0.0040956 -0.080481 0.0064075 -0.087952 0.19877 0.33604 0.28209 0.073563 -0.097628 0.035748 -0.20385 -0.28676 -0.12122 0.10025 -0.05521 0.22991 -0.326 0.062162 0.090364 -0.20831 0.3678 -0.00043566 0.059466 -0.068502 -0.072635 0.08424 0.56188 -0.2588 0.15091 -0.15923 -0.12595 0.086243 0.08293 -0.37854 0.055448 0.11274 0.19559 -0.17132 -0.0858 -0.072667 -0.10356 0.1394 
。 -0.097674 0.13847 -0.25706 0.057651 -0.29097 0.23529 -0.022163 -0.046278 0.18153 0.15302 -0.25117 0.30537 -0.22519 0.072574 -0.20933 -0.012315 -0.098127 -0.13748 -0.10589 -0.24647 0.38788 -0.077517 -0.24665 -0.1512 -0.17301 -0.13699 0.15931 -0.050389 -0.20344 -0.10393 -0.086151 -0.12502 -0.51355 -0.078194 -0.32112 -0.25169 -0.55924 -0.083918 0.13193 -0.12648 0.030666 0.37635 -0.0068401 -0.082757 0.35918 0.099755 0.048127 0.14651 -0.078756 0.16794 -0.35228 0.096068 -0.083268 -0.16416 0.30675 0.2112 -0.0034745 0.06171 0.015094 0.035436 0.13429 -0.036958 0.052708 0.39273 0.15883 0.015595 -0.014254 0.025274 -0.061765 -0.20447 -0.11626 0.12291 -0.13875 0.28874 -0.46607 -0.0064296 0.09502 -0.19274 0.32262 -0.077533 0.058291 -0.11019 -0.23094 -0.023817 0.59467 -0.31411 0.13071 -0.064146 -0.10452 -0.014019 0.28547 -0.3112 -0.019938 0.073268 0.2858 -0.087934 -0.0038124 -0.032765 -0.086257 0.07277 
的 -0.32055 0.26205 -0.12693 0.036473 -0.48332 0.37801 0.043741 0.063979 0.17719 -0.0034521 -0.28247 0.4286 -0.11431 0.02168 -0.2469 -0.34261 -0.29886 -0.11997 -0.068971 -0.084678 0.36461 -0.089133 -0.056445 -0.15533 0.00017123 0.1496 0.24858 0.12394 -0.23362 -0.26373 0.037876 -0.20656 -0.48941 0.093864 -0.21763 -0.35464 -0.31409 -0.10626 0.064067 -0.21431 0.028025 0.27952 -0.1368 -0.30315 0.39894 0.23021 0.19465 0.12281 0.22508 -0.14596 -0.31362 -0.035584 0.076387 -0.28307 0.32819 0.21772 0.2417 0.23587 -0.097756 -0.18368 -0.027078 -0.15416 0.095119 -0.16597 0.096744 0.20759 0.083306 0.24435 -0.055484 -0.17169 -0.031104 0.13582 0.15192 0.066508 -0.19847 -0.28637 0.027218 -0.030856 0.36561 -0.13589 0.26368 -0.13762 -0.21137 -0.24706 0.46078 -0.31472 0.080658 0.23818 -0.060492 0.18232 0.19158 -0.16032 0.14793 0.021469 0.22363 -0.20411 0.07628 -0.096523 -0.11407 -0.35992 
</code></pre>
<h2 id="转换为pytorch可加载格式"><a href="#转换为pytorch可加载格式" class="headerlink" title="转换为pytorch可加载格式"></a>转换为pytorch可加载格式</h2><p>为了方便训练使用，需要转换下：</p>
<pre><code>import pickle as pkl
import numpy as np
import os
import json

def create_wordVec(vec_file，word2id,vec):
    word_map = &#123;&#125;
    word_map[&#39;PAD&#39;] = len(word_map)
    word_map[&#39;UNK&#39;] = len(word_map)
    word_embed = []
    for line in open(vec_file):
        content = line.strip().split()
        if len(content) != 100 + 1:
            continue
        word_map[content[0]] = len(word_map)
        word_embed.append(np.asarray(content[1:], dtype=np.float32))
    word_embed = np.array(word_embed)
    np.save(vec,word_embed)
    with open(word2id, &#39;w+&#39;, encoding=&#39;utf-8&#39;) as fw:
      fw.write(json.dumps(word_map, ensure_ascii=False))

create_wordVec(&#39;result.vec&#39;,&#39;word2id.json&#39;,&#39;word2vec.npy&#39;)
</code></pre>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>参考opennre的cnn分类代码：</p>
<pre><code>import torch
import numpy as np
import json
import opennre
from opennre import encoder, model, framework

print(&#39;load word2vec ...&#39;)
ckpt = &#39;ckpt/semeval_cnn_softmax.pth.tar&#39;
wordi2d = json.load(open(&#39;pretrain/glove/word2id.json&#39;))
word2vec = np.load(&#39;pretrain/glove/word2vec.npy&#39;)
rel2id = json.load(open(&#39;benchmark/ccks/ccks_rel2id.txt&#39;))
print(&#39;create model ...&#39;)
sentence_encoder = opennre.encoder.CNNEncoder(token2id=wordi2d,
                                             max_length=100,
                                             word_size=100,
                                             position_size=5,
                                             hidden_size=230,
                                             blank_padding=True,
                                             kernel_size=3,
                                             padding_size=1,
                                             word2vec=word2vec,
                                             dropout=0.5)
model = opennre.model.SoftmaxNN(sentence_encoder, len(rel2id), rel2id)
framework = opennre.framework.SentenceRE(
    train_path=&#39;benchmark/ccks/ccks_train.txt&#39;,
    val_path=&#39;benchmark/ccks/ccks_dev.txt&#39;,
    test_path=&#39;benchmark/ccks/ccks_dev.txt&#39;,
    model=model,
    ckpt=ckpt,
    batch_size=32,
    max_epoch=100,
    lr=0.1,
    weight_decay=1e-5,
    opt=&#39;sgd&#39;)
# Train
#framework.train_model(metric=&#39;micro_f1&#39;)
# Test
print(&#39;load model ...&#39;)

framework.load_state_dict(torch.load(ckpt)[&#39;state_dict&#39;])
framework.train_model(metric=&#39;micro_f1&#39;)
result = framework.eval_model(framework.test_loader)
print(&#39;Accuracy on test set: &#123;&#125;&#39;.format(result[&#39;acc&#39;]))
print(&#39;Micro Precision: &#123;&#125;&#39;.format(result[&#39;micro_p&#39;]))
print(&#39;Micro Recall: &#123;&#125;&#39;.format(result[&#39;micro_r&#39;]))
print(&#39;Micro F1: &#123;&#125;&#39;.format(result[&#39;micro_f1&#39;]))
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>fastText</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP标注工具brat 配置文件说明</title>
    <url>/jadepeng/2019/10/21/jqpeng-NLP%E6%A0%87%E6%B3%A8%E5%B7%A5%E5%85%B7brat%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/brat-config.html">NLP标注工具brat 配置文件说明</a></p>
<h2 id="快速搭建brat"><a href="#快速搭建brat" class="headerlink" title="快速搭建brat"></a>快速搭建brat</h2><p>通过docker：</p>
<pre><code>docker run --name=brat -d -p 38080:80 -e BRAT_USERNAME=brat -e BRAT_PASSWORD=brat -e BRAT_EMAIL=brat@example.com cassj/brat
</code></pre>
<p>启动会拉取镜像，耐心等待，然后打开IP:38080,使用brat，brat登录</p>
<h2 id="braf-的四类配置文件"><a href="#braf-的四类配置文件" class="headerlink" title="braf 的四类配置文件"></a>braf 的四类配置文件</h2><p>the configuration of an annotation project is controlled by four files:</p>
<ul>
<li>annotation.conf: 标记类型 configuration</li>
<li>visual.conf: annotation显示配置</li>
<li>tools.conf: annotation工具配置</li>
<li>kb_shortcuts.conf: 键盘快捷键 keyboard shortcut tool configuration</li>
</ul>
<h2 id="annotation-conf"><a href="#annotation-conf" class="headerlink" title="annotation.conf"></a>annotation.conf</h2><p>标记配置文件</p>
<pre><code># 实体类型
[entities]
# 每行一个实体类型  
Protein
Simple_chemical
Complex
Organism

# 事件
[events]

# 事件名称  参数名称：参数类型
Gene_expression Theme:Protein
Binding Theme+:Protein
Positive_regulation Theme:&lt;EVENT&gt;|Protein, Cause?:&lt;EVENT&gt;|Protein
Negative_regulation Theme:&lt;EVENT&gt;|Protein, Cause?:&lt;EVENT&gt;|Protein

# 关系
[relations]

# 关系名称 关系的属性，syntax ARG:TYPE (where ARG are, by convention, Arg1 and Arg2)
Part-of Arg1:Protein, Arg2:Complex
Member-of Arg1:Protein, Arg2:Complex

# TODO: Should these really be called &quot;Equivalent&quot; instead of &quot;Equiv&quot;?
Equiv Arg1:Protein, Arg2:Protein, &lt;REL-TYPE&gt;:symmetric-transitive
Equiv Arg1:Simple_chemical, Arg2:Simple_chemical, &lt;REL-TYPE&gt;:symmetric-transitive
Equiv Arg1:Organism, Arg2:Organism, &lt;REL-TYPE&gt;:symmetric-transitive

# 属性定义
[attributes]

# 名称  参数
Negation        Arg:&lt;EVENT&gt;
Confidence        Arg:&lt;EVENT&gt;, Value:Possible|Likely|Certain
</code></pre>
<h2 id="Visual-configuration-visual-conf"><a href="#Visual-configuration-visual-conf" class="headerlink" title="Visual configuration (visual.conf)"></a>Visual configuration (visual.conf)</h2><p>可视化configuration包含两部分</p>
<ul>
<li>[labels]</li>
<li>[drawing]</li>
</ul>
<p>The [labels] 定义标记类型UI上如何显示：</p>
<pre><code>Simple_chemical | Simple chemical | Chemical
标记类型  |   全称  |  显示文字
</code></pre>
<p>使用”|”隔开，第一部分是里定义的</p>
<p>The [drawing] 用于定义显示样式，比如定义标记的颜色等</p>
<pre><code>[labels]


Simple_chemical | Simple chemical | Chemical
Protein | Protein
Complex | Complex
Organism | Organism

Gene_expression | Gene expression | Expression | Expr
Binding | Binding
Regulation | Regulation
Positive_regulation | Positive regulation | +Regulation
Negative_regulation | Negative regulation | -Regulation
Phosphorylation | Phosphorylation | Phos


Equiv | Equiv

Theme  | Theme
Cause  | Cause
Participant | Participant

[drawing]


SPAN_DEFAULT    fgColor:black, bgColor:lightgreen, borderColor:darken
ARC_DEFAULT    color:black, arrowHead:triangle-5
ATTRIBUTE_DEFAULT    glyph:*

Protein    bgColor:#7fa2ff
Simple_chemical    bgColor:#8fcfff
Complex    bgColor:#8f97ff
Organism    bgColor:#ffccaa

Positive_regulation    bgColor:#e0ff00
Regulation    bgColor:#ffff00
Negative_regulation    bgColor:#ffe000

Cause    color:#007700
Equiv    dashArray:3-3, arrowHead:none

Negation    box:crossed, glyph:&lt;NONE&gt;, dashArray:&lt;NONE&gt;
Confidence    dashArray:3-6|3-3|-, glyph:&lt;NONE&gt;
</code></pre>
<h2 id="工具栏配置-tools-conf"><a href="#工具栏配置-tools-conf" class="headerlink" title="工具栏配置 (tools.conf)"></a>工具栏配置 (tools.conf)</h2><p>The annotation tool configuration file, tools.conf, is divided into the following sections:</p>
<ul>
<li>[options]</li>
<li>[search]</li>
<li>[normalization]</li>
<li>[annotators]</li>
<li>[disambiguators]</li>
</ul>
<p>These sections are all optional: an empty file is a vali</p>
<h3 id="Option-configuration-options-section"><a href="#Option-configuration-options-section" class="headerlink" title="Option configuration ([options] section)"></a>Option configuration ([options] section)</h3><p>[options] 用来配置服务端如何处理分词、分局、验证、日志等:</p>
<ul>
<li><code>Tokens tokenizer:VALUE</code>, where <code>VALUE</code>=<ul>
<li><code>whitespace</code>: split by whitespace characters in source text (only)</li>
<li><code>ptblike</code>: emulate Penn Treebank tokenization</li>
<li><code>mecab</code>: perform Japanese tokenization using MeCab</li>
</ul>
</li>
<li><code>Sentences splitter:VALUE</code>, where <code>VALUE</code>=<ul>
<li><code>regex</code>: regular expression-based sentence splitting</li>
<li><code>newline</code>: split by newline characters in source text (only)</li>
</ul>
</li>
<li><code>Validation validate:VALUE</code>, where <code>VALUE</code>=<ul>
<li><code>all</code>: perform full validation</li>
<li><code>none</code>: don’t perform any validation</li>
</ul>
</li>
<li><code>Annotation-log logfile:VALUE</code>, where <code>VALUE</code>=<ul>
<li><code>&lt;NONE&gt;</code>: no annotation logging</li>
<li><code>NAME</code>: log into file NAME (e.g. “/home/brat/work/annotation.log”)</li>
</ul>
</li>
</ul>
<p>For example, the following [options] section gives the default brat configuration before v1.3:</p>
<p>|</p>
<table>
<thead>
<tr>
<th>[options]</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Tokens</td>
<td>tokenizer:whitespace</td>
</tr>
<tr>
<td>Sentences</td>
<td>splitter:regex</td>
</tr>
<tr>
<td>Validation</td>
<td>validate:none</td>
</tr>
<tr>
<td>Annotation-log</td>
<td>logfile:<none></none></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
</table>
<p>The following [options] section enables Japanese tokenization using MeCab, sentence splitting only by newlines, full validation, and annotation logging into the given file. (In setting <code>Annotation-log logfile</code>, remember to make sure the web server has appropriate write permissions to the file.)</p>
<p>|</p>
<table>
<thead>
<tr>
<th>[options]</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Tokens</td>
<td>tokenizer:mecab</td>
</tr>
<tr>
<td>Sentences</td>
<td>splitter:newline</td>
</tr>
<tr>
<td>Validation</td>
<td>validate:all</td>
</tr>
<tr>
<td>Annotation-log</td>
<td>logfile:/home/brat/work/annotation.log</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
</table>
<h3 id="Normalization-DB-configuration-normalization-section"><a href="#Normalization-DB-configuration-normalization-section" class="headerlink" title="Normalization DB configuration ([normalization] section)"></a>Normalization DB configuration ([normalization] section)</h3><p>The [normalization] section defines the normalization resources that are available. For information on setting up normalization DBs, see the <a href="https://brat.nlplab.org/normalization.html">brat normalization documentation</a>.</p>
<p>Each line in the [normalization] section has the following syntax:</p>
<pre><code>    DBNAME     DB:DBPATH, &lt;URL&gt;:HOMEURL, &lt;URLBASE&gt;:ENTRYURL
</code></pre>
<p>Here, <code>DB</code>, <code>&lt;URL&gt;</code>, <code>&lt;URLBASE&gt;</code> and <code>&lt;PATH&gt;</code> are literal strings (they should appear as written here), while “DBNAME”, “DBPATH”, “HOMEURL” and “ENTRYURL” should be replaced with specific values appropriate for the database being configured:</p>
<ul>
<li><code>DBNAME</code>: sets the database name (e.g. “Wiki”, “GO”). The name can be otherwise freely selected, but should not contain characters other than alphanumeric (“a”-“z”, “A”-“Z”, “0”-“9”), hyphen (“-“) and underscore (“_“). This name will be used both in the brat UI and in the <a href="https://brat.nlplab.org/configuration.html#norm-standoff">annotation file</a> to identify the DB.</li>
<li><code>DBPATH</code> (optional): provides the file system path to the normalization DB data on the server, relative to the brat server root. If <code>DBPATH</code> isn’t set, the system assumes the DB can be found in the default location under the given <code>DBNAME</code>.</li>
<li><code>HOMEURL</code>: sets the URL for the home page of the normalization resource (e.g. “<a href="http://en.wikipedia.org/wiki/">http://en.wikipedia.org/wiki/</a>“). Used both to identify the resource more specifically than <code>DBNAME</code> and to provide a link in the <a href="https://brat.nlplab.org/configuration.html#norm-annotation">annotation UI</a> for accessing the resource.</li>
<li><code>URLBASE</code> (optional): sets a URL template (e.g. “<a href="http://en.wikipedia.org/?curid=%25s">http://en.wikipedia.org/?curid=%s</a>“) that can be filled in to generate a direct link in the <a href="https://brat.nlplab.org/configuration.html#norm-annotation">annotation UI</a> to an entry in the normalization resource. The value should contain the characters “%s” as a placeholder that will be replaced with the ID of the entry.</li>
</ul>
<p>The following example shows examples of configured normalization DBs.</p>
<p>|</p>
<table>
<thead>
<tr>
<th>[normalization]</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Wiki</td>
<td>DB:dbs/wiki, <url>:<a href="http://en.wikipedia.org" target="_blank">http://en.wikipedia.org</a>, <urlbase>:<a href="http://en.wikipedia.org/?curid=%25s" target="_blank">http://en.wikipedia.org/?curid=%s</a></urlbase></url></td>
</tr>
<tr>
<td>UniProt</td>
<td><url>:<a href="http://www.uniprot.org/" target="_blank">http://www.uniprot.org/</a>, <urlbase>:<a href="http://www.uniprot.org/uniprot/%25s" target="_blank">http://www.uniprot.org/uniprot/%s</a></urlbase></url></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
</table>
<p>The first line sets configuration for a database called “Wiki”, found as “dbs/wiki” in the brat server directory, and the second for a DB called “UniProt”, found in the default location for a DB with this name.</p>
<h3 id="搜索配置-search-section"><a href="#搜索配置-search-section" class="headerlink" title="搜索配置 ([search] section)"></a>搜索配置 ([search] section)</h3><p>The [search] 用来配置在线搜索，这样选中一个词语后，可以点击搜索链接进行搜索。</p>
<p><img src="https://brat.nlplab.org/img/search-config-1.png"></p>
<p>Each line in the [search] section contains the name used in the user interface for the search service, and a single key:value pair. The key should have the special value “<url>“ and its value should be the URL URL of the search service with the string to query for replaced by&nbsp;”%s”.</url></p>
<p>The following example shows a simple [search] section.</p>
<p>|</p>
<table>
<thead>
<tr>
<th>[search]</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Google</td>
<td><url>:<a href="http://www.google.com/search?q=%25s" target="_blank">http://www.google.com/search?q=%s</a></url></td>
</tr>
<tr>
<td>Wikipedia</td>
<td><url>:<a href="http://en.wikipedia.org/wiki/%25s" target="_blank">http://en.wikipedia.org/wiki/%s</a></url></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
</table>
<p>When selecting a span or editing an annotation, these search options will then be shown in the brat annotation dialog.</p>
<h3 id="Annotation-tool-configuration-annotators-section"><a href="#Annotation-tool-configuration-annotators-section" class="headerlink" title="Annotation tool configuration ([annotators] section)"></a>Annotation tool configuration ([annotators] section)</h3><p>The [annotators] section defines automatic annotation services that can be invoked from brat.</p>
<p>Each line in the [annotators] section contains a unique name for the service and key:value pairs defining the way it is presented in the user interface and the URL of the web service for the tool. Values should be given for “tool”, “model” and “<url>“ (the first two are used for the user interface only).</url></p>
<p>The following example shows a simple [annotators] section.</p>
<p>|</p>
<table>
<thead>
<tr>
<th>[annotators]</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SNER-CoNLL</td>
<td>tool:Stanford_NER, model:CoNLL, <url>:<a href="http://example.com:80/tagger/" target="_blank">http://example.com:80/tagger/</a></url></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
</table>
<h3 id="Disambiguation-tool-configuration-disambiguators-section"><a href="#Disambiguation-tool-configuration-disambiguators-section" class="headerlink" title="Disambiguation tool configuration ([disambiguators] section)"></a>Disambiguation tool configuration ([disambiguators] section)</h3><p>The [disambiguators] section defines automatic semantic class (annotation type) disambiguation services that can be invoked from brat.</p>
<p>Each line in the [disambiguators] section contains a unique name for the service and key:value pairs defining the way it is presented in the user interface and the URL of the web service for the tool. Values should be given for “tool”, “model” and “<url>“ (the first two are used for the user interface only).</url></p>
<p>The following example shows a simple [disambiguators] section.</p>
<p>|</p>
<table>
<thead>
<tr>
<th>[disambiguators]</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>simsem-MUC</td>
<td>tool:simsem, model:MUC, <url>:<a href="http://example.com:80/simsem/%25s" target="_blank">http://example.com:80/simsem/%s</a></url></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
</table>
<p>As for search, the string to query for is identified by “%s” in the URL.</p>
<p>来看一个demo:</p>
<pre><code>[options]

# Possible values for validate:
# - all: perform full validation
# - none: don&#39;t perform any validation
Validation    validate:all

# Possible values for tokenizer
# - ptblike: emulate Penn Treebank tokenization
# - mecab: perform Japanese tokenization using MeCab
# - whitespace: split by whitespace characters in source text (only) 
Tokens       tokenizer:whitespace

# Possible values for splitter:
# - regex  : regular expression-based sentence splitting
# - newline: split by newline characters in source text (only)
Sentences    splitter:newline

# Possible values for logfile:
# - &lt;NONE&gt; : no annotation logging
# - NAME : log into file NAME (e.g. &quot;/home/brat/annotation.log&quot;)
Annotation-log logfile:&lt;NONE&gt;

[search]

# Search option configuration. Configured queries will be available in
# text span annotation dialogs. When selected on the UI, these open
# the given URL (&quot;&lt;URL&gt;&quot;) with the string &quot;%s&quot; replaced with the
# selected text span.

Google       &lt;URL&gt;:http://www.google.com/search?q=%s
Wikipedia    &lt;URL&gt;:http://en.wikipedia.org/wiki/Special:Search?search=%s
UniProt      &lt;URL&gt;:http://www.uniprot.org/uniprot/?sort=score&amp;query=%s
EntrezGene   &lt;URL&gt;:http://www.ncbi.nlm.nih.gov/gene?term=%s
GeneOntology &lt;URL&gt;:http://amigo.geneontology.org/cgi-bin/amigo/search.cgi?search_query=%s&amp;action=new-search&amp;search_constraint=term
ALC          &lt;URL&gt;:http://eow.alc.co.jp/%s

[annotators]

# Automatic annotation service configuration. The values of &quot;tool&quot; and
# &quot;model&quot; are required for the UI, and &quot;&lt;URL&gt;&quot; should be filled with
# the URL of the web service. See the brat documentation for more
# information.

# Examples:
# Random              tool:Random, model:Random, &lt;URL&gt;:http://localhost:47111/
# Stanford-CoNLL-MUC  tool:Stanford_NER, model:CoNLL+MUC, &lt;URL&gt;:http://127.0.0.1:47111/
# NERtagger-GENIA     tool:NERtagger, model:GENIA, &lt;URL&gt;:http://example.com:8080/tagger/

[disambiguators]

# Automatic semantic disambiguation service configuration. The values
# of &quot;tool&quot; and &quot;model&quot; are required for the UI, and &quot;&lt;URL&gt;&quot; should be
# filled with the URL of the web service. See the brat documentation
# for more information.

# Example:
# simsem-GENIA    tool:simsem, model:GENIA, &lt;URL&gt;:http://example.com:8080/tagger/%s

[normalization]

# Configuration for normalization against external resources. The
# resource name (first field of each line) should match that of a
# normalization DB on the brat server (see tools/norm_db_init.py),
# &quot;&lt;URL&gt;&quot; should be filled with the URL of the resource (preferably
# one providing a serach interface), and &quot;&lt;URLBASE&gt;&quot; should be a
# string containing &quot;%s&quot; that, when replacing &quot;%s&quot; with an ID in
# the external resource, becomes a link to a page representing
# the entry corresponding to the ID in that resource.

# Example
#UniProt    &lt;URL&gt;:http://www.uniprot.org/, &lt;URLBASE&gt;:http://www.uniprot.org/uniprot/%s
#GO    &lt;URL&gt;:http://www.geneontology.org/, &lt;URLBASE&gt;:http://amigo.geneontology.org/cgi-bin/amigo/term_details?term=GO:%s
#FMA    &lt;URL&gt;:http://fme.biostr.washington.edu/FME/index.html, &lt;URLBASE&gt;:http://www.ebi.ac.uk/ontology-lookup/browse.do?ontName=FMA&amp;termId=FMA:%s
</code></pre>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>选中标记后，键盘上按快捷键，可以快速切换选项</p>
<pre><code>P       Protein
S Simple_chemical
X Complex
O Organism

C Cause
T Theme
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>教程 —— 如何在自己的应用集成superset</title>
    <url>/jadepeng/2019/09/17/jqpeng-%E6%95%99%E7%A8%8B%20%E2%80%94%E2%80%94%20%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8%E9%9B%86%E6%88%90superset/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/intergate-superset.html">教程 —— 如何在自己的应用集成superset</a></p>
<p>Superset 是apache的一个孵化项目，定位为一款现代的，准商用BI系统</p>
<h2 id="superset"><a href="#superset" class="headerlink" title="superset"></a>superset</h2><blockquote>
<p>Apache Superset  (incubating) is a modern, enterprise-ready business intelligence web application</p>
</blockquote>
<p>Superset 是apache的一个孵化项目，定位为一款现代的，准商用BI系统。</p>
<p>Superset（Caravel）是由Airbnb（知名在线房屋短租公司）开源的数据分析与可视化平台（曾用名Caravel、Panoramix），该工具主要特点是可自助分析、自定义仪表盘、分析结果可视化（导出）、用户/角色权限控制，还集成了一个SQL编辑器，可以进行SQL编辑查询等。</p>
<p>通过superset，可以制作漂亮的统计图表。</p>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p><img src="https://superset.incubator.apache.org/_images/bank_dash.png" alt="_images/bank_dash.png"></p>
<hr>
<p><img src="https://superset.incubator.apache.org/_images/explore.png" alt="_images/explore.png"></p>
<hr>
<p><img src="https://superset.incubator.apache.org/_images/sqllab.png" alt="_images/sqllab.png"></p>
<hr>
<p><img src="https://superset.incubator.apache.org/_images/deckgl_dash.png" alt="_images/deckgl_dash.png"></p>
<h2 id="superset安装"><a href="#superset安装" class="headerlink" title="superset安装"></a>superset安装</h2><p>我们这里直接使用docker</p>
<pre><code>git clone https://github.com/apache/incubator-superset/
cd incubator-superset/contrib/docker
# prefix with SUPERSET_LOAD_EXAMPLES=yes to load examples:
docker-compose run --rm superset ./docker-init.sh
# you can run this command everytime you need to start superset now:
docker-compose up
</code></pre>
<p>等构建完成后，访问 <a href="http://localhost:8088/">http://localhost:8088</a> 即可。</p>
<p>想要在自己的应用集成，首先要解决认证</p>
<h2 id="superset-认证分析"><a href="#superset-认证分析" class="headerlink" title="superset 认证分析"></a>superset 认证分析</h2><p>superset基于flask-appbuilder开发，security基于flask_appbuilder.security，翻阅其代码，</p>
<p>找到入口： <code>superset/__init__.py</code>:</p>
<pre><code>custom_sm = app.config.get(&#39;CUSTOM_SECURITY_MANAGER&#39;) or SupersetSecurityManager
if not issubclass(custom_sm, SupersetSecurityManager):
    raise Exception(
        &quot;&quot;&quot;Your CUSTOM_SECURITY_MANAGER must now extend SupersetSecurityManager,
         not FAB&#39;s security manager.
         See [4565] in UPDATING.md&quot;&quot;&quot;)

appbuilder = AppBuilder(
    app,
    db.session,
    base_template=&#39;superset/base.html&#39;,
    indexview=MyIndexView,
    security_manager_class=custom_sm,
    update_perms=get_update_perms_flag(),
)

security_manager = appbuilder.sm
</code></pre>
<p>默认使用<code>SupersetSecurityManager</code>,继承自<code>SecurityManager</code>：</p>
<pre><code>class SupersetSecurityManager(SecurityManager):

    def get_schema_perm(self, database, schema):
        if schema:
            return &#39;[&#123;&#125;].[&#123;&#125;]&#39;.format(database, schema)

    def can_access(self, permission_name, view_name):
        &quot;&quot;&quot;Protecting from has_access failing from missing perms/view&quot;&quot;&quot;
        user = g.user
        if user.is_anonymous:
            return self.is_item_public(permission_name, view_name)
        return self._has_view_access(user, permission_name, view_name)        ...
</code></pre>
<p>我们再来看SecurityManager及父类，发现，登录是通过auth_view来控制的，默认是AUTH_DB，也就是AuthDBView。</p>
<pre><code>&quot;&quot;&quot; Override if you want your own Authentication LDAP view &quot;&quot;&quot;
      authdbview = AuthDBView      if self.auth_type == AUTH_DB:
            self.user_view = self.userdbmodelview
            self.auth_view = self.authdbview()
 @property
    def get_url_for_login(self):
        return url_for(&#39;%s.%s&#39; % (self.sm.auth_view.endpoint, &#39;login&#39;))
</code></pre>
<p>再来看authdbview：</p>
<pre><code>class AuthDBView(AuthView):
    login_template = &#39;appbuilder/general/security/login_db.html&#39;

    @expose(&#39;/login/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
    def login(self):
        if g.user is not None and g.user.is_authenticated:
            return redirect(self.appbuilder.get_url_for_index)
        form = LoginForm_db()
        if form.validate_on_submit():
            user = self.appbuilder.sm.auth_user_db(form.username.data, form.password.data)
            if not user:
                flash(as_unicode(self.invalid_login_message), &#39;warning&#39;)
                return redirect(self.appbuilder.get_url_for_login)
            login_user(user, remember=False)
            return redirect(self.appbuilder.get_url_for_index)
        return self.render_template(self.login_template,
                               title=self.title,
                               form=form,
                               appbuilder=self.appbuilder)
</code></pre>
<p>对外提供’/login/‘接口，读取HTTP POST里的用户名，密码，然后调用auth_user_db验证，验证通过调用login_user生成认证信息。</p>
<p>因此，我们可以自定义AuthDBView，改为从我们自己的应用认证即可。</p>
<h2 id="使用jwt来验证superset"><a href="#使用jwt来验证superset" class="headerlink" title="使用jwt来验证superset"></a>使用jwt来验证superset</h2><p>自定义CustomAuthDBView，继承自AuthDBView，登录时可以通过cookie或者url参数传入jwt token，然后验证通过的话，自动登录，。</p>
<pre><code>import jwt
import json
class CustomAuthDBView(AuthDBView):
    login_template = &#39;appbuilder/general/security/login_db.html&#39;

    @expose(&#39;/login/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
    def login(self):
        token = request.args.get(&#39;token&#39;)
        if not token:
            token = request.cookies.get(&#39;access_token&#39;)
        if token is not None:
            jwt_payload = jwt.decode(token,&#39;secret&#39;,algorithms=[&#39;RS256&#39;])
            user_name = jwt_payload.get(&quot;user_name&quot;)
            user = self.appbuilder.sm.find_user(username=user_name)
            if not user:
               role_admin = self.appbuilder.sm.find_role(&#39;Admin&#39;)
               user = self.appbuilder.sm.add_user(user_name, user_name, &#39;aimind&#39;, user_name + &quot;@aimind.com&quot;, role_admin, password = &quot;aimind&quot; + user_name)
            if user:
                login_user(user, remember=False)
                redirect_url = request.args.get(&#39;redirect&#39;)
                if not redirect_url:
                    redirect_url = self.appbuilder.get_url_for_index
                return redirect(redirect_url)
            else:
                return super(CustomAuthDBView,self).login()
        else:
            flash(&#39;Unable to auto login&#39;, &#39;warning&#39;)
            return super(CustomAuthDBView,self).login()
</code></pre>
<p>如果用户不存在，通过self.appbuilder.sm.add_user自动添加用户。</p>
<p>然后再引入这个CustomAuthDBView，</p>
<pre><code>class CustomSecurityManager(SupersetSecurityManager):
    authdbview = CustomAuthDBView
</code></pre>
<p>最后，再引入这个CustomSecurityManager,在superset_config.py 里增加：</p>
<pre><code>from aimind_security import CustomSecurityManager
CUSTOM_SECURITY_MANAGER = CustomSecurityManager
</code></pre>
<h2 id="在应用里集成superset"><a href="#在应用里集成superset" class="headerlink" title="在应用里集成superset"></a>在应用里集成superset</h2><p>集成就简单了，访问，’SUPER_SET_URL/login/?token=jwt_token’ 即可，可以通过iframe无缝集成。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>python</tag>
        <tag>superset</tag>
        <tag>BI</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱推理与实践(3) -- jena自定义builtin</title>
    <url>/jadepeng/2019/09/12/jqpeng-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5(3)%20--%20jena%E8%87%AA%E5%AE%9A%E4%B9%89builtin/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/kg-inference-3.html">知识图谱推理与实践(3) – jena自定义builtin</a></p>
<p>在<a href="https://www.cnblogs.com/xiaoqi/p/kg-inference-2.html">第2篇</a>里，介绍了<code>jena</code>的<code>The general purpose rule engine</code>（通用规则引擎）及其使用，本篇继续探究，如何自定义builtin。</p>
<h2 id="builtin介绍"><a href="#builtin介绍" class="headerlink" title="builtin介绍"></a>builtin介绍</h2><p>先回顾builtin为何物，官方叫<code>Builtin primitives</code>,可以理解为内置函数、内置指令，可以返回true或者false用来检验rule是否匹配，官方包含如下的<code>primitives</code></p>
<table>
<thead>
<tr>
<th>Builtin</th>
<th>Operations</th>
</tr>
</thead>
<tbody><tr>
<td>isLiteral(?x) notLiteral(?x)             <br>isFunctor(?x) notFunctor(?x)             <br>isBNode(?x) notBNode(?x)</td>
<td>Test whether the single argument is or is not a literal, a functor-valued</td>
</tr>
</tbody></table>
<pre><code>      literal or a blank-node, respectively. |
</code></pre>
<p>| bound(?x…) unbound(?x..) | Test if all of the arguments are bound (not bound) variables |<br>| equal(?x,?y) notEqual(?x,?y) | Test if x=y (or x != y). The equality test is semantic equality so that,<br>          for example, the xsd:int 1 and the xsd:decimal 1 would test equal. |<br>| lessThan(?x, ?y), greaterThan(?x, ?y)             <br>le(?x, ?y), ge(?x, ?y) | Test if x is &lt;, &gt;, &lt;= or &gt;= y. Only passes if both x and y<br>          are numbers or time instants (can be integer or floating point or XSDDateTime). |<br>| sum(?a, ?b, ?c)             <br>addOne(?a, ?c)             <br>difference(?a, ?b, ?c)             <br>min(?a, ?b, ?c)             <br>max(?a, ?b, ?c)             <br>product(?a, ?b, ?c)             <br>quotient(?a, ?b, ?c) | Sets c to be (a+b), (a+1) (a-b), min(a,b), max(a,b), (a<br>          <em>b), (a/b). Note that these do not run backwards, if in<br>             <code>sum</code> a and c are bound and b is unbound then the test will<br>            fail rather than bind b to (c-a). This could be fixed.</em><br> |<br>| strConcat(?a1, .. ?an, ?t)             <br>uriConcat(?a1, .. ?an, ?t) | Concatenates the lexical form of all the arguments except the last, then<br>          binds the last argument to a plain literal (strConcat) or a URI node<br>          (uriConcat) with that lexical form. In both cases if an argument node<br>          is a URI node the URI will be used as the lexical form. |<br>| regex(?t, ?p)             <br>regex(?t, ?p, ?m1, .. ?mn) | Matches the lexical form of a literal (?t) against a regular expression<br>          pattern given by another literal (?p). If the match succeeds, and if<br>          there are any additional arguments then it will bind the first n capture<br>          groups to the arguments ?m1 to ?mn. The regular expression pattern syntax<br>          is that provided by java.util.regex. Note that the capture groups are<br>          numbered from 1 and the first capture group will be bound to ?m1, we<br>          ignore the implicit capture group 0 which corresponds to the entire matched<br>          string. So for example<br>          <br><br>    regexp(‘foo bar’, ‘(.) (.<br>                )’, ?m1, ?m2)<br>              <br><br><em>will bind<br>             <code>m1</code> to<br>             <code>&quot;foo&quot;</code> and<br>             <code>m2</code> to<br>             <code>&quot;bar&quot;</code>.</em><br> |<br>| now(?x) | Binds ?x to an xsd:dateTime value corresponding to the current time. |<br>| makeTemp(?x) | Binds ?x to a newly created blank node. |<br>| makeInstance(?x, ?p, ?v)<br>          <br>makeInstance(?x, ?p, ?t, ?v) | Binds ?v to be a blank node which is asserted as the value of the ?p property<br>          on resource ?x and optionally has type ?t. Multiple calls with the same<br>          arguments will return the same blank node each time - thus allowing this<br>          call to be used in backward rules. |<br>| makeSkolem(?x, ?v1, … ?vn) | Binds ?x to be a blank node. The blank node is generated based on the values<br>          of the remain ?vi arguments, so the same combination of arguments will<br>          generate the same bNode. |<br>| noValue(?x, ?p)<br>          <br>noValue(?x ?p ?v) | True if there is no known triple (x, p, ) or (x, p, v) in the model or<br>          the explicit forward deductions so far. |<br>| remove(n, …)<br>          <br>drop(n, …) | Remove the statement (triple) which caused the n’th body term of this (forward-only)<br>          rule to match. Remove will propagate the change to other consequent rules<br>          including the firing rule (which must thus be guarded by some other clauses).<br>          In particular, if the removed statement (triple) appears in the body<br>          of a rule that has already fired, the consequences of such rule are retracted<br>          from the deducted model. Drop will silently remove the triple(s) from<br>          the graph but not fire any rules as a consequence. These are clearly<br>          non-monotonic operations and, in particular, the behaviour of a rule<br>          set in which different rules both drop and create the same triple(s)<br>          is undefined. |<br>| isDType(?l, ?t) notDType(?l, ?t) | Tests if literal ?l is (or is not) an instance of the datatype defined<br>          by resource ?t. |<br>| print(?x, …) | Print (to standard out) a representation of each argument. This is useful<br>          for debugging rather than serious IO work. |<br>| listContains(?l, ?x)<br>           <br>listNotContains(?l, ?x) | Passes if ?l is a list which contains (does not contain) the element ?x,<br>          both arguments must be ground, can not be used as a generator. |<br>| listEntry(?list, ?index, ?val) | Binds ?val to the ?index’th entry in the RDF list ?list. If there is no<br>          such entry the variable will be unbound and the call will fail. Only<br>          usable in rule bodies. |<br>| listLength(?l, ?len) | Binds ?len to the length of the list ?l. |<br>| listEqual(?la, ?lb)<br>           <br>listNotEqual(?la, ?lb) | listEqual tests if the two arguments are both lists and contain the same<br>          elements. The equality test is semantic equality on literals (sameValueAs)<br>          but will not take into account owl:sameAs aliases. listNotEqual is the<br>          negation of this (passes if listEqual fails). |<br>| listMapAsObject(?s, ?p ?l)<br>           <br>listMapAsSubject(?l, ?p, ?o) | These can only be used as actions in the head of a rule. They deduce a<br>          set of triples derived from the list argument ?l : listMapAsObject asserts<br>          triples (?s ?p ?x) for each ?x in the list ?l, listMapAsSubject asserts<br>          triples (?x ?p ?o). |<br>| table(?p) tableAll() | Declare that all goals involving property ?p (or all goals) should be tabled<br>          by the backward engine. |<br>| hide(p) | Declares that statements involving the predicate p should be hidden. Queries<br>          to the model will not report such statements. This is useful to enable<br>          non-monotonic forward rules to define flag predicates which are only<br>          used for inference control and do not “pollute” the inference results. |</p>
<h2 id="builtin-自定义"><a href="#builtin-自定义" class="headerlink" title="builtin 自定义"></a>builtin 自定义</h2><p>自定义很简单，实现<code>Builtin</code>接口, 然后使用<code>BuiltinRegistry.theRegistry.register</code>注册即可。</p>
<p>Builtin接口定义如下：</p>
<pre><code>public interface Builtin &#123;

    /**
     * Return a convenient name for this builtin, normally this will be the name of the 
     * functor that will be used to invoke it and will often be the final component of the
     * URI.
     */
    public String getName();
    
    /**
     * Return the full URI which identifies this built in.
     */
    public String getURI();
    
    /**
     * Return the expected number of arguments for this functor or 0 if the number is flexible.
     */
    public int getArgLength();
    
    /**
     * This method is invoked when the builtin is called in a rule body.
     * @param args the array of argument values for the builtin, this is an array 
     * of Nodes, some of which may be Node_RuleVariables.
     * @param length the length of the argument list, may be less than the length of the args array
     * for some rule engines
     * @param context an execution context giving access to other relevant data
     * @return return true if the buildin predicate is deemed to have succeeded in
     * the current environment
     */
    public boolean bodyCall(Node[] args, int length, RuleContext context);
    
    /**
     * This method is invoked when the builtin is called in a rule head.
     * Such a use is only valid in a forward rule.
     * @param args the array of argument values for the builtin, this is an array 
     * of Nodes.
     * @param length the length of the argument list, may be less than the length of the args array
     * for some rule engines
     * @param context an execution context giving access to other relevant data
     */
    public void headAction(Node[] args, int length, RuleContext context);
    
    /**
     * Returns false if this builtin has side effects when run in a body clause,
     * other than the binding of environment variables.
     */
    public boolean isSafe();
    
    /**
     * Returns false if this builtin is non-monotonic. This includes non-monotonic checks like noValue
     * and non-monotonic actions like remove/drop. A non-monotonic call in a head is assumed to 
     * be an action and makes the overall rule and ruleset non-monotonic. 
     * Most JenaRules are monotonic deductive closure rules in which this should be false.
     */
    public boolean isMonotonic();
&#125;
</code></pre>
<p>一般我们不用直接实现该接口，可以继承默认的实现<code>BaseBuiltin</code>, 一般只需要Override 下<code>getName</code>提供指令名称，实现<code>bodyCall</code>,提供函数调用即可。</p>
<pre><code>    @Override
    public String getName() &#123;
        return &quot;semsim&quot;;
    &#125;
</code></pre>
<p>比如，我们来自定义一个指令，用来计算两两语义相似度：</p>
<pre><code>public class SemanticSimilarityBuiltin extends BaseBuiltin &#123;
    /**
     * Return a convenient name for this builtin, normally this will be the name of the
     * functor that will be used to invoke it and will often be the final component of the
     * URI.
     */
    @Override
    public String getName() &#123;
        return &quot;semsim&quot;;
    &#125;

    @Override
    public int getArgLength() &#123;
        return 3;
    &#125;


    /**
     * This method is invoked when the builtin is called in a rule body.
     *
     * @param args    the array of argument values for the builtin, this is an array
     *                of Nodes, some of which may be Node_RuleVariables.
     * @param context an execution context giving access to other relevant data
     * @return return true if the buildin predicate is deemed to have succeeded in
     * the current environment
     */
    @Override
    public boolean bodyCall(Node[] args, int length, RuleContext context) &#123;
        checkArgs(length, context);
        Node n1 = getArg(0, args, context);
        Node n2 = getArg(1, args, context);
        Node score = getArg(2,args,context);

        if(!score.isLiteral()  || score.getLiteral().getValue()==null)&#123;
         return false;
        &#125;
        String value;
        Double hold = Double.parseDouble(score.getLiteralValue().toString());

        //  n.isLiteral() &amp;&amp; n.getLiteralValue() instanceof Number

        if (n1.isLiteral() &amp;&amp; n2.isLiteral()) &#123;
            String v1 = n1.getLiteralValue().toString();
            String v2 = n2.getLiteralValue().toString();

            // 调用服务计算相似度
            String requestUrl = &quot;http://API-URL:5101/similarity/cosine?s1=&quot;+v1+&quot;&amp;s2=&quot;+v2;
            String result = HttpClientUtil.doGet(requestUrl);
            JSONObject json = JSON.parseObject(result);
            if(json.getDouble(&quot;similarity&quot;) &gt;= hold)&#123;
                return true;
            &#125;

            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<ul>
<li>这里有个getArgLength和checkArgs(length, context)，可以用来限制参数长度，检验必须符合该长度。</li>
<li>可以通过getArg(idx, args, context)来获取待计算的参数</li>
<li>上面的计算相似度，主要是调用外度的服务来计算两两的语义向量的cosine得分，如果满足阈值，我们就认为规则匹配</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们来测试上面的定义的计算语义相似度的指令<code>semsim</code>，还是用第2篇里的例子：</p>
<p>我们新增加两个属性<code>主要业务</code>和<code>竞争对手</code>，我们定义，如果两个公司的主要业务语义上相似，我们就认为两家公司是竞争对手。</p>
<pre><code>        Property 主要业务 = myMod.createProperty(finance + &quot;主要业务&quot;);
        Property 竞争对手 = myMod.createProperty(finance + &quot;竞争对手&quot;);

        // 加入三元组
      
        myMod.add(万达集团, 主要业务, &quot;房地产，文娱&quot;);
        myMod.add(融创中国, 主要业务, &quot;房地产&quot;);
      
</code></pre>
<p>然后定义规则：</p>
<pre><code>[ruleCompetitor: (?c1 :主要业务 ?b1) (?c2 :主要业务 ?b2) notEqual(?c1,?c2) semsim(?b1,?b2,0.6)  -&gt; (?c1 :竞争对手 ?c2)] 
</code></pre>
<p>规则意思是，公司C1 主要业务是 b1,c2 主要业务是b2,并且c1和c2不是同一家公司，如果b1，b2的相似度大于0.6，那么C1和c2是竞争对手。</p>
<p>完整测试代码：</p>
<pre><code>       // 注册自定义builtin
        BuiltinRegistry.theRegistry.register(new SemanticSimilarityBuiltin());

        Model myMod = ModelFactory.createDefaultModel();
        String finance = &quot;http://www.example.org/kse/finance#&quot;;
        Resource 孙宏斌 = myMod.createResource(finance + &quot;孙宏斌&quot;);
        Resource 融创中国 = myMod.createResource(finance + &quot;融创中国&quot;);
        Resource 乐视网 = myMod.createResource(finance + &quot;乐视网&quot;);
        Property 执掌 = myMod.createProperty(finance + &quot;执掌&quot;);
        Resource 贾跃亭 = myMod.createResource(finance + &quot;贾跃亭&quot;);
        Resource 地产公司 = myMod.createResource(finance + &quot;地产公司&quot;);
        Resource 公司 = myMod.createResource(finance + &quot;公司&quot;);
        Resource 法人实体 = myMod.createResource(finance + &quot;法人实体&quot;);
        Resource 人 = myMod.createResource(finance + &quot;人&quot;);
        Property 主要收入 = myMod.createProperty(finance + &quot;主要收入&quot;);
        Resource 地产事业 = myMod.createResource(finance + &quot;地产事业&quot;);
        Resource 王健林 = myMod.createResource(finance + &quot;王健林&quot;);
        Resource 万达集团 = myMod.createResource(finance + &quot;万达集团&quot;);
        Property 主要资产 = myMod.createProperty(finance + &quot;主要资产&quot;);


        Property 股东 = myMod.createProperty(finance + &quot;股东&quot;);
        Property 关联交易 = myMod.createProperty(finance + &quot;关联交易&quot;);
        Property 收购 = myMod.createProperty(finance + &quot;收购&quot;);

        Property 主要业务 = myMod.createProperty(finance + &quot;主要业务&quot;);
        Property 竞争对手 = myMod.createProperty(finance + &quot;竞争对手&quot;);

        // 加入三元组
        myMod.add(孙宏斌, 执掌, 融创中国);
        myMod.add(贾跃亭, 执掌, 乐视网);
        myMod.add(王健林, 执掌, 万达集团);
        myMod.add(乐视网, RDF.type, 公司);
        myMod.add(万达集团, RDF.type, 公司);
        myMod.add(融创中国, RDF.type, 地产公司);
        myMod.add(地产公司, RDFS.subClassOf, 公司);
        myMod.add(公司, RDFS.subClassOf, 法人实体);
        myMod.add(孙宏斌, RDF.type, 人);
        myMod.add(贾跃亭, RDF.type, 人);
        myMod.add(王健林, RDF.type, 人);
        myMod.add(万达集团, 主要资产, 地产事业);
        myMod.add(万达集团, 主要业务, &quot;房地产，文娱&quot;);
        myMod.add(融创中国, 主要收入, 地产事业);
        myMod.add(融创中国, 主要业务, &quot;房地产&quot;);
        myMod.add(孙宏斌, 股东, 乐视网);
        myMod.add(孙宏斌, 收购, 万达集团);

        PrintUtil.registerPrefix(&quot;&quot;, finance);

        // 输出当前模型
        StmtIterator i = myMod.listStatements(null, null, (RDFNode) null);
        while (i.hasNext()) &#123;
            System.out.println(&quot; - &quot; + PrintUtil.print(i.nextStatement()));
        &#125;


        GenericRuleReasoner reasoner = (GenericRuleReasoner) GenericRuleReasonerFactory.theInstance().create(null);
        reasoner.setRules(Rule.parseRules(
            &quot;[ruleHoldShare: (?p :执掌 ?c) -&gt; (?p :股东 ?c)] \n&quot;
                + &quot;[ruleConnTrans: (?p :收购 ?c) -&gt; (?p :股东 ?c)] \n&quot;
                + &quot;[ruleConnTrans: (?p :股东 ?c) (?p :股东 ?c2) -&gt; (?c :关联交易 ?c2)] \n&quot;
                + &quot;[ruleCompetitor:: (?c1 :主要业务 ?b1) (?c2 :主要业务 ?b2) notEqual(?c1,?c2) semsim(?b1,?b2,0.6)  -&gt; (?c1 :竞争对手 ?c2)] \n&quot;
                + &quot;-&gt; tableAll().&quot;));
        reasoner.setMode(GenericRuleReasoner.HYBRID);

        InfGraph infgraph = reasoner.bind(myMod.getGraph());
        infgraph.setDerivationLogging(true);

        System.out.println(&quot;推理后...\n&quot;);

        Iterator&lt;Triple&gt; tripleIterator = infgraph.find(null, null, null);
        while (tripleIterator.hasNext()) &#123;
            System.out.println(&quot; - &quot; + PrintUtil.print(tripleIterator.next()));
        &#125;
</code></pre>
<p>运行结果：</p>
<pre><code> - (:万达集团 :关联交易 :乐视网)
 - (:万达集团 :关联交易 :融创中国)
 - (:万达集团 :竞争对手 :融创中国)
 - (:万达集团 :关联交易 :万达集团)
 - (:孙宏斌 :股东 :万达集团)
 - (:孙宏斌 :股东 :融创中国)
 - (:融创中国 :关联交易 :万达集团)
 - (:融创中国 :竞争对手 :万达集团)
 - (:融创中国 :关联交易 :乐视网)
 - (:融创中国 :关联交易 :融创中国)
 - (:乐视网 :关联交易 :万达集团)
 - (:乐视网 :关联交易 :融创中国)
 - (:乐视网 :关联交易 :乐视网)
 - (:贾跃亭 :股东 :乐视网)
 - (:王健林 :股东 :万达集团)
 - (:公司 rdfs:subClassOf :法人实体)
 - (:万达集团 :主要业务 &#39;房地产，文娱&#39;)
 - (:万达集团 :主要资产 :地产事业)
 - (:万达集团 rdf:type :公司)
 - (:地产公司 rdfs:subClassOf :公司)
 - (:融创中国 :主要业务 &#39;房地产&#39;)
 - (:融创中国 :主要收入 :地产事业)
 - (:融创中国 rdf:type :地产公司)
 - (:孙宏斌 :收购 :万达集团)
 - (:孙宏斌 :股东 :乐视网)
 - (:孙宏斌 rdf:type :人)
 - (:孙宏斌 :执掌 :融创中国)
 - (:乐视网 rdf:type :公司)
 - (:贾跃亭 rdf:type :人)
 - (:贾跃亭 :执掌 :乐视网)
 - (:王健林 rdf:type :人)
 - (:王健林 :执掌 :万达集团)
</code></pre>
<p>可以根据需要，扩展更多的builtin，比如运行js，比如http请求。。。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>知识图谱</tag>
        <tag>Jena</tag>
        <tag>推理</tag>
      </tags>
  </entry>
  <entry>
    <title>conda docker镜像</title>
    <url>/jadepeng/2019/09/10/jqpeng-conda%20docker%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/conda-docker.html">conda docker镜像</a></p>
<p>之前的python环境，使用ubuntu安装pip来安装python依赖，但是遇到缺少某些库的版本，比如一个项目需要用到faiss，pip只有最新的1.5.3版本，但是这个版本使用了较新的CPU指令，在老服务器上运行报错：</p>
<p>Illegal instruction (core dumped) - in new version of FAISS #885</p>
<p>github上提示安装旧版本：</p>
<blockquote>
<p>If anyone else is struggling and wanna go back to previous working version, use: conda install faiss-cpu=1.5.1 -c pytorch -y</p>
</blockquote>
<p>遗憾的是，下面的命令不成功，没有1.5.1版本：</p>
<pre><code>pip install faiss-cpu==1.5.1
</code></pre>
<p>转而投向conda。</p>
<p>首先，下载最新的conda安装命令：</p>
<pre><code>wget https://repo.anaconda.com/archive/Anaconda3-2019.07-Linux-x86_64.sh
</code></pre>
<p>然后构建conda的基础镜像，还是以ubuntu:16.04为底包，Dockerfile如下：</p>
<pre><code>from ubuntu:16.04
RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
      bzip2 \
      g++ \
      git \
      graphviz \
      libgl1-mesa-glx \
      libhdf5-dev \
      openmpi-bin \
      wget &amp;&amp; \
    rm -rf /var/lib/apt/lists/*

RUN sed -i &#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list
RUN apt-get update

ADD ./Anaconda3-2019.07-Linux-x86_64.sh ./anaconda.sh

ENV LANG=C.UTF-8 LC_ALL=C.UTF-8
ENV PATH /opt/conda/bin:$PATH
RUN  /bin/bash ./anaconda.sh -b -p /opt/conda  &amp;&amp; rm ./anaconda.sh &amp;&amp; ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh  &amp;&amp; echo &quot;. /opt/conda/etc/profile.d/conda.sh&quot; &gt;&gt; ~/.bashrc &amp;&amp; echo &quot;conda activate base&quot; &gt;&gt; ~/.bashrc &amp;&amp; find /opt/conda/ -follow -type f -name &#39;*.a&#39; -delete &amp;&amp; find /opt/conda/ -follow -type f -name &#39;*.js.map&#39; -delete &amp;&amp;  /opt/conda/bin/conda clean -afy


CMD [ &quot;/bin/bash&quot; ]
</code></pre>
<p>构建：</p>
<pre><code>docker build -t conda3:1.0 .
</code></pre>
<p>后面，就可以以<code>conda3:1.0 .</code>为基础镜像构建需要的镜像，比如我们需要安装faiss-cpu 1.5.1版本</p>
<pre><code>from conda3:1.0

RUN conda install pytorch -y
RUN conda install faiss-cpu=1.5.1 -c pytorch -y


CMD [ &quot;/bin/bash&quot; ]
</code></pre>
<p>构建：</p>
<pre><code>docker build -t conda-faiss:1.0 .
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱推理与实践 (2)  -- 基于jena实现规则推理</title>
    <url>/jadepeng/2019/09/06/jqpeng-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%20(2)%20%20--%20%E5%9F%BA%E4%BA%8Ejena%E5%AE%9E%E7%8E%B0%E8%A7%84%E5%88%99%E6%8E%A8%E7%90%86/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/kg-inference-2.html">知识图谱推理与实践 (2)  – 基于jena实现规则推理</a></p>
<p>本章，介绍 基于<code>jena</code>的规则引擎实现推理，并通过两个例子介绍如何coding实现。</p>
<h2 id="规则引擎概述"><a href="#规则引擎概述" class="headerlink" title="规则引擎概述"></a>规则引擎概述</h2><p>jena包含了一个通用的规则推理机，可以在RDFS和OWL推理机使用，也可以单独使用。</p>
<p>推理机支持在RDF图上推理，提供前向链、后向链和二者混合执行模式。包含RETE engine 和 one tabled datalog engine。可以通过<a href="https://jena.apache.org/documentation/javadoc/jena/org/apache/jena/reasoner/rulesys/GenericRuleReasoner.html">GenericRuleReasoner</a>来进行配置参数，使用各种推理引擎。要使用 <code>GenericRuleReasoner</code>，需要一个规则集来定义其行为.</p>
<h3 id="Rule的语法与结构"><a href="#Rule的语法与结构" class="headerlink" title="Rule的语法与结构"></a>Rule的语法与结构</h3><p>规则通过 <a href="https://jena.apache.org/documentation/javadoc/jena/org/apache/jena/reasoner/rulesys/Rule.html">Rule</a>对象来进行定义，包含 body terms列表 (premises),head terms列表 (conclusions) 和可选的 name 和可选的direction。</p>
<p>An informal description of the simplified text rule syntax is:</p>
<pre><code>_Rule_      :=   _bare-rule_ .
          or   [ _bare-rule_ ]
       or   [ ruleName : _bare-rule_ ]

_bare-rule_ :=   _term_, ... _term_ -&gt; _hterm_, ... _hterm_    // forward rule
          or   _bhterm_ &lt;- _term_, ... _term   _ // backward rule

_hterm     :=   term
_ or   [ _bare-rule_ ]

_term_      :=   (_node_, _node_, _node_)           // triple pattern
          or   (_node_, _node_, _functor_)        // extended triple pattern
          or   builtin(_node_, ... _node_)      // invoke procedural primitive

_bhterm_      :=   (_node_, _node_, _node_)           // triple pattern

_functor_   :=   functorName(_node_, ... _node_)  // structured literal

_node_      :=   _uri-ref_                   // e.g. http://foo.com/eg
          or   prefix:localname          // e.g. rdf:type
          or   &lt;_uri-ref_&gt;          // e.g. &lt;myscheme:myuri&gt;
          or   ?_varname_ // variable
          or   &#39;a literal&#39;                 // a plain string literal
          or   &#39;lex&#39;^^typeURI              // a typed literal, xsd:* type names supported
          or   number                      // e.g. 42 or 25.5
</code></pre>
<p>逗号 “,” 分隔符是可选的.</p>
<p>前向和后向规则语法之间的区别仅与混合执行策略相关，请参见下文。</p>
<p><code>_functor_</code> 是一个扩展的三元组，用于创建和访问文本值。functorName可以是任何简单的标识符。</p>
<p>为保障rules的可读性URI引用支持qname语法。可以使用在 <a href="https://jena.apache.org/documentation/javadoc/jena/org/apache/jena/util/PrintUtil.html">PrintUtil</a>对象中注册的前缀。</p>
<p>下面是一些规则示例：</p>
<pre><code>[allID: (?C rdf:type owl:Restriction), (?C owl:onProperty ?P),
     (?C owl:allValuesFrom ?D)  -&gt; (?C owl:equivalentClass all(?P, ?D)) ]

[all2: (?C rdfs:subClassOf all(?P, ?D)) -&gt; print(&#39;Rule for &#39;, ?C)
    [all1b: (?Y rdf:type ?D) &lt;- (?X ?P ?Y), (?X rdf:type ?C) ] ]

[max1: (?A rdf:type max(?P, 1)), (?A ?P ?B), (?A ?P ?C)
      -&gt; (?B owl:sameAs ?C) ]
</code></pre>
<ul>
<li>Rule <code>allID</code>说明了functor用于将OWL限制的组件收集到单个数据结构中，然后可以触发进一步的规则</li>
<li>Rule <code>all2</code> 表示一个前向规则，它创建了一个新的后向规则，并且还调用了print.</li>
<li>Rule <code>max1</code> 说明了如何使用数字</li>
</ul>
<p>可以使用以下方法加载和解析规则文件：</p>
<pre><code>List rules = Rule.rulesFromURL(&quot;file:myfile.rules&quot;);
</code></pre>
<p>或者</p>
<pre><code>BufferedReader br = / _open reader_ / ;
List rules = Rule.parseRules( Rule.rulesParserFromReader(br) );
</code></pre>
<p>或者</p>
<pre><code>String ruleSrc = / _list of rules in line_ /
List rules = Rule.parseRules( rulesSrc );
</code></pre>
<p>在前两种情况下（从URL或BufferedReader读取），规则文件由一个简单的处理器预处理，该处理器剥离注释并支持一些额外的宏命令：</p>
<dl><dt><code># ...</code></dt>
<dd>注释.</dd>
<dt><code>// ...</code></dt>
<dd>注释</dd>
<dt><code>@prefix pre: &lt;http://domain/url#&gt;.</code></dt>
<dd>定义了一个前缀<code>pre</code>&nbsp;，可以用在规则文件中.</dd>
<dt><code>@include &lt;urlToRuleFile&gt;.</code></dt>
<dd>包含指定规则,允许规则文件包含RDFS和OWL的预定义规则</dd></dl>
完整实例：


<pre><code> @prefix pre: &lt;http://jena.hpl.hp.com/prefix#&gt;. 
 @include &lt;RDFS&gt;. 
 [rule1: (?f pre:father ?a) (?u pre:brother ?f) -&gt; (?u pre:uncle ?a)]
 
</code></pre>
<h2 id="规则推理demo1–喜剧演员"><a href="#规则推理demo1–喜剧演员" class="headerlink" title="规则推理demo1–喜剧演员"></a>规则推理demo1–喜剧演员</h2><p>例如，在一个电影知识图谱里，如果一个演员参演的电影的类型是喜剧片，我们可以认为这个演员是喜剧电影</p>
<p>推理规则：</p>
<pre><code>[ruleComedian: (?p :hasActedIn ?m) (?m :hasGenre ?g) (?g :genreName &#39;喜剧&#39;) -&gt; (?p rdf:type :Comedian)] 
</code></pre>
<p>我们用代码来实现：</p>
<pre><code>         String prefix = &quot;http://www.test.com/kg/#&quot;;
        Graph data = Factory.createGraphMem();

        // 定义节点
        Node movie = NodeFactory.createURI(prefix + &quot;movie&quot;);
        Node hasActedIn = NodeFactory.createURI(prefix + &quot;hasActedIn&quot;);
        Node hasGenre = NodeFactory.createURI(prefix + &quot;hasGenre&quot;);
        Node genreName = NodeFactory.createURI(prefix + &quot;genreName&quot;);
        Node genre = NodeFactory.createURI(prefix + &quot;genre&quot;);
        Node person = NodeFactory.createURI(prefix + &quot;person&quot;);
        Node Comedian = NodeFactory.createURI(prefix + &quot;Comedian&quot;);

        // 添加三元组
        data.add(new Triple(genre, genreName, NodeFactory.createLiteral(&quot;喜剧&quot;)));
        data.add(new Triple(movie, hasGenre, genre));
        data.add(new Triple(person, hasActedIn, movie));        // 创建推理机
        GenericRuleReasoner reasoner = (GenericRuleReasoner) GenericRuleReasonerFactory.theInstance().create(null);
        PrintUtil.registerPrefix(&quot;&quot;, prefix);    // 设置规则
        reasoner.setRules(Rule.parseRules(
                &quot;[ruleComedian: (?p :hasActedIn ?m) (?m :hasGenre ?g) (?g :genreName &#39;喜剧&#39;) -&gt; (?p rdf:type :Comedian)] \n&quot;
                        + &quot;-&gt; tableAll().&quot;));
        reasoner.setMode(GenericRuleReasoner.HYBRID); // HYBRID混合推理

        InfGraph infgraph = reasoner.bind(data);
        infgraph.setDerivationLogging(true);        // 执行推理
        Iterator&lt;Triple&gt; tripleIterator = infgraph.find(person, null, null);

        while (tripleIterator.hasNext()) &#123;
            System.out.println(PrintUtil.print(tripleIterator.next()));
        &#125;
</code></pre>
<p>输出结果：</p>
<pre><code>(:person rdf:type :Comedian)
(:person :hasActedIn :movie)
</code></pre>
<p>可以看到，已经给person加上了Comedian。</p>
<h2 id="规则推理demo2-–-关联交易"><a href="#规则推理demo2-–-关联交易" class="headerlink" title="规则推理demo2 – 关联交易"></a>规则推理demo2 – 关联交易</h2><p>我们再来看上一篇文章中提到的那个金融图谱：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/6/1567758605345.png" alt="金融图谱"></p>
<p>陈华钧老师PPT里，有一个推理任务：</p>
<ol>
<li>执掌一家公司就一定是这家公司的股东；</li>
<li>某人同时是两家公司的股东，那么这两家公司一定有关联交易；</li>
</ol>
<p>PPT里是使用Drools来实现的，具体可以参见PPT。我们这里使用jena来实现，可以达到同样的效果。</p>
<p>首先，构造好图谱，为了方便理解，我们用中文变量：</p>
<pre><code>Model myMod = ModelFactory.createDefaultModel();
        String finance = &quot;http://www.example.org/kse/finance#&quot;;
        Resource 孙宏斌 = myMod.createResource(finance + &quot;孙宏斌&quot;);
        Resource 融创中国 = myMod.createResource(finance + &quot;融创中国&quot;);
        Resource 乐视网 = myMod.createResource(finance + &quot;乐视网&quot;);
        Property 执掌 = myMod.createProperty(finance + &quot;执掌&quot;);
        Resource 贾跃亭 = myMod.createResource(finance + &quot;贾跃亭&quot;);
        Resource 地产公司 = myMod.createResource(finance + &quot;地产公司&quot;);
        Resource 公司 = myMod.createResource(finance + &quot;公司&quot;);
        Resource 法人实体 = myMod.createResource(finance + &quot;法人实体&quot;);
        Resource 人 = myMod.createResource(finance + &quot;人&quot;);
        Property 主要收入 = myMod.createProperty(finance + &quot;主要收入&quot;);
        Resource 地产事业 = myMod.createResource(finance + &quot;地产事业&quot;);
        Resource 王健林 = myMod.createResource(finance + &quot;王健林&quot;);
        Resource 万达集团 = myMod.createResource(finance + &quot;万达集团&quot;);
        Property 主要资产 = myMod.createProperty(finance + &quot;主要资产&quot;);


        Property 股东 = myMod.createProperty(finance + &quot;股东&quot;);
        Property 关联交易 = myMod.createProperty(finance + &quot;关联交易&quot;);
        Property 收购 = myMod.createProperty(finance + &quot;收购&quot;);

        // 加入三元组
        myMod.add(孙宏斌, 执掌, 融创中国);
        myMod.add(贾跃亭, 执掌, 乐视网);
        myMod.add(王健林, 执掌, 万达集团);
        myMod.add(乐视网, RDF.type, 公司);
        myMod.add(万达集团, RDF.type, 公司);
        myMod.add(融创中国, RDF.type, 地产公司);
        myMod.add(地产公司, RDFS.subClassOf, 公司);
        myMod.add(公司, RDFS.subClassOf, 法人实体);
        myMod.add(孙宏斌, RDF.type, 人);
        myMod.add(贾跃亭, RDF.type, 人);
        myMod.add(王健林, RDF.type, 人);
        myMod.add(万达集团,主要资产,地产事业);
        myMod.add(融创中国,主要收入,地产事业);
        myMod.add(孙宏斌, 股东, 乐视网);
        myMod.add(孙宏斌, 收购, 万达集团);

        PrintUtil.registerPrefix(&quot;&quot;, finance);

        // 输出当前模型
        StmtIterator i = myMod.listStatements(null,null,(RDFNode)null);
        while (i.hasNext()) &#123;
            System.out.println(&quot; - &quot; + PrintUtil.print(i.nextStatement()));
        &#125;
</code></pre>
<p>上图所示的图谱，包含如下的三元组：</p>
<pre><code> - (:公司 rdfs:subClassOf :法人实体)
 - (:万达集团 :主要资产 :地产事业)
 - (:万达集团 rdf:type :公司)
 - (:地产公司 rdfs:subClassOf :公司)
 - (:融创中国 :主要收入 :地产事业)
 - (:融创中国 rdf:type :地产公司)
 - (:孙宏斌 :股东 :乐视网)
 - (:孙宏斌 rdf:type :人)
 - (:孙宏斌 :执掌 :融创中国)
 - (:乐视网 rdf:type :公司)
 - (:贾跃亭 rdf:type :人)
 - (:贾跃亭 :执掌 :乐视网)
 - (:王健林 rdf:type :人)
 - (:王健林 :执掌 :万达集团)
</code></pre>
<p>我们来定义推理规则：</p>
<ol>
<li>执掌一家公司就一定是这家公司的股东；</li>
<li>收购一家公司，就是这家公司的股东</li>
<li>某人同时是两家公司的股东，那么这两家公司一定有关联交易；</li>
</ol>
<p>用jena规则来表示：</p>
<pre><code>[ruleHoldShare: (?p :执掌 ?c) -&gt; (?p :股东 ?c)] 
[[ruleHoldShare2: (?p :收购 ?c) -&gt; (?p :股东 ?c)] 
[ruleConnTrans: (?p :股东 ?c) (?p :股东 ?c2) -&gt; (?c :关联交易 ?c2)] 
</code></pre>
<p>执行推理：</p>
<pre><code>         GenericRuleReasoner reasoner = (GenericRuleReasoner) GenericRuleReasonerFactory.theInstance().create(null);
        reasoner.setRules(Rule.parseRules(
                &quot;[ruleHoldShare: (?p :执掌 ?c) -&gt; (?p :股东 ?c)] \n&quot;
                        + &quot;[ruleConnTrans: (?p :收购 ?c) -&gt; (?p :股东 ?c)] \n&quot;
                        + &quot;[ruleConnTrans: (?p :股东 ?c) (?p :股东 ?c2) -&gt; (?c :关联交易 ?c2)] \n&quot;
                        + &quot;-&gt; tableAll().&quot;));
        reasoner.setMode(GenericRuleReasoner.HYBRID);

        InfGraph infgraph = reasoner.bind(myMod.getGraph());
        infgraph.setDerivationLogging(true);

        System.out.println(&quot;推理后...\n&quot;);

        Iterator&lt;Triple&gt; tripleIterator = infgraph.find(null, null, null);
        while (tripleIterator.hasNext()) &#123;
            System.out.println(&quot; - &quot; + PrintUtil.print(tripleIterator.next()));
        &#125;
</code></pre>
<p>输出结果：</p>
<pre><code>推理后...

 - (:万达集团 :关联交易 :乐视网)
 - (:万达集团 :关联交易 :融创中国)
 - (:万达集团 :关联交易 :万达集团)
 - (:孙宏斌 :股东 :万达集团)
 - (:孙宏斌 :股东 :融创中国)
 - (:融创中国 :关联交易 :万达集团)
 - (:融创中国 :关联交易 :乐视网)
 - (:融创中国 :关联交易 :融创中国)
 - (:乐视网 :关联交易 :万达集团)
 - (:乐视网 :关联交易 :融创中国)
 - (:乐视网 :关联交易 :乐视网)
 - (:贾跃亭 :股东 :乐视网)
 - (:王健林 :股东 :万达集团)
 - (:公司 rdfs:subClassOf :法人实体)
 - (:万达集团 :主要资产 :地产事业)
 - (:万达集团 rdf:type :公司)
 - (:地产公司 rdfs:subClassOf :公司)
 - (:融创中国 :主要收入 :地产事业)
 - (:融创中国 rdf:type :地产公司)
 - (:孙宏斌 :收购 :万达集团)
 - (:孙宏斌 :股东 :乐视网)
 - (:孙宏斌 rdf:type :人)
 - (:孙宏斌 :执掌 :融创中国)
 - (:乐视网 rdf:type :公司)
 - (:贾跃亭 rdf:type :人)
 - (:贾跃亭 :执掌 :乐视网)
 - (:王健林 rdf:type :人)
 - (:王健林 :执掌 :万达集团)
</code></pre>
<p>我们看到，推理后孙宏斌是三家公司的股东，三家公司都有关联交易。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>知识图谱</tag>
        <tag>Jena</tag>
        <tag>推理</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱推理与实践（1）</title>
    <url>/jadepeng/2019/09/05/jqpeng-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/kg-inference-1.html">知识图谱推理与实践（1）</a></p>
<p>由于工作原因，需要在系统里建立图谱推理功能，因此简单学习了浙江大学 陈华钧教授 知识图谱导论课程课件，这里记录下学习笔记。</p>
<h2 id="知识图谱推理的主要方法"><a href="#知识图谱推理的主要方法" class="headerlink" title="知识图谱推理的主要方法"></a>知识图谱推理的主要方法</h2><p>•  基于描述逻辑的推理（如DL-based）<br> •  基于图结构和统计规则挖掘的推理（如： PRA、 AMIE）<br> •  基于知识图谱表⽰学习的推理（如： TransE）<br> •  基于概率逻辑的⽅法（如： Statistical Relational Learning）</p>
<p><strong>基于符号逻辑的推理——本体推理</strong></p>
<ul>
<li>传统的符号逻辑推理中主要与知识图谱有关的推理手段是基于描述逻辑的本体推理。</li>
<li>描述逻辑主要被⽤来对事物的本体进⾏建模和推理，⽤来描述和推断概念分类及其概念之间的关系。</li>
<li>主要方法：<ul>
<li>基于表运算（Tableaux）及改进的⽅法： FaCT++、 Racer、 Pellet    Hermit等</li>
<li>基于Datalog转换的⽅法如KAON、 RDFox等</li>
<li>基于产⽣式规则的算法（如rete）： Jena 、 Sesame、 OWLIM等</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567654565558.png" alt="本体推理"></p>
<p><strong>基于图结构和统计规则挖掘的推理</strong></p>
<p>主要方法：<br> • 基于路径排序学习⽅法(PRA， Path    ranking    Algorithm)<br> • 基于关联规则挖掘⽅法(AMIE)</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567654649499.png" alt="基于图结构和统计规则挖掘的推理"></p>
<p><strong>基于知识图谱表示学习的关系推理</strong></p>
<ul>
<li>将实体和关系都表示为向量</li>
<li>通过向量之间的计算代替图的遍历和搜索来预测三元组的存在，由于向量的表示已经包含了实体原有的语义信息，计算含有⼀定的推理能⼒。</li>
<li>可应⽤于链接预测，基于路径的多度查询等</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567654752888.png" alt="表示学习推理"></p>
<p><strong>基于概率逻辑的⽅法——Statistical Relational Learning</strong></p>
<p>概率逻辑学习有时也叫Relational Machine Learning (RML)，关注关系的不确定性和复杂性。<br> 通常使用Bayesian networks or Markov networks</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567655004326.png" alt="PSL"></p>
<h2 id="基于符号逻辑的推理"><a href="#基于符号逻辑的推理" class="headerlink" title="基于符号逻辑的推理"></a>基于符号逻辑的推理</h2><h3 id="本体概念推理"><a href="#本体概念推理" class="headerlink" title="本体概念推理"></a>本体概念推理</h3><p>图谱中基于RDF来作为资源描述语言，RDF是<strong>R</strong>esource <strong>D</strong>escription <strong>F</strong>ramework的简称。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567655169157.png" alt="RDF"></p>
<p>但是RDF表示关系层次受限，因此有了RDFS,在RDF的基础上，新增了<code>Class, subClassOf, type, Property, subPropertyOf, Domain, Range</code> 词汇，可以更好的表述相关关系。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567655092663.png" alt="RDFS"></p>
<p>基于RDFS，可以做一些简单的推理</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567655311654.png" alt="RDFS推理"></p>
<p>OWL在RDFS的基础上，进一步扩展了一些复杂类型、约束：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567655366415.png" alt="OWL"></p>
<p>因此，我们也叫OWL为本体语言：</p>
<ul>
<li>OWL是知识图谱语言中最规范， 最严谨， 表达能力最强的语言</li>
<li>基于RDF语法，使表示出来的文档具有语义理解的结构基础</li>
<li>促进了统一词汇表的使用，定义了丰富的语义词汇</li>
<li>允许逻辑推理</li>
</ul>
<p>OWL的描述逻辑系统：</p>
<ul>
<li>一个描述逻辑系统包括四个基本的组成部分<ul>
<li>1）最基本的元素： <strong>概念</strong>、<strong>关系</strong>和<strong>个体</strong>（实例），</li>
<li><ol>
<li><strong>TBox</strong>术语集 (概念术语的公理集合) - 泛化的知识</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>    - 描述概念和关系的知识，被称之为公理 (Axiom)
- 1. **ABox断言集** (个体的断言集合)  --具体个体的信息


    - ABox包含外延知识 (又称断言 (Assertion))，描述论域中  
</code></pre>
<p>的特定个体<br>    - 1. <strong>TBox</strong>和<strong>ABox</strong>上的推理机制</p>
<ul>
<li>不同的描述逻辑系统的表示能力与推理机制由于对这四个组成部分的不同选择而不同</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567661842222.png" alt="描述逻辑的语义"></p>
<p>描述逻辑与OWL的对应：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567661923597.png" alt="OWL"></p>
<p>推理就是通过各种方法获取新的知识或者结论，这些知识和结论满足语义。</p>
<p>OWL本体推理</p>
<ul>
<li>可满足性<ul>
<li>本体可满足性： 检查一个本体是否可满足，即检查该本体是否有模型。</li>
<li>概念可满足性，检查某一概念的可满足性，即检查是否有模型，使得对该概念的解释不是空集。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567662582451.png" alt="可满足性"></p>
<ul>
<li>分类(classification)，针对Tbox的推理，计算新的概念的包含关系</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567662678216.png" alt="分类"></p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567662764038.png" alt="分类"></p>
<ul>
<li>实例化（materialization）,即计算属于某个概念或关系的所有实例的集合。</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567662840156.png" alt="实例化"></p>
<p>例子：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567662888484.png" alt="实例化选股"></p>
<p>典型的推理算法： Tableaux，适用于检查某一本体概念的可满足性，以及实例检测，基本思想是通过一系列规则构建Abox，以检测可满足性，或者检测某一实例是否存在于某概念，基本思想类似于一阶逻辑的归结反驳。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567663199419.png" alt="Tableaux"></p>
<h3 id="基于逻辑编程改写的方法"><a href="#基于逻辑编程改写的方法" class="headerlink" title="基于逻辑编程改写的方法"></a>基于逻辑编程改写的方法</h3><p>本体推理的局限:</p>
<ul>
<li>(1) 仅支持预定义的本体公理上的推理 (无法针对自定义的词汇支持灵活推理)</li>
<li>(2) 用户无法定义自己的推理过程</li>
</ul>
<p>因此，引入规则推理</p>
<ul>
<li>(1) 可以根据特定的场景定制规则，以实现用户自定义的推理过程</li>
<li>(2) Datalog语言可以结合本体推理和规则推理</li>
</ul>
<p>Datalog的语法：</p>
<ul>
<li>原子（atom）<ul>
<li>p(t1,t2,…,tn)</li>
<li>p是谓词，n是目数，ti是项</li>
<li>例如has_child(x,y)</li>
</ul>
</li>
<li>规则（rule）<ul>
<li>H:-B1,B2,…,Bm</li>
<li>has_child(X, Y) :−has_son(X, Y)</li>
</ul>
</li>
<li>事实(Fact)<ul>
<li>F(c1,c2,…cn):-</li>
<li>没有体部且没有变量的规则</li>
<li>例如：has_child(Alice,Bob):-</li>
</ul>
</li>
</ul>
<p>Datalog程序是规则的集合：</p>
<pre><code>has_child(X, Y) : −has_son(X, Y).
has_child(Alice, Bob) : −
</code></pre>
<p>Datalog 推理举例：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567663914942.png" alt="Datalog推理举例"></p>
<p>相关工具：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567663998133.png" alt="datalog工具"></p>
<h3 id="基于产生式规则的方法"><a href="#基于产生式规则的方法" class="headerlink" title="基于产生式规则的方法"></a>基于产生式规则的方法</h3><p>产生式系统，一种前向推理系统，可以按照一定机制执行规则从而达到某些目标，与一阶逻辑类似，也有区别，可以应用来做自动规划和专家系统。</p>
<p>产生式系统的组成：</p>
<ul>
<li>事实集合 (Working Memory)</li>
<li>产生式/规则集合 (Production Memory, PM)</li>
<li>推理引擎</li>
</ul>
<p><strong>产生式表示：</strong></p>
<p><strong>IF</strong> <em>conditions</em> <strong>THEN</strong> <em>actions</em></p>
<ul>
<li>conditions是由条件组成的集合，又称为LHS（Left Hand Side）</li>
<li>actions是由动作组成的序列，又称为RHS（Right Hand Side)</li>
</ul>
<p>LHS，是条件的集合，各条件是<strong>且</strong>（AND）的关系，当所有条件均被满足，则该规则触发。<br> 条件形如(type attr1: spec1 attr2:spec2)条件的形式：</p>
<ul>
<li>原子 (person name:alice)</li>
<li>变量（person name:x)</li>
<li>表达式 (person age:[n+4]</li>
<li>布尔  (person age:{&gt;10})</li>
<li>约束的与、或、非</li>
</ul>
<p>RHS，是执行动作（action）的序列，执行时依次运行。动作的种类有ADD pattern，Remove i，Modify i，可以理解为对WME（Working Memory）的CUD；</p>
<p>产生式举例：</p>
<pre><code>IF (Student name: x)
Then ADD (Person name: x)
</code></pre>
<p>也可以写作：</p>
<pre><code>(Student name: x) ⇒ ADD (Person name: x)
</code></pre>
<p><strong>推理引擎</strong></p>
<p>➤ 控制系统的执行：</p>
<ul>
<li>模式匹配，用规则的条件部分匹配事实集中的事实，整个LHS都被满足的规，则被触发，并被加入议程(agenda)</li>
<li>解决冲突，按一定的策略从被触发的多条规则中选择一条</li>
<li>执行动作，执行被选择出来的规则的RHS，从而对WM进行一定的操作</li>
</ul>
<blockquote>
<p>产生式系统=事实集+产生式集合+推理引擎</p>
</blockquote>
<p>产生式系统执行流程</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567664825865.png" alt="产生式系统执行流程"></p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567664993490.png" alt="匹配举例"></p>
<p>模式匹配——RETE算法</p>
<ul>
<li>将产生式的LHS组织成判别网络形式</li>
<li>用空间换时间</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567665661458.png" alt="RETE算法"></p>
<p>相关工具介绍</p>
<ul>
<li>Drools</li>
<li>Jena  提供了处理RDF、 RDFS、 OWL数据的接口，还提供了一个规则引擎</li>
</ul>
<pre><code>Model m = ModelFactory.createDefaultModel(); 
Reasoner reasoner = new
GenericRuleReasoner(Rule.rulesFromURL(&quot;file:rule.txt&quot;));
InfModel inf = ModelFactory.createInfModel(reasoner, m)
</code></pre>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567666453041.png" alt="相关工具"></p>
<h2 id="Inductive-Reasoning-–-基于图的方法"><a href="#Inductive-Reasoning-–-基于图的方法" class="headerlink" title="Inductive Reasoning – 基于图的方法"></a>Inductive Reasoning – 基于图的方法</h2><h3 id="PRA"><a href="#PRA" class="headerlink" title="PRA"></a>PRA</h3><p>➤ 将连接两个实体的路径作为特征来预测其间可能存在的关系</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567666584899.png" alt="Inductive Reasoning"></p>
<p>• 通用关系学习框架 (generic relational learning framework)</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567666662380.png" alt="PRA"></p>
<p>路径排序算法 – Path Ranking Algorithm (PRA)</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567666738103.png" alt="PRA2"></p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667132068.png" alt="enter description here"></p>
<h3 id="TransE"><a href="#TransE" class="headerlink" title="TransE"></a>TransE</h3><p>知识图谱嵌⼊模型： TransE</p>
<p>TransE(Translating Embeddings for Modeling Multi-relational Data. NIPS 3013)</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667166879.png" alt="TransE"></p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667213371.png"></p>
<p>⽬标函数：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667274835.png" alt="TransE"></p>
<p>损失函数：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667306669.png" alt="TransE 损失函数"></p>
<p>知识图谱嵌⼊模型： 预测问题</p>
<ul>
<li>测试三元组( h, r, t )</li>
<li>尾实体预测( h, r, ? )</li>
<li>头实体预测( ?, r, t )</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667416512.png" alt="图嵌入预测"></p>
<h3 id="PRA-vs-TransE"><a href="#PRA-vs-TransE" class="headerlink" title="PRA vs. TransE"></a>PRA vs. TransE</h3><p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667540090.png" alt="PRA"></p>
<h2 id="基于Jena实现演绎推理"><a href="#基于Jena实现演绎推理" class="headerlink" title="基于Jena实现演绎推理"></a>基于Jena实现演绎推理</h2><p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667584143.png" alt="实践图谱"></p>
<h3 id="构建model"><a href="#构建model" class="headerlink" title="构建model"></a>构建model</h3><p>NO BB, show code：</p>
<pre><code>Model myMod = ModelFactory.createDefaultModel();
String finance = “http://www.example.org/kse/finance#”;

// 实体
Resource shb = myMod.createResource(finance + &quot;孙宏斌&quot;);
Resource rczg = myMod.createResource(finance + &quot;融创中国&quot;);


// 关系

Property control = myMod.createProperty(finance + &quot;执掌&quot;);

// 加入三元组
myMod.add(shb, control, rczg);
</code></pre>
<p>上图所示的图谱，包含如下的三元组：</p>
<pre><code>finance :孙宏斌 finance :control finance :融创中国
finance :贾跃亭 finance :control finance :乐视网
finance :融创中国 rdf:type finance :地产公司
finance :地产公司 rdfs:subclassOf finance:公司
finance:公司 rdfs:subclassOf finance:法人实体
finance:孙宏斌 rdf:type finance:公司
finance:孙宏斌 rdf:type finance:人
finance :人 owl:disjointWith finance:公司
</code></pre>
<p>我们可以依次加入，代码略。</p>
<h3 id="添加推理机"><a href="#添加推理机" class="headerlink" title="添加推理机"></a>添加推理机</h3><p>jena推理使用的是InfModel，可以基于Model构造，实际上在原来的Model之上加了个RDFS推理机</p>
<pre><code>InfModel inf_rdfs = ModelFactory.createRDFSModel(myMod);
</code></pre>
<p>• 上下位推理</p>
<p>通过listStatements来获取是否有满足条件的三元组，从而实现判断，subClassOf是RDFS里的vob，因此使用RDFS.subClassOf。</p>
<pre><code>public static void subClassOf(Model m, Resource s, Resource o) &#123;
for (StmtIterator i = m.listStatements(s, RDFS.subClassOf, o); i.hasNext(); ) &#123;
Statement stmt = i.nextStatement();
System.out.println(&quot; yes! &quot; );
break;
&#125;
&#125;

subClassOf(inf_rdfs, myMod.getResource(finance+&quot;地产公司&quot;),myMod.getResource(finance+”法人实体&quot;));
</code></pre>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567667888587.png" alt="enter description here"></p>
<p>• 针对类别的推理，OWL推理机可以针对个体类别做出完备推理，即补充完整该个体的所有类别；在查询的时候，可以直接打印出所有类别！</p>
<p>首先构建owl推理机：</p>
<pre><code>Reasoner reasoner = ReasonerRegistry.getOWLReasoner();
InfModel inf_owl = ModelFactory.createInfModel(reasoner, myMod);
</code></pre>
<p>然后执行类别推理</p>
<pre><code>public static void printStatements(Model m, Resource s, Property p, Resource o) &#123;
for (StmtIterator i = m.listStatements(s,p,o); i.hasNext(); ) &#123;
Statement stmt = i.nextStatement();
System.out.println(&quot; - &quot; + PrintUtil.print(stmt));
&#125;
&#125;
printStatements(inf_owl, rczg, RDF.type, null);
</code></pre>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567668055162.png" alt="enter description here"></p>
<p>• 不一致检测, jena的另一个常用推理就是检验data的不一致。</p>
<pre><code>Model data = FileManager.get().loadModel(fname);
Reasoner reasoner = ReasonerRegistry.getOWLReasoner();
InfModel inf_owl = ModelFactory.createInfModel(reasoner, myMod);
ValidityReport validity = inf_owl.validate();
if (validity.isValid()) &#123;
System.out.println(“没有不一致&quot;);
&#125; else &#123;
System.out.println(“存在不一致，如下： &quot;);
for (Iterator i = validity.getReports(); i.hasNext(); ) &#123;
System.out.println(&quot; - &quot; + i.next());
&#125;
&#125;
</code></pre>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/9/5/1567668144683.png" alt="enter description here"></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>知识图谱</tag>
        <tag>Jena</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker swarm 获取service的container信息</title>
    <url>/jadepeng/2019/09/03/jqpeng-Docker%20swarm%20%E8%8E%B7%E5%8F%96service%E7%9A%84container%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/docker-service-container.html">Docker swarm 获取service的container信息</a></p>
<p>我们可以通过<code>docker service create</code>创建服务，例如：</p>
<pre><code>docker service create --name mysql mysql:latest
</code></pre>
<p>服务创建好后，如何来获取该service包含的容器信息呢？比如获取刚才创建的mysql服务的容器。我们可以通过docker service ps命令来获取，</p>
<h2 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h2><pre><code>~# docker service ps mysql
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE        ERROR               PORTS
lvskmv1lkhz6        mysql.1             mysql:latest        docker86-9          Running             Running 3 days ago 
</code></pre>
<p>遗憾的是返回的数据不包含containerId，只有serviceId, 可以通过<code>docker inspect来获取service详情</code></p>
<pre><code>~# docker inspect lvskmv1lkhz6
[
    &#123;
        &quot;ID&quot;: &quot;lvskmv1lkhz6bvynfuxa0jqgn&quot;,
        &quot;Version&quot;: &#123;
            &quot;Index&quot;: 21
        &#125;,
        &quot;CreatedAt&quot;: &quot;2019-08-30T08:04:18.382831966Z&quot;,
        &quot;UpdatedAt&quot;: &quot;2019-08-30T08:09:43.613636037Z&quot;,
        &quot;Labels&quot;: &#123;&#125;,
        &quot;Spec&quot;: &#123;
            &quot;ContainerSpec&quot;: &#123;
                &quot;Image&quot;: &quot;mysql:latest@sha256:01cf53f2538aa805bda591d83f107c394adca8d31f98eacd3654e282dada3193&quot;,
                &quot;Env&quot;: [
                    &quot;MYSQL_ROOT_PASSWORD=aimind@mysql2019\&quot;&quot;
                ],
                &quot;Isolation&quot;: &quot;default&quot;
            &#125;,
            &quot;Resources&quot;: &#123;
                &quot;Limits&quot;: &#123;&#125;,
                &quot;Reservations&quot;: &#123;&#125;
            &#125;,
            &quot;RestartPolicy&quot;: &#123;
                &quot;Condition&quot;: &quot;any&quot;,
                &quot;Delay&quot;: 5000000000,
                &quot;MaxAttempts&quot;: 0,
                &quot;Window&quot;: 0
            &#125;,
            &quot;Placement&quot;: &#123;&#125;,
            &quot;ForceUpdate&quot;: 0
        &#125;,
        &quot;ServiceID&quot;: &quot;uporil7xf4rwffa0rhg1j5htw&quot;,
        &quot;Slot&quot;: 1,
        &quot;NodeID&quot;: &quot;sixp62dhqe702b69pm6v8m9rh&quot;,
        &quot;Status&quot;: &#123;
            &quot;Timestamp&quot;: &quot;2019-08-30T08:09:43.554514932Z&quot;,
            &quot;State&quot;: &quot;running&quot;,
            &quot;Message&quot;: &quot;started&quot;,
            &quot;ContainerStatus&quot;: &#123;
                &quot;ContainerID&quot;: &quot;2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08&quot;,
                &quot;PID&quot;: 14884,
                &quot;ExitCode&quot;: 0
            &#125;,
            &quot;PortStatus&quot;: &#123;&#125;
        &#125;,
        &quot;DesiredState&quot;: &quot;running&quot;,
        &quot;NetworksAttachments&quot;: [
            &#123;
                &quot;Network&quot;: &#123;
                    &quot;ID&quot;: &quot;emypqxzjggws7uicersyz6uag&quot;,
                    &quot;Version&quot;: &#123;
                        &quot;Index&quot;: 12
                    &#125;,
                    &quot;CreatedAt&quot;: &quot;2019-08-30T08:02:57.254494392Z&quot;,
                    &quot;UpdatedAt&quot;: &quot;2019-08-30T08:02:57.271216394Z&quot;,
                    &quot;Spec&quot;: &#123;
                        &quot;Name&quot;: &quot;aimind-overlay&quot;,
                        &quot;Labels&quot;: &#123;&#125;,
                        &quot;DriverConfiguration&quot;: &#123;
                            &quot;Name&quot;: &quot;overlay&quot;
                        &#125;,
                        &quot;IPAMOptions&quot;: &#123;
                            &quot;Driver&quot;: &#123;
                                &quot;Name&quot;: &quot;default&quot;
                            &#125;
                        &#125;,
                        &quot;Scope&quot;: &quot;swarm&quot;
                    &#125;,
                    &quot;DriverState&quot;: &#123;
                        &quot;Name&quot;: &quot;overlay&quot;,
                        &quot;Options&quot;: &#123;
                            &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;4097&quot;
                        &#125;
                    &#125;,
                    &quot;IPAMOptions&quot;: &#123;
                        &quot;Driver&quot;: &#123;
                            &quot;Name&quot;: &quot;default&quot;
                        &#125;,
                        &quot;Configs&quot;: [
                            &#123;
                                &quot;Subnet&quot;: &quot;10.0.0.0/24&quot;,
                                &quot;Gateway&quot;: &quot;10.0.0.1&quot;
                            &#125;
                        ]
                    &#125;
                &#125;,
                &quot;Addresses&quot;: [
                    &quot;10.0.0.4/24&quot;
                ]
            &#125;
        ]
    &#125;
]
</code></pre>
<p>返回的json中，<code>NodeID</code>是所在节点ID，<code>Status.ContainerStatus</code> 是容器的状态信息，<code>.Status.ContainerStatus.ContainerID</code> 是容器ID，比如这里的是<code>2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08</code>。</p>
<p>拿到容器ID就能获取容器详情了，也可以获取container的统计信息：</p>
<pre><code>docker inspect 2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08
[
    &#123;
        &quot;Id&quot;: &quot;2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08&quot;,
        &quot;Created&quot;: &quot;2019-08-30T08:09:41.827551223Z&quot;,
        &quot;Path&quot;: &quot;docker-entrypoint.sh&quot;,
        &quot;Args&quot;: [
            &quot;mysqld&quot;
        ],
        &quot;State&quot;: &#123;
            &quot;Status&quot;: &quot;running&quot;,
            &quot;Running&quot;: true,
            &quot;Paused&quot;: false,
            &quot;Restarting&quot;: false,
            &quot;OOMKilled&quot;: false,
            &quot;Dead&quot;: false,
            &quot;Pid&quot;: 14884,
            &quot;ExitCode&quot;: 0,
            &quot;Error&quot;: &quot;&quot;,
            &quot;StartedAt&quot;: &quot;2019-08-30T08:09:43.402630785Z&quot;,
            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;
        &#125;,
        &quot;Image&quot;: &quot;sha256:62a9f311b99c24c0fde0a772abc6030bc48e5acc7d7416b8eeb72d3da1b4eb6c&quot;,
        &quot;ResolvConfPath&quot;: &quot;/data/docker/containers/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08/resolv.conf&quot;,
        &quot;HostnamePath&quot;: &quot;/data/docker/containers/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08/hostname&quot;,
        &quot;HostsPath&quot;: &quot;/data/docker/containers/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08/hosts&quot;,
        &quot;LogPath&quot;: &quot;/data/docker/containers/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08-json.log&quot;,
        &quot;Name&quot;: &quot;/mysql.1.lvskmv1lkhz6bvynfuxa0jqgn&quot;,
        &quot;RestartCount&quot;: 0,
        &quot;Driver&quot;: &quot;overlay2&quot;,
        &quot;Platform&quot;: &quot;linux&quot;,
        &quot;MountLabel&quot;: &quot;&quot;,
        &quot;ProcessLabel&quot;: &quot;&quot;,
        &quot;AppArmorProfile&quot;: &quot;docker-default&quot;,
        &quot;ExecIDs&quot;: null,
        &quot;HostConfig&quot;: &#123;
            &quot;Binds&quot;: null,
            &quot;ContainerIDFile&quot;: &quot;&quot;,
            &quot;LogConfig&quot;: &#123;
                &quot;Type&quot;: &quot;json-file&quot;,
                &quot;Config&quot;: &#123;
                    &quot;max-file&quot;: &quot;3&quot;,
                    &quot;max-size&quot;: &quot;10m&quot;
                &#125;
            &#125;,
            &quot;NetworkMode&quot;: &quot;default&quot;,
            &quot;PortBindings&quot;: &#123;&#125;,
            &quot;RestartPolicy&quot;: &#123;
                &quot;Name&quot;: &quot;&quot;,
                &quot;MaximumRetryCount&quot;: 0
            &#125;,
            &quot;AutoRemove&quot;: false,
            &quot;VolumeDriver&quot;: &quot;&quot;,
            &quot;VolumesFrom&quot;: null,
            &quot;CapAdd&quot;: null,
            &quot;CapDrop&quot;: null,
            &quot;Dns&quot;: null,
            &quot;DnsOptions&quot;: null,
            &quot;DnsSearch&quot;: null,
            &quot;ExtraHosts&quot;: null,
            &quot;GroupAdd&quot;: null,
            &quot;IpcMode&quot;: &quot;shareable&quot;,
            &quot;Cgroup&quot;: &quot;&quot;,
            &quot;Links&quot;: null,
            &quot;OomScoreAdj&quot;: 0,
            &quot;PidMode&quot;: &quot;&quot;,
            &quot;Privileged&quot;: false,
            &quot;PublishAllPorts&quot;: false,
            &quot;ReadonlyRootfs&quot;: false,
            &quot;SecurityOpt&quot;: null,
            &quot;UTSMode&quot;: &quot;&quot;,
            &quot;UsernsMode&quot;: &quot;&quot;,
            &quot;ShmSize&quot;: 67108864,
            &quot;Runtime&quot;: &quot;runc&quot;,
            &quot;ConsoleSize&quot;: [
                0,
                0
            ],
            &quot;Isolation&quot;: &quot;default&quot;,
            &quot;CpuShares&quot;: 0,
            &quot;Memory&quot;: 0,
            &quot;NanoCpus&quot;: 0,
            &quot;CgroupParent&quot;: &quot;&quot;,
            &quot;BlkioWeight&quot;: 0,
            &quot;BlkioWeightDevice&quot;: null,
            &quot;BlkioDeviceReadBps&quot;: null,
            &quot;BlkioDeviceWriteBps&quot;: null,
            &quot;BlkioDeviceReadIOps&quot;: null,
            &quot;BlkioDeviceWriteIOps&quot;: null,
            &quot;CpuPeriod&quot;: 0,
            &quot;CpuQuota&quot;: 0,
            &quot;CpuRealtimePeriod&quot;: 0,
            &quot;CpuRealtimeRuntime&quot;: 0,
            &quot;CpusetCpus&quot;: &quot;&quot;,
            &quot;CpusetMems&quot;: &quot;&quot;,
            &quot;Devices&quot;: null,
            &quot;DeviceCgroupRules&quot;: null,
            &quot;DiskQuota&quot;: 0,
            &quot;KernelMemory&quot;: 0,
            &quot;MemoryReservation&quot;: 0,
            &quot;MemorySwap&quot;: 0,
            &quot;MemorySwappiness&quot;: null,
            &quot;OomKillDisable&quot;: false,
            &quot;PidsLimit&quot;: 0,
            &quot;Ulimits&quot;: null,
            &quot;CpuCount&quot;: 0,
            &quot;CpuPercent&quot;: 0,
            &quot;IOMaximumIOps&quot;: 0,
            &quot;IOMaximumBandwidth&quot;: 0,
            &quot;MaskedPaths&quot;: [
                &quot;/proc/acpi&quot;,
                &quot;/proc/kcore&quot;,
                &quot;/proc/keys&quot;,
                &quot;/proc/latency_stats&quot;,
                &quot;/proc/timer_list&quot;,
                &quot;/proc/timer_stats&quot;,
                &quot;/proc/sched_debug&quot;,
                &quot;/proc/scsi&quot;,
                &quot;/sys/firmware&quot;
            ],
            &quot;ReadonlyPaths&quot;: [
                &quot;/proc/asound&quot;,
                &quot;/proc/bus&quot;,
                &quot;/proc/fs&quot;,
                &quot;/proc/irq&quot;,
                &quot;/proc/sys&quot;,
                &quot;/proc/sysrq-trigger&quot;
            ]
        &#125;,
        &quot;GraphDriver&quot;: &#123;
            &quot;Data&quot;: &#123;
                &quot;LowerDir&quot;: &quot;/data/docker/overlay2/f0184a2c979eef7a135726a49f5651e16b568ecfd47606e20e504e28ea311f25-init/diff:/data/docker/overlay2/644c4c905af78d3320559b9f388631151dcf5c19ab8f2c91999d4d59c8409784/diff:/data/docker/overlay2/7ed834798bd5eeef1b75d012a27bb01cd8a0a5e71048db72a8743980481bb74b/diff:/data/docker/overlay2/56e3eac1c86a9ae29b3251025824f93b78e43151a36eb973407feb1075d8db1c/diff:/data/docker/overlay2/40161cfa334a118eaa09c04dc7d864d00e3544f77e6979584298478f68566bc5/diff:/data/docker/overlay2/e884a3df3e827368a468a4afc8850de4fa6336a78ca9a922406237e3ab75a97e/diff:/data/docker/overlay2/a04e8776674f902eaa0e15467ad0678f03baf2a1b8a568b034ad4b4c1ddb1a23/diff:/data/docker/overlay2/7745739e901232d6b702b599844157583d02a34fa4aca10c888e0e9c44075433/diff:/data/docker/overlay2/f423b8f55475ec902cea1ea5c54897ed6a24da3cc0acd64a79e022e887d83e77/diff:/data/docker/overlay2/231e63e7fbb5084facc93c89ed23d366d915f9a2edd4f85735df5d45bc87cafa/diff:/data/docker/overlay2/c11047327e6f47e49d1abee4df8acbaba51ac6b92e59801ac613331c5bad3bc1/diff:/data/docker/overlay2/f893602043c1b5ad9d2839ec0ab8f17da7e0eaf073788f6c3d35138dfe6c06b8/diff:/data/docker/overlay2/3443517fc9e882df67d9730a9aa7530dc3c541b6872aaf05290c5e7ec588e0fb/diff&quot;,
                &quot;MergedDir&quot;: &quot;/data/docker/overlay2/f0184a2c979eef7a135726a49f5651e16b568ecfd47606e20e504e28ea311f25/merged&quot;,
                &quot;UpperDir&quot;: &quot;/data/docker/overlay2/f0184a2c979eef7a135726a49f5651e16b568ecfd47606e20e504e28ea311f25/diff&quot;,
                &quot;WorkDir&quot;: &quot;/data/docker/overlay2/f0184a2c979eef7a135726a49f5651e16b568ecfd47606e20e504e28ea311f25/work&quot;
            &#125;,
            &quot;Name&quot;: &quot;overlay2&quot;
        &#125;,
        &quot;Mounts&quot;: [
            &#123;
                &quot;Type&quot;: &quot;volume&quot;,
                &quot;Name&quot;: &quot;c2128d05001b8fec1712807f381e2c72d42ce8a83ae97f6b038f51c0d48446f1&quot;,
                &quot;Source&quot;: &quot;/data/docker/volumes/c2128d05001b8fec1712807f381e2c72d42ce8a83ae97f6b038f51c0d48446f1/_data&quot;,
                &quot;Destination&quot;: &quot;/var/lib/mysql&quot;,
                &quot;Driver&quot;: &quot;local&quot;,
                &quot;Mode&quot;: &quot;&quot;,
                &quot;RW&quot;: true,
                &quot;Propagation&quot;: &quot;&quot;
            &#125;
        ],
        &quot;Config&quot;: &#123;
            &quot;Hostname&quot;: &quot;2cf128f77797&quot;,
            &quot;Domainname&quot;: &quot;&quot;,
            &quot;User&quot;: &quot;&quot;,
            &quot;AttachStdin&quot;: false,
            &quot;AttachStdout&quot;: false,
            &quot;AttachStderr&quot;: false,
            &quot;ExposedPorts&quot;: &#123;
                &quot;3306/tcp&quot;: &#123;&#125;,
                &quot;33060/tcp&quot;: &#123;&#125;
            &#125;,
            &quot;Tty&quot;: false,
            &quot;OpenStdin&quot;: false,
            &quot;StdinOnce&quot;: false,
            &quot;Env&quot;: [
                &quot;MYSQL_ROOT_PASSWORD=aimind@mysql2019\&quot;&quot;,
                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,
                &quot;GOSU_VERSION=1.7&quot;,
                &quot;MYSQL_MAJOR=8.0&quot;,
                &quot;MYSQL_VERSION=8.0.17-1debian9&quot;
            ],
            &quot;Cmd&quot;: [
                &quot;mysqld&quot;
            ],
            &quot;ArgsEscaped&quot;: true,
            &quot;Image&quot;: &quot;mysql:latest@sha256:01cf53f2538aa805bda591d83f107c394adca8d31f98eacd3654e282dada3193&quot;,
            &quot;Volumes&quot;: &#123;
                &quot;/var/lib/mysql&quot;: &#123;&#125;
            &#125;,
            &quot;WorkingDir&quot;: &quot;&quot;,
            &quot;Entrypoint&quot;: [
                &quot;docker-entrypoint.sh&quot;
            ],
            &quot;OnBuild&quot;: null,
            &quot;Labels&quot;: &#123;
                &quot;com.docker.swarm.node.id&quot;: &quot;sixp62dhqe702b69pm6v8m9rh&quot;,
                &quot;com.docker.swarm.service.id&quot;: &quot;uporil7xf4rwffa0rhg1j5htw&quot;,
                &quot;com.docker.swarm.service.name&quot;: &quot;mysql&quot;,
                &quot;com.docker.swarm.task&quot;: &quot;&quot;,
                &quot;com.docker.swarm.task.id&quot;: &quot;lvskmv1lkhz6bvynfuxa0jqgn&quot;,
                &quot;com.docker.swarm.task.name&quot;: &quot;mysql.1.lvskmv1lkhz6bvynfuxa0jqgn&quot;
            &#125;
        &#125;,
        &quot;NetworkSettings&quot;: &#123;
            &quot;Bridge&quot;: &quot;&quot;,
            &quot;SandboxID&quot;: &quot;459ab4b83580513da251182d08dc217d0079613d10952df00ffcca6e2537958b&quot;,
            &quot;HairpinMode&quot;: false,
            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,
            &quot;LinkLocalIPv6PrefixLen&quot;: 0,
            &quot;Ports&quot;: &#123;
                &quot;3306/tcp&quot;: null,
                &quot;33060/tcp&quot;: null
            &#125;,
            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/459ab4b83580&quot;,
            &quot;SecondaryIPAddresses&quot;: null,
            &quot;SecondaryIPv6Addresses&quot;: null,
            &quot;EndpointID&quot;: &quot;&quot;,
            &quot;Gateway&quot;: &quot;&quot;,
            &quot;GlobalIPv6Address&quot;: &quot;&quot;,
            &quot;GlobalIPv6PrefixLen&quot;: 0,
            &quot;IPAddress&quot;: &quot;&quot;,
            &quot;IPPrefixLen&quot;: 0,
            &quot;IPv6Gateway&quot;: &quot;&quot;,
            &quot;MacAddress&quot;: &quot;&quot;,
            &quot;Networks&quot;: &#123;
                &quot;aimind-overlay&quot;: &#123;
                    &quot;IPAMConfig&quot;: &#123;
                        &quot;IPv4Address&quot;: &quot;10.0.0.4&quot;
                    &#125;,
                    &quot;Links&quot;: null,
                    &quot;Aliases&quot;: [
                        &quot;2cf128f77797&quot;
                    ],
                    &quot;NetworkID&quot;: &quot;emypqxzjggws7uicersyz6uag&quot;,
                    &quot;EndpointID&quot;: &quot;56a78b2527a6dcf83fd3dc2794c514aaa325457d9c8a21bd236d3ea3c22c8fa9&quot;,
                    &quot;Gateway&quot;: &quot;&quot;,
                    &quot;IPAddress&quot;: &quot;10.0.0.4&quot;,
                    &quot;IPPrefixLen&quot;: 24,
                    &quot;IPv6Gateway&quot;: &quot;&quot;,
                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,
                    &quot;GlobalIPv6PrefixLen&quot;: 0,
                    &quot;MacAddress&quot;: &quot;02:42:0a:00:00:04&quot;,
                    &quot;DriverOpts&quot;: null
                &#125;
            &#125;
        &#125;
    &#125;
]
</code></pre>
<p>然后就可以通过stats来获取资源占用情况：</p>
<pre><code>~#docker stats 2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08 --all --no-stream 
CONTAINER ID        NAME                                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
2cf128f77797        mysql.1.lvskmv1lkhz6bvynfuxa0jqgn   0.33%               374.4MiB / 188.8GiB   0.19%               230kB / 0B          8.19kB / 1.26GB     38
</code></pre>
<h2 id="coding方式"><a href="#coding方式" class="headerlink" title="coding方式"></a>coding方式</h2><p>除了命令行，我们还可以通过docker api来获取，可以参见 <a href="https://www.cnblogs.com/xiaoqi/p/docker-java.html">docker-java Docker的java API</a></p>
<h3 id="获取containerID"><a href="#获取containerID" class="headerlink" title="获取containerID"></a>获取containerID</h3><pre><code>System.out.println(client.listTasksCmd().withNameFilter(&quot;mysql&quot;).exec());
</code></pre>
<p>结果：</p>
<pre><code>[class Task &#123;
    ID: lvskmv1lkhz6bvynfuxa0jqgn
    version: 21
    createdAt: 2019-08-30T08:04:18.382831966Z
    updatedAt: 2019-08-30T08:09:43.613636037Z
    name: null
    labels: &#123;&#125;
    spec: TaskSpec[containerSpec=ContainerSpec[image=mysql:latest@sha256:01cf53f2538aa805bda591d83f107c394adca8d31f98eacd3654e282dada3193,labels=&lt;null&gt;,command=&lt;null&gt;,args=&lt;null&gt;,env=[MYSQL_ROOT_PASSWORD=aimind@mysql2019&quot;],dir=&lt;null&gt;,user=&lt;null&gt;,groups=&lt;null&gt;,tty=&lt;null&gt;,mounts=&lt;null&gt;,duration=&lt;null&gt;,stopGracePeriod=&lt;null&gt;,dnsConfig=&lt;null&gt;,openStdin=&lt;null&gt;,readOnly=&lt;null&gt;,hosts=&lt;null&gt;,hostname=&lt;null&gt;,secrets=&lt;null&gt;,healthCheck=&lt;null&gt;,stopSignal=&lt;null&gt;,privileges=&lt;null&gt;,configs=&lt;null&gt;],resources=ResourceRequirements[limits=ResourceSpecs[memoryBytes=&lt;null&gt;,nanoCPUs=&lt;null&gt;],reservations=ResourceSpecs[memoryBytes=&lt;null&gt;,nanoCPUs=&lt;null&gt;]],restartPolicy=ServiceRestartPolicy[condition=ANY,delay=5000000000,maxAttempts=0,window=0],placement=ServicePlacement[constraints=&lt;null&gt;,platforms=&lt;null&gt;],logDriver=&lt;null&gt;,forceUpdate=0,networks=&lt;null&gt;,runtime=&lt;null&gt;]
    serviceId: uporil7xf4rwffa0rhg1j5htw
    slot: 1
    nodeId: sixp62dhqe702b69pm6v8m9rh
    assignedGenericResources: null
    status: TaskStatus[timestamp=2019-08-30T08:09:43.554514932Z,state=running,message=started,err=&lt;null&gt;,containerStatus=TaskStatusContainerStatus[containerID=2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08,pid=14884,exitCode=0]]
    desiredState: running
&#125;]
</code></pre>
<p>可以看到containerID：<code>2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08</code> 和命令行一直。</p>
<p>然后获取容器详情：</p>
<pre><code> System.out.println(client.inspectContainerCmd(&quot;2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08&quot;).exec());
</code></pre>
<p>获取容器统计信息：</p>
<pre><code>        System.out.println(client.statsCmd(&quot;2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08&quot;).exec(new InvocationBuilder.AsyncResultCallback&lt;&gt;()).awaitResult());
</code></pre>
<p>对应的结果：</p>
<pre><code>InspectContainerResponse[args=&#123;mysqld&#125;,config=com.github.dockerjava.api.model.ContainerConfig@3e15bb06[attachStderr=false,attachStdin=false,attachStdout=false,cmd=&#123;mysqld&#125;,domainName=,entrypoint=&#123;docker-entrypoint.sh&#125;,env=&#123;MYSQL_ROOT_PASSWORD=aimind@mysql2019&quot;,PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin,GOSU_VERSION=1.7,MYSQL_MAJOR=8.0,MYSQL_VERSION=8.0.17-1debian9&#125;,exposedPorts=com.github.dockerjava.api.model.ExposedPorts@6778aea6,hostName=2cf128f77797,image=mysql:latest@sha256:01cf53f2538aa805bda591d83f107c394adca8d31f98eacd3654e282dada3193,labels=&#123;com.docker.swarm.node.id=sixp62dhqe702b69pm6v8m9rh, com.docker.swarm.service.id=uporil7xf4rwffa0rhg1j5htw, com.docker.swarm.service.name=mysql, com.docker.swarm.task=, com.docker.swarm.task.id=lvskmv1lkhz6bvynfuxa0jqgn, com.docker.swarm.task.name=mysql.1.lvskmv1lkhz6bvynfuxa0jqgn&#125;,macAddress=&lt;null&gt;,networkDisabled=&lt;null&gt;,onBuild=&lt;null&gt;,stdinOpen=false,portSpecs=&lt;null&gt;,stdInOnce=false,tty=false,user=,volumes=&#123;/var/lib/mysql=&#123;&#125;&#125;,workingDir=,healthCheck=&lt;null&gt;],created=2019-08-30T08:09:41.827551223Z,driver=overlay2,execDriver=&lt;null&gt;,hostConfig=com.github.dockerjava.api.model.HostConfig@5853495b[binds=&lt;null&gt;,blkioWeight=0,blkioWeightDevice=&lt;null&gt;,blkioDeviceReadBps=&lt;null&gt;,blkioDeviceWriteBps=&lt;null&gt;,blkioDeviceReadIOps=&lt;null&gt;,blkioDeviceWriteIOps=&lt;null&gt;,memorySwappiness=&lt;null&gt;,nanoCPUs=&lt;null&gt;,capAdd=&lt;null&gt;,capDrop=&lt;null&gt;,containerIDFile=,cpuPeriod=0,cpuRealtimePeriod=0,cpuRealtimeRuntime=0,cpuShares=0,cpuQuota=0,cpusetCpus=,cpusetMems=,devices=&lt;null&gt;,deviceCgroupRules=&lt;null&gt;,diskQuota=0,dns=&lt;null&gt;,dnsOptions=&lt;null&gt;,dnsSearch=&lt;null&gt;,extraHosts=&lt;null&gt;,groupAdd=&lt;null&gt;,ipcMode=shareable,cgroup=,links=&lt;null&gt;,logConfig=com.github.dockerjava.api.model.LogConfig@524a2ffb,lxcConf=&lt;null&gt;,memory=0,memorySwap=0,memoryReservation=0,kernelMemory=0,networkMode=default,oomKillDisable=false,init=&lt;null&gt;,autoRemove=false,oomScoreAdj=0,portBindings=&#123;&#125;,privileged=false,publishAllPorts=false,readonlyRootfs=false,restartPolicy=no,ulimits=&lt;null&gt;,cpuCount=0,cpuPercent=0,ioMaximumIOps=0,ioMaximumBandwidth=0,volumesFrom=&lt;null&gt;,mounts=&lt;null&gt;,pidMode=,isolation=default,securityOpts=&lt;null&gt;,storageOpt=&lt;null&gt;,cgroupParent=,volumeDriver=,shmSize=67108864,pidsLimit=0,runtime=runc,tmpFs=&lt;null&gt;,utSMode=,usernsMode=,sysctls=&lt;null&gt;,consoleSize=[0, 0]],hostnamePath=/data/docker/containers/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08/hostname,hostsPath=/data/docker/containers/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08/hosts,logPath=/data/docker/containers/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08-json.log,id=2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08,sizeRootFs=&lt;null&gt;,imageId=sha256:62a9f311b99c24c0fde0a772abc6030bc48e5acc7d7416b8eeb72d3da1b4eb6c,mountLabel=,name=/mysql.1.lvskmv1lkhz6bvynfuxa0jqgn,restartCount=0,networkSettings=com.github.dockerjava.api.model.NetworkSettings@7173ae5b[bridge=,sandboxId=459ab4b83580513da251182d08dc217d0079613d10952df00ffcca6e2537958b,hairpinMode=false,linkLocalIPv6Address=,linkLocalIPv6PrefixLen=0,ports=&#123;3306/tcp=null, 33060/tcp=null&#125;,sandboxKey=/var/run/docker/netns/459ab4b83580,secondaryIPAddresses=&lt;null&gt;,secondaryIPv6Addresses=&lt;null&gt;,endpointID=,gateway=,portMapping=&lt;null&gt;,globalIPv6Address=,globalIPv6PrefixLen=0,ipAddress=,ipPrefixLen=0,ipV6Gateway=,macAddress=,networks=&#123;aimind-overlay=com.github.dockerjava.api.model.ContainerNetwork@53a9fcfd[ipamConfig=com.github.dockerjava.api.model.ContainerNetwork$Ipam@21f459fc,links=&lt;null&gt;,aliases=[2cf128f77797],networkID=emypqxzjggws7uicersyz6uag,endpointId=56a78b2527a6dcf83fd3dc2794c514aaa325457d9c8a21bd236d3ea3c22c8fa9,gateway=,ipAddress=10.0.0.4,ipPrefixLen=24,ipV6Gateway=,globalIPv6Address=,globalIPv6PrefixLen=0,macAddress=02:42:0a:00:00:04]&#125;],path=docker-entrypoint.sh,processLabel=,resolvConfPath=/data/docker/containers/2cf128f77797f08419f50a057973388f15753efb16134ed05370ded495d0ac08/resolv.conf,execIds=&lt;null&gt;,state=com.github.dockerjava.api.command.InspectContainerResponse$ContainerState@4d192aef[status=running,running=true,paused=false,restarting=false,oomKilled=false,dead=false,pid=14884,exitCode=0,error=,startedAt=2019-08-30T08:09:43.402630785Z,finishedAt=0001-01-01T00:00:00Z,health=&lt;null&gt;],volumes=&lt;null&gt;,volumesRW=&lt;null&gt;,node=&lt;null&gt;,mounts=[com.github.dockerjava.api.command.InspectContainerResponse$Mount@1416cf9f[name=c2128d05001b8fec1712807f381e2c72d42ce8a83ae97f6b038f51c0d48446f1,source=/data/docker/volumes/c2128d05001b8fec1712807f381e2c72d42ce8a83ae97f6b038f51c0d48446f1/_data,destination=/var/lib/mysql,driver=local,mode=,rw=true]],graphDriver=com.github.dockerjava.api.command.GraphDriver@84487f4[name=overlay2,data=com.github.dockerjava.api.command.GraphData@bfc14b9[rootDir=&lt;null&gt;,deviceId=&lt;null&gt;,deviceName=&lt;null&gt;,deviceSize=&lt;null&gt;,dir=&lt;null&gt;]],platform=linux]
Disconnected from the target VM, address: &#39;127.0.0.1:60730&#39;, transport: &#39;socket&#39;
com.github.dockerjava.api.model.Statistics@55a88417[read=2019-09-02T12:20:14.534216408Z,networks=&#123;eth0=com.github.dockerjava.api.model.StatisticNetworksConfig@18acfe88[rxBytes=0,rxDropped=0,rxErrors=0,rxPackets=0,txBytes=0,txDropped=0,txErrors=0,txPackets=0], eth1=com.github.dockerjava.api.model.StatisticNetworksConfig@8a2a6a[rxBytes=197752,rxDropped=0,rxErrors=0,rxPackets=836,txBytes=0,txDropped=0,txErrors=0,txPackets=0]&#125;,network=&lt;null&gt;,memoryStats=com.github.dockerjava.api.model.MemoryStatsConfig@772861aa,blkioStats=BlkioStatsConfig[ioServiceBytesRecursive=[BlkioStatEntry[major=8,minor=0,op=Read,value=8192], BlkioStatEntry[major=8,minor=0,op=Write,value=1259921408], BlkioStatEntry[major=8,minor=0,op=Sync,value=1258987520], BlkioStatEntry[major=8,minor=0,op=Async,value=942080], BlkioStatEntry[major=8,minor=0,op=Total,value=1259929600]],ioServicedRecursive=[BlkioStatEntry[major=8,minor=0,op=Read,value=2], BlkioStatEntry[major=8,minor=0,op=Write,value=4066], BlkioStatEntry[major=8,minor=0,op=Sync,value=4009], BlkioStatEntry[major=8,minor=0,op=Async,value=59], BlkioStatEntry[major=8,minor=0,op=Total,value=4068]],ioQueueRecursive=[],ioServiceTimeRecursive=[],ioWaitTimeRecursive=[],ioMergedRecursive=[],ioTimeRecursive=[],sectorsRecursive=[]],cpuStats=com.github.dockerjava.api.model.CpuStatsConfig@4cb40e3b,preCpuStats=com.github.dockerjava.api.model.CpuStatsConfig@41b1f51e,pidsStats=com.github.dockerjava.api.model.PidsStatsConfig@3a543f31]
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
        <tag>swarm</tag>
      </tags>
  </entry>
  <entry>
    <title>XNginx升级记录</title>
    <url>/jadepeng/2019/08/26/jqpeng-XNginx%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/xnginx-v-1-1.html">XNginx升级记录</a></p>
<p>之前的博文提到过，<a href="https://www.cnblogs.com/xiaoqi/p/xnginx.html">XNginx - nginx 集群可视化管理工具</a>, 开发完成后一直稳定运行，直到前面因为一个站点的proxy站点配置问题，导致需要修改nginx 配置文件模板，因此借此机会对系统做了升级。</p>
<h2 id="前端升级到最新版的ng-alain"><a href="#前端升级到最新版的ng-alain" class="headerlink" title="前端升级到最新版的ng-alain"></a>前端升级到最新版的ng-alain</h2><p>事实证明，升级是痛苦的，前端项目真是一言难尽，能不动最好不动！</p>
<p>主要的变更是：  </p>
<ul>
<li>之前的simple-table变成了st  </li>
<li>desc也没了，成了sv，  </li>
<li>page-header等的action也需要显示的指定</li>
</ul>
<p>查查文档，前后花了一个多小时，前端的升级真是太快了。。。</p>
<h2 id="vhost增加default"><a href="#vhost增加default" class="headerlink" title="vhost增加default"></a>vhost增加default</h2><p>通常会有类似下面的配置存在，通过default来标示是默认的配置：</p>
<pre><code>  server &#123;
        listen 80 default;
        client_max_body_size 10240M;
      
        location / &#123;
        
        proxy_pass http://proxy234648622.k8s_server;
            proxy_set_header HOST $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                            
      &#125;          
   &#125;
</code></pre>
<p>因此，这次给vhost增加了default选项，这样生成配置文件就可以加上default。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/8/26/1566817603353.png" alt="default"></p>
<p>生成的配置文件：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/8/26/1566817664946.png" alt="配置文件"></p>
<h2 id="SSL配置增加导入证书"><a href="#SSL配置增加导入证书" class="headerlink" title="SSL配置增加导入证书"></a>SSL配置增加导入证书</h2><p>之前SSL配置需要手动打开证书文件，拷贝文件内容到文本框，这次前端升级，增加了导入按钮，用户选择后直接读取证书文件.</p>
<p>实现很简单，使用<code>nz-upload</code>上传文件，通过<code>nzBeforeUpload</code>进行拦截，读取文件。</p>
<pre><code> &lt;div nz-col [nzSpan]=&quot;2&quot; *ngIf=&quot;dto.enableSSL&quot;&gt;
        &lt;nz-upload nzShowUploadList=&quot;false&quot; [nzBeforeUpload]=&quot;readCertificate&quot;&gt;&lt;button nz-icon=&quot;upload&quot; nz-button
            nzType=&quot;nz-button.default&quot; nzSize=&quot;small&quot;&gt;导入&lt;/button&gt; &lt;/nz-upload&gt;
      &lt;/div&gt;  
</code></pre>
<p>读取可以使用FileReader，记得return false。</p>
<pre><code>  readCertificate = (file: File) =&gt; &#123;
    const reader = new FileReader();
    reader.readAsText(file);
    this.dto.sslCertificate.commonName = file.name;
    reader.onload = () =&gt; &#123;
      this.dto.sslCertificate.content = reader.result.toString();
    &#125;
    return false;
  &#125;
</code></pre>
<h2 id="导入已有配置文件"><a href="#导入已有配置文件" class="headerlink" title="导入已有配置文件"></a>导入已有配置文件</h2><p>本次升级，在vhosts管理地方，增加了一个导入按钮，可以导入配置信息。</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/8/26/1566818042877.png" alt="导入"></p>
<p>支持的方式是要求将配置文件及其相关资源，打包为zip，上传到系统后台进行解析, 接口代码：</p>
<pre><code>@PostMapping(&quot;/importConfig/&#123;groupId&#125;&quot;)
    @Timed
    public String uploadConfFile(@RequestParam(&quot;file&quot;) MultipartFile file, @PathVariable String groupId) &#123;
        if (file.isEmpty()) &#123;
            return &quot;Please select a file to upload&quot;;
        &#125;

        if (!file.getContentType().equalsIgnoreCase(&quot;application/x-zip-compressed&quot;)) &#123;
            return &quot;only support.zip&quot;;
        &#125;

        File upFile = new File(new File(TEMP_FILE_PATH),  System.currentTimeMillis() + file.getOriginalFilename());
        try &#123;
            if(upFile.exists())&#123;
                upFile.delete();
            &#125;
            file.transferTo(upFile);
        &#125; catch (IllegalStateException | IOException ex) &#123;
            return &quot;upload error！&quot;;
        &#125;

        try &#123;
            nginxConfigService.parseFromZipFile(upFile, groupId);
        &#125; catch (IOException e) &#123;
            return &quot;upload error！&quot;;
        &#125;
        return &quot;success&quot;;
    &#125;
</code></pre>
<p>解析代码比较简单，先解压zip，然后找到nginx.conf，再调用上文提到的解析代码解析指令。</p>
<pre><code> public void parseConfig(String confidDir, String groupId) &#123;

        // 查找nginx.conf
        String nginxFile = searchForFile(new File(confidDir), &quot;nginx.conf&quot;);
        if (nginxFile.length() == 0) &#123;
            throw new RuntimeException(&quot;can&#39;t find nginx.conf,please make sure nginx.conf exist !&quot;);
        &#125;

        List&lt;Directive&gt; directives = NginxConfParser.newBuilder().withConfigurationFile(nginxFile).parse();
        directives.stream().forEach(directive -&gt; &#123;
            if (directive instanceof ProxyDirective) &#123;
                saveUpStream((ProxyDirective) directive);
            &#125; else if (directive instanceof VirtualHostDirective) &#123;
                saveVHost((VirtualHostDirective) directive, groupId);
            &#125;
        &#125;);

    &#125;

    public void parseFromZipFile(File file, String groupId) throws IOException &#123;
        String tempDir = Paths.get(file.getPath()).getParent().toString() + File.separator + file.getName() + &quot;.extract&quot;;
        UnZipFile.unZipFiles(file, tempDir);
        parseConfig(tempDir, groupId);
    &#125;
</code></pre>
<h2 id="前后端项目合并到一起"><a href="#前后端项目合并到一起" class="headerlink" title="前后端项目合并到一起"></a>前后端项目合并到一起</h2><p>之前前后端独立部署，如果项目足够大尚可，但是这个xnginx相对比较简单，独立部署费时费力，因此本次将前后端合并到一起</p>
<p>合并方法：</p>
<ul>
<li>在backend新建一个webapp目录，将web代码放入</li>
<li>将web的相关配置文件拷贝到上层目录</li>
</ul>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/8/26/1566818538910.png" alt="目录结构"></p>
<p>然后修改<code>angular.json</code>、<code>tsconfig.json</code> 等包含路径的地址进行修改</p>
<pre><code> &quot;xnginx&quot;: &#123;
      &quot;projectType&quot;: &quot;application&quot;,
      &quot;root&quot;: &quot;&quot;,
      &quot;sourceRoot&quot;: &quot;webapp/src&quot;,
      &quot;prefix&quot;: &quot;app&quot;,
      &quot;schematics&quot;: &#123;
        &quot;@schematics/angular:component&quot;: &#123;
          &quot;styleext&quot;: &quot;less&quot;
        &#125;
      &#125;,
</code></pre>
<p>最后，修改angular.json的build配置，将构建结果保存到’target/classes/static’,这样java项目打包时就能将前端资源带入：</p>
<pre><code>  &quot;build&quot;: &#123;
          &quot;builder&quot;: &quot;@angular-devkit/build-angular:browser&quot;,
          &quot;options&quot;: &#123;
            &quot;outputPath&quot;: &quot;target/classes/static&quot;,
            &quot;index&quot;: &quot;webapp/src/index.html&quot;,
            &quot;main&quot;: &quot;webapp/src/main.ts&quot;,
            &quot;tsConfig&quot;: &quot;tsconfig.app.json&quot;,
            &quot;polyfills&quot;: &quot;webapp/src/polyfills.ts&quot;,
            &quot;assets&quot;: [
              &quot;webapp/src/assets&quot;,
              &quot;webapp/src/favicon.ico&quot;
            ],
            &quot;styles&quot;: [
              &quot;webapp/src/styles.less&quot;
            ],
            &quot;scripts&quot;: [
              &quot;node_modules/@antv/g2/build/g2.js&quot;,
              &quot;node_modules/@antv/data-set/dist/data-set.min.js&quot;,
              &quot;node_modules/@antv/g2-plugin-slider/dist/g2-plugin-slider.min.js&quot;,
              &quot;node_modules/ajv/dist/ajv.bundle.js&quot;,
              &quot;node_modules/qrious/dist/qrious.min.js&quot;
            ]
          &#125;,
</code></pre>
<p>注意事项：</p>
<ul>
<li>先构建前端，<code>npm run build</code></li>
<li>再构建后端 <code>mvn package -DskipTests</code></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>XNginx</tag>
      </tags>
  </entry>
  <entry>
    <title>sparql  查询语句快速入门</title>
    <url>/jadepeng/2019/08/23/jqpeng-sparql%20%20%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/sparql.html">sparql  查询语句快速入门</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>RDF is a directed, labeled graph data format for representing information in the Web. RDF is often used to represent, among other things, personal information, social networks, metadata about digital artifacts, as well as to provide a means of integration over disparate sources of information. This specification defines the syntax and semantics of the SPARQL query language for RDF.<br> The SPARQL query language for RDF is designed to meet the use cases and requirements identified by the RDF Data Access Working Group in RDF Data Access Use Cases and Requirements [UCNR].</p>
</blockquote>
<p>SPARQL即SPARQL Protocol and RDF Query Language的递归缩写，被专门设计用来访问和操作RDF数据，是语义网的核心技术之一。W3C的RDF数据存取小组（RDF Data Access Working Group, RDAWG）对其进行了标准化。2008年1月15日，SPARQL正式成为一项W3C推荐标准。</p>
<p>我们可以将抽取的RDF三元组导入Apache Jena Fuseki，通过SPARQL进行查询：</p>
<p><img src="https://gitee.com/jadepeng/pic/raw/master/pic/2019/8/23/1566543446161.png" alt="SParql demo"></p>
<h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><table>
<thead>
<tr>
<th>SQL</th>
<th>sparql</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT title from book where id=’book1’</td>
<td>SELECT ?title    <br>WHERE   <br>{ &lt;<a href="http://example.org/book/book1">http://example.org/book/book1</a>&gt; &lt;<a href="http://purl.org/dc/elements/1.1/title">http://purl.org/dc/elements/1.1/title</a>&gt; ?title .   <br> }</td>
</tr>
</tbody></table>
<p>Query Result:</p>
<table>
<thead>
<tr>
<th>title</th>
</tr>
</thead>
<tbody><tr>
<td>“SPARQL Tutorial”</td>
</tr>
</tbody></table>
<h2 id="多字段匹配"><a href="#多字段匹配" class="headerlink" title="多字段匹配"></a>多字段匹配</h2><p>RDF 数据</p>
<pre><code>@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   &quot;Johnny Lee Outlaw&quot; .
_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .
_:b  foaf:name   &quot;Peter Goodguy&quot; .
_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .
_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .
</code></pre>
<p>sparql:</p>
<pre><code>PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE
  &#123; ?x foaf:name ?name .
    ?x foaf:mbox ?mbox &#125;
</code></pre>
<p>SQL:</p>
<pre><code>SELECT ?name ?mbox
from foaf
</code></pre>
<p>查询结果:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>mbox</th>
</tr>
</thead>
<tbody><tr>
<td>“Johnny Lee Outlaw”</td>
<td><a href="mailto:jlow@example.com">mailto:jlow@example.com</a></td>
</tr>
<tr>
<td>“Peter Goodguy”</td>
<td><a href="mailto:peter@example.org">mailto:peter@example.org</a></td>
</tr>
</tbody></table>
<h2 id="数据属性匹配"><a href="#数据属性匹配" class="headerlink" title="数据属性匹配"></a>数据属性匹配</h2><p>对于string类型，需要用双引号包裹起来。</p>
<p>sparql:</p>
<pre><code>SELECT ?v WHERE &#123; ?v ?p &quot;cat&quot; &#125;
</code></pre>
<p>SQL:</p>
<pre><code>SELECT *
from ns
where p=&#39;cat&#39;
</code></pre>
<p>对于数字类型：</p>
<p>sparql:</p>
<pre><code>SELECT ?v WHERE &#123; ?v ?p 42 &#125;
</code></pre>
<p>SQL:</p>
<pre><code>SELECT * from ns where p= 42
</code></pre>
<p>另外，在spaql里可以指定匹配的类型：</p>
<pre><code>SELECT ?v WHERE &#123; ?v ?p &quot;abc&quot;^^&lt;http://example.org/datatype#specialDatatype&gt; &#125;
</code></pre>
<h2 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h2><h3 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h3><p>通过<code>regex</code>函数可以进行字符串正则匹配，通过<code>FILTER</code>进行过滤</p>
<pre><code>PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   &#123; ?x dc:title ?title
          FILTER regex(?title, &quot;web&quot;, &quot;i&quot; ) 
        &#125;
</code></pre>
<p>SQL:</p>
<pre><code>SELECT * from table where title like &#39;%web%&#39;
</code></pre>
<h3 id="数字比较"><a href="#数字比较" class="headerlink" title="数字比较"></a>数字比较</h3><pre><code>PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   &#123; ?x ns:price ?price .
          FILTER (?price &lt; 30.5)
          ?x dc:title ?title . &#125;
</code></pre>
<p>SQL:</p>
<pre><code>SELECT title,price from table where price &lt;30.5
</code></pre>
<h2 id="OPTIONAL（可选值）"><a href="#OPTIONAL（可选值）" class="headerlink" title="OPTIONAL（可选值）"></a>OPTIONAL（可选值）</h2><p>RDF 数据，用户Bob没有mbox，而用户Alice有两个mbox</p>
<pre><code>@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdf:        &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

_:a  rdf:type        foaf:Person .
_:a  foaf:name       &quot;Alice&quot; .
_:a  foaf:mbox       &lt;mailto:alice@example.com&gt; .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  rdf:type        foaf:Person .
_:b  foaf:name       &quot;Bob&quot; .
</code></pre>
<p>正常查询，因为Bob没有mbox，所以查询不出来，可以通过<code>OPTIONAL</code>标记mbox为可选，这样Bob就可以查询出来。</p>
<p>sparql:</p>
<pre><code>PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  &#123; ?x foaf:name  ?name .
         OPTIONAL &#123; ?x  foaf:mbox  ?mbox &#125;
       &#125;
</code></pre>
<p>查询结果</p>
<table>
<thead>
<tr>
<th>name</th>
<th>mbox</th>
</tr>
</thead>
<tbody><tr>
<td>“Alice”</td>
<td><a href="mailto:alice@example.com">mailto:alice@example.com</a></td>
</tr>
<tr>
<td>“Alice”</td>
<td><a href="mailto:alice@work.example">mailto:alice@work.example</a></td>
</tr>
<tr>
<td>“Bob”</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到， <code>&quot;Bob&quot;</code>的 <code>mbox</code>是空值。</p>
<p>对于关系型数据库，可以假设两个表</p>
<p>User { id,name}<br> Mbox {id,uid,name} (uid为外键）</p>
<p>对应的sql：</p>
<pre><code>SELECT user.name AS name,mbox.name AS mboxName
FROM User user
LEFT OUTER JOIN Mbox mbox ON mbox.uid=user.id
</code></pre>
<h2 id="OPTIONAL-FILTER"><a href="#OPTIONAL-FILTER" class="headerlink" title="OPTIONAL + FILTER"></a>OPTIONAL + FILTER</h2><p>OPTIONAL 可以和FILTER 组合使用</p>
<pre><code>PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   &#123; ?x dc:title ?title .
          OPTIONAL &#123; ?x ns:price ?price . FILTER (?price &lt; 30) &#125;
        &#125;        
</code></pre>
<h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><p>Data:</p>
<pre><code>@prefix dc10:  &lt;http://purl.org/dc/elements/1.0/&gt; .
@prefix dc11:  &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc10:title     &quot;SPARQL Query Language Tutorial&quot; .
_:a  dc10:creator   &quot;Alice&quot; .

_:b  dc11:title     &quot;SPARQL Protocol Tutorial&quot; .
_:b  dc11:creator   &quot;Bob&quot; .

_:c  dc10:title     &quot;SPARQL&quot; .
_:c  dc11:title     &quot;SPARQL (updated)&quot; 
</code></pre>
<p>查询:</p>
<pre><code>PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title
WHERE  &#123; &#123; ?book dc10:title  ?title &#125; UNION &#123; ?book dc11:title  ?title &#125; &#125;
</code></pre>
<p>Query result:</p>
<pre><code>title
&quot;SPARQL Protocol Tutorial&quot;
&quot;SPARQL&quot;
&quot;SPARQL (updated)&quot;
&quot;SPARQL Query Language Tutorial&quot;
</code></pre>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>和sql一样，使用ORDER BY 排序，示例如下：</p>
<pre><code>PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE &#123; ?x foaf:name ?name ; :empId ?emp &#125;
ORDER BY ?name DESC(?emp)
</code></pre>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>和sql一样，使用DISTINCT来去重，示例如下：</p>
<pre><code>PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT DISTINCT ?name WHERE &#123; ?x foaf:name ?name &#125;
</code></pre>
<h2 id="判断是否存在"><a href="#判断是否存在" class="headerlink" title="判断是否存在"></a>判断是否存在</h2><p>使用ask来判断是否有解决方案</p>
<pre><code>PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  &#123; ?x foaf:name  &quot;Alice&quot; ;
          foaf:mbox  &lt;mailto:alice@work.example&gt; &#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>知识图谱</tag>
        <tag>sparql</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker启用TLS进行安全配置</title>
    <url>/jadepeng/2019/08/08/jqpeng-Docker%E5%90%AF%E7%94%A8TLS%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/docker-tls.html">Docker启用TLS进行安全配置</a></p>
<p>之前开启了docker的2375 Remote API，接到公司安全部门的要求，需要启用授权，翻了下官方文档</p>
<p><a href="https://docs.docker.com/engine/security/https/">Protect the Docker daemon socket</a></p>
<h2 id="启用TLS"><a href="#启用TLS" class="headerlink" title="启用TLS"></a>启用TLS</h2><p>在docker服务器，生成CA私有和公共密钥</p>
<pre><code>$ openssl genrsa -aes256 -out ca-key.pem 4096
Generating RSA private key, 4096 bit long modulus
............................................................................................................................................................................................++
........++
e is 65537 (0x10001)
Enter pass phrase for ca-key.pem:
Verifying - Enter pass phrase for ca-key.pem:

$ openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem
Enter pass phrase for ca-key.pem:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [AU]:
State or Province Name (full name) [Some-State]:Queensland
Locality Name (eg, city) []:Brisbane
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Docker Inc
Organizational Unit Name (eg, section) []:Sales
Common Name (e.g. server FQDN or YOUR name) []:$HOST
Email Address []:Sven@home.org.au
</code></pre>
<p>有了CA后，可以创建一个服务器密钥和证书签名请求(CSR)</p>
<blockquote>
<p>$HOST 是你的服务器ip</p>
</blockquote>
<pre><code>$ openssl genrsa -out server-key.pem 4096
Generating RSA private key, 4096 bit long modulus
.....................................................................++
.................................................................................................++
e is 65537 (0x10001)

$ openssl req -subj &quot;/CN=$HOST&quot; -sha256 -new -key server-key.pem -out server.csr
</code></pre>
<p>接着，用CA来签署公共密钥:</p>
<pre><code>$ echo subjectAltName = DNS:$HOST,IP:$HOST:127.0.0.1 &gt;&gt; extfile.cnf

 $ echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf
 
</code></pre>
<p>生成key：</p>
<pre><code>$ openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem \
  -CAcreateserial -out server-cert.pem -extfile extfile.cnf
Signature ok
subject=/CN=your.host.com
Getting CA Private Key
Enter pass phrase for ca-key.pem:
</code></pre>
<p>创建客户端密钥和证书签名请求:</p>
<pre><code>$ openssl genrsa -out key.pem 4096
Generating RSA private key, 4096 bit long modulus
.........................................................++
................++
e is 65537 (0x10001)

$ openssl req -subj &#39;/CN=client&#39; -new -key key.pem -out client.csr
</code></pre>
<p>修改<code>extfile.cnf</code>：</p>
<pre><code>echo extendedKeyUsage = clientAuth &gt; extfile-client.cnf
</code></pre>
<p>生成签名私钥：</p>
<pre><code>$ openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem \
  -CAcreateserial -out cert.pem -extfile extfile-client.cnf
Signature ok
subject=/CN=client
Getting CA Private Key
Enter pass phrase for ca-key.pem:
</code></pre>
<p>将Docker服务停止，然后修改docker服务文件</p>
<pre><code>[Unit]
Description=Docker Application Container Engine
Documentation=http://docs.docker.io

[Service]
Environment=&quot;PATH=/opt/kube/bin:/bin:/sbin:/usr/bin:/usr/sbin&quot;
ExecStart=/opt/kube/bin/dockerd  --tlsverify --tlscacert=/root/docker/ca.pem --tlscert=/root/docker/server-cert.pem --tlskey=/root/docker/server-key.pem -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375
ExecStartPost=/sbin/iptables -I FORWARD -s 0.0.0.0/0 -j ACCEPT
ExecReload=/bin/kill -s HUP $MAINPID
Restart=on-failure
RestartSec=5
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
Delegate=yes
KillMode=process

[Install]
WantedBy=multi-user.target
</code></pre>
<p>然后重启服务</p>
<pre><code>systemctl daemon-reload
systemctl restart docker.service 



重启后查看服务状态：

systemctl status docker.service
● docker.service - Docker Application Container Engine
   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2019-08-08 19:22:26 CST; 1 min ago
</code></pre>
<p>已经生效。</p>
<p>使用证书连接：</p>
<p>复制<code>ca.pem</code>,<code>cert.pem</code>,<code>key.pem</code>三个文件到客户端</p>
<p><code>docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem -H=$HOST:2375 version</code>连接即可</p>
<h2 id="docker-java-启用TLS"><a href="#docker-java-启用TLS" class="headerlink" title="docker-java 启用TLS"></a>docker-java 启用TLS</h2><p>项目里使用docker的java客户端<code>docker-java</code>调用docker，为了支持TLS，在创建客户端时，需要增加TLS设置。</p>
<p>首先将<code>ca.pem cert.pem key.pem </code>这三个文件拷贝到本地，例如<code>E:\\docker\\&quot;</code>,</p>
<p>然后<code>DefaultDockerClientConfig</code>里<code>withDockerTlsVerify</code>设为true，并设置<code>certpath</code>为刚拷贝的目录。</p>
<pre><code>DefaultDockerClientConfig.Builder builder =
                DefaultDockerClientConfig.createDefaultConfigBuilder()
                    .withDockerHost(&quot;tcp://&quot; + server + &quot;:2375&quot;)
                    .withApiVersion(&quot;1.30&quot;);
            if (containerConfiguration.getDockerTlsVerify()) &#123;
                builder = builder.withDockerTlsVerify(true)
                    .withDockerCertPath(&quot;E:\\docker\\&quot;);
            &#125;return  DockerClientBuilder.getInstance(builder.build()).build()        
</code></pre>
<p>大工搞定。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb海量数据CRUD优化</title>
    <url>/jadepeng/2019/05/28/jqpeng-mongodb%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AECRUD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/java-mongo-crud.html">mongodb海量数据CRUD优化</a></p>
<h2 id="1-批量保存优化"><a href="#1-批量保存优化" class="headerlink" title="1. 批量保存优化"></a>1. 批量保存优化</h2><p>避免一条一条查询，采用<code>bulkWrite</code>, 基于<code>ReplaceOneModel</code>，启用<code>upsert</code>:</p>
<pre><code> public void batchSave(List&lt;?&gt; spoTriples, KgInstance kgInstance) &#123;
        MongoConverter converter = mongoTemplate.getConverter();
        List&lt;ReplaceOneModel&lt;Document&gt;&gt; bulkOperationList = spoTriples.stream()
                .map(thing -&gt; &#123;
                    org.bson.Document dbDoc = new org.bson.Document();
                    converter.write(thing, dbDoc);
                    ReplaceOneModel&lt;org.bson.Document&gt; replaceOneModel = new ReplaceOneModel(
                            Filters.eq(UNDERSCORE_ID, dbDoc.get(UNDERSCORE_ID)), 
                            dbDoc,
                            new UpdateOptions().upsert(true));
                    return replaceOneModel;
                &#125;)
                .collect(Collectors.toList());
        mongoTemplate.getCollection(getCollection(kgInstance)).bulkWrite(bulkOperationList);
    &#125;
</code></pre>
<h2 id="2-分页优化"><a href="#2-分页优化" class="headerlink" title="2. 分页优化"></a>2. 分页优化</h2><p>经常用于查询的字段，需要确保建立了索引。</p>
<p>对于包含多个键的查询，可以创建符合索引。</p>
<h3 id="2-1-避免不必要的count"><a href="#2-1-避免不必要的count" class="headerlink" title="2.1 避免不必要的count"></a>2.1 避免不必要的count</h3><p>查询时，走索引，速度并不慢，但是如果返回分页<code>Page&lt;?&gt;</code>，需要查询<code>totalcount</code>，当单表数据过大时，count会比较耗时，但是设想意向，你真的需要准确的数字吗？</p>
<p>在google、百度等搜索引擎搜索关键词时，只会给你有限的几个结果，因此，我们也不必给出准确的数字，设定一个阈值，比如1万，当我们发现总量大于1万时，返回1万，前端显示大于1万条即可。</p>
<p>原理也很鉴定啊，我们skip掉<code>MAX_PAGE_COUNT</code>，看是否还有数据，如果有就说明总量大于<code>MAX_PAGE_COUNT</code>，返回<code>MAX_PAGE_COUNT</code>即可，否则，计算真正的count。</p>
<pre><code>int MAX_PAGE_COUNT = 10000;


/**
     * 当总数大于阈值时，不再计算总数
     *
     * @param mongoTemplate
     * @param query
     * @param collectionName
     * @return
     */
    private long count(MongoTemplate mongoTemplate, Query query, String collectionName) &#123;
        query = query.with(PageRequest.of(MAX_PAGE_COUNT, 1));
        if (mongoTemplate.find(query, Thing.class, collectionName).size() &gt; 0) &#123;
            return MAX_PAGE_COUNT;
        &#125;
        return mongoTemplate.count(query, collectionName);
    &#125;
</code></pre>
<p>前端显示：</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-28/1559041614698.png" alt="大于10000"></p>
<h3 id="2-2-避免过多的skip"><a href="#2-2-避免过多的skip" class="headerlink" title="2.2 避免过多的skip"></a>2.2 避免过多的skip</h3><p>分页不过避免需要先跳过一些数据，这个过程是需要消耗时间的，可以通过一个小技巧避免跳过。</p>
<p>比如，显示列表时，排序为按最后修改时间倒序，每页显示100条，现在要显示第100页。<br> 按照正常的做法，需要跳过<code>99*100</code>条数据，非常大的代价。换一个角度思考，因为数据是有序的，因此第100页的数据的最后修改时间是小于第99页最小的修改时间，查询时加上这个条件，就可以直接取符合条件的前100条即可。</p>
<h2 id="3-全量导出优化"><a href="#3-全量导出优化" class="headerlink" title="3. 全量导出优化"></a>3. 全量导出优化</h2><h3 id="3-1-去掉不需要的字段"><a href="#3-1-去掉不需要的字段" class="headerlink" title="3.1 去掉不需要的字段"></a>3.1 去掉不需要的字段</h3><p>查询时，指定真正有用的字段，这样可以有效减少数据传输量，加快查询效率。<br> 例如：</p>
<pre><code>         Query query = new Query();
        query.fields().include(&quot;_id&quot;).include(&quot;name&quot;).include(&quot;hot&quot;).include(&quot;alias&quot;);
</code></pre>
<h3 id="3-2-避免使用findAll或者分页查询，改用stream"><a href="#3-2-避免使用findAll或者分页查询，改用stream" class="headerlink" title="3.2 避免使用findAll或者分页查询，改用stream"></a>3.2 避免使用findAll或者分页查询，改用stream</h3><p>全量导出有两个误区，一是直接<code>findAll</code>,当数据量过大时，很容易导致服务器<code>OutofMermory</code>，就算没有OOM，也会对服务器造成极大的负载，影响兄弟服务。另外，FindAll一次性加载数据到内存，整个速度也会比较慢，需要等待所有数据进入内存后才能开始处理。</p>
<p>另外一个误区是，分页查询，依次处理。分页查询可以有效减少服务器负担，不失为一种可行的方法。但是就和上面分页说的那样，分页到后面的时候，需要skip掉前面的数据，存在无用功。稍微好一点的做法就是按照之前说的，将skip转换为condtion，这种方式效率OK，但不推荐，存在代码冗余。</p>
<pre><code>            Page&lt;Thing&gt; dataList = entityDao.findAllByPage(kgDataStoreService.getKgCollectionByKgInstance(kg), page);
            Map&lt;String, Individual&gt; thingId2Resource = new ConcurrentHashMap&lt;&gt;();

            appendThingsToModel(model, concept2OntClass, hot, alias, dataList, thingId2Resource);

            while (dataList.hasNext()) &#123;
                page = PageRequest.of(page.getPageNumber() + 1, page.getPageSize());
                dataList = entityDao.findAllByPage(kgDataStoreService.getKgCollectionByKgInstance(kg), page);
                appendThingsToModel(model, concept2OntClass, hot, alias, dataList, thingId2Resource);
            &#125;
</code></pre>
<p>更推荐的做法是，采用mongoTemplate的steam方法,返回<code>CloseableIterator</code>迭代器，读一条数据处理一条数据，实现高效处理：</p>
<pre><code>@Overridepublic &lt;T&gt; CloseableIterator&lt;T&gt; stream(final Query query, final Class&lt;T&gt; entityType, final String collectionName) &#123;    return doStream(query, entityType, collectionName, entityType);&#125;
</code></pre>
<p>改用方法后，代码可以更简化高效：</p>
<pre><code>  CloseableIterator&lt;Thing&gt; dataList = kgDataStoreService.getSimpleInfoIterator(kg);

            // 实体导入
            // Page&lt;Thing&gt; dataList = entityDao.findAllByPage(kgDataStoreService.getKgCollectionByKgInstance(kg), page);
            Map&lt;String, Individual&gt; thingId2Resource = new ConcurrentHashMap&lt;&gt;();

            appendThingsToModel(model, concept2OntClass, hot, alias, dataList, thingId2Resource);
</code></pre>
<p>待续。。。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>多语言业务错误日志收集监控工具Sentry 安装与使用</title>
    <url>/jadepeng/2019/05/24/jqpeng-%E5%A4%9A%E8%AF%AD%E8%A8%80%E4%B8%9A%E5%8A%A1%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7Sentry%20%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/sentry.html">多语言业务错误日志收集监控工具Sentry 安装与使用</a></p>
<p>Sentry 是一个实时事件日志记录和汇集的平台。其专注于错误监控以及提取一切事后处理所需信息而不依赖于麻烦的用户反馈。</p>
<p>Sentry是一个日志平台, 它分为客户端和服务端，客户端(目前客户端有Python, PHP,C#, Ruby等多种语言)就嵌入在你的应用程序中间，程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个web节目方便查看。Sentry由python编写，源码开放，性能卓越，易于扩展，目前著名的用户有Disqus, Path, mozilla, Pinterest等。</p>
<h2 id="通过docker安装"><a href="#通过docker安装" class="headerlink" title="通过docker安装"></a>通过docker安装</h2><p>官方提供了 On-Premise 安装方式</p>
<pre><code>git clone https://github.com/getsentry/onpremise
cd onpremise
</code></pre>
<p>然后创建volume，持久化存储</p>
<pre><code>docker volume create --name=sentry-data &amp;&amp; docker volume create --name=sentry-postgres
</code></pre>
<p>创建环境变量配置文件：</p>
<pre><code>cp -n .env.example .env - create env config file
</code></pre>
<p>docker-compose build镜像，这一步会拉取官方镜像和redis等依赖，耐心等待    ：</p>
<pre><code>docker-compose build - Build and tag the Docker services
</code></pre>
<p>创建secret-key，执行后得到一个key，添加到.env中的SENTRY_SECRET_KEY</p>
<pre><code>docker-compose run --rm web config generate-secret-key 
</code></pre>
<p>创建DB和初始化用户,等待创建数据库和</p>
<pre><code>docker-compose run --rm web upgrade
Created internal Sentry project (slug=internal, id=1)

Would you like to create a user account now? [Y/n]: y
Email: 
Password: 
Repeat for confirmation: 
Should this user be a superuser? [y/N]: y
Added to organization: sentry
Running migrations for sentry.nodestore:
 - Migrating forwards to 0001_initial.
</code></pre>
<p>最后-d启动，启动成功后可以访问<a href="http://server-ip:9000/">http://server-ip:9000</a></p>
<pre><code>docker-compose up -d 
</code></pre>
<p>访问：</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-24/1558680516195.png" alt="sentry"></p>
<h2 id="创建项目并集成"><a href="#创建项目并集成" class="headerlink" title="创建项目并集成"></a>创建项目并集成</h2><p>先创建一个project，支持多种语言，我们创建一个java的</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-24/1558680561117.png" alt="create project"></p>
<h3 id="DSN（Client-Keys）"><a href="#DSN（Client-Keys）" class="headerlink" title="DSN（Client Keys）"></a>DSN（Client Keys）</h3><p>DSN格式为：</p>
<p>DSN=”<a href="https://public:private@host:port/project\_id&quot;">https://public:private@host:port/project\_id&quot;</a></p>
<p>可以在项目的setting-Client Keys（DSN）里查看。</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-24/1558684229783.png" alt="DSK"></p>
<p>然后根据格式拼成DSN即可。</p>
<h3 id="java项目集成"><a href="#java项目集成" class="headerlink" title="java项目集成"></a>java项目集成</h3><p>有多种集成方式：</p>
<h4 id="基本集成方式"><a href="#基本集成方式" class="headerlink" title="基本集成方式"></a>基本集成方式</h4><p>添加maven引用：</p>
<pre><code>    &lt;dependency&gt;    &lt;groupId&gt;io.sentry&lt;/groupId&gt;    &lt;artifactId&gt;sentry&lt;/artifactId&gt;    &lt;version&gt;1.7.16&lt;/version&gt;&lt;/dependency&gt;
</code></pre>
<p>然后在全局异常处理里集成：</p>
<pre><code> String dsn = &quot;http://&lt;SENTRY_PUBLIC_KEY&gt;:&lt;SENTRY_PRIVATE_KEY&gt;@host:port/&lt;PROJECT_ID&gt;&quot;;
 Sentry.init(dsn);
</code></pre>
<p>在有异常的地方：</p>
<pre><code>      try &#123;
            unsafeMethod();
        &#125; catch (Exception e) &#123;
            // This sends an exception event to Sentry using the statically stored instance
            // that was created in the ``main`` method.
            Sentry.capture(e);
        &#125;
</code></pre>
<h4 id="logback集成"><a href="#logback集成" class="headerlink" title="logback集成"></a>logback集成</h4><p>logback配置：</p>
<pre><code>&lt;configuration&gt;

  &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;appender name=&quot;Sentry&quot; class=&quot;io.sentry.logback.SentryAppender&quot;&gt;
    &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
      &lt;level&gt;WARN&lt;/level&gt;
    &lt;/filter&gt;
  &lt;/appender&gt;

  &lt;root level=&quot;DEBUG&quot;&gt;
    &lt;appender-ref ref=&quot;Console&quot; /&gt;
    &lt;appender-ref ref=&quot;Sentry&quot;/&gt;
  &lt;/root&gt;

&lt;/configuration&gt;
</code></pre>
<h4 id="spring-boot集成"><a href="#spring-boot集成" class="headerlink" title="spring-boot集成"></a>spring-boot集成</h4><p>先添加引用：</p>
<pre><code>        &lt;dependency&gt;        &lt;groupId&gt;io.sentry&lt;/groupId&gt;        &lt;artifactId&gt;sentry-spring&lt;/artifactId&gt;        &lt;version&gt;1.7.16&lt;/version&gt;    &lt;/dependency&gt;
</code></pre>
<p>在Application里集成：</p>
<pre><code>import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletContextInitializer;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.HandlerExceptionResolver;

@Controller
@EnableAutoConfiguration
@SpringBootApplication
public class Application &#123;
    /*
    Register a HandlerExceptionResolver that sends all exceptions to Sentry
    and then defers all handling to the other HandlerExceptionResolvers.
    You should only register this is you are not using a logging integration,
    otherwise you may double report exceptions.
     */
    @Bean
    public HandlerExceptionResolver sentryExceptionResolver() &#123;
        return new io.sentry.spring.SentryExceptionResolver();
    &#125;

    /*
    Register a ServletContextInitializer that installs the SentryServletRequestListener
    so that Sentry events contain HTTP request information.
    This should only be necessary in Spring Boot applications. &quot;Classic&quot; Spring
    should automatically load the `io.sentry.servlet.SentryServletContainerInitializer`.
     */
    @Bean
    public ServletContextInitializer sentryServletContextInitializer() &#123;
        return new io.sentry.spring.SentryServletContextInitializer();
    &#125;

    @RequestMapping(&quot;/&quot;)
    @ResponseBody
    String home() &#123;
        int x = 1 / 0;

        return &quot;Hello World!&quot;;
    &#125;

    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre>
<h3 id="前端项目集成"><a href="#前端项目集成" class="headerlink" title="前端项目集成"></a>前端项目集成</h3><p>前端集成更简单，引用sentry的js，然后init即可</p>
<pre><code>&lt;script src=&quot;https://browser.sentry-cdn.com/5.1.0/bundle.min.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
Sentry.init(&#123; dsn: &#39;dsn&#39; &#125;);
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a> 您的支持是对博主最大的鼓励，感谢您的认真阅读。 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>Sentry</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code Remote，在服务器上开发程序，开启全新开发模式</title>
    <url>/jadepeng/2019/05/08/jqpeng-VS%20Code%20Remote%EF%BC%8C%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%BC%80%E5%8F%91%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%BC%80%E5%90%AF%E5%85%A8%E6%96%B0%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/vs-code-remote.html">VS Code Remote，在服务器上开发程序，开启全新开发模式</a></p>
<p>一直使用Idea开发java 程序，头疼的是太太太占用内存了，笔记本电脑经常卡爆，在服务器开发的话又太麻烦，VS Code Remote的带来，解决了这一烦恼。下面来实战一下。</p>
<h2 id="VS-Code-Remote"><a href="#VS-Code-Remote" class="headerlink" title="VS Code Remote"></a>VS Code Remote</h2><p>2019 年 5 月 3 日，在 PyCon 2019 大会上，微软发布了 VS Code Remote，开启了远程开发的新时代<br> 。</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-8/1557283868532.png" alt="VS"></p>
<p>Visual Studio Code Remote 允许开发者将容器，远程计算机，或 Windows Subsystem for Linux (WSL) 作为完整的开发环境。你可以：</p>
<ul>
<li>在部署相同的操作系统上进行开发，或者使用更大或更专业的硬件。</li>
<li>把开发环境作为沙箱，以避免影响本地计算机配置。</li>
<li>让新手轻松上手，让每个人都保持一致的开发环境。</li>
<li>使用原本在本地环境不可用的工具或运行时，或者管理它们的多个版本。</li>
<li>在 WSL 里开发 Linux 应用。</li>
<li>从多台不同的计算机访问现有的开发环境。</li>
<li>调试在其他位置（比如客户网站或云端）运行的应用程序。</li>
</ul>
<p>所有以上的功能，并不需要在你的本地开发环境有源代码。通过 VS Code Remote，轻松连接上远程环境，在本地进行开发。</p>
<p>下面来实战。</p>
<h2 id="安装vs-code-insiders"><a href="#安装vs-code-insiders" class="headerlink" title="安装vs code insiders"></a>安装vs code insiders</h2><p>需要先安装最新的内部体验版，<a href="https://code.visualstudio.com/insiders/">https://code.visualstudio.com/insiders/</a></p>
<p>然后安装Remote Development插件</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack</a></p>
<p>为了简单起见，我们采用SSH模式。需要先在windows机器安装OpenSSH</p>
<h2 id="windows-10-安装OpenSSH"><a href="#windows-10-安装OpenSSH" class="headerlink" title="windows 10 安装OpenSSH"></a>windows 10 安装OpenSSH</h2><p>使用 PowerShell 安装 OpenSSH</p>
<p>若要安装使用 PowerShell 的 OpenSSH，请首先以管理员身份启动 PowerShell。 若要确保 OpenSSH 功能以安装方式提供：</p>
<p>PowerShell复制</p>
<pre><code>Get-WindowsCapability -Online | ? Name -like &#39;OpenSSH*&#39;

# This should return the following output:

Name  : OpenSSH.Client~~~~0.0.1.0
State : NotPresent
Name  : OpenSSH.Server~~~~0.0.1.0
State : NotPresent
</code></pre>
<p>然后，安装服务器和/或客户端功能：</p>
<p>PowerShell复制</p>
<pre><code># Install the OpenSSH Client
Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0

# Install the OpenSSH Server
Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0

# Both of these should return the following output:

Path          :
Online        : True
RestartNeeded : False
</code></pre>
<h2 id="SSH-认证"><a href="#SSH-认证" class="headerlink" title="SSH 认证"></a>SSH 认证</h2><ul>
<li>先ssh-keygen生车密钥</li>
<li>然后ssh-copy-id 到服务器</li>
</ul>
<pre><code> ssh-copy-id root@YOUR-SERVER-IP
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/c/Users/jqpeng/.ssh/id_ed25519.pub&quot;
The authenticity of host &#39;YOUR-SERVER-IP&#39; can&#39;t be established.
ECDSA key fingerprint is SHA256:HRwsmslg5ge+JYcOjW6zRtUxrFeWJ5V2AojlIvLaykc.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filterout any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@YOUR-SERVER-IP&#39;s password:

Number of key(s) added: 1

Now try logging into the machine, with:   &quot;ssh &#39;root@YOUR-SERVER-IP&#39;&quot;
and check to make sure that only the key(s) you wanted were added.
</code></pre>
<h2 id="使用VS-code-inside-开发程序"><a href="#使用VS-code-inside-开发程序" class="headerlink" title="使用VS code inside 开发程序"></a>使用VS code inside 开发程序</h2><p>准备工作：</p>
<ul>
<li>确保服务器已有JDK，mvn，没有的话先安装好</li>
<li>将代码签出到服务器一个目录</li>
</ul>
<p>打开VS code，命令行：</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-8/1557284388601.png" alt="enter description here"></p>
<p>选择<code>connect to host</code>:</p>
<p>然后输入root@YOUR_SERVETR_IP</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-8/1557284444999.png" alt="enter description here"></p>
<p>回车，VS 会自动在服务器准备相关环境。</p>
<p>搞定后，点击文件打开文件夹，VS Code会列出服务器的目录，选择项目所在地址打开即可。</p>
<p><img src="https://markdown.xiaoshujiang.com/img/spinner.gif" alt="enter description here" title="[[[1557284521346]]]"></p>
<p>接下来安装必要的语言插件，打开一个java文件，vs code会自动图惨案安装一些插件，把java相关的安装好：</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-8/1557284624056.png" alt="enter description here"></p>
<h2 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h2><p>打开包含main的java文件，点击调试菜单，会自动生成一个启动文件，配置下即可：</p>
<pre><code>&#123;
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        &#123;
            &quot;type&quot;: &quot;java&quot;,
            &quot;name&quot;: &quot;AimindWebApplication&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;mainClass&quot;: &quot;com.xxx.xxx.XXXWebApplication&quot;
        &#125;
    ]
&#125;
</code></pre>
<p>然后启动。</p>
<p>惊喜的发现，在main函数上方，自动出现了RUN|DEBUG，见下图，点击debug即可启动调试</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-8/1557285054203.png" alt="自动识别的main"></p>
<p>在调试控制台可以看到对应的输出。</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-8/1557285150474.png" alt="调试控制台"></p>
<h2 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h2><p>之前IDEA启动调试后，内存占用2G+，VS code呢？400M+！</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/images/2019/5-8/1557285229259.png" alt="VS CODE remote 内存占用"></p>
<p>把耗费计算资源、内存的都放到服务器上去执行了，本地只需要负责View，所以资源占用极小。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>makefilen  missing separator. Stop</title>
    <url>/jadepeng/2019/02/19/jqpeng-makefilen%20%20missing%20separator.%20Stop/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/10402353.html">makefilen  missing separator. Stop</a></p>
<p>makefile has a very stupid relation with tabs, all actions of every rule are identified by tabs …… and No 4 spaces don’t make a tab, only a tab makes a tab…</p>
<p>makefile使用tab来作为separator.如果你使用4个空格就会报错，makefile:n: *** missing separator. Stop，其中n是第几行</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>drone的pipeline原理与代码分析</title>
    <url>/jadepeng/2019/01/22/jqpeng-drone%E7%9A%84pipeline%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/drone-pipeline.html">drone的pipeline原理与代码分析</a></p>
<p>最近的一个项目，需要实现一个工作任务流（task pipeline），基于之前CICD的经验，jenkins pipeline和drone的pipeline进入候选。</p>
<p>drone是基于go的cicd解决方案，github上有1.6万+star，本文简单对比了其和jenkins的区别，重点介绍了drone的pipeline原理，并简单分析了代码。</p>
<h2 id="jenkins-与-drone"><a href="#jenkins-与-drone" class="headerlink" title="jenkins 与 drone"></a>jenkins 与 drone</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>jenkins</th>
<th>drone</th>
</tr>
</thead>
<tbody><tr>
<td>pipeline定义</td>
<td>编写jenkinsfile</td>
<td>编写流程yml</td>
</tr>
<tr>
<td>运行方式</td>
<td>在一个pod里运行</td>
<td>每一步骤起对应的container，通过挂载volume实现数据共享</td>
</tr>
<tr>
<td>运行环境</td>
<td>物理机或者容器环境，包括K8S</td>
<td>docker容器环境</td>
</tr>
<tr>
<td>开发语言</td>
<td>java</td>
<td>golang</td>
</tr>
</tbody></table>
<p>drone pipeline好处是相对更轻量级，yml定义也相对简洁清晰，按照功能来划分容器，可以方便的实现task的复用，而jenkins则是完全打包到一个镜像，会造成单个镜像体积过大，比如jenkins的单个镜像超过2G。</p>
<p>drone的pipeline，是基于<a href="https://github.com/cncd/pipeline">https://github.com/cncd/pipeline</a> 实现的，这里简单分析下其原理。</p>
<h2 id="编译和执行-drone-pipeline"><a href="#编译和执行-drone-pipeline" class="headerlink" title="编译和执行 drone pipeline"></a>编译和执行 drone pipeline</h2><p>要了解一个程序的原理，先从输入输出讲起。</p>
<p>先安装：</p>
<pre><code>go get -u github.com/cncd/pipeline
go install github.com/cncd/pipeline/pipec
</code></pre>
<p>然后测试</p>
<pre><code>cd $GOPATH/github.com/cncd/pipeline/samples/sample_1
# ll
total 28
drwxr-xr-x  2 root root 4096 Jan 22 11:44 ./
drwxr-xr-x 13 root root 4096 Jan 22 11:02 ../
-rw-r--r--  1 root root  549 Jan 22 11:02 .env
-rw-r--r--  1 root root 6804 Jan 22 16:30 pipeline.json
-rw-r--r--  1 root root  229 Jan 22 11:02 pipeline.yml
-rw-r--r--  1 root root  138 Jan 22 11:02 README.md
</code></pre>
<ul>
<li>pipeline.yml 定义文件</li>
<li>pipeline.json 编译后的配置文件</li>
<li>.env 环境变量</li>
</ul>
<p>先来查看<code>pipeline.yml</code> 定义</p>
<pre><code>workspace:
  base: /go
  path: src/github.com/drone/envsubst

clone:
  git:
    image: plugins/git
    depth: 50

pipeline:
  build:
    image: golang:1.7
    commands:
      - go get -t ./...
      - go build
      - go test -v
</code></pre>
<p>上面的yml定义了：</p>
<ul>
<li>工作目录workspace</li>
<li>初始化工作，git clone仓库,仓库地址在.env里定义</li>
<li>然后是定义pipeline，<ul>
<li>pipeline下面是step数组，这里只有一个build</li>
<li>使用golang:1.7镜像</li>
<li>构建命令在commands数组里定义</li>
</ul>
</li>
</ul>
<p>通过<code>pipec compile</code>compile配置文件：</p>
<pre><code># pipec compile
Successfully compiled pipeline.yml to pipeline.json
</code></pre>
<p>查看编译后的<code>pipeline.json</code></p>
<pre><code>&#123;
  &quot;pipeline&quot;: [
    &#123;
      &quot;name&quot;: &quot;pipeline_clone_0&quot;,
      &quot;alias&quot;: &quot;git&quot;,
      &quot;steps&quot;: [
        &#123;
          &quot;name&quot;: &quot;pipeline_clone_0&quot;,
          &quot;alias&quot;: &quot;git&quot;,
          &quot;image&quot;: &quot;plugins/git:latest&quot;,
          &quot;working_dir&quot;: &quot;/go/src/github.com/drone/envsubst&quot;,
          &quot;environment&quot;: &#123;
            &quot;CI&quot;: &quot;drone&quot;,
            &quot;CI_BUILD_CREATED&quot;: &quot;1486119586&quot;,
            &quot;CI_BUILD_EVENT&quot;: &quot;push&quot;,
            &quot;CI_BUILD_NUMBER&quot;: &quot;6&quot;,
            &quot;CI_BUILD_STARTED&quot;: &quot;1486119585&quot;,
            &quot;CI_COMMIT_AUTHOR&quot;: &quot;bradrydzewski&quot;,
            &quot;CI_COMMIT_AUTHOR_NAME&quot;: &quot;bradrydzewski&quot;,
            &quot;CI_COMMIT_BRANCH&quot;: &quot;master&quot;,
            &quot;CI_COMMIT_MESSAGE&quot;: &quot;added a few more test cases for escaping behavior&quot;,
            &quot;CI_COMMIT_REF&quot;: &quot;refs/heads/master&quot;,
            &quot;CI_COMMIT_SHA&quot;: &quot;d0876d3176965f9552a611cbd56e24a9264355e6&quot;,
            &quot;CI_REMOTE_URL&quot;: &quot;https://github.com/drone/envsubst.git&quot;,
            &quot;CI_REPO&quot;: &quot;drone/envsubst&quot;,
            &quot;CI_REPO_LINK&quot;: &quot;https://github.com/drone/envsubst&quot;,
            &quot;CI_REPO_NAME&quot;: &quot;drone/envsubst&quot;,
            &quot;CI_REPO_REMOTE&quot;: &quot;https://github.com/drone/envsubst.git&quot;,
            &quot;CI_SYSTEM&quot;: &quot;pipec&quot;,
            &quot;CI_SYSTEM_ARCH&quot;: &quot;linux/amd64&quot;,
            &quot;CI_SYSTEM_LINK&quot;: &quot;https://github.com/cncd/pipec&quot;,
            &quot;CI_SYSTEM_NAME&quot;: &quot;pipec&quot;,
            &quot;CI_WORKSPACE&quot;: &quot;/go/src/github.com/drone/envsubst&quot;,
            &quot;DRONE&quot;: &quot;true&quot;,
            &quot;DRONE_ARCH&quot;: &quot;linux/amd64&quot;,
            &quot;DRONE_BRANCH&quot;: &quot;master&quot;,
            &quot;DRONE_BUILD_CREATED&quot;: &quot;1486119586&quot;,
            &quot;DRONE_BUILD_EVENT&quot;: &quot;push&quot;,
            &quot;DRONE_BUILD_LINK&quot;: &quot;https://github.com/cncd/pipec/drone/envsubst/6&quot;,
            &quot;DRONE_BUILD_NUMBER&quot;: &quot;6&quot;,
            &quot;DRONE_BUILD_STARTED&quot;: &quot;1486119585&quot;,
            &quot;DRONE_COMMIT&quot;: &quot;d0876d3176965f9552a611cbd56e24a9264355e6&quot;,
            &quot;DRONE_COMMIT_AUTHOR&quot;: &quot;bradrydzewski&quot;,
            &quot;DRONE_COMMIT_BRANCH&quot;: &quot;master&quot;,
            &quot;DRONE_COMMIT_MESSAGE&quot;: &quot;added a few more test cases for escaping behavior&quot;,
            &quot;DRONE_COMMIT_REF&quot;: &quot;refs/heads/master&quot;,
            &quot;DRONE_COMMIT_SHA&quot;: &quot;d0876d3176965f9552a611cbd56e24a9264355e6&quot;,
            &quot;DRONE_JOB_STARTED&quot;: &quot;1486119585&quot;,
            &quot;DRONE_REMOTE_URL&quot;: &quot;https://github.com/drone/envsubst.git&quot;,
            &quot;DRONE_REPO&quot;: &quot;drone/envsubst&quot;,
            &quot;DRONE_REPO_LINK&quot;: &quot;https://github.com/drone/envsubst&quot;,
            &quot;DRONE_REPO_NAME&quot;: &quot;envsubst&quot;,
            &quot;DRONE_REPO_OWNER&quot;: &quot;drone&quot;,
            &quot;DRONE_REPO_SCM&quot;: &quot;git&quot;,
            &quot;DRONE_WORKSPACE&quot;: &quot;/go/src/github.com/drone/envsubst&quot;,
            &quot;PLUGIN_DEPTH&quot;: &quot;50&quot;
          &#125;,
          &quot;volumes&quot;: [
            &quot;pipeline_default:/go&quot;
          ],
          &quot;networks&quot;: [
            &#123;
              &quot;name&quot;: &quot;pipeline_default&quot;,
              &quot;aliases&quot;: [
                &quot;git&quot;
              ]
            &#125;
          ],
          &quot;on_success&quot;: true,
          &quot;auth_config&quot;: &#123;&#125;
        &#125;
      ]
    &#125;,
    &#123;
      &quot;name&quot;: &quot;pipeline_stage_0&quot;,
      &quot;alias&quot;: &quot;build&quot;,
      &quot;steps&quot;: [
        &#123;
          &quot;name&quot;: &quot;pipeline_step_0&quot;,
          &quot;alias&quot;: &quot;build&quot;,
          &quot;image&quot;: &quot;golang:1.7&quot;,
          &quot;working_dir&quot;: &quot;/go/src/github.com/drone/envsubst&quot;,
          &quot;environment&quot;: &#123;
            &quot;CI&quot;: &quot;drone&quot;,
            &quot;CI_BUILD_CREATED&quot;: &quot;1486119586&quot;,
            &quot;CI_BUILD_EVENT&quot;: &quot;push&quot;,
            &quot;CI_BUILD_NUMBER&quot;: &quot;6&quot;,
            &quot;CI_BUILD_STARTED&quot;: &quot;1486119585&quot;,
            &quot;CI_COMMIT_AUTHOR&quot;: &quot;bradrydzewski&quot;,
            &quot;CI_COMMIT_AUTHOR_NAME&quot;: &quot;bradrydzewski&quot;,
            &quot;CI_COMMIT_BRANCH&quot;: &quot;master&quot;,
            &quot;CI_COMMIT_MESSAGE&quot;: &quot;added a few more test cases for escaping behavior&quot;,
            &quot;CI_COMMIT_REF&quot;: &quot;refs/heads/master&quot;,
            &quot;CI_COMMIT_SHA&quot;: &quot;d0876d3176965f9552a611cbd56e24a9264355e6&quot;,
            &quot;CI_REMOTE_URL&quot;: &quot;https://github.com/drone/envsubst.git&quot;,
            &quot;CI_REPO&quot;: &quot;drone/envsubst&quot;,
            &quot;CI_REPO_LINK&quot;: &quot;https://github.com/drone/envsubst&quot;,
            &quot;CI_REPO_NAME&quot;: &quot;drone/envsubst&quot;,
            &quot;CI_REPO_REMOTE&quot;: &quot;https://github.com/drone/envsubst.git&quot;,
            &quot;CI_SCRIPT&quot;: &quot;CmlmIFsgLW4gIiRDSV9ORVRSQ19NQUNISU5FIiBdOyB0aGVuCmNhdCA8PEVPRiA+ICRIT01FLy5uZXRyYwptYWNoaW5lICRDSV9ORVRSQ19NQUNISU5FCmxvZ2luICRDSV9ORVRSQ19VU0VSTkFNRQpwYXNzd29yZCAkQ0lfTkVUUkNfUEFTU1dPUkQKRU9GCmNobW9kIDA2MDAgJEhPTUUvLm5ldHJjCmZpCnVuc2V0IENJX05FVFJDX1VTRVJOQU1FCnVuc2V0IENJX05FVFJDX1BBU1NXT1JECnVuc2V0IENJX1NDUklQVAp1bnNldCBEUk9ORV9ORVRSQ19VU0VSTkFNRQp1bnNldCBEUk9ORV9ORVRSQ19QQVNTV09SRAoKZWNobyArICJnbyBnZXQgLXQgLi8uLi4iCmdvIGdldCAtdCAuLy4uLgoKZWNobyArICJnbyBidWlsZCIKZ28gYnVpbGQKCmVjaG8gKyAiZ28gdGVzdCAtdiIKZ28gdGVzdCAtdgoK&quot;,
            &quot;CI_SYSTEM&quot;: &quot;pipec&quot;,
            &quot;CI_SYSTEM_ARCH&quot;: &quot;linux/amd64&quot;,
            &quot;CI_SYSTEM_LINK&quot;: &quot;https://github.com/cncd/pipec&quot;,
            &quot;CI_SYSTEM_NAME&quot;: &quot;pipec&quot;,
            &quot;CI_WORKSPACE&quot;: &quot;/go/src/github.com/drone/envsubst&quot;,
            &quot;DRONE&quot;: &quot;true&quot;,
            &quot;DRONE_ARCH&quot;: &quot;linux/amd64&quot;,
            &quot;DRONE_BRANCH&quot;: &quot;master&quot;,
            &quot;DRONE_BUILD_CREATED&quot;: &quot;1486119586&quot;,
            &quot;DRONE_BUILD_EVENT&quot;: &quot;push&quot;,
            &quot;DRONE_BUILD_LINK&quot;: &quot;https://github.com/cncd/pipec/drone/envsubst/6&quot;,
            &quot;DRONE_BUILD_NUMBER&quot;: &quot;6&quot;,
            &quot;DRONE_BUILD_STARTED&quot;: &quot;1486119585&quot;,
            &quot;DRONE_COMMIT&quot;: &quot;d0876d3176965f9552a611cbd56e24a9264355e6&quot;,
            &quot;DRONE_COMMIT_AUTHOR&quot;: &quot;bradrydzewski&quot;,
            &quot;DRONE_COMMIT_BRANCH&quot;: &quot;master&quot;,
            &quot;DRONE_COMMIT_MESSAGE&quot;: &quot;added a few more test cases for escaping behavior&quot;,
            &quot;DRONE_COMMIT_REF&quot;: &quot;refs/heads/master&quot;,
            &quot;DRONE_COMMIT_SHA&quot;: &quot;d0876d3176965f9552a611cbd56e24a9264355e6&quot;,
            &quot;DRONE_JOB_STARTED&quot;: &quot;1486119585&quot;,
            &quot;DRONE_REMOTE_URL&quot;: &quot;https://github.com/drone/envsubst.git&quot;,
            &quot;DRONE_REPO&quot;: &quot;drone/envsubst&quot;,
            &quot;DRONE_REPO_LINK&quot;: &quot;https://github.com/drone/envsubst&quot;,
            &quot;DRONE_REPO_NAME&quot;: &quot;envsubst&quot;,
            &quot;DRONE_REPO_OWNER&quot;: &quot;drone&quot;,
            &quot;DRONE_REPO_SCM&quot;: &quot;git&quot;,
            &quot;DRONE_WORKSPACE&quot;: &quot;/go/src/github.com/drone/envsubst&quot;,
            &quot;HOME&quot;: &quot;/root&quot;,
            &quot;SHELL&quot;: &quot;/bin/sh&quot;
          &#125;,
          &quot;entrypoint&quot;: [
            &quot;/bin/sh&quot;,
            &quot;-c&quot;
          ],
          &quot;command&quot;: [
            &quot;echo $CI_SCRIPT | base64 -d | /bin/sh -e&quot;
          ],
          &quot;volumes&quot;: [
            &quot;pipeline_default:/go&quot;
          ],
          &quot;networks&quot;: [
            &#123;
              &quot;name&quot;: &quot;pipeline_default&quot;,
              &quot;aliases&quot;: [
                &quot;build&quot;
              ]
            &#125;
          ],
          &quot;on_success&quot;: true,
          &quot;auth_config&quot;: &#123;&#125;
        &#125;
      ]
    &#125;
  ],
  &quot;networks&quot;: [
    &#123;
      &quot;name&quot;: &quot;pipeline_default&quot;,
      &quot;driver&quot;: &quot;bridge&quot;
    &#125;
  ],
  &quot;volumes&quot;: [
    &#123;
      &quot;name&quot;: &quot;pipeline_default&quot;,
      &quot;driver&quot;: &quot;local&quot;
    &#125;
  ],
  &quot;secrets&quot;: null
&#125;
</code></pre>
<p>简单分析结构：</p>
<ul>
<li>pipeline 定义了执行的stage，每个stage有一个或者多个step</li>
<li>networks、volumes、secrets 分别定义网络、存储和secrets<ul>
<li>通过network，实现container互通</li>
<li>通过volumes实现数据共享</li>
</ul>
</li>
</ul>
<p>最后执行，通过<code>pipec exec</code>：</p>
<pre><code># pipec exec
proc &quot;pipeline_clone_0&quot; started
+ git init
Initialized empty Git repository in /go/src/github.com/drone/envsubst/.git/
+ git remote add origin https://github.com/drone/envsubst.git
+ git fetch --no-tags --depth=50 origin +refs/heads/master:
From https://github.com/drone/envsubst
 * branch            master     -&gt; FETCH_HEAD
 * [new branch]      master     -&gt; origin/master
+ git reset --hard -q d0876d3176965f9552a611cbd56e24a9264355e6
+ git submodule update --init --recursive
proc &quot;pipeline_clone_0&quot; exited with status 0
proc &quot;pipeline_step_0&quot; started
+ go get -t ./...
+ go build
+ go test -v
=== RUN   TestExpand
--- PASS: TestExpand (0.00s)
=== RUN   TestFuzz
--- PASS: TestFuzz (0.01s)
=== RUN   Test_len
--- PASS: Test_len (0.00s)
=== RUN   Test_lower
--- PASS: Test_lower (0.00s)
=== RUN   Test_lowerFirst
--- PASS: Test_lowerFirst (0.00s)
=== RUN   Test_upper
--- PASS: Test_upper (0.00s)
=== RUN   Test_upperFirst
--- PASS: Test_upperFirst (0.00s)
=== RUN   Test_default
--- PASS: Test_default (0.00s)
PASS
ok      github.com/drone/envsubst    0.009s
proc &quot;pipeline_step_0&quot; exited with status 0
</code></pre>
<h2 id="pipeline-原理分析"><a href="#pipeline-原理分析" class="headerlink" title="pipeline 原理分析"></a>pipeline 原理分析</h2><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>可以形象的理解为 .env+pipeline.yml –&gt; pipeline.json</p>
<p>编译过程不复杂，主要是解析pipeline.yml为<code>Config</code>:</p>
<pre><code>Config struct &#123;    Cache     libcompose.Stringorslice    Platform  string    Branches  Constraint    Workspace Workspace    Clone     Containers    Pipeline  Containers    Services  Containers    Networks  Networks    Volumes   Volumes    Labels    libcompose.SliceorMap&#125;
</code></pre>
<p>然后转换为json对应的config：</p>
<pre><code>Config struct &#123;    Stages   []*Stage   `json:&quot;pipeline&quot;` // pipeline stages    Networks []*Network `json:&quot;networks&quot;` // network definitions    Volumes  []*Volume  `json:&quot;volumes&quot;`  // volume definitions    Secrets  []*Secret  `json:&quot;secrets&quot;`  // secret definitions&#125;
</code></pre>
<p>该部分主要代码在pipeline/frontend里</p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>我们主要关注执行过程，主要代码在pipeline/backend里。</p>
<p>首先是读取配置文件为backend.Config</p>
<pre><code>config, err := pipeline.Parse(reader)if err != nil &#123;    return err&#125;
</code></pre>
<p>然后创建执行环境，目前的代码仅docker可用，k8s是空代码。</p>
<pre><code>var engine backend.Engineif c.Bool(&quot;kubernetes&quot;) &#123;    engine = kubernetes.New(        c.String(&quot;kubernetes-namepsace&quot;),        c.String(&quot;kubernetes-endpoint&quot;),        c.String(&quot;kubernetes-token&quot;),    )&#125; else &#123;    engine, err = docker.NewEnv()    if err != nil &#123;        return err    &#125;&#125;
</code></pre>
<p>接着开始执行</p>
<pre><code>    ctx, cancel := context.WithTimeout(context.Background(), c.Duration(&quot;timeout&quot;))defer cancel()ctx = interrupt.WithContext(ctx)
return pipeline.New(config,    pipeline.WithContext(ctx),    pipeline.WithLogger(defaultLogger),    pipeline.WithTracer(defaultTracer),    pipeline.WithEngine(engine),).Run()
</code></pre>
<p>其中pipeline.NEW创建了<code>Runtime</code>对象;</p>
<pre><code>type Runtime struct &#123;err     error  // 错误信息spec    *backend.Config  // 配置信息engine  backend.Engine  // docker enginestarted int64 // 开始时间
ctx    context.Contexttracer Tracerlogger Logger
&#125;
</code></pre>
<p>其中Engine，操作容器的interface，目前仅docker可用。</p>
<pre><code>// Engine defines a container orchestration backend and is used
// to create and manage container resources.
type Engine interface &#123;// Setup the pipeline environment.Setup(context.Context, *Config) error// Start the pipeline step.Exec(context.Context, *Step) error// Kill the pipeline step.Kill(context.Context, *Step) error// Wait for the pipeline step to complete and returns// the completion results.Wait(context.Context, *Step) (*State, error)// Tail the pipeline step logs.Tail(context.Context, *Step) (io.ReadCloser, error)// Destroy the pipeline environment.Destroy(context.Context, *Config) error
&#125;
</code></pre>
<p>关注Run：</p>
<pre><code>// Run starts the runtime and waits for it to complete.
func (r *Runtime) Run() error &#123;
    // 延迟函数，用于销毁docker envdefer func() &#123;    r.engine.Destroy(r.ctx, r.spec)&#125;()// 初始化docker enginer.started = time.Now().Unix()if err := r.engine.Setup(r.ctx, r.spec); err != nil &#123;    return err&#125;
   
   // 依次运行stagefor _, stage := range r.spec.Stages &#123;    select &#123;    case &lt;-r.ctx.Done():        return ErrCancel    // 执行    case err := &lt;-r.execAll(stage.Steps):        if err != nil &#123;            r.err = err        &#125;    &#125;&#125;
return r.err
&#125;
</code></pre>
<p>重点在于使用errgroup.Group通过协程方式运行step：</p>
<pre><code>// 执行所有steps
func (r *Runtime) execAll(procs []*backend.Step) &lt;-chan error &#123;var g errgroup.Groupdone := make(chan error)
    // 遍历执行stepfor _, proc := range procs &#123;   // 协程 exec    proc := proc    g.Go(func() error &#123;        return r.exec(proc)    &#125;)&#125;
go func() &#123;    done &lt;- g.Wait()    close(done)&#125;()return done
&#125;

// 执行单个step
func (r *Runtime) exec(proc *backend.Step) error &#123;switch &#123;case r.err != nil &amp;&amp; proc.OnFailure == false:    return nilcase r.err == nil &amp;&amp; proc.OnSuccess == false:    return nil&#125;// trace日志if r.tracer != nil &#123;    state := new(State)    state.Pipeline.Time = r.started    state.Pipeline.Error = r.err    state.Pipeline.Step = proc    state.Process = new(backend.State) // empty    if err := r.tracer.Trace(state); err == ErrSkip &#123;        return nil    &#125; else if err != nil &#123;        return err    &#125;&#125;
   
   // docker engine执行if err := r.engine.Exec(r.ctx, proc); err != nil &#123;    return err&#125;
   
   // 记录日志信息if r.logger != nil &#123;    rc, err := r.engine.Tail(r.ctx, proc)    if err != nil &#123;        return err    &#125;
    go func() &#123;        r.logger.Log(proc, multipart.New(rc))        rc.Close()    &#125;()&#125;
if proc.Detached &#123;    return nil&#125;

   // 等待docker engine执行完成wait, err := r.engine.Wait(r.ctx, proc)if err != nil &#123;    return err&#125;
if r.tracer != nil &#123;    state := new(State)    state.Pipeline.Time = r.started    state.Pipeline.Error = r.err    state.Pipeline.Step = proc    state.Process = wait    if err := r.tracer.Trace(state); err != nil &#123;        return err    &#125;&#125;
   if wait.OOMKilled &#123;    return &amp;OomError&#123;        Name: proc.Name,        Code: wait.ExitCode,    &#125;&#125; else if wait.ExitCode != 0 &#123;    return &amp;ExitError&#123;        Name: proc.Name,        Code: wait.ExitCode,    &#125;&#125;return nil
&#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>drone</tag>
        <tag>pipeline</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Client （another java docker client api）</title>
    <url>/jadepeng/2019/01/22/jqpeng-Docker%20Client%20%EF%BC%88another%20java%20docker%20client%20api%EF%BC%89/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/java-Docker-Client.html">Docker Client （another java docker client api）</a></p>
<p>前一篇提到了docker-java，这里介绍另一个docker client 库，<a href="https://github.com/spotify/docker-client">Docker Client</a></p>
<h2 id="版本兼容"><a href="#版本兼容" class="headerlink" title="版本兼容"></a>版本兼容</h2><p>兼容17.03.1<del>ce - 17.12.1</del>ce (点 [here][1]查看).</p>
<h2 id="下载jar包"><a href="#下载jar包" class="headerlink" title="下载jar包"></a>下载jar包</h2><p>点击 [via Maven][maven-search]搜索和下载最新的jar包.</p>
<p>pom.xml配置如下：</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.spotify&lt;/groupId&gt;
  &lt;artifactId&gt;docker-client&lt;/artifactId&gt;
  &lt;version&gt;LATEST-VERSION&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>当前最新的是8.15.0</p>
<pre><code>&lt;dependency&gt;&lt;groupId&gt;com.spotify&lt;/groupId&gt;&lt;artifactId&gt;docker-client&lt;/artifactId&gt;&lt;version&gt;8.15.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2><pre><code>// Create a client based on DOCKER_HOST and DOCKER_CERT_PATH env vars
final DockerClient docker = DefaultDockerClient.fromEnv().build();

// Pull an image
docker.pull(&quot;busybox&quot;);

// Bind container ports to host ports
final String[] ports = &#123;&quot;80&quot;, &quot;22&quot;&#125;;
final Map&lt;String, List&lt;PortBinding&gt;&gt; portBindings = new HashMap&lt;&gt;();
for (String port : ports) &#123;
    List&lt;PortBinding&gt; hostPorts = new ArrayList&lt;&gt;();
    hostPorts.add(PortBinding.of(&quot;0.0.0.0&quot;, port));
    portBindings.put(port, hostPorts);
&#125;

// Bind container port 443 to an automatically allocated available host port.
List&lt;PortBinding&gt; randomPort = new ArrayList&lt;&gt;();
randomPort.add(PortBinding.randomPort(&quot;0.0.0.0&quot;));
portBindings.put(&quot;443&quot;, randomPort);

final HostConfig hostConfig = HostConfig.builder().portBindings(portBindings).build();

// Create container with exposed ports
final ContainerConfig containerConfig = ContainerConfig.builder()
    .hostConfig(hostConfig)
    .image(&quot;busybox&quot;).exposedPorts(ports)
    .cmd(&quot;sh&quot;, &quot;-c&quot;, &quot;while :; do sleep 1; done&quot;)
    .build();

final ContainerCreation creation = docker.createContainer(containerConfig);
final String id = creation.id();

// Inspect container
final ContainerInfo info = docker.inspectContainer(id);

// Start container
docker.startContainer(id);

// Exec command inside running container with attached STDOUT and STDERR
final String[] command = &#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls&quot;&#125;;
final ExecCreation execCreation = docker.execCreate(
    id, command, DockerClient.ExecCreateParam.attachStdout(),
    DockerClient.ExecCreateParam.attachStderr());
final LogStream output = docker.execStart(execCreation.id());
final String execOutput = output.readFully();

// Kill container
docker.killContainer(id);

// Remove container
docker.removeContainer(id);

// Close the docker client
docker.close();
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-java Docker的java API</title>
    <url>/jadepeng/2019/01/22/jqpeng-docker-java%20Docker%E7%9A%84java%20API/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/docker-java.html">docker-java Docker的java API</a></p>
<h2 id="docker-java"><a href="#docker-java" class="headerlink" title="docker-java"></a>docker-java</h2><p>docker-java 是 Docker的 Java 版本API  <a href="http://docs.docker.io/" title="Docker">Docker</a></p>
<p><strong>当前的实现基于 Jersey 2.x 因此 classpath 不兼容老版本的 Jersey 1.x !</strong></p>
<p>开发者论坛 <a href="https://groups.google.com/forum/#!forum/docker-java-dev" title="docker-java">docker-java</a></p>
<p><a href="https://github.com/docker-java/docker-java/blob/master/CHANGELOG.md">Changelog</a>  </p>
<p><a href="https://github.com/docker-java/docker-java/wiki">Wiki</a></p>
<h2 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h2><p>Supports a subset of the Docker Remote API <a href="https://docs.docker.com/engine/api/v1.37/">v1.37</a>, Docker Server version since 1.12.6</p>
<pre><code>&lt;dependency&gt;
      &lt;groupId&gt;com.github.docker-java&lt;/groupId&gt;
      &lt;artifactId&gt;docker-java&lt;/artifactId&gt;
      &lt;!-- use latest version https://github.com/docker-java/docker-java/releases --&gt;
      &lt;version&gt;3.X.Y&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>当前最新的版本是3.1.0，可以点击<a href="https://github.com/docker-java/docker-java/releases">这里</a>查看最新版本。</p>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;com.github.docker-java&lt;/groupId&gt;
        &lt;artifactId&gt;docker-java&lt;/artifactId&gt;
        &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<h2 id="wiki文档"><a href="#wiki文档" class="headerlink" title="wiki文档"></a>wiki文档</h2><p>For code examples, please look at the <a href="https://github.com/docker-java/docker-java/wiki">Wiki</a> or <a href="https://github.com/docker-java/docker-java/tree/master/src/test/java/com/github/dockerjava/core/command" title="Test cases">Test cases</a></p>
<h2 id="配置Docker环境"><a href="#配置Docker环境" class="headerlink" title="配置Docker环境"></a>配置Docker环境</h2><p>系统的可配置项及默认值如下:</p>
<ul>
<li><code>DOCKER_HOST</code> The Docker Host URL, e.g. <code>tcp://localhost:2376</code> or <code>unix:///var/run/docker.sock</code></li>
<li><code>DOCKER_TLS_VERIFY</code> enable/disable TLS verification (switch between <code>http</code> and <code>https</code> protocol)</li>
<li><code>DOCKER_CERT_PATH</code> Path to the certificates needed for TLS verification</li>
<li><code>DOCKER_CONFIG</code> Path for additional docker configuration files (like <code>.dockercfg</code>)</li>
<li><code>api.version</code> The API version, e.g. <code>1.23</code>.</li>
<li><code>registry.url</code> Your registry’s address.</li>
<li><code>registry.username</code> Your registry username (required to push containers).</li>
<li><code>registry.password</code> Your registry password.</li>
<li><code>registry.email</code> Your registry email.</li>
</ul>
<p>There are three ways to configure, in descending order of precedence:</p>
<h3 id="编程方式配置"><a href="#编程方式配置" class="headerlink" title="编程方式配置:"></a>编程方式配置:</h3><pre><code>DockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder()
    .withDockerHost(&quot;tcp://my-docker-host.tld:2376&quot;)
    .withDockerTlsVerify(true)
    .withDockerCertPath(&quot;/home/user/.docker/certs&quot;)
    .withDockerConfig(&quot;/home/user/.docker&quot;)
    .withApiVersion(&quot;1.30&quot;) // optional
    .withRegistryUrl(&quot;https://index.docker.io/v1/&quot;)
    .withRegistryUsername(&quot;dockeruser&quot;)
    .withRegistryPassword(&quot;ilovedocker&quot;)
    .withRegistryEmail(&quot;dockeruser@github.com&quot;)
    .build();
DockerClient docker = DockerClientBuilder.getInstance(config).build();
</code></pre>
<h3 id="通过Properties-docker-java-properties"><a href="#通过Properties-docker-java-properties" class="headerlink" title="通过Properties (docker-java.properties)"></a>通过Properties (docker-java.properties)</h3><pre><code>DOCKER_HOST=tcp://localhost:2376
DOCKER_TLS_VERIFY=1
DOCKER_CERT_PATH=/home/user/.docker/certs
DOCKER_CONFIG=/home/user/.docker
api.version=1.23
registry.url=https://index.docker.io/v1/
registry.username=dockeruser
registry.password=ilovedocker
registry.email=dockeruser@github.com
</code></pre>
<h3 id="通过System-Properties"><a href="#通过System-Properties" class="headerlink" title="通过System Properties:"></a>通过System Properties:</h3><pre><code>java -DDOCKER_HOST=tcp://localhost:2375 -Dregistry.username=dockeruser pkg.Main
</code></pre>
<h3 id="通过-Environment"><a href="#通过-Environment" class="headerlink" title="通过 Environment"></a>通过 Environment</h3><pre><code>export DOCKER_HOST=tcp://localhost:2376
export DOCKER_TLS_VERIFY=1
export DOCKER_CERT_PATH=/home/user/.docker/certs
export DOCKER_CONFIG=/home/user/.docker
</code></pre>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们来简单测试下：</p>
<pre><code>    DockerClient dockerClient = createClient();

    // docker info
    Info info = dockerClient.infoCmd().exec();
    System.out.print(info);

    // 搜索镜像
    List&lt;SearchItem&gt; dockerSearch = dockerClient.searchImagesCmd(&quot;busybox&quot;).exec();
    System.out.println(&quot;Search returned&quot; + dockerSearch.toString());

    // pull

    dockerClient.pullImageCmd(&quot;busybox:latest&quot;).exec(new ResultCallback&lt;PullResponseItem&gt;() &#123;
        public void onStart(Closeable closeable) &#123;

        &#125;

        public void onNext(PullResponseItem object) &#123;
            System.out.println(object.getStatus());
        &#125;

        public void onError(Throwable throwable) &#123;
            throwable.printStackTrace();
        &#125;

        public void onComplete() &#123;
            System.out.println(&quot;pull finished&quot;);
        &#125;

        public void close() throws IOException &#123;

        &#125;
    &#125;);




    // 创建container 并测试

    // create
    CreateContainerResponse container = dockerClient.createContainerCmd(&quot;busybox&quot;)
            .withCmd(&quot;/bin/bash&quot;)
            .exec();
    // start
    dockerClient.startContainerCmd(container.getId()).exec();
    dockerClient.stopContainerCmd(container.getId()).exec();
    dockerClient.removeContainerCmd(container.getId()).exec();

    EventsResultCallback callback = new EventsResultCallback() &#123;
        @Override
        public void onNext(Event event) &#123;
            System.out.println(&quot;Event: &quot; + event);
            super.onNext(event);
        &#125;
    &#125;;

    dockerClient.eventsCmd().exec(callback).awaitCompletion().close();
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker运行php网站程序</title>
    <url>/jadepeng/2019/01/03/jqpeng-docker%E8%BF%90%E8%A1%8Cphp%E7%BD%91%E7%AB%99%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/docker-php.html">docker运行php网站程序</a></p>
<p>有一个之前的php网站程序需要迁移到K8S，简单调研了下。</p>
<h2 id="基础镜像"><a href="#基础镜像" class="headerlink" title="基础镜像"></a>基础镜像</h2><p>官方提供了诸如php:7.1-apache的基础镜像，但是确认必要的扩展，例如gd，当然官方提供了<code>docker-php-ext-install</code>命令，可以用来安装需要的扩展。但是每次构建都重新安装非常费时，最好的办法是构建一个包含必要扩展的基础镜像。</p>
<pre><code>FROM php:7.1-apache
ENV PORT 80
EXPOSE 80

RUN buildDeps=&quot; \
        default-libmysqlclient-dev \
        libbz2-dev \
        libsasl2-dev \
    &quot; \
    runtimeDeps=&quot; \
        curl \
        git \
        libfreetype6-dev \
        libicu-dev \
        libjpeg-dev \
        libmcrypt-dev \
        libpng-dev \
        libpq-dev \
        libxml2-dev \
    &quot; \
    sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list  \
    &amp;&amp; apt-get update &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -y $buildDeps $runtimeDeps \
    &amp;&amp; docker-php-ext-install bcmath bz2 calendar iconv intl mbstring mcrypt mysqli opcache pdo_mysql pdo_pgsql pgsql soap zip \
    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \
    &amp;&amp; docker-php-ext-install gd \
    &amp;&amp; apt-get purge -y --auto-remove $buildDeps \
    &amp;&amp; rm -r /var/lib/apt/lists/* 

ENV PATH=$PATH:/root/composer/vendor/bin COMPOSER_ALLOW_SUPERUSER=1
</code></pre>
<p>然后构建基础镜像</p>
<pre><code>docker build -t common/php:7.1-apache .
</code></pre>
<p>PS： 更多的php镜像，查看 <a href="https://github.com/chialab/docker-php">https://github.com/chialab/docker-php</a></p>
<h2 id="使用基础镜像"><a href="#使用基础镜像" class="headerlink" title="使用基础镜像"></a>使用基础镜像</h2><p>Dockerfile应用刚构建好的基础镜像：</p>
<pre><code>FROM common/php:7.1-apache
ENV PORT 80
EXPOSE 80
COPY . /var/www/html
RUN usermod -u 1000 www-data; \a2enmod rewrite; \chown -R www-data:www-data /var/www/html
</code></pre>
<p>构建即可：</p>
<pre><code>docker build -t common/zhifou:v0.0.12 .
</code></pre>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>易企秀H5 json配置文件解密分析</title>
    <url>/jadepeng/2018/11/27/jqpeng-%E6%98%93%E4%BC%81%E7%A7%80H5%20json%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/10028472.html">易企秀H5 json配置文件解密分析</a></p>
<p>最近需要参考下易企秀H5的json配置文件，发现已经做了加密，其实前端的加密分析起来只是麻烦点。</p>
<h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>先看一个H5： <a href="https://h5.eqxiu.com/s/XvEn30op">https://h5.eqxiu.com/s/XvEn30op</a></p>
<p>F12可以看到，配置json地址是：<a href="https://s1-cdn.eqxiu.com/eqs/page/142626394?code=XvEn30op&amp;time=1542972816000">https://s1-cdn.eqxiu.com/eqs/page/142626394?code=XvEn30op&amp;time=1542972816000</a></p>
<p>对应的json：</p>
<p>{“success”:true,”code”:200,”msg”:”操作成功”,”obj”:”加密后的字符串”}</p>
<p>obj对应的是正式的配置信息</p>
<h2 id="解码分析"><a href="#解码分析" class="headerlink" title="解码分析"></a>解码分析</h2><p>需要对加密信息进行解密，首先可以定位到解密代码</p>
<pre><code>function _0x230bc7(_0x2fb175) &#123;
    return _0x3c31(&#39;0xee&#39;) == typeof _0x2fb175[_0x3c31(&#39;0x25&#39;)] &amp;&amp; _0x2fb175[&#39;\x6f\x62\x6a&#39;][_0x3c31(&#39;0xe&#39;)] &gt; 0x64 ? _0x54c90c[_0x3c31(&#39;0x31f&#39;)]()[&#39;\x74\x68\x65\x6e&#39;](function() &#123;
        _0x249a60();
        var _0x5ab652 = null
          , _0x2cf0a4 = null
          , _0x4d1175 = null;
        try &#123;
            var _0x3dbfaa = _0x2fb175[_0x3c31(&#39;0x25&#39;)][&#39;\x73\x75\x62\x73\x74\x72\x69\x6e\x67&#39;](0x0, 0x13)
              , _0x360e25 = _0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xeb&#39;)](0x13 + 0x10);
            _0x2cf0a4 = _0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xeb&#39;)](0x13, 0x13 + 0x10),
            _0x4d1175 = _0x2cf0a4,
            _0x5ab652 = _0x3dbfaa + _0x360e25,
            _0x2cf0a4 = CryptoJS[&#39;\x65\x6e\x63&#39;][_0x3c31(&#39;0x320&#39;)][_0x3c31(&#39;0x6b&#39;)](_0x2cf0a4),
            _0x4d1175 = CryptoJS[_0x3c31(&#39;0x321&#39;)][_0x3c31(&#39;0x320&#39;)][&#39;\x70\x61\x72\x73\x65&#39;](_0x4d1175);
            var _0x57e61a = CryptoJS[_0x3c31(&#39;0x322&#39;)][_0x3c31(&#39;0x323&#39;)](_0x5ab652, _0x2cf0a4, &#123;
                &#39;\x69\x76&#39;: _0x4d1175,
                &#39;\x6d\x6f\x64\x65&#39;: CryptoJS[_0x3c31(&#39;0x324&#39;)][_0x3c31(&#39;0x325&#39;)],
                &#39;\x70\x61\x64\x64\x69\x6e\x67&#39;: CryptoJS[_0x3c31(&#39;0x326&#39;)][_0x3c31(&#39;0x327&#39;)]
            &#125;);
            return _0x2fb175[_0x3c31(&#39;0x36&#39;)] = JSON[_0x3c31(&#39;0x6b&#39;)](CryptoJS[_0x3c31(&#39;0x321&#39;)][_0x3c31(&#39;0x320&#39;)][_0x3c31(&#39;0x267&#39;)](_0x57e61a)),
            _0x2fb175;
        &#125; catch (_0x36fffe) &#123;
            _0x5ab652 = _0x2fb175[_0x3c31(&#39;0x25&#39;)][&#39;\x73\x75\x62\x73\x74\x72\x69\x6e\x67&#39;](0x0, _0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xe&#39;)] - 0x10),
            _0x2cf0a4 = _0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xeb&#39;)](_0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xe&#39;)] - 0x10),
            _0x4d1175 = _0x2cf0a4,
            _0x2cf0a4 = CryptoJS[_0x3c31(&#39;0x321&#39;)][_0x3c31(&#39;0x320&#39;)][_0x3c31(&#39;0x6b&#39;)](_0x2cf0a4),
            _0x4d1175 = CryptoJS[_0x3c31(&#39;0x321&#39;)][_0x3c31(&#39;0x320&#39;)][_0x3c31(&#39;0x6b&#39;)](_0x4d1175);
            var _0x4ff7de = CryptoJS[_0x3c31(&#39;0x322&#39;)][_0x3c31(&#39;0x323&#39;)](_0x5ab652, _0x2cf0a4, &#123;
                &#39;\x69\x76&#39;: _0x4d1175,
                &#39;\x6d\x6f\x64\x65&#39;: CryptoJS[&#39;\x6d\x6f\x64\x65&#39;][_0x3c31(&#39;0x325&#39;)],
                &#39;\x70\x61\x64\x64\x69\x6e\x67&#39;: CryptoJS[_0x3c31(&#39;0x326&#39;)][_0x3c31(&#39;0x327&#39;)]
            &#125;);
            return _0x2fb175[_0x3c31(&#39;0x36&#39;)] = JSON[_0x3c31(&#39;0x6b&#39;)](CryptoJS[_0x3c31(&#39;0x321&#39;)][&#39;\x55\x74\x66\x38&#39;][_0x3c31(&#39;0x267&#39;)](_0x4ff7de)),
            _0x2fb175;
        &#125;
    &#125;) : Promise[_0x3c31(&#39;0x1e&#39;)](_0x2fb175);
</code></pre>
<p>这个代码基本不可读，简单分析下可以发现，_0x3c31(‘0x321’)对应一个字符串，’\x6f\x62\x6a’等也可以转义：</p>
<p>先转义：</p>
<pre><code>function decode(xData) &#123;
    return xData.replace(/\\x(\w&#123;2&#125;)/g, function (_, $1) &#123; return String.fromCharCode(parseInt($1, 16)) &#125;);
&#125;
</code></pre>
<p>然后替换下：</p>
<pre><code>Function.prototype.getMultiLine = function () &#123;
    var lines = new String(this);
    lines = lines.substring(lines.indexOf(&quot;/*&quot;) + 3, lines.lastIndexOf(&quot;*/&quot;));
    return lines;
&#125;

function decode(xData) &#123;
    return xData.replace(/\\x(\w&#123;2&#125;)/g, function (_, $1) &#123; return String.fromCharCode(parseInt($1, 16)) &#125;);
&#125;

var str1 = function () &#123;
    /* 
   var _0x5ab652 = _0x50019d(_0x3c31(&#39;0x30c&#39;))
, _0x2cf0a4 = _0x50019d(&#39;\x63\x6f\x6d\x70\x4b\x65\x79&#39;)
, _0x5cba8a = &#123;
  &#39;\x74\x79\x70\x65&#39;: _0x3c31(&#39;0x16c&#39;),
  &#39;\x75\x72\x6c&#39;: _0x8aa6f1()
&#125;
, _0xfca4af = &#123;
  &#39;\x74\x79\x70\x65&#39;: _0x3c31(&#39;0x16c&#39;),
  &#39;\x75\x72\x6c&#39;: _0xefaeb()
&#125;;
_0x31f1b8 &amp;&amp; (_0x5cba8a[_0x3c31(&#39;0x2cb&#39;)] = &#123;
  &#39;\x70\x61\x73\x73\x77\x6f\x72\x64&#39;: _0x31f1b8
&#125;);
var _0x11871b = null
, _0x170c7e = Promise[_0x3c31(&#39;0x1e&#39;)](null);
 
var _0x256cd0 = _0x2cf0a4(0x16)
, _0x36150e = _0x2cf0a4(0x15)
, _0x42a8d9 = _0x36150e[&#39;\x61\x6a\x61\x78&#39;]
, _0xdc46dc = _0x36150e[_0x3c31(&#39;0x1ef&#39;)]
, _0xcca797 = _0x2cf0a4(0x18)
, _0x50019d = _0xcca797[_0x3c31(&#39;0x5f&#39;)]
, _0x5c77e3 = _0xcca797[&#39;\x70\x61\x72\x73\x65\x55\x72\x6c&#39;]
, _0x36d54a = _0x2cf0a4(0x3a)[&#39;\x70\x65\x72\x66\x65\x63\x74\x4d\x65\x74\x61&#39;]
, _0x4c6a9e = _0x2cf0a4(0x2c)[_0x3c31(&#39;0x328&#39;)]
, _0x296a9b = _0x2cf0a4(0x2c)[_0x3c31(&#39;0x329&#39;)]
, _0x54c90c = _0x2cf0a4(0x17)
, _0x50f238 = _0x2cf0a4(0x3d)[_0x3c31(&#39;0x32a&#39;)]
, 0x13 = 0x13
, 0x0 = 0x0
, 0x10 = 0x10
, CryptoJS = null;
    function _0x230bc7(_0x2fb175) &#123;
    return _0x3c31(&#39;0xee&#39;) == typeof _0x2fb175[_0x3c31(&#39;0x25&#39;)] &amp;&amp; _0x2fb175[&#39;\x6f\x62\x6a&#39;][_0x3c31(&#39;0xe&#39;)] &gt; 0x64 ? _0x54c90c[_0x3c31(&#39;0x31f&#39;)]()[&#39;\x74\x68\x65\x6e&#39;](function() &#123;
        _0x249a60();
        var _0x5ab652 = null
          , _0x2cf0a4 = null
          , _0x4d1175 = null;
        try &#123;
            var _0x3dbfaa = _0x2fb175[_0x3c31(&#39;0x25&#39;)][&#39;\x73\x75\x62\x73\x74\x72\x69\x6e\x67&#39;](0x0, 0x13)
              , _0x360e25 = _0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xeb&#39;)](0x13 + 0x10);
            _0x2cf0a4 = _0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xeb&#39;)](0x13, 0x13 + 0x10),
            _0x4d1175 = _0x2cf0a4,
            _0x5ab652 = _0x3dbfaa + _0x360e25,
            _0x2cf0a4 = CryptoJS[&#39;\x65\x6e\x63&#39;][_0x3c31(&#39;0x320&#39;)][_0x3c31(&#39;0x6b&#39;)](_0x2cf0a4),
            _0x4d1175 = CryptoJS[_0x3c31(&#39;0x321&#39;)][_0x3c31(&#39;0x320&#39;)][&#39;\x70\x61\x72\x73\x65&#39;](_0x4d1175);
            var _0x57e61a = CryptoJS[_0x3c31(&#39;0x322&#39;)][_0x3c31(&#39;0x323&#39;)](_0x5ab652, _0x2cf0a4, &#123;
                &#39;\x69\x76&#39;: _0x4d1175,
                &#39;\x6d\x6f\x64\x65&#39;: CryptoJS[_0x3c31(&#39;0x324&#39;)][_0x3c31(&#39;0x325&#39;)],
                &#39;\x70\x61\x64\x64\x69\x6e\x67&#39;: CryptoJS[_0x3c31(&#39;0x326&#39;)][_0x3c31(&#39;0x327&#39;)]
            &#125;);
            return _0x2fb175[_0x3c31(&#39;0x36&#39;)] = JSON[_0x3c31(&#39;0x6b&#39;)](CryptoJS[_0x3c31(&#39;0x321&#39;)][_0x3c31(&#39;0x320&#39;)][_0x3c31(&#39;0x267&#39;)](_0x57e61a)),
            _0x2fb175;
        &#125; catch (_0x36fffe) &#123;
            _0x5ab652 = _0x2fb175[_0x3c31(&#39;0x25&#39;)][&#39;\x73\x75\x62\x73\x74\x72\x69\x6e\x67&#39;](0x0, _0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xe&#39;)] - 0x10),
            _0x2cf0a4 = _0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xeb&#39;)](_0x2fb175[_0x3c31(&#39;0x25&#39;)][_0x3c31(&#39;0xe&#39;)] - 0x10),
            _0x4d1175 = _0x2cf0a4,
            _0x2cf0a4 = CryptoJS[_0x3c31(&#39;0x321&#39;)][_0x3c31(&#39;0x320&#39;)][_0x3c31(&#39;0x6b&#39;)](_0x2cf0a4),
            _0x4d1175 = CryptoJS[_0x3c31(&#39;0x321&#39;)][_0x3c31(&#39;0x320&#39;)][_0x3c31(&#39;0x6b&#39;)](_0x4d1175);
            var _0x4ff7de = CryptoJS[_0x3c31(&#39;0x322&#39;)][_0x3c31(&#39;0x323&#39;)](_0x5ab652, _0x2cf0a4, &#123;
                &#39;\x69\x76&#39;: _0x4d1175,
                &#39;\x6d\x6f\x64\x65&#39;: CryptoJS[&#39;\x6d\x6f\x64\x65&#39;][_0x3c31(&#39;0x325&#39;)],
                &#39;\x70\x61\x64\x64\x69\x6e\x67&#39;: CryptoJS[_0x3c31(&#39;0x326&#39;)][_0x3c31(&#39;0x327&#39;)]
            &#125;);
            return _0x2fb175[_0x3c31(&#39;0x36&#39;)] = JSON[_0x3c31(&#39;0x6b&#39;)](CryptoJS[_0x3c31(&#39;0x321&#39;)][&#39;\x55\x74\x66\x38&#39;][_0x3c31(&#39;0x267&#39;)](_0x4ff7de)),
            _0x2fb175;
        &#125;
    &#125;) : Promise[_0x3c31(&#39;0x1e&#39;)](_0x2fb175);
&#125;&quot;
  */
&#125;
var js1 = decode(str1.getMultiLine());
js1 = js1.replace(/_0x3c31\(&#39;([^\&#39;]+)&#39;\)/g, function ($v, $g) &#123; return _0x3c31($g); &#125;)
</code></pre>
<p>得到</p>
<pre><code>var _0x5ab652 = _0x50019d(userKey)
, _0x2cf0a4 = _0x50019d(&#39;compKey&#39;)
, _0x5cba8a = &#123;
  &#39;type&#39;: GET,
  &#39;url&#39;: _0x8aa6f1()
&#125;
, _0xfca4af = &#123;
  &#39;type&#39;: GET,
  &#39;url&#39;: _0xefaeb()
&#125;;
_0x31f1b8 &amp;&amp; (_0x5cba8a[data] = &#123;
  &#39;password&#39;: _0x31f1b8
&#125;);
var _0x11871b = null
, _0x170c7e = Promise[resolve](null);
 
var _0x256cd0 = _0x2cf0a4(0x16)
, _0x36150e = _0x2cf0a4(0x15)
, _0x42a8d9 = _0x36150e[&#39;ajax&#39;]
, _0xdc46dc = _0x36150e[$ajax]
, _0xcca797 = _0x2cf0a4(0x18)
, _0x50019d = _0xcca797[getUrlParam]
, _0x5c77e3 = _0xcca797[&#39;parseUrl&#39;]
, _0x36d54a = _0x2cf0a4(0x3a)[&#39;perfectMeta&#39;]
, _0x4c6a9e = _0x2cf0a4(0x2c)[isVipScene]
, _0x296a9b = _0x2cf0a4(0x2c)[isTgScene]
, _0x54c90c = _0x2cf0a4(0x17)
, _0x50f238 = _0x2cf0a4(0x3d)[setJsCrypto]
, 0x13 = 0x13
, 0x0 = 0x0
, 0x10 = 0x10
, CryptoJS = null;
    function _0x230bc7(_0x2fb175) &#123;
    return string == typeof _0x2fb175[obj] &amp;&amp; _0x2fb175[&#39;obj&#39;][length] &gt; 0x64 ? _0x54c90c[$loadCryptoJS]()[&#39;then&#39;](function() &#123;
        _0x249a60();
        var _0x5ab652 = null
          , _0x2cf0a4 = null
          , _0x4d1175 = null;
        try &#123;
            var _0x3dbfaa = _0x2fb175[obj][&#39;substring&#39;](0x0, 0x13)
              , _0x360e25 = _0x2fb175[obj][substring](0x13 + 0x10);
            _0x2cf0a4 = _0x2fb175[obj][substring](0x13, 0x13 + 0x10),
            _0x4d1175 = _0x2cf0a4,
            _0x5ab652 = _0x3dbfaa + _0x360e25,
            _0x2cf0a4 = CryptoJS[&#39;enc&#39;][Utf8][parse](_0x2cf0a4),
            _0x4d1175 = CryptoJS[enc][Utf8][&#39;parse&#39;](_0x4d1175);
            var _0x57e61a = CryptoJS[AES][decrypt](_0x5ab652, _0x2cf0a4, &#123;
                &#39;iv&#39;: _0x4d1175,
                &#39;mode&#39;: CryptoJS[mode][CFB],
                &#39;padding&#39;: CryptoJS[pad][NoPadding]
            &#125;);
            return _0x2fb175[list] = JSON[parse](CryptoJS[enc][Utf8][stringify](_0x57e61a)),
            _0x2fb175;
        &#125; catch (_0x36fffe) &#123;
            _0x5ab652 = _0x2fb175[obj][&#39;substring&#39;](0x0, _0x2fb175[obj][length] - 0x10),
            _0x2cf0a4 = _0x2fb175[obj][substring](_0x2fb175[obj][length] - 0x10),
            _0x4d1175 = _0x2cf0a4,
            _0x2cf0a4 = CryptoJS[enc][Utf8][parse](_0x2cf0a4),
            _0x4d1175 = CryptoJS[enc][Utf8][parse](_0x4d1175);
            var _0x4ff7de = CryptoJS[AES][decrypt](_0x5ab652, _0x2cf0a4, &#123;
                &#39;iv&#39;: _0x4d1175,
                &#39;mode&#39;: CryptoJS[&#39;mode&#39;][CFB],
                &#39;padding&#39;: CryptoJS[pad][NoPadding]
            &#125;);
            return _0x2fb175[list] = JSON[parse](CryptoJS[enc][&#39;Utf8&#39;][stringify](_0x4ff7de)),
            _0x2fb175;
        &#125;
    &#125;) : Promise[resolve](_0x2fb175);
&#125;&quot;
</code></pre>
<p>基板上可以读了，使用CryptoJS做的前端解密，然后直接给最后的代码：</p>
<pre><code>// 依赖： https://lib.eqh5.com/CryptoJS/1.0.1/cryptoJs.js
function decrypt(result) &#123;
    var ciphertext = null
        , key = null
        , iv = null;
    try &#123;
        var part0 = result.obj.substring(0x0, 0x13)
            , part1 = result.obj.substring(0x13 + 0x10);
        key = result.obj.substring(0x13, 0x13 + 0x10),
            iv = key,
            ciphertext = part0 + part1,
            key = CryptoJS.enc.Utf8.parse(key),
            iv = CryptoJS.enc.Utf8.parse(iv);
        var decryptData = CryptoJS.AES.decrypt(ciphertext, key, &#123;
            &#39;iv&#39;: iv,
            &#39;mode&#39;: CryptoJS.mode.CFB,
            &#39;padding&#39;: CryptoJS.pad.NoPadding
        &#125;);
        return CryptoJS.enc.Utf8.stringify(decryptData);
    &#125; catch (_0x36fffe) &#123;
        ciphertext = result[obj][&#39;substring&#39;](0x0, result.obj.length - 0x10),
            key = result[obj][substring](result.obj.length - 0x10),
            iv = key,
            key = CryptoJS.enc.Utf8.parse(key),
            iv = CryptoJS.enc.Utf8.parse(iv);
        var decryptData = CryptoJS.AES.decrypt(ciphertext, key, &#123;
            &#39;iv&#39;: iv,
            &#39;mode&#39;: CryptoJS.mode.CFB,
            &#39;padding&#39;: CryptoJS.pad.NoPadding
        &#125;);
        return CryptoJS.enc.Utf8.stringify(decryptData)
    &#125;
&#125;     
</code></pre>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>易企秀</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S集群安装</title>
    <url>/jadepeng/2018/11/12/jqpeng-K8S%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/9944706.html">K8S集群安装</a></p>
<p>主要参考 <a href="https://github.com/opsnull/follow-me-install-kubernetes-cluster">https://github.com/opsnull/follow-me-install-kubernetes-cluster</a></p>
<h2 id="01-系统初始化和全局变量"><a href="#01-系统初始化和全局变量" class="headerlink" title="01.系统初始化和全局变量"></a>01.系统初始化和全局变量</h2><h3 id="添加-k8s-和-docker-账户"><a href="#添加-k8s-和-docker-账户" class="headerlink" title="添加 k8s 和 docker 账户"></a>添加 k8s 和 docker 账户</h3><p>在每台机器上添加 k8s 账户，可以无密码 sudo：</p>
<pre><code>$ sudo useradd -m k8s
$ sudo visudo
$ sudo grep &#39;%wheel.*NOPASSWD: ALL&#39; /etc/sudoers
%wheel    ALL=(ALL)    NOPASSWD: ALL
$ sudo gpasswd -a k8s wheel
</code></pre>
<p>在每台机器上添加 docker 账户，将 k8s 账户添加到 docker 组中，同时配置 dockerd 参数：</p>
<pre><code>$ sudo useradd -m docker
$ sudo gpasswd -a k8s docker
$ sudo mkdir -p  /etc/docker/
$ cat /etc/docker/daemon.json
&#123;
    &quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;],
    &quot;max-concurrent-downloads&quot;: 20
&#125;
</code></pre>
<h3 id="无密码-ssh-登录其它节点"><a href="#无密码-ssh-登录其它节点" class="headerlink" title="无密码 ssh 登录其它节点"></a>无密码 ssh 登录其它节点</h3><p>ssh-copy-id root@docker86-18<br> ssh-copy-id root@docker86-21<br> ssh-copy-id root@docker86-91<br> ssh-copy-id root@docker86-9</p>
<p>ssh-copy-id k8s@docker86-155<br> ssh-copy-id k8s@docker86-18<br> ssh-copy-id root@docker86-21<br> ssh-copy-id root@docker86-91<br> ssh-copy-id root@docker86-9</p>
<pre><code>source ./environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /opt/k8s/bin &amp;&amp; chown -R k8s /opt/k8s &amp;&amp; mkdir -p /etc/kubernetes/cert &amp;&amp;chown -R k8s /etc/kubernetes &amp;&amp; mkdir -p /etc/etcd/cert &amp;&amp; chown -R k8s /etc/etcd/cert &amp;&amp;  mkdir -p /var/lib/etcd &amp;&amp; chown -R k8s /etc/etcd/cert&quot;
    scp environment.sh k8s@$&#123;node_ip&#125;:/opt/k8s/bin/
    ssh k8s@$&#123;node_ip&#125; &quot;chmod +x /opt/k8s/bin/*&quot;
  done
</code></pre>
<h3 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h3><pre><code>cat &lt;&lt;EOF &gt;environment.sh 
#!/usr/bin/bash

# 生成 EncryptionConfig 所需的加密 key
ENCRYPTION_KEY=$(head -c 32 /dev/urandom | base64)

# 最好使用 当前未用的网段 来定义服务网段和 Pod 网段

# 服务网段，部署前路由不可达，部署后集群内路由可达(kube-proxy 和 ipvs 保证)
SERVICE_CIDR=&quot;10.69.0.0/16&quot;

# Pod 网段，建议 /16 段地址，部署前路由不可达，部署后集群内路由可达(flanneld 保证)
CLUSTER_CIDR=&quot;170.22.0.0/16&quot;

# 服务端口范围 (NodePort Range)
export NODE_PORT_RANGE=&quot;10000-40000&quot;

# 集群各机器 IP 数组
export NODE_IPS=(192.168.86.154 192.168.86.155 192.168.86.156 192.168.86.18 192.168.86.21 192.168.86.91 192.168.86.9)

# etcd节点
export ETCD_NODE_IPS=(192.168.86.154 192.168.86.155 192.168.86.156)

# 集群各 IP 对应的 主机名数组
export NODE_NAMES=(docker86-154 docker86-155 docker86-156 docker86-18 docker86-21 docker86-91 docker86-9)

# kube-apiserver 的 VIP（HA 组件 keepalived 发布的 IP）
export MASTER_VIP=192.168.86.214

# kube-apiserver VIP 地址（HA 组件 haproxy 监听 8443 端口）
export KUBE_APISERVER=&quot;https://$&#123;MASTER_VIP&#125;:8443&quot;

# HA 节点，配置 VIP 的网络接口名称
export VIP_IF=&quot;em1&quot;

# etcd 集群服务地址列表
export ETCD_ENDPOINTS=&quot;https://192.168.86.154:2379,https://192.168.86.155:2379,https://192.168.86.156:2379&quot;

# etcd 集群间通信的 IP 和端口
export ETCD_NODES=&quot;docker86-154=https://192.168.86.154:2380,docker86-155=https://192.168.86.155:2380,docker86-156=https://192.168.86.156:2380&quot;

# flanneld 网络配置前缀
export FLANNEL_ETCD_PREFIX=&quot;/kubernetes/network&quot;

# kubernetes 服务 IP (一般是 SERVICE_CIDR 中第一个IP)
export CLUSTER_KUBERNETES_SVC_IP=&quot;10.69.0.1&quot;

# 集群 DNS 服务 IP (从 SERVICE_CIDR 中预分配)
export CLUSTER_DNS_SVC_IP=&quot;10.69.0.2&quot;

# 集群 DNS 域名
export CLUSTER_DNS_DOMAIN=&quot;cluster.local.&quot;

# 将二进制目录 /opt/k8s/bin 加到 PATH 中
export PATH=/opt/k8s/bin:$PATH
EOF
</code></pre>
<p>然后，把全局变量定义脚本拷贝到所有节点的 /opt/k8s/bin 目录：</p>
<pre><code>source ./environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp environment.sh k8s@$&#123;node_ip&#125;:/opt/k8s/bin/
    ssh k8s@$&#123;node_ip&#125; &quot;chmod +x /opt/k8s/bin/*&quot;
  done
</code></pre>
<h3 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h3><p>配置文件：<br> 17520h 2年，最大2年</p>
<pre><code>cat &gt; ca-config.json &lt;&lt;EOF
&#123;
  &quot;signing&quot;: &#123;
    &quot;default&quot;: &#123;
      &quot;expiry&quot;: &quot;17520h&quot;
    &#125;,
    &quot;profiles&quot;: &#123;
      &quot;kubernetes&quot;: &#123;
        &quot;usages&quot;: [
            &quot;signing&quot;,
            &quot;key encipherment&quot;,
            &quot;server auth&quot;,
            &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;87600h&quot;
      &#125;
    &#125;
  &#125;
&#125;
EOF
</code></pre>
<p>ca证书签名请求</p>
<pre><code>cat &gt; ca-csr.json &lt;&lt;EOF
&#123;
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;BeiJing&quot;,
      &quot;L&quot;: &quot;BeiJing&quot;,
      &quot;O&quot;: &quot;k8s&quot;,
      &quot;OU&quot;: &quot;4Paradigm&quot;
    &#125;
  ]
&#125;
EOF
</code></pre>
<ul>
<li>CN：<code>Common Name</code>，kube-apiserver 从证书中提取该字段作为请求的**用户名 (User Name)**，浏览器使用该字段验证网站是否合法；</li>
<li>O：<code>Organization</code>，kube-apiserver 从证书中提取该字段作为请求用户所属的**组 (Group)**；</li>
<li>kube-apiserver 将提取的 User、Group 作为 <code>RBAC</code> 授权的用户标识；</li>
</ul>
<h4 id="生成-CA-证书和私钥"><a href="#生成-CA-证书和私钥" class="headerlink" title="生成 CA 证书和私钥"></a>生成 CA 证书和私钥</h4><pre><code>cfssl gencert -initca ca-csr.json | cfssljson -bare ca
ls ca*
</code></pre>
<p>将生成的 CA 证书、秘钥文件、配置文件拷贝到所有节点的 /etc/kubernetes/cert 目录下：</p>
<pre><code>source /opt/k8s/bin/environment.sh # 导入 NODE_IPS 环境变量
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /etc/kubernetes/cert &amp;&amp; chown -R k8s /etc/kubernetes&quot;
    scp ca*.pem ca-config.json k8s@$&#123;node_ip&#125;:/etc/kubernetes/cert
  done
</code></pre>
<h3 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h3><p>wget <a href="https://dl.k8s.io/v1.12.1/kubernetes-client-linux-amd64.tar.gz">https://dl.k8s.io/v1.12.1/kubernetes-client-linux-amd64.tar.gz</a><br> tar -xzvf kubernetes-client-linux-amd64.tar.gz</p>
<p>分发到所有使用 kubectl 的节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp kubernetes/client/bin/kubectl k8s@$&#123;node_ip&#125;:/opt/k8s/bin/
    ssh k8s@$&#123;node_ip&#125; &quot;chmod +x /opt/k8s/bin/*&quot;
  done
</code></pre>
<h3 id="创建-admin-证书和私钥"><a href="#创建-admin-证书和私钥" class="headerlink" title="创建 admin 证书和私钥"></a>创建 admin 证书和私钥</h3><p>kubectl 与 apiserver https 安全端口通信，apiserver 对提供的证书进行认证和授权。</p>
<p>kubectl 作为集群的管理工具，需要被授予最高权限。这里创建具有最高权限的 admin 证书。</p>
<p>创建证书签名请求：</p>
<pre><code>cat &gt; admin-csr.json &lt;&lt;EOF
&#123;
  &quot;CN&quot;: &quot;admin&quot;,
  &quot;hosts&quot;: [],
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;BeiJing&quot;,
      &quot;L&quot;: &quot;BeiJing&quot;,
      &quot;O&quot;: &quot;system:masters&quot;,
      &quot;OU&quot;: &quot;4Paradigm&quot;
    &#125;
  ]
&#125;
EOF
</code></pre>
<p>O 为 system:masters，kube-apiserver 收到该证书后将请求的 Group 设置为 system:masters；<br> 预定义的 ClusterRoleBinding cluster-admin 将 Group system:masters 与 Role cluster-admin 绑定，该 Role 授予所有 API的权限；<br> 该证书只会被 kubectl 当做 client 证书使用，所以 hosts 字段为空；</p>
<h3 id="生成证书和私钥："><a href="#生成证书和私钥：" class="headerlink" title="生成证书和私钥："></a>生成证书和私钥：</h3><pre><code>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem \
  -ca-key=/etc/kubernetes/cert/ca-key.pem \
  -config=/etc/kubernetes/cert/ca-config.json \
  -profile=kubernetes admin-csr.json | cfssljson -bare admin
ls admin*
</code></pre>
<h3 id="创建-kubeconfig-文件"><a href="#创建-kubeconfig-文件" class="headerlink" title="创建 kubeconfig 文件"></a>创建 kubeconfig 文件</h3><p>kubeconfig 为 kubectl 的配置文件，包含访问 apiserver 的所有信息，如 apiserver 地址、CA 证书和自身使用的证书；</p>
<pre><code>source /opt/k8s/bin/environment.sh
# 设置集群参数
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/cert/ca.pem \
  --embed-certs=true \
  --server=$&#123;KUBE_APISERVER&#125; \
  --kubeconfig=kubectl.kubeconfig

# 设置客户端认证参数
kubectl config set-credentials admin \
  --client-certificate=admin.pem \
  --client-key=admin-key.pem \
  --embed-certs=true \
  --kubeconfig=kubectl.kubeconfig

# 设置上下文参数
kubectl config set-context kubernetes \
  --cluster=kubernetes \
  --user=admin \
  --kubeconfig=kubectl.kubeconfig
  
# 设置默认上下文
kubectl config use-context kubernetes --kubeconfig=kubectl.kubeconfig
--certificate-authority：验证 kube-apiserver 证书的根证书；
--client-certificate、--client-key：刚生成的 admin 证书和私钥，连接 kube-apiserver 时使用；
--embed-certs=true：将 ca.pem 和 admin.pem 证书内容嵌入到生成的 kubectl.kubeconfig 文件中(不加时，写入的是证书文件路径)；
</code></pre>
<h3 id="分发-kubeconfig-文件"><a href="#分发-kubeconfig-文件" class="headerlink" title="分发 kubeconfig 文件"></a>分发 kubeconfig 文件</h3><p>分发到所有使用 kubectl 命令的节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh k8s@$&#123;node_ip&#125; &quot;mkdir -p ~/.kube&quot;
    scp kubectl.kubeconfig k8s@$&#123;node_ip&#125;:~/.kube/config
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p ~/.kube&quot;
    scp kubectl.kubeconfig root@$&#123;node_ip&#125;:~/.kube/config
  done
</code></pre>
<p>保存到用户的 ~/.kube/config 文件；</p>
<h2 id="etcd安装"><a href="#etcd安装" class="headerlink" title="etcd安装"></a>etcd安装</h2><p>到 <a href="https://github.com/coreos/etcd/releases">https://github.com/coreos/etcd/releases</a> 页面下载最新版本的发布包：</p>
<pre><code>wget https://github.com/etcd-io/etcd/releases/download/v3.3.10/etcd-v3.3.10-linux-amd64.tar.gz
tar -xvf etcd-v3.3.10-linux-amd64.tar.gz
</code></pre>
<h3 id="分发二进制文件到集群所有节点："><a href="#分发二进制文件到集群所有节点：" class="headerlink" title="分发二进制文件到集群所有节点："></a>分发二进制文件到集群所有节点：</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp etcd-v3.3.10-linux-amd64/etcd* k8s@$&#123;node_ip&#125;:/opt/k8s/bin
    ssh k8s@$&#123;node_ip&#125; &quot;chmod +x /opt/k8s/bin/*&quot;
  done
</code></pre>
<h3 id="创建-etcd-证书和私钥"><a href="#创建-etcd-证书和私钥" class="headerlink" title="创建 etcd 证书和私钥"></a>创建 etcd 证书和私钥</h3><p>创建证书签名请求：</p>
<pre><code>cat &gt; etcd-csr.json &lt;&lt;EOF
&#123;
  &quot;CN&quot;: &quot;etcd&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;192.168.86.156&quot;,
    &quot;192.168.86.155&quot;,
    &quot;192.168.86.154&quot;
  ],
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;BeiJing&quot;,
      &quot;L&quot;: &quot;BeiJing&quot;,
      &quot;O&quot;: &quot;k8s&quot;,
      &quot;OU&quot;: &quot;4Paradigm&quot;
    &#125;
  ]
&#125;
EOF
</code></pre>
<h3 id="生成证书和私钥：-1"><a href="#生成证书和私钥：-1" class="headerlink" title="生成证书和私钥："></a>生成证书和私钥：</h3><pre><code>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem \
    -ca-key=/etc/kubernetes/cert/ca-key.pem \
    -config=/etc/kubernetes/cert/ca-config.json \
    -profile=kubernetes etcd-csr.json | cfssljson -bare etcd
ls etcd*
</code></pre>
<h3 id="分发生成的证书和私钥到各-etcd-节点："><a href="#分发生成的证书和私钥到各-etcd-节点：" class="headerlink" title="分发生成的证书和私钥到各 etcd 节点："></a>分发生成的证书和私钥到各 etcd 节点：</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /etc/etcd/cert &amp;&amp; chown -R k8s /etc/etcd/cert&quot;
    scp etcd*.pem k8s@$&#123;node_ip&#125;:/etc/etcd/cert/
  done
</code></pre>
<p>ETCD_NODE_IPS</p>
<h3 id="创建-etcd-的-systemd-unit-模板文件"><a href="#创建-etcd-的-systemd-unit-模板文件" class="headerlink" title="创建 etcd 的 systemd unit 模板文件"></a>创建 etcd 的 systemd unit 模板文件</h3><p>cat &gt; etcd.service.template &lt;&lt;EOF<br> [Unit]<br> Description=Etcd Server<br> After=network.target<br> After=network-online.target<br> Wants=network-online.target<br> Documentation=<a href="https://github.com/coreos">https://github.com/coreos</a></p>
<p>[Service]<br> User=k8s<br> Type=notify<br> WorkingDirectory=/var/lib/etcd/<br> ExecStart=/opt/k8s/bin/etcd \<br> –data-dir=/var/lib/etcd \<br> –name=##NODE_NAME## \</p>
<p>–cert-file=/etc/etcd/cert/etcd.pem \<br> –key-file=/etc/etcd/cert/etcd-key.pem \<br> –trusted-ca-file=/etc/kubernetes/cert/ca.pem \<br> –peer-cert-file=/etc/etcd/cert/etcd.pem \<br> –peer-key-file=/etc/etcd/cert/etcd-key.pem \<br> –peer-trusted-ca-file=/etc/kubernetes/cert/ca.pem \<br> –peer-client-cert-auth \<br> –client-cert-auth \<br> –listen-peer-urls=https://##NODE_IP##:2380 \<br> –initial-advertise-peer-urls=https://##NODE_IP##:2380 \<br> –listen-client-urls=https://##NODE_IP##:2379,<a href="http://127.0.0.1:2379/">http://127.0.0.1:2379</a> \<br> –advertise-client-urls=https://##NODE_IP##:2379 \<br> –initial-cluster-token=etcd-cluster-0 \<br> –initial-cluster=${ETCD_NODES} \<br> –initial-cluster-state=new<br> Restart=on-failure<br> RestartSec=5<br> LimitNOFILE=65536</p>
<p>[Install]<br> WantedBy=multi-user.target<br> EOF</p>
<p>User：指定以 k8s 账户运行；<br> WorkingDirectory、–data-dir：指定工作目录和数据目录为 /var/lib/etcd，需在启动服务前创建这个目录；<br> –name：指定节点名称，当 –initial-cluster-state 值为 new 时，–name 的参数值必须位于 –initial-cluster 列表中；<br> –cert-file、–key-file：etcd server 与 client 通信时使用的证书和私钥；<br> –trusted-ca-file：签名 client 证书的 CA 证书，用于验证 client 证书；<br> –peer-cert-file、–peer-key-file：etcd 与 peer 通信使用的证书和私钥；<br> –peer-trusted-ca-file：签名 peer 证书的 CA 证书，用于验证 peer 证书；</p>
<h3 id="为各节点创建和分发-etcd-systemd-unit-文件"><a href="#为各节点创建和分发-etcd-systemd-unit-文件" class="headerlink" title="为各节点创建和分发 etcd systemd unit 文件"></a>为各节点创建和分发 etcd systemd unit 文件</h3><pre><code>source /opt/k8s/bin/environment.sh
for (( i=0; i &lt; 3; i++ ))
  do
    sed -e &quot;s/##NODE_NAME##/$&#123;NODE_NAMES[i]&#125;/&quot; -e &quot;s/##NODE_IP##/$&#123;NODE_IPS[i]&#125;/&quot; etcd.service.template &gt; etcd-$&#123;NODE_IPS[i]&#125;.service 
  done
ls *.service
</code></pre>
<p>分发生成的 systemd unit 文件：</p>
<p>source /opt/k8s/bin/environment.sh<br> for node_ip in ${ETCD_NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh root@${node_ip} “mkdir -p /var/lib/etcd &amp;&amp; chown -R k8s /var/lib/etcd”<br> scp etcd-${node_ip}.service root@${node_ip}:/etc/systemd/system/etcd.service<br> done</p>
<h3 id="启动-etcd-服务"><a href="#启动-etcd-服务" class="headerlink" title="启动 etcd 服务"></a>启动 etcd 服务</h3><p>source ./environment.sh<br> for node_ip in ${ETCD_NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh root@${node_ip} “systemctl daemon-reload &amp;&amp; systemctl enable etcd &amp;&amp; systemctl restart etcd &amp;”<br> done</p>
<p>etcd 进程首次启动时会等待其它节点的 etcd 加入集群，命令 systemctl start etcd 会卡住一段时间，为正常现象。</p>
<h3 id="检查启动结果"><a href="#检查启动结果" class="headerlink" title="检查启动结果"></a>检查启动结果</h3><pre><code>source ./environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh k8s@$&#123;node_ip&#125; &quot;systemctl status etcd|grep Active&quot;
  done
</code></pre>
<p>确保状态为 active (running)，否则查看日志，确认原因：</p>
<p>$ journalctl -u etcd</p>
<h3 id="验证服务状态"><a href="#验证服务状态" class="headerlink" title="验证服务状态"></a>验证服务状态</h3><p>部署完 etcd 集群后，在任一 etc 节点上执行如下命令：</p>
<p>source ./environment.sh<br> for node_ip in ${ETCD_NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ETCDCTL_API=3 /opt/k8s/bin/etcdctl<br> –endpoints=https://${node_ip}:2379<br> –cacert=/etc/kubernetes/cert/ca.pem<br> –cert=/etc/etcd/cert/etcd.pem<br> –key=/etc/etcd/cert/etcd-key.pem endpoint health<br> done<br> 预期输出：</p>
<blockquote>
<blockquote>
<blockquote>
<p>192.168.86.154<br><a href="https://192.168.86.154:2379/">https://192.168.86.154:2379</a> is healthy: successfully committed proposal: took = 2.197007ms</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>192.168.86.155<br><a href="https://192.168.86.155:2379/">https://192.168.86.155:2379</a> is healthy: successfully committed proposal: took = 2.299328ms</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>192.168.86.156<br><a href="https://192.168.86.156:2379/">https://192.168.86.156:2379</a> is healthy: successfully committed proposal: took = 2.014274ms</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="05-部署-flannel-网络"><a href="#05-部署-flannel-网络" class="headerlink" title="05.部署 flannel 网络"></a>05.部署 flannel 网络</h2><p>kubernetes 要求集群内各节点(包括 master 节点)能通过 Pod 网段互联互通。flannel 使用 vxlan 技术为各节点创建一个可以互通的 Pod 网络，使用的端口为 UDP 8472，需要开放该端口（如公有云 AWS 等）。</p>
<p>flannel 第一次启动时，从 etcd 获取 Pod 网段信息，为本节点分配一个未使用的 /24 段地址，然后创建 flannel.1（也可能是其它名称，如 flannel1 等） 接口。</p>
<p>flannel 将分配的 Pod 网段信息写入 /run/flannel/docker 文件，docker 后续使用这个文件中的环境变量设置 docker0 网桥。</p>
<h3 id="下载和分发-flanneld-二进制文件"><a href="#下载和分发-flanneld-二进制文件" class="headerlink" title="下载和分发 flanneld 二进制文件"></a>下载和分发 flanneld 二进制文件</h3><p>到 <a href="https://github.com/coreos/flannel/releases">https://github.com/coreos/flannel/releases</a> 页面下载最新版本的发布包：</p>
<pre><code>mkdir flannel
wget https://github.com/coreos/flannel/releases/download/v0.10.0/flannel-v0.10.0-linux-amd64.tar.gz
tar -xzvf flannel-v0.10.0-linux-amd64.tar.gz -C flannel
</code></pre>
<h3 id="创建证书签名请求："><a href="#创建证书签名请求：" class="headerlink" title="创建证书签名请求："></a>创建证书签名请求：</h3><pre><code>cat &gt; flanneld-csr.json &lt;&lt;EOF
&#123;
  &quot;CN&quot;: &quot;flanneld&quot;,
  &quot;hosts&quot;: [],
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;BeiJing&quot;,
      &quot;L&quot;: &quot;BeiJing&quot;,
      &quot;O&quot;: &quot;k8s&quot;,
      &quot;OU&quot;: &quot;4Paradigm&quot;
    &#125;
  ]
&#125;
EOF
</code></pre>
<p>该证书只会被 kubectl 当做 client 证书使用，所以 hosts 字段为空；<br> 生成证书和私钥：</p>
<pre><code>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem \
  -ca-key=/etc/kubernetes/cert/ca-key.pem \
  -config=/etc/kubernetes/cert/ca-config.json \
  -profile=kubernetes flanneld-csr.json | cfssljson -bare flanneld
ls flanneld*pem
</code></pre>
<p>分发 flanneld 二进制文件和flannel 证书、私钥 到集群所有节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp  flannel/&#123;flanneld,mk-docker-opts.sh&#125; k8s@$&#123;node_ip&#125;:/opt/k8s/bin/
    ssh k8s@$&#123;node_ip&#125; &quot;chmod +x /opt/k8s/bin/*&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /etc/flanneld/cert &amp;&amp; chown -R k8s /etc/flanneld&quot;scp flanneld*.pem k8s@$&#123;node_ip&#125;:/etc/flanneld/cert
  done
</code></pre>
<p>创建<br> flannel 从 etcd 集群存取网段分配信息，而 etcd 集群启用了双向 x509 证书认证，所以需要为 flanneld 生成证书和私钥。</p>
<p>向 etcd 写入集群 Pod 网段信息<br> 注意：本步骤只需执行一次。</p>
<pre><code>source /opt/k8s/bin/environment.sh
etcdctl \
  --endpoints=$&#123;ETCD_ENDPOINTS&#125; \
  --ca-file=/etc/kubernetes/cert/ca.pem \
  --cert-file=/etc/flanneld/cert/flanneld.pem \
  --key-file=/etc/flanneld/cert/flanneld-key.pem \
  set $&#123;FLANNEL_ETCD_PREFIX&#125;/config &#39;&#123;&quot;Network&quot;:&quot;&#39;$&#123;CLUSTER_CIDR&#125;&#39;&quot;, &quot;SubnetLen&quot;: 24, &quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125;&#39;
</code></pre>
<p>flanneld 当前版本 (v0.10.0) 不支持 etcd v3，故使用 etcd v2 API 写入配置 key 和网段数据；<br> 写入的 Pod 网段 ${CLUSTER_CIDR} 必须是 /16 段地址，必须与 kube-controller-manager 的 –cluster-cidr 参数值一致；</p>
<h3 id="创建-flanneld-的-systemd-unit-文件"><a href="#创建-flanneld-的-systemd-unit-文件" class="headerlink" title="创建 flanneld 的 systemd unit 文件"></a>创建 flanneld 的 systemd unit 文件</h3><pre><code>source /opt/k8s/bin/environment.sh
export IFACE=eno1 # 有的为em1，eth0
cat &gt; flanneld.service &lt;&lt; EOF
[Unit]
Description=Flanneld overlay address etcd agent
After=network.target
After=network-online.target
Wants=network-online.target
After=etcd.service
Before=docker.service

[Service]
Type=notify
ExecStart=/opt/k8s/bin/flanneld \\
  -etcd-cafile=/etc/kubernetes/cert/ca.pem \\
  -etcd-certfile=/etc/flanneld/cert/flanneld.pem \\
  -etcd-keyfile=/etc/flanneld/cert/flanneld-key.pem \\
  -etcd-endpoints=$&#123;ETCD_ENDPOINTS&#125; \\
  -etcd-prefix=$&#123;FLANNEL_ETCD_PREFIX&#125; \\
  -iface=$&#123;IFACE&#125;
ExecStartPost=/opt/k8s/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker
Restart=on-failure

[Install]
WantedBy=multi-user.target
RequiredBy=docker.service
EOF
</code></pre>
<p>mk-docker-opts.sh 脚本将分配给 flanneld 的 Pod 子网网段信息写入 /run/flannel/docker 文件，后续 docker 启动时使用这个文件中的环境变量配置 docker0 网桥；<br> flanneld 使用系统缺省路由所在的接口与其它节点通信，对于有多个网络接口（如内网和公网）的节点，可以用 -iface 参数指定通信接口，如上面的 eth0 接口;<br> flanneld 运行时需要 root 权限；<br> 完整 unit 见 flanneld.service</p>
<p>注意：<br> 有的IFACE=eno1，有的为em1，eth，通过ifconfig查看</p>
<h3 id="分发-flanneld-systemd-unit-文件到所有节点"><a href="#分发-flanneld-systemd-unit-文件到所有节点" class="headerlink" title="分发 flanneld systemd unit 文件到所有节点"></a>分发 flanneld systemd unit 文件到所有节点</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp flanneld.service root@$&#123;node_ip&#125;:/etc/systemd/system/
  done
</code></pre>
<h3 id="启动-flanneld-服务"><a href="#启动-flanneld-服务" class="headerlink" title="启动 flanneld 服务"></a>启动 flanneld 服务</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl daemon-reload &amp;&amp; systemctl enable flanneld &amp;&amp; systemctl restart flanneld&quot;
  done
</code></pre>
<h3 id="检查启动结果-1"><a href="#检查启动结果-1" class="headerlink" title="检查启动结果"></a>检查启动结果</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh k8s@$&#123;node_ip&#125; &quot;systemctl status flanneld|grep Active&quot;
  done
</code></pre>
<p>确保状态为 active (running)，否则查看日志，确认原因：</p>
<p>$ journalctl -u flanneld</p>
<h3 id="检查分配给各-flanneld-的-Pod-网段信息"><a href="#检查分配给各-flanneld-的-Pod-网段信息" class="headerlink" title="检查分配给各 flanneld 的 Pod 网段信息"></a>检查分配给各 flanneld 的 Pod 网段信息</h3><p>查看集群 Pod 网段(/16)：</p>
<p>source /opt/k8s/bin/environment.sh<br> etcdctl<br> –endpoints=${ETCD_ENDPOINTS}<br> –ca-file=/etc/kubernetes/cert/ca.pem<br> –cert-file=/etc/flanneld/cert/flanneld.pem<br> –key-file=/etc/flanneld/cert/flanneld-key.pem<br> get ${FLANNEL_ETCD_PREFIX}/config<br> 输出：</p>
<p>{“Network”:”170.22.0.0/16”, “SubnetLen”: 24, “Backend”: {“Type”: “vxlan”}}</p>
<p>查看已分配的 Pod 子网段列表(/24):</p>
<p>source /opt/k8s/bin/environment.sh<br> etcdctl<br> –endpoints=${ETCD_ENDPOINTS}<br> –ca-file=/etc/kubernetes/cert/ca.pem<br> –cert-file=/etc/flanneld/cert/flanneld.pem<br> –key-file=/etc/flanneld/cert/flanneld-key.pem<br> ls ${FLANNEL_ETCD_PREFIX}/subnets<br> 输出：</p>
<p>/kubernetes/network/subnets/170.22.76.0-24<br> /kubernetes/network/subnets/170.22.84.0-24<br> /kubernetes/network/subnets/170.22.45.0-24<br> /kubernetes/network/subnets/170.22.7.0-24<br> /kubernetes/network/subnets/170.22.12.0-24<br> /kubernetes/network/subnets/170.22.78.0-24<br> /kubernetes/network/subnets/170.22.5.0-24</p>
<p>查看某一 Pod 网段对应的节点 IP 和 flannel 接口地址:</p>
<p>source /opt/k8s/bin/environment.sh<br> etcdctl<br> –endpoints=${ETCD_ENDPOINTS}<br> –ca-file=/etc/kubernetes/cert/ca.pem<br> –cert-file=/etc/flanneld/cert/flanneld.pem<br> –key-file=/etc/flanneld/cert/flanneld-key.pem<br> get ${FLANNEL_ETCD_PREFIX}/subnets/170.22.76.0-24<br> 输出：</p>
<p>{“PublicIP”:”192.168.86.156”,”BackendType”:”vxlan”,”BackendData”:{“VtepMAC”:”6a:aa:ca:8a:ac:ed”}}</p>
<p>验证各节点能通过 Pod 网段互通<br> 在各节点上部署 flannel 后，检查是否创建了 flannel 接口(名称可能为 flannel0、flannel.0、flannel.1 等)：</p>
<p>source /opt/k8s/bin/environment.sh<br> for node_ip in ${NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh ${node_ip} “/usr/sbin/ip addr show flannel.1|grep -w inet”<br> done<br> 输出：</p>
<p>inet 172.30.81.0/32 scope global flannel.1<br> inet 172.30.29.0/32 scope global flannel.1<br> inet 172.30.39.0/32 scope global flannel.1<br> 在各节点上 ping 所有 flannel 接口 IP，确保能通：</p>
<p>source /opt/k8s/bin/environment.sh<br> for node_ip in ${NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh ${node_ip} “ping -c 1 172.30.81.0”<br> ssh ${node_ip} “ping -c 1 172.30.29.0”<br> ssh ${node_ip} “ping -c 1 172.30.39.0”<br> done</p>
<h2 id="06-0-部署-master-节点"><a href="#06-0-部署-master-节点" class="headerlink" title="06-0.部署 master 节点"></a>06-0.部署 master 节点</h2><p>kubernetes master 节点运行如下组件：</p>
<p>kube-apiserver<br> kube-scheduler<br> kube-controller-manager<br> kube-scheduler 和 kube-controller-manager 可以以集群模式运行，通过 leader 选举产生一个工作进程，其它进程处于阻塞模式。</p>
<p>对于 kube-apiserver，可以运行多个实例（本文档是 3 实例），但对其它组件需要提供统一的访问地址，该地址需要高可用。本文档使用 keepalived 和 haproxy 实现 kube-apiserver VIP 高可用和负载均衡。</p>
<h3 id="下载最新版本的二进制文件"><a href="#下载最新版本的二进制文件" class="headerlink" title="下载最新版本的二进制文件"></a>下载最新版本的二进制文件</h3><p>从 CHANGELOG页面 下载 server tarball 文件（需要翻墙）</p>
<pre><code>wget https://dl.k8s.io/v1.12.1/kubernetes-server-linux-amd64.tar.gz
tar -xzvf kubernetes-server-linux-amd64.tar.gz
</code></pre>
<p>将二进制文件拷贝到所有 所有节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp kubernetes/server/bin/* k8s@$&#123;node_ip&#125;:/opt/k8s/bin/
    ssh k8s@$&#123;node_ip&#125; &quot;chmod +x /opt/k8s/bin/*&quot;
  done
</code></pre>
<p>如果有老版本运行，先停止：</p>
<pre><code>systemctl stop kubelet.service 
systemctl stop kube-controller-manager.service 
systemctl stop kube-apiserver.service 
systemctl stop kube-proxy.service 
systemctl stop kube-scheduler.service
systemctl stop etcd
systemctl stop 
</code></pre>
<h2 id="06-1-部署高可用组件（keepalived-haproxy"><a href="#06-1-部署高可用组件（keepalived-haproxy" class="headerlink" title="06-1.部署高可用组件（keepalived+haproxy)"></a>06-1.部署高可用组件（keepalived+haproxy)</h2><p>使用 keepalived 和 haproxy 实现 kube-apiserver 高可用的步骤：</p>
<ul>
<li>keepalived 提供 kube-apiserver 对外服务的 VIP；</li>
<li>haproxy 监听 VIP，后端连接所有 kube-apiserver 实例，提供健康检查和负载均衡功能；</li>
<li>运行 keepalived 和 haproxy 的节点称为 LB 节点。由于 keepalived 是一主多备运行模式，故至少两个 LB 节点。</li>
</ul>
<p>本文档复用 master 节点的三台机器，haproxy 监听的端口(8443) 需要与 kube-apiserver 的端口 6443 不同，避免冲突。</p>
<p>keepalived 在运行过程中周期检查本机的 haproxy 进程状态，如果检测到 haproxy 进程异常，则触发重新选主的过程，VIP 将飘移到新选出来的主节点，从而实现 VIP 的高可用。</p>
<p>所有组件（如 kubeclt、apiserver、controller-manager、scheduler 等）都通过 VIP 和 haproxy 监听的 8443 端口访问 kube-apiserver 服务。</p>
<h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;yum install -y keepalived haproxy&quot;
  done
</code></pre>
<p>ubuntu机器，apt-get install</p>
<h3 id="配置和下发-haproxy-配置文件"><a href="#配置和下发-haproxy-配置文件" class="headerlink" title="配置和下发 haproxy 配置文件"></a>配置和下发 haproxy 配置文件</h3><p>haproxy 配置文件：</p>
<pre><code>cat &gt; haproxy.cfg &lt;&lt;EOF
 global
     log /dev/log    local0
     log /dev/log    local1 notice
     chroot /var/lib/haproxy
     stats socket /var/run/haproxy-admin.sock mode 660 level admin
     stats timeout 30s
     user haproxy
     group haproxy
     daemon
     nbproc 1
 
 defaults
     log     global
     timeout connect 5000
     timeout client  10m
     timeout server  10m
 
 listen  admin_stats
     bind 0.0.0.0:10080
     mode http
     log 127.0.0.1 local0 err
     stats refresh 30s
     stats uri /status
     stats realm welcome login\ Haproxy
     stats auth admin:123456
     stats hide-version
     stats admin if TRUE
 
 listen kube-master
     bind 0.0.0.0:8443
     mode tcp
     option tcplog
     balance source
     server 192.168.86.154 192.168.86.154:6443 check inter 2000 fall 2 rise 2 weight 1
     server 192.168.86.155 192.168.86.155:6443 check inter 2000 fall 2 rise 2 weight 1
     server 192.168.86.156 192.168.86.156:6443 check inter 2000 fall 2 rise 2 weight 1
EOF
</code></pre>
<ul>
<li>haproxy 在 10080 端口输出 status 信息；</li>
<li>haproxy 监听所有接口的 8443 端口，该端口与环境变量 ${KUBE_APISERVER} 指定的端口必须一致；</li>
<li>server 字段列出所有 kube-apiserver 监听的 IP 和端口；</li>
</ul>
<p>下发 haproxy.cfg 到所有 master 节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp haproxy.cfg root@$&#123;node_ip&#125;:/etc/haproxy
  done
</code></pre>
<p>起 haproxy 服务</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl restart haproxy&quot;
  done
</code></pre>
<p>检查 haproxy 服务状态</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl status haproxy|grep Active&quot;
  done
</code></pre>
<p>确保状态为 active (running)，否则查看日志，确认原因：</p>
<blockquote>
<blockquote>
<blockquote>
<p>192.168.86.154<br> Active: active (running) since Tue 2018-11-06 10:48:13 CST; 5s ago</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>192.168.86.155<br> Active: active (running) since Tue 2018-11-06 10:48:14 CST; 5s ago</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>192.168.86.156<br> Active: active (running) since Tue 2018-11-06 10:48:13 CST; 5s ago</p>
</blockquote>
</blockquote>
</blockquote>
<p>journalctl -u haproxy<br> 检查 haproxy 是否监听 8443 端口：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;netstat -lnpt|grep haproxy&quot;
  done
</code></pre>
<p>确保输出类似于:</p>
<p>tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      45606/haproxy</p>
<h3 id="配置和下发-keepalived-配置文件"><a href="#配置和下发-keepalived-配置文件" class="headerlink" title="配置和下发 keepalived 配置文件"></a>配置和下发 keepalived 配置文件</h3><p>keepalived 是一主（master）多备（backup）运行模式，故有两种类型的配置文件。master 配置文件只有一份，backup 配置文件视节点数目而定，对于本文档而言，规划如下：</p>
<p>master: 192.168.86.156<br> backup：192.168.86.155，192.168.86.154</p>
<p>master 配置文件：</p>
<pre><code>source /opt/k8s/bin/environment.sh
cat  &gt; keepalived-master.conf &lt;&lt;EOF
global_defs &#123;
    router_id lb-master-105
&#125;

vrrp_script check-haproxy &#123;
    script &quot;killall -0 haproxy&quot;
    interval 5
    weight -30
&#125;

vrrp_instance VI-kube-master &#123;
    state MASTER
    priority 120
    dont_track_primary
    interface $&#123;VIP_IF&#125;
    virtual_router_id 68
    advert_int 3
    track_script &#123;
        check-haproxy
    &#125;
    virtual_ipaddress &#123;
        $&#123;MASTER_VIP&#125;
    &#125;
&#125;
EOF
</code></pre>
<p>VIP 所在的接口（interface ${VIP_IF}）为 em1<br> 使用 killall -0 haproxy 命令检查所在节点的 haproxy 进程是否正常。如果异常则将权重减少（-30）,从而触发重新选主过程；<br> router_id、virtual_router_id 用于标识属于该 HA 的 keepalived 实例，如果有多套 keepalived HA，则必须各不相同；<br> backup 配置文件：</p>
<p>source /opt/k8s/bin/environment.sh<br> cat  &gt; keepalived-backup.conf &lt;&lt;EOF<br> global_defs {<br> router_id lb-backup-105<br> }</p>
<p>vrrp_script check-haproxy {<br> script “killall -0 haproxy”<br> interval 5<br> weight -30<br> }</p>
<p>vrrp_instance VI-kube-master {<br> state BACKUP<br> priority 110<br> dont_track_primary<br> interface ${VIP_IF}<br> virtual_router_id 68<br> advert_int 3<br> track_script {<br> check-haproxy<br> }<br> virtual_ipaddress {<br> ${MASTER_VIP}<br> }<br> }<br> EOF</p>
<p>VIP 所在的接口（interface ${VIP_IF}）为 em1<br> 使用 killall -0 haproxy 命令检查所在节点的 haproxy 进程是否正常。如果异常则将权重减少（-30）,从而触发重新选主过程；<br> router_id、virtual_router_id 用于标识属于该 HA 的 keepalived 实例，如果有多套 keepalived HA，则必须各不相同；<br> priority 的值必须小于 master 的值；</p>
<h3 id="下发-keepalived-配置文件"><a href="#下发-keepalived-配置文件" class="headerlink" title="下发 keepalived 配置文件"></a>下发 keepalived 配置文件</h3><p>下发 master 配置文件：</p>
<pre><code>scp keepalived-master.conf root@172.27.129.105:/etc/keepalived/keepalived.conf
</code></pre>
<p>下发 backup 配置文件：</p>
<pre><code>scp keepalived-backup.conf root@172.27.129.111:/etc/keepalived/keepalived.conf
scp keepalived-backup.conf root@172.27.129.112:/etc/keepalived/keepalived.conf
</code></pre>
<p>起 keepalived 服务</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl restart keepalived&quot;
  done
</code></pre>
<p>检查 keepalived 服务<br> source /opt/k8s/bin/environment.sh<br> for node_ip in ${ETCD_NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh root@${node_ip} “systemctl status keepalived|grep Active”<br> done<br> 确保状态为 active (running)，否则查看日志（journalctl -u keepalived），确认原因：</p>
<blockquote>
<blockquote>
<blockquote>
<p>192.168.86.154<br> Active: active (running) since Tue 2018-11-06 10:54:01 CST; 17s ago</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>192.168.86.155<br> Active: active (running) since Tue 2018-11-06 10:54:03 CST; 18s ago</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>192.168.86.156<br> Active: active (running) since Tue 2018-11-06 10:54:03 CST; 17s ago</p>
</blockquote>
</blockquote>
</blockquote>
<p>查看 VIP 所在的节点，确保可以 ping 通 VIP：</p>
<p>source /opt/k8s/bin/environment.sh<br> for node_ip in ${NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh ${node_ip} “/usr/sbin/ip addr show ${VIP_IF}”<br> ssh ${node_ip} “ping -c 1 ${MASTER_VIP}”<br> done<br> 查看 haproxy 状态页面<br> 浏览器访问 ${MASTER_VIP}:10080/status 地址，查看 haproxy 状态页面：</p>
<h2 id="06-1-部署-kube-apiserver-组件"><a href="#06-1-部署-kube-apiserver-组件" class="headerlink" title="06-1.部署 kube-apiserver 组件"></a>06-1.部署 kube-apiserver 组件</h2><p>使用 keepalived 和 haproxy 部署一个 3 节点高可用 master 集群的步骤，对应的 LB VIP 为环境变量 ${MASTER_VIP}。</p>
<h3 id="创建-kubernetes-证书和私钥"><a href="#创建-kubernetes-证书和私钥" class="headerlink" title="创建 kubernetes 证书和私钥"></a>创建 kubernetes 证书和私钥</h3><pre><code>source /opt/k8s/bin/environment.sh
cat &gt; kubernetes-csr.json &lt;&lt;EOF
&#123;
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;192.168.86.156&quot;,
    &quot;192.168.86.155&quot;,
    &quot;192.168.86.154&quot;,
    &quot;192.168.86.9&quot;,
    &quot;$&#123;MASTER_VIP&#125;&quot;,
    &quot;$&#123;CLUSTER_KUBERNETES_SVC_IP&#125;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.local&quot;,
    &quot;kubernetes.default.svc.local.com&quot;
  ],
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;BeiJing&quot;,
      &quot;L&quot;: &quot;BeiJing&quot;,
      &quot;O&quot;: &quot;k8s&quot;,
      &quot;OU&quot;: &quot;4Paradigm&quot;
    &#125;
  ]
&#125;
EOF
</code></pre>
<ul>
<li>hosts 字段指定授权使用该证书的 IP 或域名列表，这里列出了 VIP 、apiserver 节点 IP、kubernetes 服务 IP 和域名</li>
<li>域名最后字符不能是 .(如不能为 kubernetes.default.svc.cluster.local.)，否则解析时失败，提示： x509: cannot parse dnsName “kubernetes.default.svc.cluster.local.”；</li>
<li>如果使用非 cluster.local 域名，如 opsnull.com，则需要修改域名列表中的最后两个域名为：kubernetes.default.svc.opsnull、kubernetes.default.svc.opsnull.com</li>
<li>kubernetes 服务 IP 是 apiserver 自动创建的，一般是 –service-cluster-ip-range 参数指定的网段的第一个IP，后续可以通过如下命令获取：kubectl get svc kubernetes</li>
</ul>
<p>生成证书和私钥：</p>
<pre><code>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem \
  -ca-key=/etc/kubernetes/cert/ca-key.pem \
  -config=/etc/kubernetes/cert/ca-config.json \
  -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes
ls kubernetes*pem
</code></pre>
<p>将生成的证书和私钥文件拷贝到 master 节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /etc/kubernetes/cert/ &amp;&amp; sudo chown -R k8s /etc/kubernetes/cert/&quot;
    scp kubernetes*.pem k8s@$&#123;node_ip&#125;:/etc/kubernetes/cert/
  done
</code></pre>
<p>k8s 账户可以读写 /etc/kubernetes/cert/ 目录；</p>
<h3 id="创建加密配置文件"><a href="#创建加密配置文件" class="headerlink" title="创建加密配置文件"></a>创建加密配置文件</h3><pre><code>source /opt/k8s/bin/environment.sh
cat &gt; encryption-config.yaml &lt;&lt;EOF
kind: EncryptionConfig
apiVersion: v1
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: $&#123;ENCRYPTION_KEY&#125;
      - identity: &#123;&#125;
EOF

将加密配置文件拷贝到 master 节点的 /etc/kubernetes 目录下：

source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp encryption-config.yaml root@$&#123;node_ip&#125;:/etc/kubernetes/
  done
</code></pre>
<h3 id="创建-kube-apiserver-systemd-unit-模板文件"><a href="#创建-kube-apiserver-systemd-unit-模板文件" class="headerlink" title="创建 kube-apiserver systemd unit 模板文件"></a>创建 kube-apiserver systemd unit 模板文件</h3><pre><code>source /opt/k8s/bin/environment.sh
cat &gt; kube-apiserver.service.template &lt;&lt;EOF
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target

[Service]
ExecStart=/opt/k8s/bin/kube-apiserver \\
  --enable-admission-plugins=Initializers,NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \\
  --anonymous-auth=false \\
  --experimental-encryption-provider-config=/etc/kubernetes/encryption-config.yaml \\
  --advertise-address=##NODE_IP## \\
  --bind-address=##NODE_IP## \\
  --insecure-port=0 \\
  --authorization-mode=Node,RBAC \\
  --runtime-config=api/all \\
  --enable-bootstrap-token-auth \\
  --service-cluster-ip-range=$&#123;SERVICE_CIDR&#125; \\
  --service-node-port-range=$&#123;NODE_PORT_RANGE&#125; \\
  --tls-cert-file=/etc/kubernetes/cert/kubernetes.pem \\
  --tls-private-key-file=/etc/kubernetes/cert/kubernetes-key.pem \\
  --client-ca-file=/etc/kubernetes/cert/ca.pem \\
  --kubelet-client-certificate=/etc/kubernetes/cert/kubernetes.pem \\
  --kubelet-client-key=/etc/kubernetes/cert/kubernetes-key.pem \\
  --service-account-key-file=/etc/kubernetes/cert/ca-key.pem \\
  --etcd-cafile=/etc/kubernetes/cert/ca.pem \\
  --etcd-certfile=/etc/kubernetes/cert/kubernetes.pem \\
  --etcd-keyfile=/etc/kubernetes/cert/kubernetes-key.pem \\
  --etcd-servers=$&#123;ETCD_ENDPOINTS&#125; \\
  --enable-swagger-ui=true \\
  --allow-privileged=true \\
  --apiserver-count=3 \\
  --audit-log-maxage=30 \\
  --audit-log-maxbackup=3 \\
  --audit-log-maxsize=100 \\
  --audit-log-path=/var/log/kube-apiserver-audit.log \\
  --event-ttl=1h \\
  --alsologtostderr=true \\
  --logtostderr=false \\
  --log-dir=/var/log/kubernetes \\
  --v=2
Restart=on-failure
RestartSec=5
Type=notify
User=k8s
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
</code></pre>
<ul>
<li>–experimental-encryption-provider-config：启用加密特性；</li>
<li>–authorization-mode=Node,RBAC： 开启 Node 和 RBAC 授权模式，拒绝未授权的请求；</li>
<li>–enable-admission-plugins：启用 ServiceAccount 和 NodeRestriction；</li>
<li>–service-account-key-file：签名 ServiceAccount Token 的公钥文件，kube-controller-manager 的 –service-account-private-key-file 指定私钥文件，两者配对使用；</li>
<li>–tls-*-file：指定 apiserver 使用的证书、私钥和 CA 文件。–client-ca-file 用于验证 client (kue-controller-manager、kube-scheduler、kubelet、kube-proxy 等)请求所带的证书；</li>
<li>–kubelet-client-certificate、–kubelet-client-key：如果指定，则使用 https 访问 kubelet APIs；需要为证书对应的用户(上面 kubernetes*.pem 证书的用户为 kubernetes) 用户定义 RBAC 规则，否则访问 kubelet API * 时提示未授权；</li>
<li>–bind-address： 不能为 127.0.0.1，否则外界不能访问它的安全端口 6443；</li>
<li>–insecure-port=0：关闭监听非安全端口(8080)；</li>
<li>–service-cluster-ip-range： 指定 Service Cluster IP 地址段；</li>
<li>–service-node-port-range： 指定 NodePort 的端口范围；</li>
<li>–runtime-config=api/all=true： 启用所有版本的 APIs，如 autoscaling/v2alpha1；</li>
<li>–enable-bootstrap-token-auth：启用 kubelet bootstrap 的 token 认证；</li>
<li>–apiserver-count=3：指定集群运行模式，多台 kube-apiserver 会通过 leader 选举产生一个工作节点，其它节点处于阻塞状态；</li>
<li>User=k8s：使用 k8s 账户运行；</li>
</ul>
<h3 id="为各节点创建和分发-kube-apiserver-systemd-unit-文件"><a href="#为各节点创建和分发-kube-apiserver-systemd-unit-文件" class="headerlink" title="为各节点创建和分发 kube-apiserver systemd unit 文件"></a>为各节点创建和分发 kube-apiserver systemd unit 文件</h3><p>替换模板文件中的变量，为各节点创建 systemd unit 文件：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for (( i=0; i &lt; 3; i++ ))
  do
    sed -e &quot;s/##NODE_NAME##/$&#123;NODE_NAMES[i]&#125;/&quot; -e &quot;s/##NODE_IP##/$&#123;NODE_IPS[i]&#125;/&quot; kube-apiserver.service.template &gt; kube-apiserver-$&#123;NODE_IPS[i]&#125;.service 
  done
ls kube-apiserver*.service
</code></pre>
<p>分发生成的 systemd unit 文件</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /var/log/kubernetes &amp;&amp; chown -R k8s /var/log/kubernetes&quot;
    scp kube-apiserver-$&#123;node_ip&#125;.service root@$&#123;node_ip&#125;:/etc/systemd/system/kube-apiserver.service
  done
</code></pre>
<h3 id="启动-kube-apiserver-服务"><a href="#启动-kube-apiserver-服务" class="headerlink" title="启动 kube-apiserver 服务"></a>启动 kube-apiserver 服务</h3><p>source /opt/k8s/bin/environment.sh<br> for node_ip in ${ETCD_NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh root@${node_ip} “systemctl daemon-reload &amp;&amp; systemctl enable kube-apiserver &amp;&amp; systemctl restart kube-apiserver”<br> done</p>
<h3 id="检查-kube-apiserver-运行状态"><a href="#检查-kube-apiserver-运行状态" class="headerlink" title="检查 kube-apiserver 运行状态"></a>检查 kube-apiserver 运行状态</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl status kube-apiserver |grep &#39;Active:&#39;&quot;
  done
</code></pre>
<p>确保状态为 active (running)，否则到 master 节点查看日志，确认原因：</p>
<p>journalctl -u kube-apiserver</p>
<h3 id="打印-kube-apiserver-写入-etcd-的数据"><a href="#打印-kube-apiserver-写入-etcd-的数据" class="headerlink" title="打印 kube-apiserver 写入 etcd 的数据"></a>打印 kube-apiserver 写入 etcd 的数据</h3><p>source /opt/k8s/bin/environment.sh<br> ETCDCTL_API=3 etcdctl<br> –endpoints=${ETCD_ENDPOINTS}<br> –cacert=/etc/kubernetes/cert/ca.pem<br> –cert=/etc/etcd/cert/etcd.pem<br> –key=/etc/etcd/cert/etcd-key.pem<br> get /registry/ –prefix –keys-only</p>
<p>检查集群信息</p>
<pre><code>kubectl cluster-info
kubectl get all --all-namespaces
kubectl get componentstatuses
</code></pre>
<p>检查 kube-apiserver 监听的端口<br> sudo netstat -lnpt|grep kube<br> tcp        0      0 172.27.129.105:6443     0.0.0.0:*               LISTEN      13075/kube-apiserve</p>
<p>6443: 接收 https 请求的安全端口，对所有请求做认证和授权；<br> 由于关闭了非安全端口，故没有监听 8080；</p>
<h3 id="授予-kubernetes-证书访问-kubelet-API-的权限"><a href="#授予-kubernetes-证书访问-kubelet-API-的权限" class="headerlink" title="授予 kubernetes 证书访问 kubelet API 的权限"></a>授予 kubernetes 证书访问 kubelet API 的权限</h3><p>在执行 kubectl exec、run、logs 等命令时，apiserver 会转发到 kubelet。这里定义 RBAC 规则，授权 apiserver 调用 kubelet API。</p>
<pre><code>kubectl create clusterrolebinding kube-apiserver:kubelet-apis --clusterrole=system:kubelet-api-admin --user kubernetes
</code></pre>
<h2 id="06-3-部署高可用-kube-controller-manager-集群"><a href="#06-3-部署高可用-kube-controller-manager-集群" class="headerlink" title="06-3.部署高可用 kube-controller-manager 集群"></a>06-3.部署高可用 kube-controller-manager 集群</h2><p>该集群包含 3 个节点，启动后将通过竞争选举机制产生一个 leader 节点，其它节点为阻塞状态。当 leader 节点不可用后，剩余节点将再次进行选举产生新的 leader 节点，从而保证服务的可用性。</p>
<p>为保证通信安全，本文档先生成 x509 证书和私钥，kube-controller-manager 在如下两种情况下使用该证书：</p>
<p>与 kube-apiserver 的安全端口通信时;<br> 在安全端口(https，10252) 输出 prometheus 格式的 metrics；</p>
<h3 id="创建-kube-controller-manager-证书和私钥"><a href="#创建-kube-controller-manager-证书和私钥" class="headerlink" title="创建 kube-controller-manager 证书和私钥"></a>创建 kube-controller-manager 证书和私钥</h3><p>创建证书签名请求：</p>
<pre><code>cat &gt; kube-controller-manager-csr.json &lt;&lt;EOF
&#123;
    &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,
    &quot;key&quot;: &#123;
        &quot;algo&quot;: &quot;rsa&quot;,
        &quot;size&quot;: 2048
    &#125;,
    &quot;hosts&quot;: [
      &quot;127.0.0.1&quot;,
      &quot;192.168.86.156&quot;,  &quot;192.168.86.155&quot;,  &quot;192.168.86.154&quot;
    ],
    &quot;names&quot;: [
      &#123;
        &quot;C&quot;: &quot;CN&quot;,
        &quot;ST&quot;: &quot;BeiJing&quot;,
        &quot;L&quot;: &quot;BeiJing&quot;,
        &quot;O&quot;: &quot;system:kube-controller-manager&quot;,
        &quot;OU&quot;: &quot;4Paradigm&quot;
      &#125;
    ]
&#125;
EOF
</code></pre>
<p>hosts 列表包含所有 kube-controller-manager 节点 IP；<br> CN 为 system:kube-controller-manager、O 为 system:kube-controller-manager，kubernetes 内置的 ClusterRoleBindings system:kube-controller-manager 赋予 kube-controller-manager 工作所需的权限。<br> 生成证书和私钥：</p>
<pre><code>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem \
  -ca-key=/etc/kubernetes/cert/ca-key.pem \
  -config=/etc/kubernetes/cert/ca-config.json \
  -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager
</code></pre>
<p>将生成的证书和私钥分发到所有 master 节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp kube-controller-manager*.pem k8s@$&#123;node_ip&#125;:/etc/kubernetes/cert/
  done
</code></pre>
<h3 id="创建和分发-kubeconfig-文件"><a href="#创建和分发-kubeconfig-文件" class="headerlink" title="创建和分发 kubeconfig 文件"></a>创建和分发 kubeconfig 文件</h3><p>kubeconfig 文件包含访问 apiserver 的所有信息，如 apiserver 地址、CA 证书和自身使用的证书；</p>
<pre><code>source /opt/k8s/bin/environment.sh
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/cert/ca.pem \
  --embed-certs=true \
  --server=$&#123;KUBE_APISERVER&#125; \
  --kubeconfig=kube-controller-manager.kubeconfig

kubectl config set-credentials system:kube-controller-manager \
  --client-certificate=kube-controller-manager.pem \
  --client-key=kube-controller-manager-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-controller-manager.kubeconfig

kubectl config set-context system:kube-controller-manager \
  --cluster=kubernetes \
  --user=system:kube-controller-manager \
  --kubeconfig=kube-controller-manager.kubeconfig

kubectl config use-context system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig
</code></pre>
<p>分发 kubeconfig 到所有 master 节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp kube-controller-manager.kubeconfig k8s@$&#123;node_ip&#125;:/etc/kubernetes/
  done
</code></pre>
<h3 id="创建和分发-kube-controller-manager-systemd-unit-文件"><a href="#创建和分发-kube-controller-manager-systemd-unit-文件" class="headerlink" title="创建和分发 kube-controller-manager systemd unit 文件"></a>创建和分发 kube-controller-manager systemd unit 文件</h3><pre><code>source /opt/k8s/bin/environment.sh
cat &gt; kube-controller-manager.service &lt;&lt;EOF
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
ExecStart=/opt/k8s/bin/kube-controller-manager \\
  --port=0 \\
  --secure-port=10252 \\
  --bind-address=127.0.0.1 \\
  --kubeconfig=/etc/kubernetes/kube-controller-manager.kubeconfig \\
  --service-cluster-ip-range=$&#123;SERVICE_CIDR&#125; \\
  --cluster-name=kubernetes \\
  --cluster-signing-cert-file=/etc/kubernetes/cert/ca.pem \\
  --cluster-signing-key-file=/etc/kubernetes/cert/ca-key.pem \\
  --experimental-cluster-signing-duration=17520h \\
  --root-ca-file=/etc/kubernetes/cert/ca.pem \\
  --service-account-private-key-file=/etc/kubernetes/cert/ca-key.pem \\
  --leader-elect=true \\
  --feature-gates=RotateKubeletServerCertificate=true \\
  --controllers=*,bootstrapsigner,tokencleaner \\
  --horizontal-pod-autoscaler-use-rest-clients=true \\
  --horizontal-pod-autoscaler-sync-period=10s \\
  --tls-cert-file=/etc/kubernetes/cert/kube-controller-manager.pem \\
  --tls-private-key-file=/etc/kubernetes/cert/kube-controller-manager-key.pem \\
  --use-service-account-credentials=true \\
  --alsologtostderr=true \\
  --logtostderr=false \\
  --log-dir=/var/log/kubernetes \\
  --v=2
Restart=on
Restart=on-failure
RestartSec=5
User=k8s

[Install]
WantedBy=multi-user.target
EOF
</code></pre>
<ul>
<li>–port=0：关闭监听 http /metrics 的请求，同时 –address 参数无效，–bind-address 参数有效；</li>
<li>–secure-port=10252、–bind-address=0.0.0.0: 在所有网络接口监听 10252 端口的 https /metrics 请求；</li>
<li>–kubeconfig：指定 kubeconfig 文件路径，kube-controller-manager 使用它连接和验证 kube-apiserver；</li>
<li>–cluster-signing-*-file：签名 TLS Bootstrap 创建的证书；</li>
<li>–experimental-cluster-signing-duration：指定 TLS Bootstrap 证书的有效期；</li>
<li>–root-ca-file：放置到容器 ServiceAccount 中的 CA 证书，用来对 kube-apiserver 的证书进行校验；</li>
<li>–service-account-private-key-file：签名 ServiceAccount 中 Token 的私钥文件，必须和 kube-apiserver 的 –service-account-key-file 指定的公钥文件配对使用；</li>
<li>–service-cluster-ip-range ：指定 Service Cluster IP 网段，必须和 kube-apiserver 中的同名参数一致；</li>
<li>–leader-elect=true：集群运行模式，启用选举功能；被选为 leader 的节点负责处理工作，其它节点为阻塞状态；</li>
<li>–feature-gates=RotateKubeletServerCertificate=true：开启 kublet server 证书的自动更新特性；</li>
<li>–controllers=*,bootstrapsigner,tokencleaner：启用的控制器列表，tokencleaner 用于自动清理过期的 Bootstrap token；</li>
<li>–horizontal-pod-autoscaler-*：custom metrics 相关参数，支持 autoscaling/v2alpha1；</li>
<li>–tls-cert-file、–tls-private-key-file：使用 https 输出 metrics 时使用的 Server 证书和秘钥；</li>
<li>–use-service-account-credentials=true:</li>
<li>User=k8s：使用 k8s 账户运行；</li>
<li>kube-controller-manager 不对请求 https metrics 的 Client 证书进行校验，故不需要指定 –tls-ca-file 参数，而且该参数已被淘汰。</li>
</ul>
<p>分发 systemd unit 文件到所有 master 节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp kube-controller-manager.service root@$&#123;node_ip&#125;:/etc/systemd/system/
  done
</code></pre>
<h3 id="kube-controller-manager-的权限"><a href="#kube-controller-manager-的权限" class="headerlink" title="kube-controller-manager 的权限"></a>kube-controller-manager 的权限</h3><p>ClusteRole: system:kube-controller-manager 的权限很小，只能创建 secret、serviceaccount 等资源对象，各 controller 的权限分散到 ClusterRole system:controller:XXX 中。</p>
<p>需要在 kube-controller-manager 的启动参数中添加 –use-service-account-credentials=true 参数，这样 main controller 会为各 controller 创建对应的 ServiceAccount XXX-controller。</p>
<p>内置的 ClusterRoleBinding system:controller:XXX 将赋予各 XXX-controller ServiceAccount 对应的 ClusterRole system:controller:XXX 权限。</p>
<h3 id="启动-kube-controller-manager-服务"><a href="#启动-kube-controller-manager-服务" class="headerlink" title="启动 kube-controller-manager 服务"></a>启动 kube-controller-manager 服务</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /var/log/kubernetes &amp;&amp; chown -R k8s /var/log/kubernetes&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl daemon-reload &amp;&amp; systemctl enable kube-controller-manager &amp;&amp; systemctl restart kube-controller-manager&quot;
  done
</code></pre>
<p>必须先创建日志目录；</p>
<h3 id="检查服务运行状态"><a href="#检查服务运行状态" class="headerlink" title="检查服务运行状态"></a>检查服务运行状态</h3><p>source /opt/k8s/bin/environment.sh<br> for node_ip in ${ETCD_NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh k8s@${node_ip} “systemctl status kube-controller-manager|grep Active”<br> done<br> 确保状态为 active (running)，否则查看日志，确认原因：</p>
<pre><code>$ journalctl -u kube-controller-manager
</code></pre>
<h3 id="查看输出的-metric"><a href="#查看输出的-metric" class="headerlink" title="查看输出的 metric"></a>查看输出的 metric</h3><p>注意：以下命令在 kube-controller-manager 节点上执行。</p>
<p>kube-controller-manager 监听 10252 端口，接收 https 请求：</p>
<pre><code>$ sudo netstat -lnpt|grep kube-controll
tcp        0      0 127.0.0.1:10252         0.0.0.0:*               LISTEN      18377/kube-controll
$ curl -s --cacert /etc/kubernetes/cert/ca.pem https://127.0.0.1:10252/metrics |head
# HELP ClusterRoleAggregator_adds Total number of adds handled by workqueue: ClusterRoleAggregator
# TYPE ClusterRoleAggregator_adds counter
ClusterRoleAggregator_adds 3
# HELP ClusterRoleAggregator_depth Current depth of workqueue: ClusterRoleAggregator
# TYPE ClusterRoleAggregator_depth gauge
ClusterRoleAggregator_depth 0
# HELP ClusterRoleAggregator_queue_latency How long an item stays in workqueueClusterRoleAggregator before being requested.
# TYPE ClusterRoleAggregator_queue_latency summary
ClusterRoleAggregator_queue_latency&#123;quantile=&quot;0.5&quot;&#125; 57018
ClusterRoleAggregator_queue_latency&#123;quantile=&quot;0.9&quot;&#125; 57268
</code></pre>
<p>curl –cacert CA 证书用来验证 kube-controller-manager https server 证书；<br> 测试 kube-controller-manager 集群的高可用<br> 停掉一个或两个节点的 kube-controller-manager 服务，观察其它节点的日志，看是否获取了 leader 权限。</p>
<h3 id="查看当前的-leader"><a href="#查看当前的-leader" class="headerlink" title="查看当前的 leader"></a>查看当前的 leader</h3><pre><code>$ kubectl get endpoints kube-controller-manager --namespace=kube-system  -o yaml
apiVersion: v1
kind: Endpoints
metadata:
  annotations:
    control-plane.alpha.kubernetes.io/leader: &#39;&#123;&quot;holderIdentity&quot;:&quot;docker86-155_32dbaca9-e15f-11e8-87e7-e0db5521eb14&quot;,&quot;leaseDurationSeconds&quot;:15,&quot;acquireTime&quot;:&quot;2018-11-06T00:59:52Z&quot;,&quot;renewTime&quot;:&quot;2018-11-06T01:34:01Z&quot;,&quot;leaderTransitions&quot;:39&#125;&#39;
  creationTimestamp: 2018-10-10T15:18:11Z
  name: kube-controller-manager
  namespace: kube-system
  resourceVersion: &quot;6281708&quot;
  selfLink: /api/v1/namespaces/kube-system/endpoints/kube-controller-manager
  uid: b38d3ea9-cc9f-11e8-9cde-d4ae52a3b675
</code></pre>
<p>可见，当前的 leader 为docker86-155 节点。</p>
<p>参考<br> 关于 controller 权限和 use-service-account-credentials 参数：<a href="https://github.com/kubernetes/kubernetes/issues/48208">https://github.com/kubernetes/kubernetes/issues/48208</a><br> kublet 认证和授权：<a href="https://kubernetes.io/docs/admin/kubelet-authentication-authorization/#kubelet-authorization">https://kubernetes.io/docs/admin/kubelet-authentication-authorization/#kubelet-authorization</a></p>
<h2 id="06-3-部署高可用-kube-scheduler-集群"><a href="#06-3-部署高可用-kube-scheduler-集群" class="headerlink" title="06-3.部署高可用 kube-scheduler 集群"></a>06-3.部署高可用 kube-scheduler 集群</h2><p>该集群包含 3 个节点，启动后将通过竞争选举机制产生一个 leader 节点，其它节点为阻塞状态。当 leader 节点不可用后，剩余节点将再次进行选举产生新的 leader 节点，从而保证服务的可用性。</p>
<p>为保证通信安全，本文档先生成 x509 证书和私钥，kube-scheduler 在如下两种情况下使用该证书：</p>
<p>与 kube-apiserver 的安全端口通信;<br> 在安全端口(https，10251) 输出 prometheus 格式的 metrics；</p>
<h3 id="创建-kube-scheduler-证书和私钥"><a href="#创建-kube-scheduler-证书和私钥" class="headerlink" title="创建 kube-scheduler 证书和私钥"></a>创建 kube-scheduler 证书和私钥</h3><pre><code>cat &gt; kube-scheduler-csr.json &lt;&lt;EOF
&#123;
    &quot;CN&quot;: &quot;system:kube-scheduler&quot;,
    &quot;hosts&quot;: [
      &quot;127.0.0.1&quot;,
      &quot;192.168.86.156&quot;,  &quot;192.168.86.155&quot;,  &quot;192.168.86.154&quot;
    ],
    &quot;key&quot;: &#123;
        &quot;algo&quot;: &quot;rsa&quot;,
        &quot;size&quot;: 2048
    &#125;,
    &quot;names&quot;: [
      &#123;
        &quot;C&quot;: &quot;CN&quot;,
        &quot;ST&quot;: &quot;BeiJing&quot;,
        &quot;L&quot;: &quot;BeiJing&quot;,
        &quot;O&quot;: &quot;system:kube-scheduler&quot;,
        &quot;OU&quot;: &quot;4Paradigm&quot;
      &#125;
    ]
&#125;
EOF
</code></pre>
<p>生成证书和私钥：</p>
<pre><code>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem \
  -ca-key=/etc/kubernetes/cert/ca-key.pem \
  -config=/etc/kubernetes/cert/ca-config.json \
  -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler
</code></pre>
<h3 id="创建和分发-kubeconfig-文件-1"><a href="#创建和分发-kubeconfig-文件-1" class="headerlink" title="创建和分发 kubeconfig 文件"></a>创建和分发 kubeconfig 文件</h3><p>kubeconfig 文件包含访问 apiserver 的所有信息，如 apiserver 地址、CA 证书和自身使用的证书；</p>
<pre><code>source /opt/k8s/bin/environment.sh
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/cert/ca.pem \
  --embed-certs=true \
  --server=$&#123;KUBE_APISERVER&#125; \
  --kubeconfig=kube-scheduler.kubeconfig

kubectl config set-credentials system:kube-scheduler \
  --client-certificate=kube-scheduler.pem \
  --client-key=kube-scheduler-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-scheduler.kubeconfig

kubectl config set-context system:kube-scheduler \
  --cluster=kubernetes \
  --user=system:kube-scheduler \
  --kubeconfig=kube-scheduler.kubeconfig

kubectl config use-context system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig
</code></pre>
<p>分发 kubeconfig 到所有 master 节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp kube-scheduler.kubeconfig k8s@$&#123;node_ip&#125;:/etc/kubernetes/
  done
</code></pre>
<h3 id="创建和分发-kube-scheduler-systemd-unit-文件"><a href="#创建和分发-kube-scheduler-systemd-unit-文件" class="headerlink" title="创建和分发 kube-scheduler systemd unit 文件"></a>创建和分发 kube-scheduler systemd unit 文件</h3><pre><code>cat &gt; kube-scheduler.service &lt;&lt;EOF
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
ExecStart=/opt/k8s/bin/kube-scheduler \\
  --address=127.0.0.1 \\
  --kubeconfig=/etc/kubernetes/kube-scheduler.kubeconfig \\
  --leader-elect=true \\
  --alsologtostderr=true \\
  --logtostderr=false \\
  --log-dir=/var/log/kubernetes \\
  --v=2
Restart=on-failure
RestartSec=5
User=k8s

[Install]
WantedBy=multi-user.target
EOF
</code></pre>
<p>–address：在 127.0.0.1:10251 端口接收 http /metrics 请求；kube-scheduler 目前还不支持接收 https 请求；<br> –kubeconfig：指定 kubeconfig 文件路径，kube-scheduler 使用它连接和验证 kube-apiserver；<br> –leader-elect=true：集群运行模式，启用选举功能；被选为 leader 的节点负责处理工作，其它节点为阻塞状态；<br> User=k8s：使用 k8s 账户运行；</p>
<h3 id="分发-systemd-unit-文件到所有-master-节点："><a href="#分发-systemd-unit-文件到所有-master-节点：" class="headerlink" title="分发 systemd unit 文件到所有 master 节点："></a>分发 systemd unit 文件到所有 master 节点：</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp kube-scheduler.service root@$&#123;node_ip&#125;:/etc/systemd/system/
  done
</code></pre>
<h3 id="启动-kube-scheduler-服务"><a href="#启动-kube-scheduler-服务" class="headerlink" title="启动 kube-scheduler 服务"></a>启动 kube-scheduler 服务</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /var/log/kubernetes &amp;&amp; chown -R k8s /var/log/kubernetes&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl daemon-reload &amp;&amp; systemctl enable kube-scheduler &amp;&amp; systemctl restart kube-scheduler&quot;
  done
</code></pre>
<p>必须先创建日志目录；</p>
<p>检查服务运行状态<br> source /opt/k8s/bin/environment.sh<br> for node_ip in ${ETCD_NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh k8s@${node_ip} “systemctl status kube-scheduler|grep Active”<br> done</p>
<p>确保状态为 active (running)，否则查看日志，确认原因：</p>
<pre><code>journalctl -u kube-scheduler
</code></pre>
<h3 id="查看输出的-metric-1"><a href="#查看输出的-metric-1" class="headerlink" title="查看输出的 metric"></a>查看输出的 metric</h3><p>注意：以下命令在 kube-scheduler 节点上执行。</p>
<p>kube-scheduler 监听 10251 端口，接收 http 请求：</p>
<p>$ sudo netstat -lnpt|grep kube-sche<br> tcp        0      0 127.0.0.1:10251         0.0.0.0:*               LISTEN      23783/kube-schedule<br> $ curl -s <a href="http://127.0.0.1:10251/metrics">http://127.0.0.1:10251/metrics</a> |head</p>
<h1 id="HELP-apiserver-audit-event-total-Counter-of-audit-events-generated-and-sent-to-the-audit-backend"><a href="#HELP-apiserver-audit-event-total-Counter-of-audit-events-generated-and-sent-to-the-audit-backend" class="headerlink" title="HELP apiserver_audit_event_total Counter of audit events generated and sent to the audit backend."></a>HELP apiserver_audit_event_total Counter of audit events generated and sent to the audit backend.</h1><h1 id="TYPE-apiserver-audit-event-total-counter"><a href="#TYPE-apiserver-audit-event-total-counter" class="headerlink" title="TYPE apiserver_audit_event_total counter"></a>TYPE apiserver_audit_event_total counter</h1><p>apiserver_audit_event_total 0</p>
<h1 id="HELP-go-gc-duration-seconds-A-summary-of-the-GC-invocation-durations"><a href="#HELP-go-gc-duration-seconds-A-summary-of-the-GC-invocation-durations" class="headerlink" title="HELP go_gc_duration_seconds A summary of the GC invocation durations."></a>HELP go_gc_duration_seconds A summary of the GC invocation durations.</h1><h1 id="TYPE-go-gc-duration-seconds-summary"><a href="#TYPE-go-gc-duration-seconds-summary" class="headerlink" title="TYPE go_gc_duration_seconds summary"></a>TYPE go_gc_duration_seconds summary</h1><p>go_gc_duration_seconds{quantile=”0”} 9.7715e-05<br> go_gc_duration_seconds{quantile=”0.25”} 0.000107676<br> go_gc_duration_seconds{quantile=”0.5”} 0.00017868<br> go_gc_duration_seconds{quantile=”0.75”} 0.000262444<br> go_gc_duration_seconds{quantile=”1”} 0.001205223</p>
<h3 id="测试-kube-scheduler-集群的高可用"><a href="#测试-kube-scheduler-集群的高可用" class="headerlink" title="测试 kube-scheduler 集群的高可用"></a>测试 kube-scheduler 集群的高可用</h3><p>随便找一个或两个 master 节点，停掉 kube-scheduler 服务，看其它节点是否获取了 leader 权限（systemd 日志）。</p>
<p>查看当前的 leader<br> $ kubectl get endpoints kube-scheduler –namespace=kube-system  -o yaml<br> apiVersion: v1<br> kind: Endpoints<br> metadata:<br> annotations:<br> control-plane.alpha.kubernetes.io/leader: ‘{“holderIdentity”:”kube-node3_61f34593-6cc8-11e8-8af7-5254002f288e”,”leaseDurationSeconds”:15,”acquireTime”:”2018-06-10T16:09:56Z”,”renewTime”:”2018-06-10T16:20:54Z”,”leaderTransitions”:1}’<br> creationTimestamp: 2018-06-10T16:07:33Z<br> name: kube-scheduler<br> namespace: kube-system<br> resourceVersion: “4645”<br> selfLink: /api/v1/namespaces/kube-system/endpoints/kube-scheduler<br> uid: 62382d98-6cc8-11e8-96fa-525400ba84c6</p>
<h2 id="07-1-部署-docker-组件"><a href="#07-1-部署-docker-组件" class="headerlink" title="07-1.部署 docker 组件"></a>07-1.部署 docker 组件</h2><p>docker 是容器的运行环境，管理它的生命周期。kubelet 通过 Container Runtime Interface (CRI) 与 docker 进行交互。</p>
<h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><p>参考 <a href="07-0.%E9%83%A8%E7%BD%B2worker%E8%8A%82%E7%82%B9.md">07-0.部署worker节点.md</a></p>
<h3 id="下载和分发-docker-二进制文件"><a href="#下载和分发-docker-二进制文件" class="headerlink" title="下载和分发 docker 二进制文件"></a>下载和分发 docker 二进制文件</h3><p>到 <a href="http://mirrors.ustc.edu.cn/docker-ce/linux/static/stable/x86_64/">http://mirrors.ustc.edu.cn/docker-ce/linux/static/stable/x86_64/</a> 页面下载最新发布包：</p>
<pre><code>wget http://mirrors.ustc.edu.cn/docker-ce/linux/static/stable/x86_64/docker-18.06.1-ce.tgz
tar -xvf docker-18.06.1-ce.tgz
</code></pre>
<p>分发二进制文件到所有 worker 节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp docker/docker*  k8s@$&#123;node_ip&#125;:/opt/k8s/bin/
    ssh k8s@$&#123;node_ip&#125; &quot;chmod +x /opt/k8s/bin/*&quot;
  done
</code></pre>
<h3 id="创建和分发-systemd-unit-文件"><a href="#创建和分发-systemd-unit-文件" class="headerlink" title="创建和分发 systemd unit 文件"></a>创建和分发 systemd unit 文件</h3><pre><code>cat &gt; docker.service &lt;&lt;&quot;EOF&quot;
[Unit]
Description=Docker Application Container Engine
Documentation=http://docs.docker.io

[Service]
Environment=&quot;PATH=/opt/k8s/bin:/bin:/sbin:/usr/bin:/usr/sbin&quot;
EnvironmentFile=-/run/flannel/docker
ExecStart=/opt/k8s/bin/dockerd --log-level=error $DOCKER_NETWORK_OPTIONS
ExecReload=/bin/kill -s HUP $MAINPID
Restart=on-failure
RestartSec=5
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
Delegate=yes
KillMode=process

[Install]
WantedBy=multi-user.target
EOF
</code></pre>
<ul>
<li>EOF 前后有双引号，这样 bash 不会替换文档中的变量，如 $DOCKER_NETWORK_OPTIONS；</li>
<li>dockerd 运行时会调用其它 docker 命令，如 docker-proxy，所以需要将 docker 命令所在的目录加到 PATH 环境变量中；</li>
<li>flanneld 启动时将网络配置写入 <code>/run/flannel/docker</code> 文件中，dockerd 启动前读取该文件中的环境变量 <code>DOCKER_NETWORK_OPTIONS</code> ，然后设置 docker0 网桥网段；</li>
<li>如果指定了多个 <code>EnvironmentFile</code> 选项，则必须将 <code>/run/flannel/docker</code> 放在最后(确保 docker0 使用 flanneld 生成的 bip 参数)；</li>
<li>docker 需要以 root 用于运行；</li>
<li>docker 从 1.13 版本开始，可能将 <strong>iptables FORWARD chain的默认策略设置为DROP</strong>，从而导致 ping 其它 Node 上的 Pod IP 失败，遇到这种情况时，需要手动设置策略为 <code>ACCEPT</code>：</li>
</ul>
<pre><code>    $ sudo iptables -P FORWARD ACCEPT

并且把以下命令写入 `/etc/rc.local` 文件中，防止节点重启**iptables FORWARD chain的默认策略又还原为DROP**


    /sbin/iptables -P FORWARD ACCEPT
</code></pre>
<p>完整 unit 见 <a href="https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/systemd/docker.service">docker.service</a></p>
<p>分发 systemd unit 文件到所有 worker 机器:</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    scp docker.service root@$&#123;node_ip&#125;:/etc/systemd/system/
  done
</code></pre>
<h3 id="配置和分发-docker-配置文件"><a href="#配置和分发-docker-配置文件" class="headerlink" title="配置和分发 docker 配置文件"></a>配置和分发 docker 配置文件</h3><p>使用国内的仓库镜像服务器以加快 pull image 的速度，同时增加下载的并发数 (需要重启 dockerd 生效)：</p>
<pre><code>cat &gt; docker-daemon.json &lt;&lt;EOF
&#123;&quot;insecure-registries&quot;:[&quot;192.168.86.8:5000&quot;,&quot;registry.xxx.com&quot;],
    &quot;registry-mirrors&quot;: [&quot;https://jk4bb75a.mirror.aliyuncs.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;],
    &quot;max-concurrent-downloads&quot;: 20
&#125;
EOF
</code></pre>
<p>分发 docker 配置文件到所有 work 节点：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p  /etc/docker/&quot;
    scp docker-daemon.json root@$&#123;node_ip&#125;:/etc/docker/daemon.json
  done
</code></pre>
<h3 id="启动-docker-服务"><a href="#启动-docker-服务" class="headerlink" title="启动 docker 服务"></a>启动 docker 服务</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl stop firewalld &amp;&amp; systemctl disable firewalld&quot;
    ssh root@$&#123;node_ip&#125; &quot;/usr/sbin/iptables -F &amp;&amp; /usr/sbin/iptables -X &amp;&amp; /usr/sbin/iptables -F -t nat &amp;&amp; /usr/sbin/iptables -X -t nat&quot;
    ssh root@$&#123;node_ip&#125; &quot;/usr/sbin/iptables -P FORWARD ACCEPT&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl daemon-reload &amp;&amp; systemctl enable docker &amp;&amp; systemctl restart docker&quot;
    ssh root@$&#123;node_ip&#125; &#39;for intf in /sys/devices/virtual/net/docker0/brif/*; do echo 1 &gt; $intf/hairpin_mode; done&#39;
    ssh root@$&#123;node_ip&#125; &quot;sudo sysctl -p /etc/sysctl.d/kubernetes.conf&quot;
  done



source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
     ssh root@$&#123;node_ip&#125; &quot;systemctl restart docker&quot;
  done
</code></pre>
<ul>
<li>关闭 firewalld(centos7)/ufw(ubuntu16.04)，否则可能会重复创建 iptables 规则；</li>
<li>清理旧的 iptables rules 和 chains 规则；</li>
<li>开启 docker0 网桥下虚拟网卡的 hairpin 模式;</li>
</ul>
<h3 id="检查服务运行状态-1"><a href="#检查服务运行状态-1" class="headerlink" title="检查服务运行状态"></a>检查服务运行状态</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh k8s@$&#123;node_ip&#125; &quot;systemctl status docker|grep Active&quot;
  done
</code></pre>
<p>确保状态为 <code>active (running)</code>，否则查看日志，确认原因：</p>
<pre><code>$ journalctl -u docker
</code></pre>
<h4 id="检查-docker0-网桥"><a href="#检查-docker0-网桥" class="headerlink" title="检查 docker0 网桥"></a>检查 docker0 网桥</h4><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh k8s@$&#123;node_ip&#125; &quot;/usr/sbin/ip addr show flannel.1 &amp;&amp; /usr/sbin/ip addr show docker0&quot;
  done
</code></pre>
<p>确认各 work 节点的 docker0 网桥和 flannel.1 接口的 IP 处于同一个网段中(如下 172.30.39.0 和 172.30.39.1)：</p>
<pre><code>3: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN group default
    link/ether ce:2f:d6:53:e5:f3 brd ff:ff:ff:ff:ff:ff
    inet 172.30.39.0/32 scope global flannel.1
      valid_lft forever preferred_lft forever
    inet6 fe80::cc2f:d6ff:fe53:e5f3/64 scope link
      valid_lft forever preferred_lft forever
4: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default
    link/ether 02:42:bf:65:16:5c brd ff:ff:ff:ff:ff:ff
    inet 172.30.39.1/24 brd 172.30.39.255 scope global docker0
      valid_lft forever preferred_lft forever
</code></pre>
<h2 id="07-2-部署-kubelet-组件"><a href="#07-2-部署-kubelet-组件" class="headerlink" title="07-2.部署 kubelet 组件"></a>07-2.部署 kubelet 组件</h2><p>kublet 运行在每个 worker 节点上，接收 kube-apiserver 发送的请求，管理 Pod 容器，执行交互式命令，如 exec、run、logs 等。</p>
<p>kublet 启动时自动向 kube-apiserver 注册节点信息，内置的 cadvisor 统计和监控节点的资源使用情况。</p>
<p>为确保安全，本文档只开启接收 https 请求的安全端口，对请求进行认证和授权，拒绝未授权的访问(如 apiserver、heapster)。</p>
<h3 id="创建-kubelet-bootstrap-kubeconfig-文件"><a href="#创建-kubelet-bootstrap-kubeconfig-文件" class="headerlink" title="创建 kubelet bootstrap kubeconfig 文件"></a>创建 kubelet bootstrap kubeconfig 文件</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_name in $&#123;NODE_NAMES[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_name&#125;&quot;

    # 创建 token
    export BOOTSTRAP_TOKEN=$(kubeadm token create \
      --description kubelet-bootstrap-token \
      --groups system:bootstrappers:$&#123;node_name&#125; \
      --kubeconfig ~/.kube/config)

    # 设置集群参数
    kubectl config set-cluster kubernetes \
      --certificate-authority=/etc/kubernetes/cert/ca.pem \
      --embed-certs=true \
      --server=$&#123;KUBE_APISERVER&#125; \
      --kubeconfig=kubelet-bootstrap-$&#123;node_name&#125;.kubeconfig

    # 设置客户端认证参数
    kubectl config set-credentials kubelet-bootstrap \
      --token=$&#123;BOOTSTRAP_TOKEN&#125; \
      --kubeconfig=kubelet-bootstrap-$&#123;node_name&#125;.kubeconfig

    # 设置上下文参数
    kubectl config set-context default \
      --cluster=kubernetes \
      --user=kubelet-bootstrap \
      --kubeconfig=kubelet-bootstrap-$&#123;node_name&#125;.kubeconfig

    # 设置默认上下文
    kubectl config use-context default --kubeconfig=kubelet-bootstrap-$&#123;node_name&#125;.kubeconfig
  done
</code></pre>
<ul>
<li>证书中写入 Token 而非证书，证书后续由 controller-manager 创建。</li>
</ul>
<p>查看 kubeadm 为各节点创建的 token：</p>
<pre><code>$ kubeadm token list --kubeconfig ~/.kube/config
TOKEN                     TTL       EXPIRES                     USAGES                   DESCRIPTION               EXTRA GROUPS
k0s2bj.7nvw1zi1nalyz4gz   23h       2018-06-14T15:14:31+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:kube-node1
mkus5s.vilnjk3kutei600l   23h       2018-06-14T15:14:32+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:kube-node3
zkiem5.0m4xhw0jc8r466nk   23h       2018-06-14T15:14:32+08:00   authentication,signing   kubelet-bootstrap-token   system:bootstrappers:kube-node2
</code></pre>
<ul>
<li>创建的 token 有效期为 1 天，超期后将不能再被使用，且会被 kube-controller-manager 的 tokencleaner 清理(如果启用该 controller 的话)；</li>
<li>kube-apiserver 接收 kubelet 的 bootstrap token 后，将请求的 user 设置为 system:bootstrap:<token id="">，group 设置为 system:bootstrappers；</token></li>
</ul>
<p>各 token 关联的 Secret：</p>
<pre><code>$ kubectl get secrets  -n kube-system
NAME                     TYPE                                  DATA      AGE
bootstrap-token-k0s2bj   bootstrap.kubernetes.io/token         7         1m
bootstrap-token-mkus5s   bootstrap.kubernetes.io/token         7         1m
bootstrap-token-zkiem5   bootstrap.kubernetes.io/token         7         1m
default-token-99st7      kubernetes.io/service-account-token   3         2d
</code></pre>
<h2 id="分发-bootstrap-kubeconfig-文件到所有-worker-节点"><a href="#分发-bootstrap-kubeconfig-文件到所有-worker-节点" class="headerlink" title="分发 bootstrap kubeconfig 文件到所有 worker 节点"></a>分发 bootstrap kubeconfig 文件到所有 worker 节点</h2><pre><code>source /opt/k8s/bin/environment.sh
for node_name in $&#123;NODE_NAMES[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_name&#125;&quot;
    scp kubelet-bootstrap-$&#123;node_name&#125;.kubeconfig k8s@$&#123;node_name&#125;:/etc/kubernetes/kubelet-bootstrap.kubeconfig
  done
</code></pre>
<h2 id="创建和分发-kubelet-参数配置文件"><a href="#创建和分发-kubelet-参数配置文件" class="headerlink" title="创建和分发 kubelet 参数配置文件"></a>创建和分发 kubelet 参数配置文件</h2><p>从 v1.10 开始，kubelet <strong>部分参数</strong>需在配置文件中配置，<code>kubelet --help</code> 会提示：</p>
<pre><code>DEPRECATED: This parameter should be set via the config file specified by the Kubelet&#39;s --config flag
</code></pre>
<p>创建 kubelet 参数配置模板文件：</p>
<pre><code>source /opt/k8s/bin/environment.sh
cat &gt; kubelet.config.json.template &lt;&lt;EOF
&#123;
  &quot;kind&quot;: &quot;KubeletConfiguration&quot;,
  &quot;apiVersion&quot;: &quot;kubelet.config.k8s.io/v1beta1&quot;,
  &quot;authentication&quot;: &#123;
    &quot;x509&quot;: &#123;
      &quot;clientCAFile&quot;: &quot;/etc/kubernetes/cert/ca.pem&quot;
    &#125;,
    &quot;webhook&quot;: &#123;
      &quot;enabled&quot;: true,
      &quot;cacheTTL&quot;: &quot;2m0s&quot;
    &#125;,
    &quot;anonymous&quot;: &#123;
      &quot;enabled&quot;: false
    &#125;
  &#125;,
  &quot;authorization&quot;: &#123;
    &quot;mode&quot;: &quot;Webhook&quot;,
    &quot;webhook&quot;: &#123;
      &quot;cacheAuthorizedTTL&quot;: &quot;5m0s&quot;,
      &quot;cacheUnauthorizedTTL&quot;: &quot;30s&quot;
    &#125;
  &#125;,
  &quot;address&quot;: &quot;##NODE_IP##&quot;,
  &quot;port&quot;: 10250,
  &quot;readOnlyPort&quot;: 0,
  &quot;cgroupDriver&quot;: &quot;cgroupfs&quot;,
  &quot;hairpinMode&quot;: &quot;promiscuous-bridge&quot;,
  &quot;serializeImagePulls&quot;: false,
  &quot;featureGates&quot;: &#123;
    &quot;RotateKubeletClientCertificate&quot;: true,
    &quot;RotateKubeletServerCertificate&quot;: true
  &#125;,
  &quot;clusterDomain&quot;: &quot;$&#123;CLUSTER_DNS_DOMAIN&#125;&quot;,
  &quot;clusterDNS&quot;: [&quot;$&#123;CLUSTER_DNS_SVC_IP&#125;&quot;]
&#125;
EOF
</code></pre>
<ul>
<li>address：API 监听地址，不能为 127.0.0.1，否则 kube-apiserver、heapster 等不能调用 kubelet 的 API；</li>
<li>readOnlyPort=0：关闭只读端口(默认 10255)，等效为未指定；</li>
<li>authentication.anonymous.enabled：设置为 false，不允许匿名访问 10250 端口；</li>
<li>authentication.x509.clientCAFile：指定签名客户端证书的 CA 证书，开启 HTTP 证书认证；</li>
<li>authentication.webhook.enabled=true：开启 HTTPs bearer token 认证；</li>
<li>对于未通过 x509 证书和 webhook 认证的请求(kube-apiserver 或其他客户端)，将被拒绝，提示 Unauthorized；</li>
<li>authroization.mode=Webhook：kubelet 使用 SubjectAccessReview API 查询 kube-apiserver 某 user、group 是否具有操作资源的权限(RBAC)；</li>
<li>featureGates.RotateKubeletClientCertificate、featureGates.RotateKubeletServerCertificate：自动 rotate 证书，证书的有效期取决于 kube-controller-manager 的 –experimental-cluster-signing-duration 参数；</li>
<li>需要 root 账户运行；</li>
</ul>
<p>为各节点创建和分发 kubelet 配置文件：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do 
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    sed -e &quot;s/##NODE_IP##/$&#123;node_ip&#125;/&quot; kubelet.config.json.template &gt; kubelet.config-$&#123;node_ip&#125;.json
    scp kubelet.config-$&#123;node_ip&#125;.json root@$&#123;node_ip&#125;:/etc/kubernetes/kubelet.config.json
  done
</code></pre>
<p>替换后的 kubelet.config.json 文件： <a href="https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/systemd/kubelet.config.json">kubelet.config.json</a></p>
<h2 id="创建和分发-kubelet-systemd-unit-文件"><a href="#创建和分发-kubelet-systemd-unit-文件" class="headerlink" title="创建和分发 kubelet systemd unit 文件"></a>创建和分发 kubelet systemd unit 文件</h2><p>创建 kubelet systemd unit 文件模板：</p>
<pre><code>cat &gt; kubelet.service.template &lt;&lt;EOF
[Unit]
Description=Kubernetes Kubelet
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=docker.service
Requires=docker.service

[Service]
WorkingDirectory=/var/lib/kubelet
ExecStart=/opt/k8s/bin/kubelet \\
  --bootstrap-kubeconfig=/etc/kubernetes/kubelet-bootstrap.kubeconfig \\
  --cert-dir=/etc/kubernetes/cert \\
  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \\
  --config=/etc/kubernetes/kubelet.config.json \\
  --hostname-override=##NODE_NAME## \\
  --pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest \\
  --allow-privileged=true \\
  --alsologtostderr=true \\
  --logtostderr=false \\
  --log-dir=/var/log/kubernetes \\
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
</code></pre>
<ul>
<li>如果设置了 <code>--hostname-override</code> 选项，则 <code>kube-proxy</code> 也需要设置该选项，否则会出现找不到 Node 的情况；</li>
<li><code>--bootstrap-kubeconfig</code>：指向 bootstrap kubeconfig 文件，kubelet 使用该文件中的用户名和 token 向 kube-apiserver 发送 TLS Bootstrapping 请求；</li>
<li>K8S approve kubelet 的 csr 请求后，在 <code>--cert-dir</code> 目录创建证书和私钥文件，然后写入 <code>--kubeconfig</code> 文件；</li>
</ul>
<p>替换后的 unit 文件：<a href="https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/systemd/kubelet.service">kubelet.service</a></p>
<p>为各节点创建和分发 kubelet systemd unit 文件：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_name in $&#123;NODE_NAMES[@]&#125;
  do 
    echo &quot;&gt;&gt;&gt; $&#123;node_name&#125;&quot;
    sed -e &quot;s/##NODE_NAME##/$&#123;node_name&#125;/&quot; kubelet.service.template &gt; kubelet-$&#123;node_name&#125;.service
    scp kubelet-$&#123;node_name&#125;.service root@$&#123;node_name&#125;:/etc/systemd/system/kubelet.service
  done
</code></pre>
<h2 id="Bootstrap-Token-Auth-和授予权限"><a href="#Bootstrap-Token-Auth-和授予权限" class="headerlink" title="Bootstrap Token Auth 和授予权限"></a>Bootstrap Token Auth 和授予权限</h2><p>kublet 启动时查找配置的 –kubeletconfig 文件是否存在，如果不存在则使用 –bootstrap-kubeconfig 向 kube-apiserver 发送证书签名请求 (CSR)。</p>
<p>kube-apiserver 收到 CSR 请求后，对其中的 Token 进行认证（事先使用 kubeadm 创建的 token），认证通过后将请求的 user 设置为 system:bootstrap:<token id="">，group 设置为 system:bootstrappers，这一过程称为 Bootstrap Token Auth。</token></p>
<p>默认情况下，这个 user 和 group 没有创建 CSR 的权限:q，kubelet 启动失败，错误日志如下：</p>
<pre><code>$ sudo journalctl -u kubelet -a |grep -A 2 &#39;certificatesigningrequests&#39;
May 06 06:42:36 kube-node1 kubelet[26986]: F0506 06:42:36.314378   26986 server.go:233] failed to run Kubelet: cannot create certificate signing request: certificatesigningrequests.certificates.k8s.io is forbidden: User &quot;system:bootstrap:lemy40&quot; cannot create certificatesigningrequests.certificates.k8s.io at the cluster scope
May 06 06:42:36 kube-node1 systemd[1]: kubelet.service: Main process exited, code=exited, status=255/n/a
May 06 06:42:36 kube-node1 systemd[1]: kubelet.service: Failed with result &#39;exit-code&#39;.
</code></pre>
<p>解决办法是：创建一个 clusterrolebinding，将 group system:bootstrappers 和 clusterrole system:node-bootstrapper 绑定：</p>
<pre><code>$ kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --group=system:bootstrappers
</code></pre>
<h2 id="启动-kubelet-服务"><a href="#启动-kubelet-服务" class="headerlink" title="启动 kubelet 服务"></a>启动 kubelet 服务</h2><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;ETCD_NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /var/lib/kubelet&quot;
    ssh root@$&#123;node_ip&#125; &quot;/usr/sbin/swapoff -a&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /var/log/kubernetes &amp;&amp; chown -R k8s /var/log/kubernetes&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl daemon-reload &amp;&amp; systemctl enable kubelet &amp;&amp; systemctl restart kubelet&quot;
  done
</code></pre>
<ul>
<li>关闭 swap 分区，否则 kubelet 会启动失败；</li>
<li>必须先创建工作和日志目录；</li>
</ul>
<p>source /opt/k8s/bin/environment.sh<br> for node_ip in ${NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh root@${node_ip} “systemctl restart kubelet &amp;&amp; systemctl status kubelet|grep Active:”<br> done</p>
<pre><code>$ journalctl -u kubelet |tail
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.388242   22343 feature_gate.go:226] feature gates: &amp;&#123;&#123;&#125; map[RotateKubeletServerCertificate:true RotateKubeletClientCertificate:true]&#125;
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.394342   22343 mount_linux.go:211] Detected OS with systemd
Jun 13 16:05:40 kube-node2 kubelet[22343]: W0613 16:05:40.394494   22343 cni.go:171] Unable to update cni config: No networks found in /etc/cni/net.d
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.399508   22343 server.go:376] Version: v1.10.4
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.399583   22343 feature_gate.go:226] feature gates: &amp;&#123;&#123;&#125; map[RotateKubeletServerCertificate:true RotateKubeletClientCertificate:true]&#125;
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.399736   22343 plugins.go:89] No cloud provider specified.
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.399752   22343 server.go:492] No cloud provider specified: &quot;&quot; from the config file: &quot;&quot;
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.399777   22343 bootstrap.go:58] Using bootstrap kubeconfig to generate TLS client cert, key and kubeconfig file
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.446068   22343 csr.go:105] csr for this node already exists, reusing
Jun 13 16:05:40 kube-node2 kubelet[22343]: I0613 16:05:40.453761   22343 csr.go:113] csr for this node is still valid
</code></pre>
<p>kubelet 启动后使用 –bootstrap-kubeconfig 向 kube-apiserver 发送 CSR 请求，当这个 CSR 被 approve 后，kube-controller-manager 为 kubelet 创建 TLS 客户端证书、私钥和 –kubeletconfig 文件。</p>
<p>注意：kube-controller-manager 需要配置 <code>--cluster-signing-cert-file</code> 和 <code>--cluster-signing-key-file</code> 参数，才会为 TLS Bootstrap 创建证书和私钥。</p>
<pre><code>$ kubectl get csr
NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-QzuuQiuUfcSdp3j5W4B2UOuvQ_n9aTNHAlrLzVFiqrk   43s       system:bootstrap:zkiem5   Pending
node-csr-oVbPmU-ikVknpynwu0Ckz_MvkAO_F1j0hmbcDa__sGA   27s       system:bootstrap:mkus5s   Pending
node-csr-u0E1-ugxgotO_9FiGXo8DkD6a7-ew8sX2qPE6KPS2IY   13m       system:bootstrap:k0s2bj   Pending

$ kubectl get nodes
No resources found.
</code></pre>
<ul>
<li>三个 work 节点的 csr 均处于 pending 状态；</li>
</ul>
<h2 id="approve-kubelet-CSR-请求"><a href="#approve-kubelet-CSR-请求" class="headerlink" title="approve kubelet CSR 请求"></a>approve kubelet CSR 请求</h2><p>可以手动或自动 approve CSR 请求。推荐使用自动的方式，因为从 v1.8 版本开始，可以自动轮转approve csr 后生成的证书。</p>
<h3 id="手动-approve-CSR-请求"><a href="#手动-approve-CSR-请求" class="headerlink" title="手动 approve CSR 请求"></a>手动 approve CSR 请求</h3><p>查看 CSR 列表：</p>
<pre><code>$ kubectl get csr
NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-QzuuQiuUfcSdp3j5W4B2UOuvQ_n9aTNHAlrLzVFiqrk   43s       system:bootstrap:zkiem5   Pending
node-csr-oVbPmU-ikVknpynwu0Ckz_MvkAO_F1j0hmbcDa__sGA   27s       system:bootstrap:mkus5s   Pending
node-csr-u0E1-ugxgotO_9FiGXo8DkD6a7-ew8sX2qPE6KPS2IY   13m       system:bootstrap:k0s2bj   Pending
</code></pre>
<p>approve CSR：</p>
<pre><code>$ kubectl certificate approve node-csr-QzuuQiuUfcSdp3j5W4B2UOuvQ_n9aTNHAlrLzVFiqrk
certificatesigningrequest.certificates.k8s.io &quot;node-csr-QzuuQiuUfcSdp3j5W4B2UOuvQ_n9aTNHAlrLzVFiqrk&quot; approved
</code></pre>
<p>查看 Approve 结果：</p>
<pre><code>$ kubectl describe  csr node-csr-QzuuQiuUfcSdp3j5W4B2UOuvQ_n9aTNHAlrLzVFiqrk
Name:               node-csr-QzuuQiuUfcSdp3j5W4B2UOuvQ_n9aTNHAlrLzVFiqrk
Labels:             &lt;none&gt;
Annotations:        &lt;none&gt;
CreationTimestamp:  Wed, 13 Jun 2018 16:05:04 +0800
Requesting User:    system:bootstrap:zkiem5
Status:             Approved
Subject:
         Common Name:    system:node:kube-node2
         Serial Number:
         Organization:   system:nodes
Events:  &lt;none&gt;
</code></pre>
<ul>
<li><code>Requesting User</code>：请求 CSR 的用户，kube-apiserver 对它进行认证和授权；</li>
<li><code>Subject</code>：请求签名的证书信息；</li>
<li>证书的 CN 是 system:node:kube-node2， Organization 是 system:nodes，kube-apiserver 的 Node 授权模式会授予该证书的相关权限；</li>
</ul>
<h3 id="自动-approve-CSR-请求"><a href="#自动-approve-CSR-请求" class="headerlink" title="自动 approve CSR 请求"></a>自动 approve CSR 请求</h3><p>创建三个 ClusterRoleBinding，分别用于自动 approve client、renew client、renew server 证书：</p>
<pre><code>cat &gt; csr-crb.yaml &lt;&lt;EOF
 # Approve all CSRs for the group &quot;system:bootstrappers&quot;
 kind: ClusterRoleBinding
 apiVersion: rbac.authorization.k8s.io/v1
 metadata:
   name: auto-approve-csrs-for-group
 subjects:
 - kind: Group
   name: system:bootstrappers
   apiGroup: rbac.authorization.k8s.io
 roleRef:
   kind: ClusterRole
   name: system:certificates.k8s.io:certificatesigningrequests:nodeclient
   apiGroup: rbac.authorization.k8s.io
---
 # To let a node of the group &quot;system:nodes&quot; renew its own credentials
 kind: ClusterRoleBinding
 apiVersion: rbac.authorization.k8s.io/v1
 metadata:
   name: node-client-cert-renewal
 subjects:
 - kind: Group
   name: system:nodes
   apiGroup: rbac.authorization.k8s.io
 roleRef:
   kind: ClusterRole
   name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient
   apiGroup: rbac.authorization.k8s.io
---
# A ClusterRole which instructs the CSR approver to approve a node requesting a
# serving cert matching its client cert.
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: approve-node-server-renewal-csr
rules:
- apiGroups: [&quot;certificates.k8s.io&quot;]
  resources: [&quot;certificatesigningrequests/selfnodeserver&quot;]
  verbs: [&quot;create&quot;]
---
 # To let a node of the group &quot;system:nodes&quot; renew its own server credentials
 kind: ClusterRoleBinding
 apiVersion: rbac.authorization.k8s.io/v1
 metadata:
   name: node-server-cert-renewal
 subjects:
 - kind: Group
   name: system:nodes
   apiGroup: rbac.authorization.k8s.io
 roleRef:
   kind: ClusterRole
   name: approve-node-server-renewal-csr
   apiGroup: rbac.authorization.k8s.io
EOF
</code></pre>
<ul>
<li>auto-approve-csrs-for-group：自动 approve node 的第一次 CSR； 注意第一次 CSR 时，请求的 Group 为 system:bootstrappers；</li>
<li>node-client-cert-renewal：自动 approve node 后续过期的 client 证书，自动生成的证书 Group 为 system:nodes;</li>
<li>node-server-cert-renewal：自动 approve node 后续过期的 server 证书，自动生成的证书 Group 为 system:nodes;</li>
</ul>
<p>生效配置：</p>
<pre><code>$ kubectl apply -f csr-crb.yaml
</code></pre>
<h2 id="查看-kublet-的情况"><a href="#查看-kublet-的情况" class="headerlink" title="查看 kublet 的情况"></a>查看 kublet 的情况</h2><p>等待一段时间(1-10 分钟)，三个节点的 CSR 都被自动 approve：</p>
<pre><code>$ kubectl get csr
NAME                                                   AGE       REQUESTOR                 CONDITION
csr-98h25                                              6m        system:node:kube-node2    Approved,Issued
csr-lb5c9                                              7m        system:node:kube-node3    Approved,Issued
csr-m2hn4                                              14m       system:node:kube-node1    Approved,Issued平时
node-csr-7q7i0q4MF_K2TSEJj16At4CJFLlJkHIqei6nMIAaJCU   28m       system:bootstrap:k0s2bj   Approved,Issued
node-csr-ND77wk2P8k2lHBtgBaObiyYw0uz1Um7g2pRvveMF-c4   35m       system:bootstrap:mkus5s   Approved,Issued
node-csr-Nysmrw55nnM48NKwEJuiuCGmZoxouK4N8jiEHBtLQso   6m        system:bootstrap:zkiem5   Approved,Issued
node-csr-QzuuQiuUfcSdp3j5W4B2UOuvQ_n9aTNHAlrLzVFiqrk   1h        system:bootstrap:zkiem5   Approved,Issued
node-csr-oVbPmU-ikVknpynwu0Ckz_MvkAO_F1j0hmbcDa__sGA   1h        system:bootstrap:mkus5s   Approved,Issued
node-csr-u0E1-ugxgotO_9FiGXo8DkD6a7-ew8sX2qPE6KPS2IY   1h        system:bootstrap:k0s2bj   Approved,Issued
</code></pre>
<p>所有节点均 ready：</p>
<pre><code>$ kubectl get nodes
NAME         STATUS    ROLES     AGE       VERSION
kube-node1   Ready     &lt;none&gt;    18m       v1.10.4
kube-node2   Ready     &lt;none&gt;    10m       v1.10.4
kube-node3   Ready     &lt;none&gt;    11m       v1.10.4
</code></pre>
<p>kube-controller-manager 为各 node 生成了 kubeconfig 文件和公私钥：</p>
<pre><code>$ ls -l /etc/kubernetes/kubelet.kubeconfig
-rw------- 1 root root 2293 Jun 13 17:07 /etc/kubernetes/kubelet.kubeconfig

$ ls -l /etc/kubernetes/cert/|grep kubelet
-rw-r--r-- 1 root root 1046 Jun 13 17:07 kubelet-client.crt
-rw------- 1 root root  227 Jun 13 17:07 kubelet-client.key
-rw------- 1 root root 1334 Jun 13 17:07 kubelet-server-2018-06-13-17-07-45.pem
lrwxrwxrwx 1 root root   58 Jun 13 17:07 kubelet-server-current.pem -&gt; /etc/kubernetes/cert/kubelet-server-2018-06-13-17-07-45.pem
</code></pre>
<ul>
<li>kubelet-server 证书会周期轮转；</li>
</ul>
<h2 id="kubelet-提供的-API-接口"><a href="#kubelet-提供的-API-接口" class="headerlink" title="kubelet 提供的 API 接口"></a>kubelet 提供的 API 接口</h2><p>kublet 启动后监听多个端口，用于接收 kube-apiserver 或其它组件发送的请求：</p>
<pre><code>$ sudo netstat -lnpt|grep kubelet
tcp        0      0 172.27.129.111:4194     0.0.0.0:*               LISTEN      2490/kubelet
tcp        0      0 127.0.0.1:10248         0.0.0.0:*               LISTEN      2490/kubelet
tcp        0      0 172.27.129.111:10250    0.0.0.0:*               LISTEN      2490/kubelet
</code></pre>
<ul>
<li>4194: cadvisor http 服务；</li>
<li>10248: healthz http 服务；</li>
<li>10250: https API 服务；注意：未开启只读端口 10255；</li>
</ul>
<p>例如执行 <code>kubectl ec -it nginx-ds-5rmws -- sh</code> 命令时，kube-apiserver 会向 kubelet 发送如下请求：</p>
<pre><code>POST /exec/default/nginx-ds-5rmws/my-nginx?command=sh&amp;input=1&amp;output=1&amp;tty=1
</code></pre>
<p>kubelet 接收 10250 端口的 https 请求：</p>
<ul>
<li>/pods、/runningpods</li>
<li>/metrics、/metrics/cadvisor、/metrics/probes</li>
<li>/spec</li>
<li>/stats、/stats/container</li>
<li>/logs</li>
<li>/run/、”/exec/“, “/attach/“, “/portForward/“, “/containerLogs/“ 等管理；</li>
</ul>
<p>详情参考：<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/server/server.go#L434:3">https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/server/server.go#L434:3</a></p>
<p>由于关闭了匿名认证，同时开启了 webhook 授权，所有访问 10250 端口 https API 的请求都需要被认证和授权。</p>
<p>预定义的 ClusterRole system:kubelet-api-admin 授予访问 kubelet 所有 API 的权限：</p>
<pre><code>$ kubectl describe clusterrole system:kubelet-api-admin
Name:         system:kubelet-api-admin
Labels:       kubernetes.io/bootstrapping=rbac-defaults
Annotations:  rbac.authorization.kubernetes.io/autoupdate=true
PolicyRule:
  Resources      Non-Resource URLs  Resource Names  Verbs
  ---------      -----------------  --------------  -----
  nodes          []                 []              [get list watch proxy]
  nodes/log      []                 []              [*]
  nodes/metrics  []                 []              [*]
  nodes/proxy    []                 []              [*]
  nodes/spec     []                 []              [*]
  nodes/stats    []                 []              [*]
</code></pre>
<h2 id="kublet-api-认证和授权"><a href="#kublet-api-认证和授权" class="headerlink" title="kublet api 认证和授权"></a>kublet api 认证和授权</h2><p>kublet 配置了如下认证参数：</p>
<ul>
<li>authentication.anonymous.enabled：设置为 false，不允许匿名访问 10250 端口；</li>
<li>authentication.x509.clientCAFile：指定签名客户端证书的 CA 证书，开启 HTTPs 证书认证；</li>
<li>authentication.webhook.enabled=true：开启 HTTPs bearer token 认证；</li>
</ul>
<p>同时配置了如下授权参数：</p>
<ul>
<li>authroization.mode=Webhook：开启 RBAC 授权；</li>
</ul>
<p>kubelet 收到请求后，使用 clientCAFile 对证书签名进行认证，或者查询 bearer token 是否有效。如果两者都没通过，则拒绝请求，提示 Unauthorized：</p>
<pre><code>$ curl -s --cacert /etc/kubernetes/cert/ca.pem https://192.168.86.156:10250/metrics
Unauthorized

$ curl -s --cacert /etc/kubernetes/cert/ca.pem -H &quot;Authorization: Bearer 123456&quot; https://172.27.129.111:10250/metrics
Unauthorized
</code></pre>
<p>通过认证后，kubelet 使用 SubjectAccessReview API 向 kube-apiserver 发送请求，查询证书或 token 对应的 user、group 是否有操作资源的权限(RBAC)；</p>
<p>证书认证和授权：</p>
<pre><code>$ # 权限不足的证书；
$ curl -s --cacert /etc/kubernetes/cert/ca.pem --cert /etc/kubernetes/cert/kube-controller-manager.pem --key /etc/kubernetes/cert/kube-controller-manager-key.pem https://172.27.129.111:10250/metrics
Forbidden (user=system:kube-controller-manager, verb=get, resource=nodes, subresource=metrics)

$ # 使用部署 kubectl 命令行工具时创建的、具有最高权限的 admin 证书；
$ curl -s --cacert /etc/kubernetes/cert/ca.pem --cert ./admin.pem --key ./admin-key.pem https://192.168.86.156:10250/metrics|head
# HELP apiserver_client_certificate_expiration_seconds Distribution of the remaining lifetime on the certificate used to authenticate a request.
# TYPE apiserver_client_certificate_expiration_seconds histogram
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;0&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;21600&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;43200&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;86400&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;172800&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;345600&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;604800&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;2.592e+06&quot;&#125; 0
</code></pre>
<ul>
<li><code>--cacert</code>、<code>--cert</code>、<code>--key</code> 的参数值必须是文件路径，如上面的 <code>./admin.pem</code> 不能省略 <code>./</code>，否则返回 <code>401 Unauthorized</code>；</li>
</ul>
<p>bear token 认证和授权：</p>
<p>创建一个 ServiceAccount，将它和 ClusterRole system:kubelet-api-admin 绑定，从而具有调用 kubelet API 的权限：</p>
<pre><code>kubectl create sa kubelet-api-test
kubectl create clusterrolebinding kubelet-api-test --clusterrole=system:kubelet-api-admin --serviceaccount=default:kubelet-api-test
SECRET=$(kubectl get secrets | grep kubelet-api-test | awk &#39;&#123;print $1&#125;&#39;)
TOKEN=$(kubectl describe secret $&#123;SECRET&#125; | grep -E &#39;^token&#39; | awk &#39;&#123;print $2&#125;&#39;)
echo $&#123;TOKEN&#125;

$ curl -s --cacert /etc/kubernetes/cert/ca.pem -H &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; https://172.27.129.111:10250/metrics|head
# HELP apiserver_client_certificate_expiration_seconds Distribution of the remaining lifetime on the certificate used to authenticate a request.
# TYPE apiserver_client_certificate_expiration_seconds histogram
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;0&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;21600&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;43200&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;86400&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;172800&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;345600&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;604800&quot;&#125; 0
apiserver_client_certificate_expiration_seconds_bucket&#123;le=&quot;2.592e+06&quot;&#125; 0
</code></pre>
<h3 id="cadvisor-和-metrics"><a href="#cadvisor-和-metrics" class="headerlink" title="cadvisor 和 metrics"></a>cadvisor 和 metrics</h3><p>cadvisor 统计所在节点各容器的资源(CPU、内存、磁盘、网卡)使用情况，分别在自己的 http web 页面(4194 端口)和 10250 以 promehteus metrics 的形式输出。</p>
<p>浏览器访问 <a href="http://172.27.129.105:4194/containers/">http://172.27.129.105:4194/containers/</a> 可以查看到 cadvisor 的监控页面：</p>
<p><img src="/jadepeng/images/cadvisor-home.png" alt="cadvisor-home"></p>
<p>浏览器访问 <a href="https://172.27.129.80:10250/metrics">https://172.27.129.80:10250/metrics</a> 和 <a href="https://172.27.129.80:10250/metrics/cadvisor">https://172.27.129.80:10250/metrics/cadvisor</a> 分别返回 kublet 和 cadvisor 的 metrics。</p>
<p><img src="/jadepeng/images/cadvisor-metrics.png" alt="cadvisor-metrics"></p>
<p>注意：</p>
<ul>
<li>kublet.config.json 设置 authentication.anonymous.enabled 为 false，不允许匿名证书访问 10250 的 https 服务；</li>
<li>参考<a href="A.%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEkube-apiserver%E5%AE%89%E5%85%A8%E7%AB%AF%E5%8F%A3.md">A.浏览器访问kube-apiserver安全端口.md</a>，创建和导入相关证书，然后访问上面的 10250 端口；</li>
</ul>
<h2 id="获取-kublet-的配置"><a href="#获取-kublet-的配置" class="headerlink" title="获取 kublet 的配置"></a>获取 kublet 的配置</h2><p>从 kube-apiserver 获取各 node 的配置：</p>
<p>curl -sSL –cacert /etc/kubernetes/cert/ca.pem –cert ./admin.pem –key ./admin-key.pem <a href="https://192.168.86.214:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy">https://192.168.86.214:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</a></p>
<pre><code>$ source /opt/k8s/bin/environment.sh
$ # 使用部署 kubectl 命令行工具时创建的、具有最高权限的 admin 证书；
$ curl -sSL --cacert /etc/kubernetes/cert/ca.pem --cert ./admin.pem --key ./admin-key.pem $&#123;KUBE_APISERVER&#125;/api/v1/nodes/docker86-155/proxy/configz | jq \
  &#39;.kubeletconfig|.kind=&quot;KubeletConfiguration&quot;|.apiVersion=&quot;kubelet.config.k8s.io/v1beta1&quot;&#39;
&#123;
  &quot;syncFrequency&quot;: &quot;1m0s&quot;,
  &quot;fileCheckFrequency&quot;: &quot;20s&quot;,
  &quot;httpCheckFrequency&quot;: &quot;20s&quot;,
  &quot;address&quot;: &quot;172.27.129.80&quot;,
  &quot;port&quot;: 10250,
  &quot;readOnlyPort&quot;: 10255,
  &quot;authentication&quot;: &#123;
    &quot;x509&quot;: &#123;&#125;,
    &quot;webhook&quot;: &#123;
      &quot;enabled&quot;: false,
      &quot;cacheTTL&quot;: &quot;2m0s&quot;
    &#125;,
    &quot;anonymous&quot;: &#123;
      &quot;enabled&quot;: true
    &#125;
  &#125;,
  &quot;authorization&quot;: &#123;
    &quot;mode&quot;: &quot;AlwaysAllow&quot;,
    &quot;webhook&quot;: &#123;
      &quot;cacheAuthorizedTTL&quot;: &quot;5m0s&quot;,
      &quot;cacheUnauthorizedTTL&quot;: &quot;30s&quot;
    &#125;
  &#125;,
  &quot;registryPullQPS&quot;: 5,
  &quot;registryBurst&quot;: 10,
  &quot;eventRecordQPS&quot;: 5,
  &quot;eventBurst&quot;: 10,
  &quot;enableDebuggingHandlers&quot;: true,
  &quot;healthzPort&quot;: 10248,
  &quot;healthzBindAddress&quot;: &quot;127.0.0.1&quot;,
  &quot;oomScoreAdj&quot;: -999,
  &quot;clusterDomain&quot;: &quot;cluster.local.&quot;,
  &quot;clusterDNS&quot;: [
    &quot;10.254.0.2&quot;
  ],
  &quot;streamingConnectionIdleTimeout&quot;: &quot;4h0m0s&quot;,
  &quot;nodeStatusUpdateFrequency&quot;: &quot;10s&quot;,
  &quot;imageMinimumGCAge&quot;: &quot;2m0s&quot;,
  &quot;imageGCHighThresholdPercent&quot;: 85,
  &quot;imageGCLowThresholdPercent&quot;: 80,
  &quot;volumeStatsAggPeriod&quot;: &quot;1m0s&quot;,
  &quot;cgroupsPerQOS&quot;: true,
  &quot;cgroupDriver&quot;: &quot;cgroupfs&quot;,
  &quot;cpuManagerPolicy&quot;: &quot;none&quot;,
  &quot;cpuManagerReconcilePeriod&quot;: &quot;10s&quot;,
  &quot;runtimeRequestTimeout&quot;: &quot;2m0s&quot;,
  &quot;hairpinMode&quot;: &quot;promiscuous-bridge&quot;,
  &quot;maxPods&quot;: 110,
  &quot;podPidsLimit&quot;: -1,
  &quot;resolvConf&quot;: &quot;/etc/resolv.conf&quot;,
  &quot;cpuCFSQuota&quot;: true,
  &quot;maxOpenFiles&quot;: 1000000,
  &quot;contentType&quot;: &quot;application/vnd.kubernetes.protobuf&quot;,
  &quot;kubeAPIQPS&quot;: 5,
  &quot;kubeAPIBurst&quot;: 10,
  &quot;serializeImagePulls&quot;: false,
  &quot;evictionHard&quot;: &#123;
    &quot;imagefs.available&quot;: &quot;15%&quot;,
    &quot;memory.available&quot;: &quot;100Mi&quot;,
    &quot;nodefs.available&quot;: &quot;10%&quot;,
    &quot;nodefs.inodesFree&quot;: &quot;5%&quot;
  &#125;,
  &quot;evictionPressureTransitionPeriod&quot;: &quot;5m0s&quot;,
  &quot;enableControllerAttachDetach&quot;: true,
  &quot;makeIPTablesUtilChains&quot;: true,
  &quot;iptablesMasqueradeBit&quot;: 14,
  &quot;iptablesDropBit&quot;: 15,
  &quot;featureGates&quot;: &#123;
    &quot;RotateKubeletClientCertificate&quot;: true,
    &quot;RotateKubeletServerCertificate&quot;: true
  &#125;,
  &quot;failSwapOn&quot;: true,
  &quot;containerLogMaxSize&quot;: &quot;10Mi&quot;,
  &quot;containerLogMaxFiles&quot;: 5,
  &quot;enforceNodeAllocatable&quot;: [
    &quot;pods&quot;
  ],
  &quot;kind&quot;: &quot;KubeletConfiguration&quot;,
  &quot;apiVersion&quot;: &quot;kubelet.config.k8s.io/v1beta1&quot;
&#125;
</code></pre>
<p>或者参考代码中的注释：<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/apis/kubeletconfig/v1beta1/types.go">https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/apis/kubeletconfig/v1beta1/types.go</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>kubelet 认证和授权：<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/">https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/</a></li>
</ol>
<p>source /opt/k8s/bin/environment.sh<br> for node_ip in ${NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh root@${node_ip} “systemctl daemon-reload &amp;&amp; systemctl enable kubelet &amp;&amp; systemctl restart kubelet”<br> done</p>
<p>source /opt/k8s/bin/environment.sh</p>
<p>for node_ip in ${ETCD_NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> ssh root@${node_ip} “mkdir -p /var/lib/kube-proxy”<br> ssh root@${node_ip} “mkdir -p /var/log/kubernetes &amp;&amp; chown -R k8s /var/log/kubernetes”<br> ssh root@${node_ip} “systemctl daemon-reload &amp;&amp; systemctl enable kube-proxy &amp;&amp; systemctl restart kube-proxy”<br> done</p>
<p>source /opt/k8s/bin/environment.sh</p>
<p>for node_ip in ${NODE_IPS[@]}<br> do<br> echo “&gt;&gt;&gt; ${node_ip}”<br> scp /usr/local/bin/pull-google-container root@${node_ip}:/usr/local/bin/<br> ssh root@${node_ip} “/usr/local/bin/pull-google-container k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.0”<br> done</p>
<p>192.168.86.18 192.168.86.21 192.168.86.91 192.168.86.9</p>
<p>cat &lt;&lt;EOF | kubectl apply -f -<br> kind: ClusterRoleBinding<br> apiVersion: rbac.authorization.k8s.io/v1beta1<br> metadata:<br> name: heapster-kubelet-api<br> roleRef:<br> apiGroup: rbac.authorization.k8s.io<br> kind: ClusterRole<br> name: system:kubelet-api-admin<br> subjects:</p>
<ul>
<li>kind: ServiceAccount  </li>
</ul>
<p>name: heapster  </p>
<p>namespace: kube-system  </p>
<p>EOF</p>
<h2 id="07-3-部署-kube-proxy-组件"><a href="#07-3-部署-kube-proxy-组件" class="headerlink" title="07-3.部署 kube-proxy 组件"></a>07-3.部署 kube-proxy 组件</h2><p>kube-proxy 运行在所有 worker 节点上，，它监听 apiserver 中 service 和 Endpoint 的变化情况，创建路由规则来进行服务负载均衡。</p>
<p>本文档讲解部署 kube-proxy 的部署，使用 ipvs 模式。</p>
<h3 id="下载和分发-kube-proxy-二进制文件"><a href="#下载和分发-kube-proxy-二进制文件" class="headerlink" title="下载和分发 kube-proxy 二进制文件"></a>下载和分发 kube-proxy 二进制文件</h3><p>参考 <a href="06-0.%E9%83%A8%E7%BD%B2master%E8%8A%82%E7%82%B9.md">06-0.部署master节点.md</a></p>
<h3 id="安装依赖包-1"><a href="#安装依赖包-1" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><p>各节点需要安装 <code>ipvsadm</code> 和 <code>ipset</code> 命令，加载 <code>ip_vs</code> 内核模块。</p>
<p>参考 <a href="07-0.%E9%83%A8%E7%BD%B2worker%E8%8A%82%E7%82%B9.md">07-0.部署worker节点.md</a></p>
<h3 id="创建-kube-proxy-证书"><a href="#创建-kube-proxy-证书" class="headerlink" title="创建 kube-proxy 证书"></a>创建 kube-proxy 证书</h3><p>创建证书签名请求：</p>
<pre><code>cat &gt; kube-proxy-csr.json &lt;&lt;EOF
&#123;
  &quot;CN&quot;: &quot;system:kube-proxy&quot;,
  &quot;key&quot;: &#123;
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  &#125;,
  &quot;names&quot;: [
    &#123;
      &quot;C&quot;: &quot;CN&quot;,
      &quot;ST&quot;: &quot;BeiJing&quot;,
      &quot;L&quot;: &quot;BeiJing&quot;,
      &quot;O&quot;: &quot;k8s&quot;,
      &quot;OU&quot;: &quot;4Paradigm&quot;
    &#125;
  ]
&#125;
EOF
</code></pre>
<ul>
<li>CN：指定该证书的 User 为 <code>system:kube-proxy</code>；</li>
<li>预定义的 RoleBinding <code>system:node-proxier</code> 将User <code>system:kube-proxy</code> 与 Role <code>system:node-proxier</code> 绑定，该 Role 授予了调用 <code>kube-apiserver</code> Proxy 相关 API 的权限；</li>
<li>该证书只会被 kube-proxy 当做 client 证书使用，所以 hosts 字段为空；</li>
</ul>
<p>生成证书和私钥：</p>
<pre><code>cfssl gencert -ca=/etc/kubernetes/cert/ca.pem \
  -ca-key=/etc/kubernetes/cert/ca-key.pem \
  -config=/etc/kubernetes/cert/ca-config.json \
  -profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy
</code></pre>
<h2 id="创建和分发-kubeconfig-文件-2"><a href="#创建和分发-kubeconfig-文件-2" class="headerlink" title="创建和分发 kubeconfig 文件"></a>创建和分发 kubeconfig 文件</h2><pre><code>source /opt/k8s/bin/environment.sh
kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/cert/ca.pem \
  --embed-certs=true \
  --server=$&#123;KUBE_APISERVER&#125; \
  --kubeconfig=kube-proxy.kubeconfig

kubectl config set-credentials kube-proxy \
  --client-certificate=kube-proxy.pem \
  --client-key=kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-proxy.kubeconfig

kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=kube-proxy.kubeconfig

kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
</code></pre>
<ul>
<li><code>--embed-certs=true</code>：将 ca.pem 和 admin.pem 证书内容嵌入到生成的 kubectl-proxy.kubeconfig 文件中(不加时，写入的是证书文件路径)；</li>
</ul>
<p>分发 kubeconfig 文件：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_name in $&#123;NODE_NAMES[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_name&#125;&quot;
    scp kube-proxy.kubeconfig k8s@$&#123;node_name&#125;:/etc/kubernetes/
  done
</code></pre>
<h2 id="创建-kube-proxy-配置文件"><a href="#创建-kube-proxy-配置文件" class="headerlink" title="创建 kube-proxy 配置文件"></a>创建 kube-proxy 配置文件</h2><p>从 v1.10 开始，kube-proxy <strong>部分参数</strong>可以配置文件中配置。可以使用 <code>--write-config-to</code> 选项生成该配置文件，或者参考 kubeproxyconfig 的类型定义源文件 ：<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/apis/kubeproxyconfig/types.go">https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/apis/kubeproxyconfig/types.go</a></p>
<p>创建 kube-proxy config 文件模板：</p>
<pre><code>cat &gt;kube-proxy.config.yaml.template &lt;&lt;EOF
apiVersion: kubeproxy.config.k8s.io/v1alpha1
bindAddress: ##NODE_IP##
clientConnection:
  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig
clusterCIDR: $&#123;CLUSTER_CIDR&#125;
healthzBindAddress: ##NODE_IP##:10256
hostnameOverride: ##NODE_NAME##
kind: KubeProxyConfiguration
metricsBindAddress: ##NODE_IP##:10249
mode: &quot;ipvs&quot;
EOF
</code></pre>
<ul>
<li><code>bindAddress</code>: 监听地址；</li>
<li><code>clientConnection.kubeconfig</code>: 连接 apiserver 的 kubeconfig 文件；</li>
<li><code>clusterCIDR</code>: kube-proxy 根据 <code>--cluster-cidr</code> 判断集群内部和外部流量，指定 <code>--cluster-cidr</code> 或 <code>--masquerade-all</code> 选项后 kube-proxy 才会对访问 Service IP 的请求做 SNAT；</li>
<li><code>hostnameOverride</code>: 参数值必须与 kubelet 的值一致，否则 kube-proxy 启动后会找不到该 Node，从而不会创建任何 ipvs 规则；</li>
<li><code>mode</code>: 使用 ipvs 模式；</li>
</ul>
<p>为各节点创建和分发 kube-proxy 配置文件：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for (( i=0; i &lt; 7; i++ ))
  do 
    echo &quot;&gt;&gt;&gt; $&#123;NODE_NAMES[i]&#125;&quot;
    sed -e &quot;s/##NODE_NAME##/$&#123;NODE_NAMES[i]&#125;/&quot; -e &quot;s/##NODE_IP##/$&#123;NODE_IPS[i]&#125;/&quot; kube-proxy.config.yaml.template &gt; kube-proxy-$&#123;NODE_NAMES[i]&#125;.config.yaml
    scp kube-proxy-$&#123;NODE_NAMES[i]&#125;.config.yaml root@$&#123;NODE_NAMES[i]&#125;:/etc/kubernetes/kube-proxy.config.yaml
  done
</code></pre>
<p>替换后的 kube-proxy.config.yaml 文件：<a href="https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/systemd/kube-proxy.config.yaml">kube-proxy.config.yaml</a></p>
<h2 id="创建和分发-kube-proxy-systemd-unit-文件"><a href="#创建和分发-kube-proxy-systemd-unit-文件" class="headerlink" title="创建和分发 kube-proxy systemd unit 文件"></a>创建和分发 kube-proxy systemd unit 文件</h2><pre><code>source /opt/k8s/bin/environment.sh
cat &gt; kube-proxy.service &lt;&lt;EOF
[Unit]
Description=Kubernetes Kube-Proxy Server
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target

[Service]
WorkingDirectory=/var/lib/kube-proxy
ExecStart=/opt/k8s/bin/kube-proxy \\
  --config=/etc/kubernetes/kube-proxy.config.yaml \\
  --alsologtostderr=true \\
  --logtostderr=false \\
  --log-dir=/var/log/kubernetes \\
  --v=2
Restart=on-failure
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
</code></pre>
<p>替换后的 unit 文件：<a href="https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/systemd/kube-proxy.service">kube-proxy.service</a></p>
<p>分发 kube-proxy systemd unit 文件：</p>
<pre><code>source /opt/k8s/bin/environment.sh
for node_name in $&#123;NODE_NAMES[@]&#125;
  do 
    echo &quot;&gt;&gt;&gt; $&#123;node_name&#125;&quot;
    scp kube-proxy.service root@$&#123;node_name&#125;:/etc/systemd/system/
  done
</code></pre>
<h3 id="启动-kube-proxy-服务"><a href="#启动-kube-proxy-服务" class="headerlink" title="启动 kube-proxy 服务"></a>启动 kube-proxy 服务</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /var/lib/kube-proxy&quot;
    ssh root@$&#123;node_ip&#125; &quot;mkdir -p /var/log/kubernetes &amp;&amp; chown -R k8s /var/log/kubernetes&quot;
    ssh root@$&#123;node_ip&#125; &quot;systemctl daemon-reload &amp;&amp; systemctl enable kube-proxy &amp;&amp; systemctl restart kube-proxy&quot;
  done
</code></pre>
<ul>
<li>必须先创建工作和日志目录；</li>
</ul>
<h3 id="检查启动结果-2"><a href="#检查启动结果-2" class="headerlink" title="检查启动结果"></a>检查启动结果</h3><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh k8s@$&#123;node_ip&#125; &quot;systemctl status kube-proxy|grep Active&quot;
  done
</code></pre>
<p>确保状态为 <code>active (running)</code>，否则查看日志，确认原因：</p>
<pre><code>journalctl -u kube-proxy
</code></pre>
<h2 id="查看监听端口和-metrics"><a href="#查看监听端口和-metrics" class="headerlink" title="查看监听端口和 metrics"></a>查看监听端口和 metrics</h2><pre><code>[k8s@kube-node1 ~]$ sudo netstat -lnpt|grep kube-prox
tcp        0      0 172.27.129.105:10249    0.0.0.0:*               LISTEN      16847/kube-proxy
tcp        0      0 172.27.129.105:10256    0.0.0.0:*               LISTEN      16847/kube-proxy
</code></pre>
<ul>
<li>10249：http prometheus metrics port;</li>
<li>10256：http healthz port;</li>
</ul>
<h2 id="查看-ipvs-路由规则"><a href="#查看-ipvs-路由规则" class="headerlink" title="查看 ipvs 路由规则"></a>查看 ipvs 路由规则</h2><pre><code>source /opt/k8s/bin/environment.sh
for node_ip in $&#123;NODE_IPS[@]&#125;
  do
    echo &quot;&gt;&gt;&gt; $&#123;node_ip&#125;&quot;
    ssh root@$&#123;node_ip&#125; &quot;/usr/sbin/ipvsadm -ln&quot;
  done
</code></pre>
<p>预期输出：</p>
<pre><code>&gt;&gt;&gt; 172.27.129.105
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.254.0.1:443 rr persistent 10800
  -&gt; 172.27.129.105:6443          Masq    1      0          0
&gt;&gt;&gt; 172.27.129.111
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.254.0.1:443 rr persistent 10800
  -&gt; 172.27.129.105:6443          Masq    1      0          0
&gt;&gt;&gt; 172.27.129.112
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.254.0.1:443 rr persistent 10800
  -&gt; 172.27.129.105:6443          Masq    1      0          0
</code></pre>
<p>可见将所有到 kubernetes cluster ip 443 端口的请求都转发到 kube-apiserver 的 6443 端口；</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>XNginx  - nginx 集群可视化管理工具</title>
    <url>/jadepeng/2018/09/28/jqpeng-XNginx%20%20-%20nginx%20%E9%9B%86%E7%BE%A4%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/xnginx.html">XNginx  - nginx 集群可视化管理工具</a></p>
<p>之前团队的nginx管理，都是运维同学每次去修改配置文件，然后重启，非常不方便，一直想找一个可以方便管理nginx集群的工具，翻遍web，未寻到可用之物，于是自己设计开发了一个。</p>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><ol>
<li>集群group管理界面</li>
</ol>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/pic/28/1538116402607.png" alt="Xnginx pic1"></p>
<p>可以管理group的节点，配置文件，修改后可以一键重启所有节点，且配置文件出错时会提示错误，不会影响线上服务。</p>
<p>2.集群Node节点管理</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/pic/28/1538116456272.png" alt="集群节点"></p>
<p>3 .集群Node节点日志查看</p>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/pic/28/1538116799984.png" alt="集群日志管理"></p>
<ol>
<li>生成的配置文件预览</li>
</ol>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/pic/28/1538116495120.png" alt="配置文件"></p>
<ol>
<li>vhost管理</li>
</ol>
<p><img src="https://www.github.com/jadepeng/blogpic/raw/master/pic/28/1538116669140.png" alt="Vhost管理"></p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>数据结构：<br> 一个nginxGroup，拥有多个NginxNode，共享同一份配置文件。</p>
<p>分布式架构：Manager节点+agent节点+web管理<br> 每个nginx机器部署一个agent，agent启动后自动注册到manager，通过web可以设置agent所属group，以及管理group的配置文件。</p>
<p>配置文件变更后，manager生成配置文件，分发给存活的agent，检验OK后，控制agent重启nginx。</p>
<h2 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h2><h3 id="分布式管理"><a href="#分布式管理" class="headerlink" title="分布式管理"></a>分布式管理</h3><p>一般分布式可以借助zookeeper等注册中心来实现，作为java项目，其实使用EurekaServer就可以了：</p>
<p>manager加入eureka依赖：</p>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<p>然后在入口程序添加 @EnableEurekaServer</p>
<p>agent 添加注册配置：</p>
<pre><code>eureka:instance:    prefer-ip-address: trueclient:    service-url:        defaultZone: http://admin:admin@ip:3002/eureka/
</code></pre>
<p>manager 节点获取存活的agent，可以通过EurekaServerContextHolder来获取注册的agent，同时可以通过定时任务自动发现新节点。</p>
<pre><code>public class NginxNodeDiscover &#123;

    private static final String AGENT_NAME = &quot;XNGINXAGENT&quot;;

    private PeerAwareInstanceRegistry getRegistry() &#123;
        return getServerContext().getRegistry();
    &#125;

    private EurekaServerContext getServerContext() &#123;
        return EurekaServerContextHolder.getInstance().getServerContext();
    &#125;

    @Autowired
    NginxNodeRepository nginxNodeRepository;

    @Scheduled(fixedRate = 60000)
    public void discoverNginxNode() &#123;
        List&lt;String&gt; nodes = getAliveAgents();
        nodes.stream().forEach(node-&gt;&#123;
            if(!nginxNodeRepository.findByAgent(node).isPresent())&#123;
                NginxNode nginxNode = new NginxNode();
                nginxNode.setAgent(node);
                nginxNode.setName(node);
                nginxNodeRepository.save(nginxNode);
            &#125;
        &#125;);
    &#125;

    public List&lt;String&gt; getAliveAgents() &#123;
        List&lt;String&gt; instances = new ArrayList&lt;&gt;();
        List&lt;Application&gt; sortedApplications = getRegistry().getSortedApplications();
        Optional&lt;Application&gt; targetApp = sortedApplications.stream().filter(a-&gt;a.getName().equals(AGENT_NAME)).findFirst();
        if(targetApp.isPresent())&#123;
            Application app = targetApp.get();
            for (InstanceInfo info : app.getInstances()) &#123;
                instances.add(info.getHomePageUrl());
            &#125;
        &#125;
        return instances;
    &#125;
&#125;
</code></pre>
<h3 id="RPC调用"><a href="#RPC调用" class="headerlink" title="RPC调用"></a>RPC调用</h3><p>manager 需要控制agent，按最简单的方案，agent提供rest服务，从Eureka获取地址后直接调用就可以了，另外可以借助feign来方便调用。</p>
<p>定义接口：</p>
<pre><code>public interface NginxAgentManager &#123;

    @RequestLine(&quot;GET /nginx/start&quot;)
     RuntimeBuilder.RuntimeResult start() ;

    @RequestLine(&quot;GET /nginx/status&quot;)
     RuntimeBuilder.RuntimeResult status() ;

    @RequestLine(&quot;GET /nginx/reload&quot;)
     RuntimeBuilder.RuntimeResult reload() ;

    @RequestLine(&quot;GET /nginx/stop&quot;)
     RuntimeBuilder.RuntimeResult stop();

    @RequestLine(&quot;GET /nginx/testConfiguration&quot;)
     RuntimeBuilder.RuntimeResult testConfiguration();

    @RequestLine(&quot;GET /nginx/kill&quot;)
     RuntimeBuilder.RuntimeResult kill() ;

    @RequestLine(&quot;GET /nginx/restart&quot;)
     RuntimeBuilder.RuntimeResult restart() ;

    @RequestLine(&quot;GET /nginx/info&quot;)
     NginxInfo info();

    @RequestLine(&quot;GET /nginx/os&quot;)
     OperationalSystemInfo os() ;

    @RequestLine(&quot;GET /nginx/accesslogs/&#123;lines&#125;&quot;)
    List&lt;NginxLoggerVM&gt; getAccesslogs(@Param(&quot;lines&quot;) int lines);

    @RequestLine(&quot;GET /nginx/errorlogs/&#123;lines&#125;&quot;)
    List&lt;NginxLoggerVM&gt; getErrorLogs(@Param(&quot;lines&quot;) int lines);

&#125;
</code></pre>
<p>agent 实现功能：</p>
<pre><code>@RestController
@RequestMapping(&quot;/nginx&quot;)
public class NginxResource &#123;

   ...

    @PostMapping(&quot;/update&quot;)
    @Timed
    public String  update(@RequestBody NginxConf conf)&#123;
        if(conf.getSslDirectives()!=null)&#123;
            for(SslDirective sslDirective : conf.getSslDirectives())&#123;
                nginxControl.conf(sslDirective.getCommonName(),sslDirective.getContent());
            &#125;
        &#125;
        return updateConfig(conf.getConf());
    &#125;

    @GetMapping(&quot;/accesslogs/&#123;lines&#125;&quot;)
    @Timed
    public List&lt;NginxLoggerVM&gt; getAccesslogs(@PathVariable Integer lines) &#123;
        return nginxControl.getAccessLogs(lines);
    &#125;


&#125;
</code></pre>
<p>manager 调用;</p>
<p>先生成一个Proxy实例，其中nodeurl是agent节点的url地址</p>
<pre><code>    public NginxAgentManager getAgentManager(String nodeUrl)&#123;
        return Feign.builder()
            .options(new Request.Options(1000, 3500))
            .retryer(new Retryer.Default(5000, 5000, 3))
            .requestInterceptor(new HeaderRequestInterceptor())
            .encoder(new GsonEncoder())
            .decoder(new GsonDecoder())
            .target(NginxAgentManager.class, nodeUrl);
    &#125;
</code></pre>
<p>然后调用就简单了，比如要启动group：</p>
<pre><code>public void start(String groupId)&#123;
        operateGroup(groupId,((conf, node) -&gt; &#123;
            NginxAgentManager manager = getAgentManager(node.getAgent());

            String result = manager.update(conf);
            if(!result.equals(&quot;success&quot;))&#123;
                throw new XNginxException(&quot;node &quot;+ node.getAgent()+&quot; update config file failed!&quot;);
            &#125;

            RuntimeBuilder.RuntimeResult runtimeResult =   manager.start();
            if(!runtimeResult.isSuccess())&#123;
                throw new XNginxException(&quot;node &quot;+ node.getAgent()+&quot; start failed,&quot;+runtimeResult.getOutput());
            &#125;
        &#125;));
    &#125;

    public void operateGroup(String groupId,BiConsumer&lt;NginxConf,NginxNode&gt; action)&#123;

        List&lt;String&gt; alivedNodes = nodeDiscover.getAliveAgents();
        if(alivedNodes.size() == 0)&#123;
            throw new XNginxException(&quot;no alived agent!&quot;);
        &#125;
        List&lt;NginxNode&gt; nginxNodes = nodeRepository.findAllByGroupId(groupId);
        if(nginxNodes.size() ==0)&#123;
            throw new XNginxException(&quot;the group has no nginx Nodes!&quot;);
        &#125;

        NginxConf conf = nginxConfigService.genConfig(groupId);

        for(NginxNode node : nginxNodes)&#123;

            if(!alivedNodes.contains(node.getAgent()))&#123;
                continue;
            &#125;

            action.accept(conf, node);
       &#125;
    &#125;
</code></pre>
<h3 id="Nginx-配置管理"><a href="#Nginx-配置管理" class="headerlink" title="Nginx 配置管理"></a>Nginx 配置管理</h3><p>nginx的核心是各种Directive（指令），最核心的是vhost和Location。</p>
<p>我们先来定义VHOST：</p>
<pre><code>public class VirtualHostDirective implements Directive &#123;
private Integer port = 80;private String aliases;private boolean enableSSL;private SslDirective sslCertificate;private SslDirective sslCertificateKey;private List&lt;LocationDirective&gt; locations;
private String root;private  String index;private String access_log;
&#125;
</code></pre>
<p>其中核心的LocationDirective，设计思路是passAddress存储location的目标地址，可以是url，也可以是upstream，通过type来区分，同时如果有upstream，则通过proxy来设置负载信息。</p>
<pre><code>public class LocationDirective &#123;
public static final String PROXY = &quot;PROXY&quot;;public static final String UWSGI = &quot;UWSGI&quot;;public static final String FASTCGI = &quot;FASTCGI&quot;;public static final String COMMON = &quot;STATIC&quot;;
private String path;
private String type = COMMON;
private ProxyDirective proxy;
private List&lt;String&gt; rewrites;
private String advanced;
private String passAddress;&#125;
</code></pre>
<p>再来看ProxyDirective，通过balance来区分是普通的url还是upstream，如果是upstream，servers存储负载的服务器。</p>
<pre><code>public class ProxyDirective implements Directive &#123;
public static final String BALANCE_UPSTREAM = &quot;upstream&quot;;public static final String BALANCE_URL = &quot;url&quot;;

private String name;
private String strategy;
/** *  Upstream balance type : upsteam,url */private String balance = BALANCE_UPSTREAM;
private List&lt;UpstreamDirectiveServer&gt; servers;&#125;
</code></pre>
<h3 id="历史数据导入"><a href="#历史数据导入" class="headerlink" title="历史数据导入"></a>历史数据导入</h3><p>已经有了配置信息，可以通过解析导入系统，解析就是常规的文本解析，这里不再赘述。</p>
<p>核心思想就是通过匹配大括号，将配置文件分成block，然后通过正则等提取信息,比如下面的代码拆分出server{…}</p>
<pre><code>private List&lt;String&gt; blocks() &#123;
        List&lt;String&gt; blocks = new ArrayList&lt;&gt;();
        List&lt;String&gt; lines = Arrays.asList(fileContent.split(&quot;\n&quot;));

        AtomicInteger atomicInteger = new AtomicInteger(0);
        AtomicInteger currentLine = new AtomicInteger(1);
        Integer indexStart = 0;
        Integer serverStartIndex = 0;
        for (String line : lines) &#123;
            if (line.contains(&quot;&#123;&quot;)) &#123;
                atomicInteger.getAndIncrement();
                if (line.contains(&quot;server&quot;)) &#123;
                    indexStart = currentLine.get() - 1;
                    serverStartIndex = atomicInteger.get() - 1;
                &#125;
            &#125; else if (line.contains(&quot;&#125;&quot;)) &#123;
                atomicInteger.getAndDecrement();
                if (atomicInteger.get() == serverStartIndex) &#123;
                    if (lines.get(indexStart).trim().startsWith(&quot;server&quot;)) &#123;
                        blocks.add(StringUtils.join(lines.subList(indexStart, currentLine.get()), &quot;\n&quot;));
                    &#125;
                &#125;
            &#125;
            currentLine.getAndIncrement();
        &#125;
        return blocks;
    &#125;
</code></pre>
<h3 id="配置文件生成"><a href="#配置文件生成" class="headerlink" title="配置文件生成"></a>配置文件生成</h3><p>配置文件生成，一般是通过模板引擎，这里也不例外，使用了Velocity库。</p>
<pre><code>    public static StringWriter mergeFileTemplate(String pTemplatePath, Map&lt;String, Object&gt; pDto) &#123;
        if (StringUtils.isEmpty(pTemplatePath)) &#123;
            throw new NullPointerException(&quot;????????????&quot;);
        &#125;
        StringWriter writer = new StringWriter();
        Template template;
        try &#123;
            template = ve.getTemplate(pTemplatePath);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(&quot;????????&quot;, e);
        &#125;
        VelocityContext context = VelocityHelper.convertDto2VelocityContext(pDto);
        try &#123;
            template.merge(context, writer);
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(&quot;????????&quot;, e);
        &#125;
        return writer;
    &#125;
</code></pre>
<p>定义模板：</p>
<pre><code>#if($&#123;config.user&#125;)user $&#123;config.user&#125;;#end
#if($&#123;config.workerProcesses&#125;== 0 )
worker_processes auto;
#else
worker_processes  $&#123;config.workerProcesses&#125;;
#end
pid        /opt/xnginx/settings/nginx.pid;

events &#123;
    multi_accept off;
    worker_connections $&#123;config.workerConnections&#125;;
&#125;

...
</code></pre>
<p>生成配置文件;</p>
<pre><code>    public static StringWriter buildNginxConfString(ServerConfig serverConfig, List&lt;VirtualHostDirective&gt; hostDirectiveList, List&lt;ProxyDirective&gt; proxyDirectiveList) &#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;config&quot;,serverConfig);
        map.put(&quot;upstreams&quot;, proxyDirectiveList);
        map.put(&quot;hosts&quot;,hostDirectiveList);
        return VelocityHelper.mergeFileTemplate(NGINX_CONF_VM, map);
    &#125;
</code></pre>
<h3 id="管理web"><a href="#管理web" class="headerlink" title="管理web"></a>管理web</h3><p>管理web基于<a href="https://www.cnblogs.com/xiaoqi/p/angular-ng-alain.html">ng-alain框架</a>，typescript+angular mvvm开发起来，和后端没有本质区别</p>
<p>开发相对简单，这里不赘述。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>目前只实现了基本的管理功能，后续可根据需要再继续补充完善，比如支持业务、负责人等信息管理维护。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>XNginx</tag>
      </tags>
  </entry>
  <entry>
    <title>APM 原理与框架选型</title>
    <url>/jadepeng/2018/08/27/jqpeng-APM%20%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/apm.html">APM 原理与框架选型</a></p>
<p>发些存稿:)</p>
<h2 id="0-APM简介"><a href="#0-APM简介" class="headerlink" title="0. APM简介"></a>0. APM简介</h2><p>随着微服务架构的流行，一次请求往往需要涉及到多个服务，因此服务性能监控和排查就变得更复杂：</p>
<ul>
<li>不同的服务可能由不同的团队开发、甚至可能使用不同的编程语言来实现</li>
<li>服务有可能布在了几千台服务器，横跨多个不同的数据中心</li>
</ul>
<p>因此，就需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题，这就是APM系统，全称是（<strong>A</strong>pplication <strong>P</strong>erformance <strong>M</strong>onitor，当然也有叫 <strong>A</strong>pplication <strong>P</strong>erformance <strong>M</strong>anagement tools）</p>
<p>AMP最早是谷歌公开的论文提到的 <a href="http://bigbully.github.io/Dapper-translation">Google Dapper</a>。Dapper是Google生产环境下的分布式跟踪系统，自从Dapper发展成为一流的监控系统之后，给google的开发者和运维团队帮了大忙，所以谷歌公开论文分享了Dapper。</p>
<h2 id="1-谷歌Dapper介绍"><a href="#1-谷歌Dapper介绍" class="headerlink" title="1. 谷歌Dapper介绍"></a>1. 谷歌Dapper介绍</h2><h3 id="1-1-Dapper的挑战"><a href="#1-1-Dapper的挑战" class="headerlink" title="1.1 Dapper的挑战"></a>1.1 <strong>Dapper的挑战</strong></h3><p>在google的首页页面，提交一个查询请求后，会经历什么：</p>
<ul>
<li>可能对上百台查询服务器发起了一个Web查询，每一个查询都有自己的Index</li>
<li>这个查询可能会被发送到多个的子系统，这些子系统分别用来处理广告、进行拼写检查或是查找一些像图片、视频或新闻这样的特殊结果</li>
<li>根据每个子系统的查询结果进行筛选，得到最终结果，最后汇总到页面上</li>
</ul>
<p>总结一下：</p>
<ul>
<li>一次全局搜索有可能调用上千台服务器，涉及各种服务。</li>
<li>用户对搜索的耗时是很敏感的，而任何一个子系统的低效都导致导致最终的搜索耗时</li>
</ul>
<p>如果一次查询耗时不正常，工程师怎么来排查到底是由哪个服务调用造成的？</p>
<ul>
<li>首先，这个工程师可能无法准确的定位到这次全局搜索是调用了哪些服务，因为新的服务、乃至服务上的某个片段，都有可能在任何时间上过线或修改过，有可能是面向用户功能，也有可能是一些例如针对性能或安全认证方面的功能改进</li>
<li>其次，你不能苛求这个工程师对所有参与这次全局搜索的服务都了如指掌，每一个服务都有可能是由不同的团队开发或维护的</li>
<li>再次，这些暴露出来的服务或服务器有可能同时还被其他客户端使用着，所以这次全局搜索的性能问题甚至有可能是由其他应用造成的</li>
</ul>
<p>从上面可以看出Dapper需要：</p>
<ul>
<li>无所不在的部署，无所不在的重要性不言而喻，因为在使用跟踪系统的进行监控时，即便只有一小部分没被监控到，那么人们对这个系统是不是值得信任都会产生巨大的质疑</li>
<li>持续的监控</li>
</ul>
<h3 id="1-2-Dapper的三个具体设计目标"><a href="#1-2-Dapper的三个具体设计目标" class="headerlink" title="1.2 Dapper的三个具体设计目标"></a>1.2 Dapper的三个具体设计目标</h3><ol>
<li><strong>性能消耗低</strong><br> APM组件服务的影响应该做到足够小。<strong>服务调用埋点本身会带来性能损耗，这就需要调用跟踪的低损耗，实际中还会通过配置采样率的方式，选择一部分请求去分析请求路径</strong>。在一些高度优化过的服务，即使一点点损耗也会很容易察觉到，而且有可能迫使在线服务的部署团队不得不将跟踪系统关停。</li>
<li><strong>应用透明</strong>，也就是<strong>代码的侵入性小</strong><br> <strong>即也作为业务组件，应当尽可能少入侵或者无入侵其他业务系统，对于使用方透明，减少开发人员的负担</strong>。<br> 对于应用的程序员来说，是不需要知道有跟踪系统这回事的。如果一个跟踪系统想生效，就必须需要依赖应用的开发者主动配合，那么这个跟踪系统也太脆弱了，往往由于跟踪系统在应用中植入代码的bug或疏忽导致应用出问题，这样才是无法满足对跟踪系统“无所不在的部署”这个需求。</li>
<li><strong>可扩展性</strong><br> <strong>一个优秀的调用跟踪系统必须支持分布式部署，具备良好的可扩展性。能够支持的组件越多当然越好</strong>。或者提供便捷的插件开发API，对于一些没有监控到的组件，应用开发者也可以自行扩展。</li>
<li><strong>数据的分析</strong><br> <strong>数据的分析要快 ，分析的维度尽可能多</strong>。跟踪系统能提供足够快的信息反馈，就可以对生产环境下的异常状况做出快速反应。<strong>分析的全面，能够避免二次开发</strong>。</li>
</ol>
<h3 id="1-3-Dapper的分布式跟踪原理"><a href="#1-3-Dapper的分布式跟踪原理" class="headerlink" title="1.3 Dapper的分布式跟踪原理"></a>1.3 Dapper的分布式跟踪原理</h3><p>先来看一次请求调用示例：</p>
<ol>
<li>包括：前端（A），两个中间层（B和C），以及两个后端（D和E）</li>
<li>当用户发起一个请求时，首先到达前端A服务，然后分别对B服务和C服务进行RPC调用；</li>
<li>B服务处理完给A做出响应，但是C服务还需要和后端的D服务和E服务交互之后再返还给A服务，最后由A服务来响应用户的请求；</li>
</ol>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535337727679.png" alt="Dapper的分布式跟踪"></p>
<p>Dapper是如何来跟踪记录这次请求呢？</p>
<h4 id="1-3-1-跟踪树和span"><a href="#1-3-1-跟踪树和span" class="headerlink" title="1.3.1  跟踪树和span"></a>1.3.1  <strong>跟踪树和span</strong></h4><p>Span是dapper的<strong>基本工作单元</strong>，一次链路调用（可以是RPC，DB等没有特定的限制）创建一个span，通过一个64位ID标识它；同时附加（Annotation）作为payload负载信息，用于记录性能等数据。</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535338174615.png" alt="5个span在Dapper跟踪树种短暂的关联关系"></p>
<p>上图说明了span在一次大的跟踪过程中是什么样的。<strong>Dapper记录了span名称，以及每个span的ID和父ID，以重建在一次追踪过程中不同span之间的关系</strong>。如果一个span没有父ID被称为root span。<strong>所有span都挂在一个特定的跟踪上，也共用一个跟踪id</strong>。</p>
<p>再来看下<strong>Span的细节</strong>：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535338251754.png" alt="一个单独的span的细节图"></p>
<p><strong>Span数据结构</strong>：</p>
<pre><code>type Span struct &#123;
    TraceID    int64 // 用于标示一次完整的请求id
    Name       string
    ID         int64 // 当前这次调用span_id
    ParentID   int64 // 上层服务的调用span_id  最上层服务parent_id为null
    Annotation []Annotation // 用于标记的时间戳
    Debug      bool
&#125;
</code></pre>
<h4 id="1-3-2-TraceID"><a href="#1-3-2-TraceID" class="headerlink" title="1.3.2 TraceID"></a>1.3.2 TraceID</h4><p>类似于 <strong>树结构的Span集合</strong>，表示一次完整的跟踪，从请求到服务器开始，服务器返回response结束，跟踪每次rpc调用的耗时，存在唯一标识trace_id。比如：你运行的分布式大数据存储一次Trace就由你的一次请求组成。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/4/163c9bee3a9d029a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Trace"></p>
<p>每种颜色的note标注了一个span，一条链路通过TraceId唯一标识，Span标识发起的请求信息。<strong>树节点是整个架构的基本单元，而每一个节点又是对span的引用</strong>。节点之间的连线表示的span和它的父span直接的关系。虽然span在日志文件中只是简单的代表span的开始和结束时间，他们在整个树形结构中却是相对独立的。</p>
<h4 id="1-3-3-Annotation"><a href="#1-3-3-Annotation" class="headerlink" title="1.3.3 Annotation"></a>1.3.3 Annotation</h4><p>Dapper允许应用程序开发人员在Dapper跟踪的过程中添加额外的信息，以监控更高级别的系统行为，或帮助调试问题。这就是Annotation：</p>
<p><strong>Annotation</strong>，用来记录请求特定事件相关信息（例如时间），<strong>一个span中会有多个annotation注解描述</strong>。通常包含四个注解信息：</p>
<blockquote>
<p>(1) <strong>cs</strong>：Client Start，表示客户端发起请求<br> (2) <strong>sr</strong>：Server Receive，表示服务端收到请求<br> (3) <strong>ss</strong>：Server Send，表示服务端完成处理，并将结果发送给客户端<br> (4) <strong>cr</strong>：Client Received，表示客户端获取到服务端返回信息</p>
</blockquote>
<p><strong>Annotation数据结构</strong>：</p>
<pre><code>type Annotation struct &#123;
    Timestamp int64
    Value     string
    Host      Endpoint
    Duration  int32
&#125;
</code></pre>
<h4 id="1-3-4-采样率"><a href="#1-3-4-采样率" class="headerlink" title="1.3.4 采样率"></a>1.3.4 采样率</h4><p>低损耗的是Dapper的一个关键的设计目标，因为如果这个工具价值未被证实但又对性能有影响的话，你可以理解服务运营人员为什么不愿意部署它。</p>
<p>另外，某些类型的Web服务对植入带来的性能损耗确实非常敏感。</p>
<p>因此，除了把Dapper的收集工作对基本组件的性能损耗限制的尽可能小之外，Dapper支持设置采样率来减少性能损耗，同时支持<strong>可变采样</strong>。</p>
<h2 id="2-APM组件选型"><a href="#2-APM组件选型" class="headerlink" title="2. APM组件选型"></a>2. APM组件选型</h2><p>市面上的全链路监控理论模型大多都是借鉴Google Dapper论文，重点关注以下三种APM组件：</p>
<blockquote>
<ol>
<li>**<a href="https://link.juejin.im/?target=http://zipkin.io/">Zipkin</a>**：由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微服务架构中的延迟问题，包括：数据的收集、存储、查找和展现。</li>
<li>**<a href="https://link.juejin.im/?target=https://github.com/naver/pinpoint">Pinpoint</a>**：一款对Java编写的大规模分布式系统的APM工具，由韩国人开源的分布式跟踪组件。</li>
<li>**<a href="https://link.juejin.im/?target=http://skywalking.org/">Skywalking</a>**：国产的优秀APM组件，是一个对JAVA分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统。</li>
</ol>
</blockquote>
<h3 id="2-1-对比项"><a href="#2-1-对比项" class="headerlink" title="2.1 对比项"></a>2.1 对比项</h3><p>主要对比项：</p>
<ol>
<li><strong>探针的性能</strong><br> 主要是agent对服务的吞吐量、CPU和内存的影响。微服务的规模和动态性使得数据收集的成本大幅度提高。</li>
<li><strong>collector的可扩展性</strong><br> 能够水平扩展以便支持大规模服务器集群。</li>
<li><strong>全面的调用链路数据分析</strong><br> 提供代码级别的可见性以便轻松定位失败点和瓶颈。</li>
<li><strong>对于开发透明，容易开关</strong><br> 添加新功能而无需修改代码，容易启用或者禁用。</li>
<li><strong>完整的调用链应用拓扑</strong><br> 自动检测应用拓扑，帮助你搞清楚应用的架构</li>
</ol>
<h3 id="2-2-探针的性能"><a href="#2-2-探针的性能" class="headerlink" title="2.2 探针的性能"></a>2.2 探针的性能</h3><p>比较关注探针的性能，毕竟APM定位还是工具，如果启用了链路监控组建后，直接导致吞吐量降低过半，那也是不能接受的。对skywalking、zipkin、pinpoint进行了压测，并与基线（未使用探针）的情况进行了对比。</p>
<p>选用了一个常见的基于Spring的应用程序，他包含Spring Boot, Spring MVC，redis客户端，mysql。 监控这个应用程序，每个trace，探针会抓取5个span(1 Tomcat, 1 SpringMVC, 2 Jedis, 1 Mysql)。这边基本和 <a href="https://link.juejin.im/?target=https://link.juejin.im?target=https%253A%252F%252Fskywalkingtest.github.io%252FAgent-Benchmarks%252FREADME_zh.html">skywalkingtest</a> 的测试应用差不多。</p>
<p>模拟了三种并发用户：500，750，1000。使用jmeter测试，每个线程发送30个请求，设置思考时间为10ms。使用的采样率为1，即100%，这边与生产可能有差别。pinpoint默认的采样率为20，即50%，通过设置agent的配置文件改为100%。zipkin默认也是1。组合起来，一共有12种。下面看下汇总表：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339573733.png" alt="探针性能"></p>
<p>从上表可以看出，在三种链路监控组件中，<strong>skywalking的探针对吞吐量的影响最小，zipkin的吞吐量居中。pinpoint的探针对吞吐量的影响较为明显</strong>，在500并发用户时，测试服务的吞吐量从1385降低到774，影响很大。然后再看下CPU和memory的影响，在内部服务器进行的压测，对CPU和memory的影响都差不多在10%之内。</p>
<h3 id="2-3-collector的可扩展性"><a href="#2-3-collector的可扩展性" class="headerlink" title="2.3 collector的可扩展性"></a>2.3 collector的可扩展性</h3><p>collector的可扩展性，使得能够水平扩展以便支持大规模服务器集群。</p>
<ol>
<li><strong>zipkin</strong><br> 开发zipkin-Server（其实就是提供的开箱即用包），zipkin-agent与zipkin-Server通过http或者mq进行通信，<strong>http通信会对正常的访问造成影响，所以还是推荐基于mq异步方式通信</strong>，zipkin-Server通过订阅具体的topic进行消费。这个当然是可以扩展的，<strong>多个zipkin-Server实例进行异步消费mq中的监控信息</strong>。</li>
<li><strong>skywalking</strong><br> skywalking的collector支持两种部署方式：<strong>单机和集群模式。collector与agent之间的通信使用了gRPC</strong>。</li>
<li><strong>pinpoint</strong><br> 同样，pinpoint也是支持集群和单机部署的。<strong>pinpoint agent通过thrift通信框架，发送链路信息到collector</strong>。</li>
</ol>
<h3 id="2-4-全面的调用链路数据分析"><a href="#2-4-全面的调用链路数据分析" class="headerlink" title="2.4 全面的调用链路数据分析"></a>2.4 全面的调用链路数据分析</h3><p>全面的调用链路数据分析，提供代码级别的可见性以便轻松定位失败点和瓶颈。</p>
<p><strong>zipkin</strong></p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339676013.png" alt="zipkin"><br><strong>zipkin的链路监控粒度相对没有那么细</strong>，从上图可以看到调用链中具体到接口级别，再进一步的调用信息并未涉及。</p>
<p><strong>skywalking</strong></p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339690665.png" alt="skywalking"></p>
<pre><code>**skywalking 还支持20+的中间件、框架、类库**，比如：主流的dubbo、Okhttp，还有DB和消息中间件。上图skywalking链路调用分析截取的比较简单，网关调用user服务，**由于支持众多的中间件，所以skywalking链路调用分析比zipkin完备些**。
</code></pre>
<p><strong>pinpoint</strong></p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339702378.png" alt="pinpoint"><br> pinpoint应该是这三种APM组件中，<strong>数据分析最为完备的组件</strong>。提供代码级别的可见性以便轻松定位失败点和瓶颈，上图可以看到对于执行的sql语句，都进行了记录。还可以配置报警规则等，设置每个应用对应的负责人，根据配置的规则报警，支持的中间件和框架也比较完备。</p>
<h3 id="2-5-对于开发透明，容易开关"><a href="#2-5-对于开发透明，容易开关" class="headerlink" title="2.5  对于开发透明，容易开关"></a>2.5  对于开发透明，容易开关</h3><p>对于开发透明，容易开关，添加新功能而无需修改代码，容易启用或者禁用。我们期望功能可以不修改代码就工作并希望得到代码级别的可见性。</p>
<p>对于这一点，<strong>Zipkin 使用修改过的类库和它自己的容器(Finagle)来提供分布式事务跟踪的功能</strong>。但是，它要求在需要时修改代码。<strong>skywalking和pinpoint都是基于字节码增强的方式，开发人员不需要修改代码，并且可以收集到更多精确的数据因为有字节码中的更多信息</strong>。</p>
<h3 id="2-6-完整的调用链应用拓扑"><a href="#2-6-完整的调用链应用拓扑" class="headerlink" title="2.6  完整的调用链应用拓扑"></a>2.6  完整的调用链应用拓扑</h3><p>自动检测应用拓扑，帮助你搞清楚应用的架构。</p>
<p>zipkin链路拓扑：<br><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339925728.png" alt="zipkin链路拓扑"></p>
<p>skywalking链路拓扑：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339959895.png" alt="skywalking链路拓扑"></p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/27/1535339973274.png" alt="pinpoint"></p>
<p>三个组件都能实现完整的调用链应用拓扑。相对来说：</p>
<ul>
<li>pinpoint界面显示的更加丰富，具体到调用的DB名</li>
<li>zipkin的拓扑局限于服务于服务之间</li>
</ul>
<h3 id="2-7-社区支持"><a href="#2-7-社区支持" class="headerlink" title="2.7  社区支持"></a>2.7  社区支持</h3><p>Zipkin 由 Twitter 开发，可以算得上是明星团队，而 pinpoint的Naver 的团队只是一个默默无闻的小团队，skywalking是国内的明星项目，目前属于apache孵化项目，社区活跃。</p>
<h3 id="2-8-总结"><a href="#2-8-总结" class="headerlink" title="2.8  总结"></a>2.8  总结</h3><table>
<thead>
<tr>
<th></th>
<th>zipkin</th>
<th>pinpoint</th>
<th>skywalking</th>
</tr>
</thead>
<tbody><tr>
<td>探针性能</td>
<td>中</td>
<td>低</td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>collector扩展性</td>
<td><strong>高</strong></td>
<td>中</td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>调用链路数据分析</td>
<td>低</td>
<td><strong>高</strong></td>
<td>中</td>
</tr>
<tr>
<td>对开发透明性</td>
<td>中</td>
<td><strong>高</strong></td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>调用链应用拓扑</td>
<td>中</td>
<td><strong>高</strong></td>
<td>中</td>
</tr>
<tr>
<td>社区支持</td>
<td><strong>高</strong></td>
<td>中</td>
<td><strong>高</strong></td>
</tr>
</tbody></table>
<p>相对来说，skywalking更占优，因此团队采用skywalking作为APM工具。</p>
<h2 id="3-参考内容"><a href="#3-参考内容" class="headerlink" title="3. 参考内容"></a>3. 参考内容</h2><p>本文主要内容参考下文：<br><a href="https://juejin.im/post/5a7a9e0af265da4e914b46f1">https://juejin.im/post/5a7a9e0af265da4e914b46f1</a><br><a href="http://bigbully.github.io/Dapper-translation/">http://bigbully.github.io/Dapper-translation/</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>apm</tag>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>统一配置中心选型对比</title>
    <url>/jadepeng/2018/08/24/jqpeng-%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/configserver-compair.html">统一配置中心选型对比</a></p>
<p>整理笔记时发现之前整理的一些东西，分享给大家。</p>
<h2 id="为什么需要集中配置"><a href="#为什么需要集中配置" class="headerlink" title="为什么需要集中配置"></a>为什么需要集中配置</h2><p><strong>程序的发展，需要引入集中配置</strong>：</p>
<ul>
<li>随着程序功能的日益复杂，程序的配置日益增多：各种功能的开关、参数的配置、服务器的地址……</li>
<li>并且对配置的期望也越来越高，配置修改后实时生效，灰度发布，分环境、分集群管理配置，完善的权限、审核机制……</li>
<li>并且随着采用分布式的开发模式，项目之间的相互引用随着服务的不断增多，相互之间的调用复杂度成指数升高，每次投产或者上线新的项目时苦不堪言，因此需要引用配置中心治理。</li>
</ul>
<p><strong>已有zookeeper、etcd还需要引入吗</strong>？</p>
<ul>
<li>之前的音乐服务项目，通过etcd实现了服务的注册与发现，且一些业务配置也存储到etcd中，通过实践我们收获了集中配置带来的优势</li>
<li>但是etcd并没有方便的UI管理工具，且缺乏权限、审核等机制</li>
<li>最重要的是，etcd和zookeeper通常定义为<strong>服务注册中心</strong>，统一配置中心的事情交给专业的工具去解决。</li>
</ul>
<h2 id="有哪些开源配置中心"><a href="#有哪些开源配置中心" class="headerlink" title="有哪些开源配置中心"></a>有哪些开源配置中心</h2><ol>
<li>spring-cloud/spring-cloud-config<br><a href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a><br>spring出品，可以和spring cloud无缝配合</li>
<li>淘宝 diamond<br><a href="https://github.com/takeseem/diamond">https://github.com/takeseem/diamond</a><br>已经不维护</li>
<li>disconf<br><a href="https://github.com/knightliao/disconf">https://github.com/knightliao/disconf</a><br>java开发，蚂蚁金服技术专家发起，业界使用广泛</li>
<li>ctrip apollo<br><a href="https://github.com/ctripcorp/apollo/">https://github.com/ctripcorp/apollo/</a><br>Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，具备规范的权限、流程治理等特性。</li>
</ol>
<h2 id="配置中心对别"><a href="#配置中心对别" class="headerlink" title="配置中心对别"></a>配置中心对别</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><p>我们先从功能层面来对别</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>静态配置管理</td>
<td>高</td>
<td>基于file</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>动态配置管理</td>
<td>高</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>统一管理</td>
<td>高</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>多环境</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>本地配置缓存</td>
<td>高</td>
<td>无</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置锁</td>
<td>中</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不允许动态及远程更新</td>
</tr>
<tr>
<td>配置校验</td>
<td>中</td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>如：ip地址校验，配置</td>
</tr>
<tr>
<td>配置生效时间</td>
<td></td>
<td>重启生效，或手动refresh生效</td>
<td>实时</td>
<td>实时</td>
<td>需要结合热加载管理， springcloudconfig需要 git webhook+rabbitmq 实时生效</td>
</tr>
<tr>
<td>配置更新推送</td>
<td>高</td>
<td>需要手工触发</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置定时拉取</td>
<td>高</td>
<td>无</td>
<td>支持</td>
<td>配置更新目前依赖事件驱动， client重启或者server端推送操作</td>
<td></td>
</tr>
<tr>
<td>用户权限管理</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>支持</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>授权、审核、审计</td>
<td>中</td>
<td>无，需要github</td>
<td>支持</td>
<td>无</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>配置版本管理</td>
<td>高</td>
<td>Git做版本管理</td>
<td>界面上直接提供发布历史和回滚按钮</td>
<td>操作记录有落数据库，但无查询接口</td>
<td></td>
</tr>
<tr>
<td>配置合规检测</td>
<td>高</td>
<td>不支持</td>
<td>支持（但还需完善）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>实例配置监控</td>
<td>高</td>
<td>需要结合springadmin</td>
<td>支持</td>
<td>支持，可以查看每个配置在哪些机器上加载</td>
<td></td>
</tr>
<tr>
<td>灰度发布</td>
<td>中</td>
<td>不支持</td>
<td>支持</td>
<td>不支持部分更新</td>
<td>现阶段可以人工处理</td>
</tr>
<tr>
<td>告警通知</td>
<td>中</td>
<td>不支持</td>
<td>支持，邮件方式告警</td>
<td>支持，邮件方式告警</td>
<td></td>
</tr>
<tr>
<td>依赖关系</td>
<td>高</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
<td>配置与系统版本的依赖系统运行时的依赖关系</td>
</tr>
</tbody></table>
<h3 id="技术路线兼容性"><a href="#技术路线兼容性" class="headerlink" title="技术路线兼容性"></a>技术路线兼容性</h3><p>引入配置中心，需要考虑和现有项目的兼容性，以及是否引入额外的第三方组件。我们的java项目以SpringBoot为主，需要重点关注springboot支持性。</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SpringBoot支持</td>
<td>高</td>
<td>原生支持</td>
<td>支持</td>
<td>与spring boot无相关</td>
<td></td>
</tr>
<tr>
<td>SpringCloud支持</td>
<td>高</td>
<td>原生支持</td>
<td>支持</td>
<td>与spring cloud无相关</td>
<td></td>
</tr>
<tr>
<td>客户端支持</td>
<td>低</td>
<td>Java</td>
<td>Java、.Net</td>
<td>java</td>
<td></td>
</tr>
<tr>
<td>业务系统侵入性</td>
<td>高</td>
<td>侵入性弱</td>
<td>侵入性弱</td>
<td>侵入性弱，支持注解及xml方式</td>
<td></td>
</tr>
<tr>
<td>依赖组件</td>
<td>高</td>
<td>Eureka</td>
<td>Eureka</td>
<td>zookeeper</td>
<td></td>
</tr>
</tbody></table>
<h3 id="可用性与易用性"><a href="#可用性与易用性" class="headerlink" title="可用性与易用性"></a>可用性与易用性</h3><p>引入配置中心后，所有的应用都需要依赖配置中心，因此可用性需要重点关注，另外管理的易用性也需要关注。</p>
<table>
<thead>
<tr>
<th><strong>功能点</strong></th>
<th><strong>优先级</strong></th>
<th><strong>spring-cloud-config</strong></th>
<th><strong>ctrip apollo</strong></th>
<th><strong>disconf</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>单点故障（SPOF）</td>
<td>高</td>
<td>支持HA部署</td>
<td>支持HA部署</td>
<td>支持HA部署，高可用由zookeeper保证</td>
<td></td>
</tr>
<tr>
<td>多数据中心部署</td>
<td>高</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>配置获取性能</td>
<td>高</td>
<td>unkown</td>
<td>unkown（官方说比spring快）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>配置界面</td>
<td>中</td>
<td>无，需要通过git操作</td>
<td>统一界面（ng编写）</td>
<td>统一界面</td>
<td></td>
</tr>
</tbody></table>
<h2 id="最终选择"><a href="#最终选择" class="headerlink" title="最终选择"></a>最终选择</h2><p>综上，ctrip applo是较好的选择方案，最终选择applo。</p>
<ul>
<li>支持不同环境（开发、测试、生产）、不同集群</li>
<li>完善的管理系统，权限管理、发布审核、操作审计</li>
<li>SpringBoot集成友好 ，较小的迁移成本</li>
<li>配置修改实时生效（热发布）</li>
<li>版本发布管理</li>
</ul>
<h3 id="部署情况"><a href="#部署情况" class="headerlink" title="部署情况"></a>部署情况</h3><ul>
<li>管理Web：<a href="http://config/">http://config</a>.***.com/</li>
<li>三个环境MetaServer：<ul>
<li>Dev： config.devmeta.***.com</li>
<li>Test： config.testmeta.***.com</li>
<li>PRO: config.prometa.***.com</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot国际化</title>
    <url>/jadepeng/2018/08/19/jqpeng-Spring%20boot%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/spring-boot-i18n.html">Spring boot国际化</a></p>
<p>国际化主要是引入了MessageSource，我们简单看下如何使用，以及其原理。</p>
<h2 id="1-1-设置资源文件"><a href="#1-1-设置资源文件" class="headerlink" title="1.1 设置资源文件"></a>1.1 设置资源文件</h2><p>在 properties新建i18n目录</p>
<p>新建message文件：</p>
<p>messages.properties</p>
<pre><code>error.title=Your request cannot be processed
</code></pre>
<p>messages_zh_CN.properties</p>
<pre><code>error.title=您的请求无法处理
</code></pre>
<h2 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h2><p>修改properties文件的目录：在application.yml或者application.properties中配置 spring.message.basename</p>
<pre><code>spring:
    application:
        name: test-worklog
    messages:
        basename: i18n/messages
        encoding: UTF-8
</code></pre>
<h2 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h2><p>引用自动注解的MessageSource,调用<code>messageSource.getMessage</code>即可，注意，需要通过<code> LocaleContextHolder.getLocale()</code>获取当前的地区。</p>
<pre><code>@Autowired
private MessageSource messageSource;
/**
 * 国际化
 *
 * @param result
 * @return
 */
public String getMessage(String result, Object[] params) &#123;
    String message = &quot;&quot;;
    try &#123;
        Locale locale = LocaleContextHolder.getLocale();
        message = messageSource.getMessage(result, params, locale);
    &#125; catch (Exception e) &#123;
        LOGGER.error(&quot;parse message error! &quot;, e);
    &#125;
    return message;
&#125;
</code></pre>
<p>如何设置个性化的地区呢? <code>forLanguageTag</code> 即可</p>
<pre><code> Locale locale = Locale.forLanguageTag(user.getLangKey());
</code></pre>
<h2 id="1-4-原理分析"><a href="#1-4-原理分析" class="headerlink" title="1.4 原理分析"></a>1.4 原理分析</h2><p><code>MessageSourceAutoConfiguration</code>中，实现了autoconfig</p>
<pre><code>@Configuration
@ConditionalOnMissingBean(value = MessageSource.class, search = SearchStrategy.CURRENT)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Conditional(ResourceBundleCondition.class)
@EnableConfigurationProperties
@ConfigurationProperties(prefix = &quot;spring.messages&quot;)
public class MessageSourceAutoConfiguration &#123;
</code></pre>
<p>该类一方面读取配置文件，一方面创建了MessageSource的实例:</p>
<pre><code>@Beanpublic MessageSource messageSource() &#123;    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();    if (StringUtils.hasText(this.basename)) &#123;        messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(                StringUtils.trimAllWhitespace(this.basename)));    &#125;    if (this.encoding != null) &#123;        messageSource.setDefaultEncoding(this.encoding.name());    &#125;    messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);    messageSource.setCacheSeconds(this.cacheSeconds);    messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);    return messageSource;&#125;
</code></pre>
<p>因此，默认是加载的<code>ResourceBundleMessageSource</code>，该类派生与于AbstractResourceBasedMessageSource</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532590285975.jpg" alt="enter description here" title="1532590285975"></p>
<pre><code>@Overridepublic final String getMessage(String code, Object[] args, String defaultMessage, Locale locale) &#123;    String msg = getMessageInternal(code, args, locale);    if (msg != null) &#123;        return msg;    &#125;    if (defaultMessage == null) &#123;        String fallback = getDefaultMessage(code);        if (fallback != null) &#123;            return fallback;        &#125;    &#125;    return renderDefaultMessage(defaultMessage, args, locale);&#125;
</code></pre>
<p>最终是调用resolveCode来获取message，通过ResourceBundle来获取message</p>
<pre><code>    @Overrideprotected MessageFormat resolveCode(String code, Locale locale) &#123;    // 遍历语言文件路径    Set&lt;String&gt; basenames = getBasenameSet();    for (String basename : basenames) &#123;        ResourceBundle bundle = getResourceBundle(basename, locale);        if (bundle != null) &#123;            MessageFormat messageFormat = getMessageFormat(bundle, code, locale);            if (messageFormat != null) &#123;                return messageFormat;            &#125;        &#125;    &#125;    return null;&#125;
// 获取ResourceBundle    
protected ResourceBundle getResourceBundle(String basename, Locale locale) &#123;    if (getCacheMillis() &gt;= 0) &#123;        // Fresh ResourceBundle.getBundle call in order to let ResourceBundle        // do its native caching, at the expense of more extensive lookup steps.        return doGetBundle(basename, locale);    &#125;    else &#123;        // Cache forever: prefer locale cache over repeated getBundle calls.        synchronized (this.cachedResourceBundles) &#123;            Map&lt;Locale, ResourceBundle&gt; localeMap = this.cachedResourceBundles.get(basename);            if (localeMap != null) &#123;                ResourceBundle bundle = localeMap.get(locale);                if (bundle != null) &#123;                    return bundle;                &#125;            &#125;            try &#123;                ResourceBundle bundle = doGetBundle(basename, locale);                if (localeMap == null) &#123;                    localeMap = new HashMap&lt;Locale, ResourceBundle&gt;();                    this.cachedResourceBundles.put(basename, localeMap);                &#125;                localeMap.put(locale, bundle);                return bundle;            &#125;            catch (MissingResourceException ex) &#123;                if (logger.isWarnEnabled()) &#123;                    logger.warn(&quot;ResourceBundle [&quot; + basename + &quot;] not found for MessageSource: &quot; + ex.getMessage());                &#125;                // Assume bundle not found                // -&gt; do NOT throw the exception to allow for checking parent message source.                return null;            &#125;        &#125;    &#125;&#125;

//  ResourceBundle    
protected ResourceBundle doGetBundle(String basename, Locale locale) throws MissingResourceException &#123;    return ResourceBundle.getBundle(basename, locale, getBundleClassLoader(), new MessageSourceControl());
&#125;
</code></pre>
<p>最后来看getMessageFormat：</p>
<pre><code>/** * Return a MessageFormat for the given bundle and code, * fetching already generated MessageFormats from the cache. * @param bundle the ResourceBundle to work on * @param code the message code to retrieve * @param locale the Locale to use to build the MessageFormat * @return the resulting MessageFormat, or &#123;@code null&#125; if no message * defined for the given code * @throws MissingResourceException if thrown by the ResourceBundle */protected MessageFormat getMessageFormat(ResourceBundle bundle, String code, Locale locale)        throws MissingResourceException &#123;
    synchronized (this.cachedBundleMessageFormats) &#123;        // 从缓存读取        Map&lt;String, Map&lt;Locale, MessageFormat&gt;&gt; codeMap = this.cachedBundleMessageFormats.get(bundle);        Map&lt;Locale, MessageFormat&gt; localeMap = null;        if (codeMap != null) &#123;            localeMap = codeMap.get(code);            if (localeMap != null) &#123;                MessageFormat result = localeMap.get(locale);                if (result != null) &#123;                    return result;                &#125;            &#125;        &#125;        // 缓存miss，从bundle读取        String msg = getStringOrNull(bundle, code);        if (msg != null) &#123;            if (codeMap == null) &#123;                codeMap = new HashMap&lt;String, Map&lt;Locale, MessageFormat&gt;&gt;();                this.cachedBundleMessageFormats.put(bundle, codeMap);            &#125;            if (localeMap == null) &#123;                localeMap = new HashMap&lt;Locale, MessageFormat&gt;();                codeMap.put(code, localeMap);            &#125;            MessageFormat result = createMessageFormat(msg, locale);            localeMap.put(locale, result);            return result;        &#125;
        return null;    &#125;&#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>管理培训笔记</title>
    <url>/jadepeng/2018/08/09/jqpeng-%E7%AE%A1%E7%90%86%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/9447480.html">管理培训笔记</a></p>
<h2 id="开启-领导之路"><a href="#开启-领导之路" class="headerlink" title="开启 领导之路"></a>开启 领导之路</h2><h3 id="建立团队"><a href="#建立团队" class="headerlink" title="建立团队"></a>建立团队</h3><h4 id="什么是团队？"><a href="#什么是团队？" class="headerlink" title="什么是团队？"></a>什么是团队？</h4><ol>
<li>一群人为了共同目的而奋斗，惟有通过成员间有效合作共事才能达成目标</li>
<li>团队具有共同的目的：使命、职责、目标</li>
</ol>
<h4 id="使命"><a href="#使命" class="headerlink" title="使命"></a>使命</h4><p>包含三个方面：</p>
<ol>
<li>团队是谁</li>
<li>团队存在的理由</li>
<li>团队支持何种组织目标的实现</li>
</ol>
<h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h4><p>团队所负责的具体职责，是具体的可落地工作：</p>
<p>对于一个IT团队，可能的职责是：</p>
<ol>
<li>推动公司内部管理信息化， 负责内部网络信息系统的建设</li>
<li>负责公司电子商务 的应用推广工作</li>
<li>负责公司员工 电子商务系统应用的培训</li>
</ol>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>目标是短期、中长期具体工作规划。制定目标需要符合SMART原则。</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672418534.jpg" alt="SMART原则" title="SMART原则"></p>
<p>建立团队规范：<br> 沟通、会议、决策、冲突</p>
<h2 id="保障-运营卓越"><a href="#保障-运营卓越" class="headerlink" title="保障 运营卓越"></a>保障 运营卓越</h2><p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672674475.jpg" alt=" 任务规划与执行的步骤" title="1532672674475"></p>
<h3 id="1-明确需求"><a href="#1-明确需求" class="headerlink" title="1. 明确需求"></a>1. 明确需求</h3><h4 id="什么是计划"><a href="#什么是计划" class="headerlink" title="什么是计划"></a>什么是计划</h4><p>为实现目标，而规划自己与他人的行动</p>
<h4 id="什么是“执行力”？"><a href="#什么是“执行力”？" class="headerlink" title="什么是“执行力”？"></a>什么是“执行力”？</h4><p>有效运用资源，达成目标的能力</p>
<h4 id="任务规划与执行的步骤"><a href="#任务规划与执行的步骤" class="headerlink" title="任务规划与执行的步骤"></a>任务规划与执行的步骤</h4><ul>
<li>建立信息基础，分析整理已知信息，计划需要收集的信息</li>
<li>信息基础：假设、准则/条件、资源、行动</li>
<li>考虑个人特质： 客观、远见、主动</li>
</ul>
<h3 id="2-定计划"><a href="#2-定计划" class="headerlink" title="2. 定计划"></a>2. 定计划</h3><ul>
<li><p>任务和行动：</p>
<ul>
<li>任务并非单一的行动，而是若干个单一行动组成的</li>
<li>行动是可执行的步骤，是能够推进任务完成的、具体的、可实施的行动</li>
<li>行动需要为任务服务</li>
</ul>
</li>
<li><p>注意行动排序</p>
<ul>
<li>识别任务清单中各项行动的相互关联与依赖关系</li>
<li>并据各项行动的先后顺序，安排和确定工作</li>
</ul>
</li>
<li><p>评估风险、机会 四象限</p>
<ul>
<li>从影响大小、概率高低</li>
</ul>
<p>  <img src="http://oyqmmpkcm.bkt.clouddn.com/1532672842584.jpg" alt="评估风险/机会" title="1532672842584"></p>
</li>
</ul>
<h3 id="3-分职责"><a href="#3-分职责" class="headerlink" title="3. 分职责"></a>3. 分职责</h3><ul>
<li>团队分工：RACI<ul>
<li>Responsible 负责人</li>
<li>Accountable 当责人</li>
<li>Consult 被咨询人</li>
<li>Inform 知情者</li>
</ul>
</li>
</ul>
<p>需要注意，负责人和当责人之间的三不管地带：</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532672894561.jpg" alt="团队分工:RACI" title="1532672894561"></p>
<p>任务分配时，需要明确期待的结果，方便跟踪和评价。</p>
<p>同时注意，选择合适人员  </p>
<ul>
<li>客观条件  </li>
<li>人员意愿  </li>
</ul>
<ul>
<li>不会做  </li>
<li>不能做  </li>
<li>不想做</li>
</ul>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532673100397.jpg" alt="enter description here" title="1532673100397"></p>
<h3 id="4-做追踪"><a href="#4-做追踪" class="headerlink" title="4. 做追踪"></a>4. 做追踪</h3><blockquote>
<p>郭士纳说：人们不会做你希望的，只会做你检查的；如果你强调什么，你就检查什么，你不检查就等于不重视</p>
</blockquote>
<p>因此，你强调什么，就一定要检查什么！</p>
<p>追踪流程：  </p>
<ul>
<li> 收集资料  </li>
<li> 对标找差  </li>
<li> 纠偏强化</li>
</ul>
<p>追踪需要重点关注结果和行为。</p>
<p>常见的追踪方法：  </p>
<ul>
<li> 召集 会议  </li>
<li> 观察 检查  </li>
<li> 定期反馈 及报告</li>
</ul>
<p>如何有效追踪：</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1532673452477.jpg" alt="如何有效追踪" title="如何有效追踪"></p>
<h2 id="确保-沟通有效"><a href="#确保-沟通有效" class="headerlink" title="确保 沟通有效"></a>确保 沟通有效</h2><h3 id="破除沟通障碍"><a href="#破除沟通障碍" class="headerlink" title="破除沟通障碍"></a>破除沟通障碍</h3><h4 id="常见沟通障碍"><a href="#常见沟通障碍" class="headerlink" title="常见沟通障碍"></a>常见沟通障碍</h4><p>认知偏差、听不到位 无效表达、缺乏参与</p>
<h4 id="破除沟通障碍三法宝：-听、问、说"><a href="#破除沟通障碍三法宝：-听、问、说" class="headerlink" title="破除沟通障碍三法宝： 听、问、说"></a>破除沟通障碍三法宝： 听、问、说</h4><p>提高沟通效能</p>
<p>互动五流程：</p>
<ol>
<li>定方向</li>
<li>理情况</li>
<li>想方法</li>
<li>明作法</li>
<li>做总结</li>
</ol>
<h4 id="观人沟通术"><a href="#观人沟通术" class="headerlink" title="观人沟通术"></a>观人沟通术</h4><p>人际矩阵</p>
<p>理解自己，理解他人-PDP</p>
<p>利用PDP与风格不同的人更 好合作</p>
<h2 id="辅导员工"><a href="#辅导员工" class="headerlink" title="辅导员工"></a>辅导员工</h2><h3 id="主管，你是教练"><a href="#主管，你是教练" class="headerlink" title="主管，你是教练"></a>主管，你是教练</h3><p>常见辅导议题</p>
<h3 id="发现辅导机会"><a href="#发现辅导机会" class="headerlink" title="发现辅导机会"></a>发现辅导机会</h3><p>发现征兆、收集信息</p>
<p>检验原因、做出判断</p>
<h3 id="进行有效辅导"><a href="#进行有效辅导" class="headerlink" title="进行有效辅导"></a>进行有效辅导</h3><p>利用沟通三法宝和互动五流 程进行有效辅导</p>
<h3 id="辅导反馈与跟进"><a href="#辅导反馈与跟进" class="headerlink" title="辅导反馈与跟进"></a>辅导反馈与跟进</h3><p>有效反馈要诀： 及时、平衡、具体<br> 两种反馈工具： 正面反馈(STAR) 改进型反馈(STAR/AR)</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Jhipster Registry（Eureka Server） Docker双向联通与高可用部署</title>
    <url>/jadepeng/2018/07/05/jqpeng-Jhipster%20Registry%EF%BC%88Eureka%20Server%EF%BC%89%20Docker%E5%8F%8C%E5%90%91%E8%81%94%E9%80%9A%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/9266722.html">Jhipster Registry（Eureka Server） Docker双向联通与高可用部署</a></p>
<p>使用Compose来编排这个Eureka Server集群：</p>
<h2 id="peer1配置："><a href="#peer1配置：" class="headerlink" title="peer1配置："></a>peer1配置：</h2><pre><code>server:
    port: 8761

eureka:
    instance:
        hostname: eureka-peer-1
    server:
        # see discussion about enable-self-preservation:
        # https://github.com/jhipster/generator-jhipster/issues/3654
        enable-self-preservation: false
        registry-sync-retry-wait-ms: 500
        a-sgcache-expiry-timeout-ms: 60000
        eviction-interval-timer-in-ms: 30000
        peer-eureka-nodes-update-interval-ms: 30000
        renewal-threshold-update-interval-ms: 15000
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
            defaultZone: http://admin:$&#123;spring.security.user.password:admin&#125;@eureka-peer-2:8762/eureka/
</code></pre>
<h2 id="peer2配置："><a href="#peer2配置：" class="headerlink" title="peer2配置："></a>peer2配置：</h2><pre><code>server:
    port: 8762

eureka:
    instance:
        hostname: eureka-peer-2
    server:
        # see discussion about enable-self-preservation:
        # https://github.com/jhipster/generator-jhipster/issues/3654
        enable-self-preservation: false
        registry-sync-retry-wait-ms: 500
        a-sgcache-expiry-timeout-ms: 60000
        eviction-interval-timer-in-ms: 30000
        peer-eureka-nodes-update-interval-ms: 30000
        renewal-threshold-update-interval-ms: 15000
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
            defaultZone: http://admin:$&#123;spring.security.user.password:admin&#125;@eureka-peer-1:8761/eureka/
</code></pre>
<h2 id="构建Image"><a href="#构建Image" class="headerlink" title="构建Image"></a>构建Image</h2><p>使用官方的DockerFile：</p>
<pre><code>FROM openjdk:8-jre-alpine

ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \
    JAVA_OPTS=&quot;&quot; \
    JHIPSTER_SLEEP=0

VOLUME /tmp
EXPOSE 8761
CMD echo &quot;The application will start in $&#123;JHIPSTER_SLEEP&#125;s...&quot; &amp;&amp; \
    sleep $&#123;JHIPSTER_SLEEP&#125; &amp;&amp; \
    java $&#123;JAVA_OPTS&#125; -Djava.security.egd=file:/dev/./urandom -jar /app.war

# add directly the war
ADD *.war /app.war
</code></pre>
<p>构建Image并push到registry，这里是192.168.86.8:5000/registry-dev</p>
<h2 id="编写compose文件："><a href="#编写compose文件：" class="headerlink" title="编写compose文件："></a>编写compose文件：</h2><pre><code>version: &quot;3&quot; 
services:
  eureka-peer-1 :
    image: 192.168.86.8:5000/registry-dev:latest
    links:
      - eureka-peer-2
    ports:
      - &quot;8761:8761&quot;
    environment:
      spring.profiles.active: oauth2,peer1,swagger
    entrypoint:
      - java
      - -Dspring.profiles.active=oauth2,peer1,swagger
      - -Djava.security.egd=file:/dev/./urandom
      - -jar
      - /app.war
  eureka-peer-2:
    image: 192.168.86.8:5000/registry-dev:latest
    links:
      - eureka-peer-1
    expose:
      - &quot;8762&quot;
    ports:
      - &quot;8762:8762&quot;
    environment:
      spring.profiles.active: oauth2,peer2,swagger
    entrypoint:
      - java
      - -Dspring.profiles.active=oauth2,peer2,swagger
      - -Djava.security.egd=file:/dev/./urandom
      - -jar
      - /app.war
</code></pre>
<p>启动即可。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>Jhipster</tag>
      </tags>
  </entry>
  <entry>
    <title>（转阮一峰）深入理解OAuth 2.0</title>
    <url>/jadepeng/2018/06/29/jqpeng-%EF%BC%88%E8%BD%AC%E9%98%AE%E4%B8%80%E5%B3%B0%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OAuth%202.0/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/9241712.html">（转阮一峰）深入理解OAuth 2.0</a></p>
<p><a href="http://en.wikipedia.org/wiki/OAuth">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。</p>
<p>本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749">RFC 6749</a>。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051201.png" alt="OAuth Logo"></p>
<h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p>
<p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051202.png" alt="云冲印"></p>
<p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p>
<p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p>
<blockquote>
<p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。</p>
<p>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</p>
<p>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。</p>
<p>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</p>
<p>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p>
</blockquote>
<p>OAuth就是为了解决上面这些问题而诞生的。</p>
<h2 id="二、名词定义"><a href="#二、名词定义" class="headerlink" title="二、名词定义"></a>二、名词定义</h2><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p>
<blockquote>
<p>（1） <strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</p>
<p>（2）<strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。</p>
<p>（3）<strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。</p>
<p>（4）<strong>User Agent</strong>：用户代理，本文中就是指浏览器。</p>
<p>（5）<strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</p>
<p>（6）<strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
</blockquote>
<p>知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p>
<h2 id="三、OAuth的思路"><a href="#三、OAuth的思路" class="headerlink" title="三、OAuth的思路"></a>三、OAuth的思路</h2><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<h2 id="四、运行流程"><a href="#四、运行流程" class="headerlink" title="四、运行流程"></a>四、运行流程</h2><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png" alt="OAuth运行流程"></p>
<blockquote>
<p>（A）用户打开客户端以后，客户端要求用户给予授权。</p>
<p>（B）用户同意给予客户端授权。</p>
<p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p>
<p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p>
<p>（E）客户端使用令牌，向资源服务器申请获取资源。</p>
<p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
</blockquote>
<p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<p>下面一一讲解客户端获取授权的四种模式。</p>
<h2 id="五、客户端的授权模式"><a href="#五、客户端的授权模式" class="headerlink" title="五、客户端的授权模式"></a>五、客户端的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h2 id="六、授权码模式"><a href="#六、授权码模式" class="headerlink" title="六、授权码模式"></a>六、授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051204.png" alt="授权码模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A步骤中，客户端申请认证的URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1<br>    Host: server.example.com</p>
</blockquote>
<p>C步骤中，服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 302 Found<br>    Location: <a href="https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA">https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</a><br>              &amp;state=xyz</p>
</blockquote>
<p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>    Host: server.example.com<br>    Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>    Content-Type: application/x-www-form-urlencoded</p>
<pre><code>grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
</code></pre>
</blockquote>
<p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p>
<h2 id="七、简化模式"><a href="#七、简化模式" class="headerlink" title="七、简化模式"></a>七、简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051205.png" alt="简化模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端将用户导向认证服务器。</p>
<p>（B）用户决定是否给于客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p>
<p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p>
<p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p>
<p>（G）浏览器将令牌发给客户端。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，此处的值固定为”token”，必选项。</li>
<li>client_id：表示客户端的ID，必选项。</li>
<li>redirect_uri：表示重定向的URI，可选项。</li>
<li>scope：表示权限范围，可选项。</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz<br>            &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1<br>        Host: server.example.com</p>
</blockquote>
<p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 302 Found<br>         Location: <a href="http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA">http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</a><br>                   &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</p>
</blockquote>
<p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p>
<p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p>
<h2 id="八、密码模式"><a href="#八、密码模式" class="headerlink" title="八、密码模式"></a>八、密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051206.png" alt="密码模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户向客户端提供用户名和密码。</p>
<p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p>
<p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=password&amp;username=johndoe&amp;password=A3ddj3w
</code></pre>
</blockquote>
<p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<p>整个过程中，客户端不得保存用户的密码。</p>
<h2 id="九、客户端模式"><a href="#九、客户端模式" class="headerlink" title="九、客户端模式"></a>九、客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051207.png" alt="客户端模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p>
<p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”client_credentials”，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=client_credentials
</code></pre>
</blockquote>
<p>认证服务器必须以某种方式，验证客户端身份。</p>
<p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<blockquote>
<p>HTTP/1.1 200 OK<br>         Content-Type: application/json;charset=UTF-8<br>         Cache-Control: no-store<br>         Pragma: no-cache</p>
<pre><code>     &#123;
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;example&quot;,
       &quot;expires_in&quot;:3600,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     &#125;
</code></pre>
</blockquote>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<h2 id="十、更新令牌"><a href="#十、更新令牌" class="headerlink" title="十、更新令牌"></a>十、更新令牌</h2><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，此处的值固定为”refresh_token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<p>POST /token HTTP/1.1<br>         Host: server.example.com<br>         Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW<br>         Content-Type: application/x-www-form-urlencoded</p>
<pre><code>     grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
</code></pre>
</blockquote>
<p>（完）</p>
<hr>
<p>出处：<a href="http://www.ruanyifeng.com/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/2014/05/oauth_2_0.html</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>OAuth 2</tag>
      </tags>
  </entry>
  <entry>
    <title>基于spring security 实现前后端分离项目权限控制</title>
    <url>/jadepeng/2018/06/14/jqpeng-%E5%9F%BA%E4%BA%8Espring%20security%20%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/spring-security-usage.html">基于spring security 实现前后端分离项目权限控制</a></p>
<p>前后端分离的项目，前端有菜单（menu），后端有API（backendApi），一个menu对应的页面有N个API接口来支持，本文介绍如何基于spring security实现前后端的同步权限控制。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>还是基于Role来实现，具体的思路是，一个Role拥有多个Menu，一个menu有多个backendApi，其中Role和menu，以及menu和backendApi都是ManyToMany关系。</p>
<p>验证授权也很简单，用户登陆系统时，获取Role关联的Menu，页面访问后端API时，再验证下用户是否有访问API的权限。</p>
<h3 id="domain定义"><a href="#domain定义" class="headerlink" title="domain定义"></a>domain定义</h3><p>我们用JPA来实现，先来定义Role</p>
<pre><code>public class Role implements Serializable &#123;


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 名称
     */
    @NotNull
    @ApiModelProperty(value = &quot;名称&quot;, required = true)
    @Column(name = &quot;name&quot;, nullable = false)
    private String name;

    /**
     * 备注
     */
    @ApiModelProperty(value = &quot;备注&quot;)
    @Column(name = &quot;remark&quot;)
    private String remark;

    @JsonIgnore
    @ManyToMany
    @JoinTable(
        name = &quot;role_menus&quot;,
        joinColumns = &#123;@JoinColumn(name = &quot;role_id&quot;, referencedColumnName = &quot;id&quot;)&#125;,
        inverseJoinColumns = &#123;@JoinColumn(name = &quot;menu_id&quot;, referencedColumnName = &quot;id&quot;)&#125;)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    @BatchSize(size = 100)
    private Set&lt;Menu&gt; menus = new HashSet&lt;&gt;();&#125;
</code></pre>
<p>以及Menu：</p>
<pre><code>public class Menu implements Serializable &#123;


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = &quot;parent_id&quot;)
    private Integer parentId;

    /**
     * 文本
     */
    @ApiModelProperty(value = &quot;文本&quot;)
    @Column(name = &quot;text&quot;)
    private String text;@ApiModelProperty(value = &quot;angular路由&quot;)
    @Column(name = &quot;link&quot;)
    private String link;
    @ManyToMany
    @JsonIgnore
    @JoinTable(name = &quot;backend_api_menus&quot;,
        joinColumns = @JoinColumn(name=&quot;menus_id&quot;, referencedColumnName=&quot;id&quot;),
        inverseJoinColumns = @JoinColumn(name=&quot;backend_apis_id&quot;, referencedColumnName=&quot;id&quot;))
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set&lt;BackendApi&gt; backendApis = new HashSet&lt;&gt;();

    @ManyToMany(mappedBy = &quot;menus&quot;)
    @JsonIgnore
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();&#125;
</code></pre>
<p>最后是BackendApi，区分method（HTTP请求方法）、tag（哪一个Controller）和path（API请求路径）：</p>
<pre><code>public class BackendApi implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = &quot;tag&quot;)
    private String tag;

    @Column(name = &quot;path&quot;)
    private String path;

    @Column(name = &quot;method&quot;)
    private String method;

    @Column(name = &quot;summary&quot;)
    private String summary;

    @Column(name = &quot;operation_id&quot;)
    private String operationId;

    @ManyToMany(mappedBy = &quot;backendApis&quot;)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set&lt;Menu&gt; menus = new HashSet&lt;&gt;();&#125;
</code></pre>
<h2 id="管理页面实现"><a href="#管理页面实现" class="headerlink" title="管理页面实现"></a>管理页面实现</h2><p>Menu菜单是业务需求确定的，因此提供CRUD编辑即可。<br> BackendAPI，可以通过swagger来获取。<br> 前端选择ng-algin，参见<a href="https://www.cnblogs.com/xiaoqi/p/angular-ng-alain.html">Angular 中后台前端解决方案 - Ng Alain 介绍</a></p>
<h3 id="通过swagger获取BackendAPI"><a href="#通过swagger获取BackendAPI" class="headerlink" title="通过swagger获取BackendAPI"></a>通过swagger获取BackendAPI</h3><p>获取swagger api有多种方法，最简单的就是访问http接口获取json，然后解析，这很简单，这里不赘述，还有一种就是直接调用相关API获取Swagger对象。</p>
<p>查看官方的web代码，可以看到获取数据大概是这样的：</p>
<pre><code>        String groupName = Optional.fromNullable(swaggerGroup).or(Docket.DEFAULT_GROUP_NAME);
        Documentation documentation = documentationCache.documentationByGroup(groupName);
        if (documentation == null) &#123;
            return new ResponseEntity&lt;Json&gt;(HttpStatus.NOT_FOUND);
        &#125;
        Swagger swagger = mapper.mapDocumentation(documentation);
        UriComponents uriComponents = componentsFrom(servletRequest, swagger.getBasePath());
        swagger.basePath(Strings.isNullOrEmpty(uriComponents.getPath()) ? &quot;/&quot; : uriComponents.getPath());
        if (isNullOrEmpty(swagger.getHost())) &#123;
            swagger.host(hostName(uriComponents));
        &#125;
        return new ResponseEntity&lt;Json&gt;(jsonSerializer.toJson(swagger), HttpStatus.OK);
</code></pre>
<p>其中的documentationCache、environment、mapper等可以直接Autowired获得：</p>
<pre><code>@Autowired
    public SwaggerResource(
        Environment environment,
        DocumentationCache documentationCache,
        ServiceModelToSwagger2Mapper mapper,
        BackendApiRepository backendApiRepository,
        JsonSerializer jsonSerializer) &#123;

        this.hostNameOverride = environment.getProperty(&quot;springfox.documentation.swagger.v2.host&quot;, &quot;DEFAULT&quot;);
        this.documentationCache = documentationCache;
        this.mapper = mapper;
        this.jsonSerializer = jsonSerializer;

        this.backendApiRepository = backendApiRepository;

    &#125;
</code></pre>
<p>然后我们自动加载就简单了，写一个updateApi接口，读取swagger对象，然后解析成BackendAPI，存储到数据库：</p>
<pre><code>@RequestMapping(
        value = &quot;/api/updateApi&quot;,
        method = RequestMethod.GET,
        produces = &#123; APPLICATION_JSON_VALUE, HAL_MEDIA_TYPE &#125;)
    @PropertySourcedMapping(
        value = &quot;$&#123;springfox.documentation.swagger.v2.path&#125;&quot;,
        propertyKey = &quot;springfox.documentation.swagger.v2.path&quot;)
    @ResponseBody
    public ResponseEntity&lt;Json&gt; updateApi(
        @RequestParam(value = &quot;group&quot;, required = false) String swaggerGroup) &#123;

        // 加载已有的api
        Map&lt;String,Boolean&gt; apiMap = Maps.newHashMap();
        List&lt;BackendApi&gt; apis = backendApiRepository.findAll();
        apis.stream().forEach(api-&gt;apiMap.put(api.getPath()+api.getMethod(),true));

        // 获取swagger
        String groupName = Optional.fromNullable(swaggerGroup).or(Docket.DEFAULT_GROUP_NAME);
        Documentation documentation = documentationCache.documentationByGroup(groupName);
        if (documentation == null) &#123;
            return new ResponseEntity&lt;Json&gt;(HttpStatus.NOT_FOUND);
        &#125;
        Swagger swagger = mapper.mapDocumentation(documentation);

        // 加载到数据库
        for(Map.Entry&lt;String, Path&gt; item : swagger.getPaths().entrySet())&#123;
            String path = item.getKey();
            Path pathInfo = item.getValue();
            createApiIfNeeded(apiMap, path,  pathInfo.getGet(), HttpMethod.GET.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getPost(), HttpMethod.POST.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getDelete(), HttpMethod.DELETE.name());
            createApiIfNeeded(apiMap, path,  pathInfo.getPut(), HttpMethod.PUT.name());
        &#125;
        return new ResponseEntity&lt;Json&gt;(HttpStatus.OK);
    &#125;
</code></pre>
<p>其中createApiIfNeeded，先判断下是否存在，不存在的则新增：</p>
<pre><code> private void createApiIfNeeded(Map&lt;String, Boolean&gt; apiMap, String path, Operation operation, String method) &#123;
        if(operation==null) &#123;
            return;
        &#125;
        if(!apiMap.containsKey(path+ method))&#123;
            apiMap.put(path+ method,true);

            BackendApi api = new BackendApi();
            api.setMethod( method);
            api.setOperationId(operation.getOperationId());
            api.setPath(path);
            api.setTag(operation.getTags().get(0));
            api.setSummary(operation.getSummary());

            // 保存
            this.backendApiRepository.save(api);
        &#125;
    &#125;
</code></pre>
<p>最后，做一个简单页面展示即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886480360.jpg" alt="enter description here" title="1528886480360"></p>
<h3 id="菜单管理"><a href="#菜单管理" class="headerlink" title="菜单管理"></a>菜单管理</h3><p>新增和修改页面，可以选择上级菜单，后台API做成按tag分组，可多选即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886647893.jpg" alt="enter description here" title="1528886647893"></p>
<p>列表页面</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886586348.jpg" alt="enter description here" title="1528886586348"></p>
<h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><p>普通的CRUD，最主要的增加一个菜单授权页面，菜单按层级显示即可：</p>
<p><img src="https://gitee.com/jadepeng/blogpic/raw/master/pic/2018/1528886692091.jpg" alt="enter description here" title="1528886692091"></p>
<h2 id="认证实现"><a href="#认证实现" class="headerlink" title="认证实现"></a>认证实现</h2><p>管理页面可以做成千奇百样，最核心的还是如何实现认证。</p>
<p>在上一篇文章<a href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a>里我们说了，可以自定义<code>FilterInvocationSecurityMetadataSource</code>来实现。</p>
<p>实现<code>FilterInvocationSecurityMetadataSource</code>接口即可，核心是根据FilterInvocation的Request的method和path，获取对应的Role，然后交给RoleVoter去判断是否有权限。</p>
<h3 id="自定义FilterInvocationSecurityMetadataSource"><a href="#自定义FilterInvocationSecurityMetadataSource" class="headerlink" title="自定义FilterInvocationSecurityMetadataSource"></a>自定义FilterInvocationSecurityMetadataSource</h3><p>我们新建一个DaoSecurityMetadataSource实现FilterInvocationSecurityMetadataSource接口，主要看getAttributes方法：</p>
<pre><code>     @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;
        FilterInvocation fi = (FilterInvocation) object;

        List&lt;Role&gt; neededRoles = this.getRequestNeededRoles(fi.getRequest().getMethod(), fi.getRequestUrl());

        if (neededRoles != null) &#123;
            return SecurityConfig.createList(neededRoles.stream().map(role -&gt; role.getName()).collect(Collectors.toList()).toArray(new String[]&#123;&#125;));
        &#125;

        //  返回默认配置
        return superMetadataSource.getAttributes(object);
    &#125;
</code></pre>
<p>核心是getRequestNeededRoles怎么实现，获取到干净的RequestUrl（去掉参数）,然后看是否有对应的backendAPI，如果没有，则有可能该API有path参数，我们可以去掉最后的path，去库里模糊匹配，直到找到。</p>
<pre><code> public List&lt;Role&gt; getRequestNeededRoles(String method, String path) &#123;
        String rawPath = path;
        //  remove parameters
        if(path.indexOf(&quot;?&quot;)&gt;-1)&#123;
            path = path.substring(0,path.indexOf(&quot;?&quot;));
        &#125;
        // /menus/&#123;id&#125;
        BackendApi api = backendApiRepository.findByPathAndMethod(path, method);
        if (api == null)&#123;
            // try fetch by remove last path
            api = loadFromSimilarApi(method, path, rawPath);
        &#125;

        if (api != null &amp;&amp; api.getMenus().size() &gt; 0) &#123;
            return api.getMenus()
                .stream()
                .flatMap(menu -&gt; menuRepository.findOneWithRolesById(menu.getId()).getRoles().stream())
                .collect(Collectors.toList());
        &#125;
        return null;
    &#125;

    private BackendApi loadFromSimilarApi(String method, String path, String rawPath) &#123;
        if(path.lastIndexOf(&quot;/&quot;)&gt;-1)&#123;
            path = path.substring(0,path.lastIndexOf(&quot;/&quot;));
            List&lt;BackendApi&gt; apis = backendApiRepository.findByPathStartsWithAndMethod(path, method);

            // 如果为空，再去掉一层path
            while(apis==null)&#123;
                if(path.lastIndexOf(&quot;/&quot;)&gt;-1) &#123;
                    path = path.substring(0, path.lastIndexOf(&quot;/&quot;));
                    apis = backendApiRepository.findByPathStartsWithAndMethod(path, method);
                &#125;else&#123;
                    break;
                &#125;
            &#125;

            if(apis!=null)&#123;
                for(BackendApi backendApi : apis)&#123;
                    if (antPathMatcher.match(backendApi.getPath(), rawPath)) &#123;
                        return backendApi;
                    &#125;
                &#125;
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<p>其中，BackendApiRepository：</p>
<pre><code>    @EntityGraph(attributePaths = &quot;menus&quot;)
    BackendApi findByPathAndMethod(String path,String method);

    @EntityGraph(attributePaths = &quot;menus&quot;)
    List&lt;BackendApi&gt; findByPathStartsWithAndMethod(String path,String method);
</code></pre>
<p>以及MenuRepository</p>
<pre><code>    @EntityGraph(attributePaths = &quot;roles&quot;)
    Menu findOneWithRolesById(long id);
</code></pre>
<h3 id="使用DaoSecurityMetadataSource"><a href="#使用DaoSecurityMetadataSource" class="headerlink" title="使用DaoSecurityMetadataSource"></a>使用DaoSecurityMetadataSource</h3><p>需要注意的是，在DaoSecurityMetadataSource里，不能直接注入Repository，我们可以给DaoSecurityMetadataSource添加一个方法，方便传入：</p>
<pre><code>   public void init(MenuRepository menuRepository, BackendApiRepository backendApiRepository) &#123;
        this.menuRepository = menuRepository;
        this.backendApiRepository = backendApiRepository;
    &#125;
</code></pre>
<p>然后建立一个容器，存储实例化的DaoSecurityMetadataSource，我们可以建立如下的ApplicationContext来作为对象容器，存取对象：</p>
<pre><code>public class ApplicationContext &#123;
    static Map&lt;Class&lt;?&gt;,Object&gt; beanMap = Maps.newConcurrentMap();

    public static &lt;T&gt; T getBean(Class&lt;T&gt; requireType)&#123;
        return (T) beanMap.get(requireType);
    &#125;

    public static void registerBean(Object item)&#123;
        beanMap.put(item.getClass(),item);
    &#125;
&#125;
</code></pre>
<p>在SecurityConfiguration配置中使用<code>DaoSecurityMetadataSource</code>，并通过<code> ApplicationContext.registerBean</code>将<code>DaoSecurityMetadataSource</code>注册：</p>
<pre><code> @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)        ....
           // .withObjectPostProcessor()
            // 自定义accessDecisionManager
            .accessDecisionManager(accessDecisionManager())
            // 自定义FilterInvocationSecurityMetadataSource
            .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;
                @Override
                public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
                    O fsi) &#123;
                    fsi.setSecurityMetadataSource(daoSecurityMetadataSource(fsi.getSecurityMetadataSource()));
                    return fsi;
                &#125;
            &#125;)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;

    @Bean
    public DaoSecurityMetadataSource daoSecurityMetadataSource(FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource) &#123;
        DaoSecurityMetadataSource securityMetadataSource = new DaoSecurityMetadataSource(filterInvocationSecurityMetadataSource);
        ApplicationContext.registerBean(securityMetadataSource);
        return securityMetadataSource;
    &#125;
</code></pre>
<p>最后，在程序启动后，通过<code>ApplicationContext.getBean</code>获取到daoSecurityMetadataSource，然后调用init注入Repository</p>
<pre><code> public static void postInit()&#123;
        ApplicationContext
            .getBean(DaoSecurityMetadataSource.class)
 .init(applicationContext.getBean(MenuRepository.class),applicationContext.getBean(BackendApiRepository.class));
    &#125;

    static ConfigurableApplicationContext applicationContext;

    public static void main(String[] args) throws UnknownHostException &#123;
        SpringApplication app = new SpringApplication(UserCenterApp.class);
        DefaultProfileUtil.addDefaultProfile(app);
        applicationContext = app.run(args);

        // 后初始化
        postInit();
&#125;
</code></pre>
<p>大功告成！</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a></li>
<li><a href="https://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>spring security实现动态配置url权限的两种方法</title>
    <url>/jadepeng/2018/06/07/jqpeng-spring%20security%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AEurl%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/spring-security-rabc.html">spring security实现动态配置url权限的两种方法</a></p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>标准的RABC, 权限需要支持动态配置，spring security默认是在代码里约定好权限，真实的业务场景通常需要可以支持动态配置角色访问权限，即在运行时去配置url对应的访问角色。</p>
<p>基于spring security，如何实现这个需求呢？</p>
<p>最简单的方法就是自定义一个Filter去完成权限判断，但这脱离了spring security框架，如何基于spring security优雅的实现呢？</p>
<h2 id="spring-security-授权回顾"><a href="#spring-security-授权回顾" class="headerlink" title="spring security 授权回顾"></a>spring security 授权回顾</h2><p>spring security 通过FilterChainProxy作为注册到web的filter，FilterChainProxy里面一次包含了内置的多个过滤器，我们首先需要了解spring security内置的各种filter：</p>
<table>
<thead>
<tr>
<th>Alias</th>
<th>Filter Class</th>
<th>Namespace Element or Attribute</th>
</tr>
</thead>
<tbody><tr>
<td>CHANNEL_FILTER</td>
<td>ChannelProcessingFilter</td>
<td>http/intercept-url@requires-channel</td>
</tr>
<tr>
<td>SECURITY_CONTEXT_FILTER</td>
<td>SecurityContextPersistenceFilter</td>
<td>http</td>
</tr>
<tr>
<td>CONCURRENT_SESSION_FILTER</td>
<td>ConcurrentSessionFilter</td>
<td>session-management/concurrency-control</td>
</tr>
<tr>
<td>HEADERS_FILTER</td>
<td>HeaderWriterFilter</td>
<td>http/headers</td>
</tr>
<tr>
<td>CSRF_FILTER</td>
<td>CsrfFilter</td>
<td>http/csrf</td>
</tr>
<tr>
<td>LOGOUT_FILTER</td>
<td>LogoutFilter</td>
<td>http/logout</td>
</tr>
<tr>
<td>X509_FILTER</td>
<td>X509AuthenticationFilter</td>
<td>http/x509</td>
</tr>
<tr>
<td>PRE_AUTH_FILTER</td>
<td>AbstractPreAuthenticatedProcessingFilter Subclasses</td>
<td>N/A</td>
</tr>
<tr>
<td>CAS_FILTER</td>
<td>CasAuthenticationFilter</td>
<td>N/A</td>
</tr>
<tr>
<td>FORM_LOGIN_FILTER</td>
<td>UsernamePasswordAuthenticationFilter</td>
<td>http/form-login</td>
</tr>
<tr>
<td>BASIC_AUTH_FILTER</td>
<td>BasicAuthenticationFilter</td>
<td>http/http-basic</td>
</tr>
<tr>
<td>SERVLET_API_SUPPORT_FILTER</td>
<td>SecurityContextHolderAwareRequestFilter</td>
<td>http/@servlet-api-provision</td>
</tr>
<tr>
<td>JAAS_API_SUPPORT_FILTER</td>
<td>JaasApiIntegrationFilter</td>
<td>http/@jaas-api-provision</td>
</tr>
<tr>
<td>REMEMBER_ME_FILTER</td>
<td>RememberMeAuthenticationFilter</td>
<td>http/remember-me</td>
</tr>
<tr>
<td>ANONYMOUS_FILTER</td>
<td>AnonymousAuthenticationFilter</td>
<td>http/anonymous</td>
</tr>
<tr>
<td>SESSION_MANAGEMENT_FILTER</td>
<td>SessionManagementFilter</td>
<td>session-management</td>
</tr>
<tr>
<td>EXCEPTION_TRANSLATION_FILTER</td>
<td>ExceptionTranslationFilter</td>
<td>http</td>
</tr>
<tr>
<td>FILTER_SECURITY_INTERCEPTOR</td>
<td>FilterSecurityInterceptor</td>
<td>http</td>
</tr>
<tr>
<td>SWITCH_USER_FILTER</td>
<td>SwitchUserFilter</td>
<td>N/A</td>
</tr>
</tbody></table>
<p>最重要的是<code>FilterSecurityInterceptor</code>，该过滤器实现了主要的鉴权逻辑，最核心的代码在这里：</p>
<pre><code>protected InterceptorStatusToken beforeInvocation(Object object) &#123;    // 获取访问URL所需权限    Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource()            .getAttributes(object);
    Authentication authenticated = authenticateIfRequired();
    // 通过accessDecisionManager鉴权    try &#123;        this.accessDecisionManager.decide(authenticated, object, attributes);    &#125;    catch (AccessDeniedException accessDeniedException) &#123;        publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated,                accessDeniedException));
        throw accessDeniedException;    &#125;
    if (debug) &#123;        logger.debug(&quot;Authorization successful&quot;);    &#125;
    if (publishAuthorizationSuccess) &#123;        publishEvent(new AuthorizedEvent(object, attributes, authenticated));    &#125;
    // Attempt to run as a different user    Authentication runAs = this.runAsManager.buildRunAs(authenticated, object,            attributes);
    if (runAs == null) &#123;        if (debug) &#123;            logger.debug(&quot;RunAsManager did not change Authentication object&quot;);        &#125;
        // no further work post-invocation        return new InterceptorStatusToken(SecurityContextHolder.getContext(), false,                attributes, object);    &#125;    else &#123;        if (debug) &#123;            logger.debug(&quot;Switching to RunAs Authentication: &quot; + runAs);        &#125;
        SecurityContext origCtx = SecurityContextHolder.getContext();        SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());        SecurityContextHolder.getContext().setAuthentication(runAs);
        // need to revert to token.Authenticated post-invocation        return new InterceptorStatusToken(origCtx, true, attributes, object);    &#125;&#125;
</code></pre>
<p>从上面可以看出，要实现动态鉴权，可以从两方面着手：</p>
<ul>
<li>自定义SecurityMetadataSource，实现从数据库加载ConfigAttribute</li>
<li>另外就是可以自定义accessDecisionManager，官方的UnanimousBased其实足够使用，并且他是基于AccessDecisionVoter来实现权限认证的，因此我们只需要自定义一个AccessDecisionVoter就可以了</li>
</ul>
<p>下面来看分别如何实现。</p>
<h2 id="自定义AccessDecisionManager"><a href="#自定义AccessDecisionManager" class="headerlink" title="自定义AccessDecisionManager"></a>自定义AccessDecisionManager</h2><p>官方的三个AccessDecisionManager都是基于AccessDecisionVoter来实现权限认证的，因此我们只需要自定义一个AccessDecisionVoter就可以了。</p>
<p>自定义主要是实现<code>AccessDecisionVoter</code>接口，我们可以仿照官方的RoleVoter实现一个：</p>
<pre><code>public class RoleBasedVoter implements AccessDecisionVoter&lt;Object&gt; &#123;

    @Override
    public boolean supports(ConfigAttribute attribute) &#123;
        return true;
    &#125;

    @Override
    public int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes) &#123;
        if(authentication == null) &#123;
            return ACCESS_DENIED;
        &#125;
        int result = ACCESS_ABSTAIN;
        Collection&lt;? extends GrantedAuthority&gt; authorities = extractAuthorities(authentication);

        for (ConfigAttribute attribute : attributes) &#123;
            if(attribute.getAttribute()==null)&#123;
                continue;
            &#125;
            if (this.supports(attribute)) &#123;
                result = ACCESS_DENIED;

                // Attempt to find a matching granted authority
                for (GrantedAuthority authority : authorities) &#123;
                    if (attribute.getAttribute().equals(authority.getAuthority())) &#123;
                        return ACCESS_GRANTED;
                    &#125;
                &#125;
            &#125;
        &#125;

        return result;
    &#125;

    Collection&lt;? extends GrantedAuthority&gt; extractAuthorities(
        Authentication authentication) &#123;
        return authentication.getAuthorities();
    &#125;

    @Override
    public boolean supports(Class clazz) &#123;
        return true;
    &#125;
&#125;
</code></pre>
<p>如何加入动态权限呢？</p>
<p><code>vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes) </code>里的<code>Object object</code>的类型是<code>FilterInvocation</code>，可以通过<code>getRequestUrl</code>获取当前请求的URL:</p>
<pre><code>  FilterInvocation fi = (FilterInvocation) object;
  String url = fi.getRequestUrl();
</code></pre>
<p>因此这里扩展空间就大了，可以从DB动态加载，然后判断URL的ConfigAttribute就可以了。</p>
<p>如何使用这个RoleBasedVoter呢？在configure里使用accessDecisionManager方法自定义，我们还是使用官方的<code>UnanimousBased</code>，然后将自定义的RoleBasedVoter加入即可。</p>
<pre><code>@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;

 
    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
            // 自定义accessDecisionManager
            .accessDecisionManager(accessDecisionManager())
          
        .and()
            .apply(securityConfigurerAdapter());

    &#125;


    @Bean
    public AccessDecisionManager accessDecisionManager() &#123;
        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters
            = Arrays.asList(
            new WebExpressionVoter(),
            // new RoleVoter(),
            new RoleBasedVoter(),
            new AuthenticatedVoter());
        return new UnanimousBased(decisionVoters);
    &#125;
</code></pre>
<h2 id="自定义SecurityMetadataSource"><a href="#自定义SecurityMetadataSource" class="headerlink" title="自定义SecurityMetadataSource"></a>自定义SecurityMetadataSource</h2><p>自定义FilterInvocationSecurityMetadataSource只要实现接口即可，在接口里从DB动态加载规则。</p>
<p>为了复用代码里的定义，我们可以将代码里生成的SecurityMetadataSource带上，在构造函数里传入默认的FilterInvocationSecurityMetadataSource。</p>
<pre><code>public class AppFilterInvocationSecurityMetadataSource implements org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource &#123;

    private FilterInvocationSecurityMetadataSource  superMetadataSource;

    @Override
    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123;
        return null;
    &#125;

    public AppFilterInvocationSecurityMetadataSource(FilterInvocationSecurityMetadataSource expressionBasedFilterInvocationSecurityMetadataSource)&#123;
         this.superMetadataSource = expressionBasedFilterInvocationSecurityMetadataSource;

         // TODO 从数据库加载权限配置
    &#125;

    private final AntPathMatcher antPathMatcher = new AntPathMatcher();
    // 这里的需要从DB加载
    private final Map&lt;String,String&gt; urlRoleMap = new HashMap&lt;String,String&gt;()&#123;&#123;
            put("/open/**","ROLE_ANONYMOUS");
            put("/health","ROLE_ANONYMOUS");
            put("/restart","ROLE_ADMIN");
            put("/demo","ROLE_USER");
        &#125;&#125;;

    @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;
        FilterInvocation fi = (FilterInvocation) object;
        String url = fi.getRequestUrl();

        for(Map.Entry&lt;String,String&gt; entry:urlRoleMap.entrySet())&#123;
            if(antPathMatcher.match(entry.getKey(),url))&#123;
                return SecurityConfig.createList(entry.getValue());
            &#125;
        &#125;

        //  返回代码定义的默认配置
        return superMetadataSource.getAttributes(object);
    &#125;



    @Override
    public boolean supports(Class&lt;?&gt; clazz) &#123;
        return FilterInvocation.class.isAssignableFrom(clazz);
    &#125;
&#125;
</code></pre>
<p>怎么使用？和<code>accessDecisionManager</code>不一样，<code>ExpressionUrlAuthorizationConfigurer</code> 并没有提供set方法设置<code>FilterSecurityInterceptor</code>的<code>FilterInvocationSecurityMetadataSource</code>，how to do?</p>
<p>发现一个扩展方法<code>withObjectPostProcessor</code>，通过该方法自定义一个处理<code>FilterSecurityInterceptor</code>类型的<code>ObjectPostProcessor</code>就可以修改<code>FilterSecurityInterceptor</code>。</p>
<pre><code>@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123;

 
    @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
              // 自定义FilterInvocationSecurityMetadataSource
            .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;
                @Override
                public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
                    O fsi) &#123;
                    fsi.setSecurityMetadataSource(mySecurityMetadataSource(fsi.getSecurityMetadataSource()));
                    return fsi;
                &#125;
            &#125;)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;


    @Bean
    public AppFilterInvocationSecurityMetadataSource mySecurityMetadataSource(FilterInvocationSecurityMetadataSource filterInvocationSecurityMetadataSource) &#123;
        AppFilterInvocationSecurityMetadataSource securityMetadataSource = new AppFilterInvocationSecurityMetadataSource(filterInvocationSecurityMetadataSource);
        return securityMetadataSource;
&#125;
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了两种基于spring security实现动态权限的方法，一是自定义accessDecisionManager，二是自定义FilterInvocationSecurityMetadataSource。实际项目里可以根据需要灵活选择。</p>
<p>延伸阅读:</p>
<p><a href="http://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Spring Boot</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 架构与源码分析</title>
    <url>/jadepeng/2018/06/06/jqpeng-Spring%20Security%20%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/spring-security.html">Spring Security 架构与源码分析</a></p>
<p>Spring Security 主要实现了Authentication（认证，解决who are you? ） 和 Access Control（访问控制，也就是what are you allowed to do？，也称为Authorization）。Spring Security在架构上将认证与授权分离，并提供了扩展点。</p>
<h2 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h2><p>主要代码在<code>spring-security-core</code>包下面。要了解Spring Security，需要先关注里面的核心对象。</p>
<h3 id="SecurityContextHolder-SecurityContext-和-Authentication"><a href="#SecurityContextHolder-SecurityContext-和-Authentication" class="headerlink" title="SecurityContextHolder, SecurityContext 和 Authentication"></a>SecurityContextHolder, SecurityContext 和 Authentication</h3><p>SecurityContextHolder 是 SecurityContext的存放容器，默认使用ThreadLocal 存储，意味SecurityContext在相同线程中的方法都可用。<br> SecurityContext主要是存储应用的principal信息，在Spring Security中用Authentication 来表示。</p>
<p>获取principal：</p>
<pre><code>Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

if (principal instanceof UserDetails) &#123;
String username = ((UserDetails)principal).getUsername();
&#125; else &#123;
String username = principal.toString();
&#125;
</code></pre>
<p>在Spring Security中，可以看一下Authentication定义：</p>
<pre><code>public interface Authentication extends Principal, Serializable &#123;
Collection&lt;? extends GrantedAuthority&gt; getAuthorities();
/** * 通常是密码 */Object getCredentials();
/** * Stores additional details about the authentication request. These might be an IP * address, certificate serial number etc. */Object getDetails();
/** * 用来标识是否已认证，如果使用用户名和密码登录,通常是用户名  */Object getPrincipal();
/** * 是否已认证 */boolean isAuthenticated();
void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
&#125;
</code></pre>
<p>在实际应用中，通常使用<code>UsernamePasswordAuthenticationToken</code>：</p>
<pre><code>public abstract class AbstractAuthenticationToken implements Authentication,    CredentialsContainer &#123;    &#125;
public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken &#123;
&#125;
</code></pre>
<p>一个常见的认证过程通常是这样的，创建一个UsernamePasswordAuthenticationToken，然后交给authenticationManager认证（后面详细说明），认证通过则通过SecurityContextHolder存放Authentication信息。</p>
<pre><code> UsernamePasswordAuthenticationToken authenticationToken =
            new UsernamePasswordAuthenticationToken(loginVM.getUsername(), loginVM.getPassword());

Authentication authentication = this.authenticationManager.authenticate(authenticationToken);
SecurityContextHolder.getContext().setAuthentication(authentication);
</code></pre>
<h3 id="UserDetails与UserDetailsService"><a href="#UserDetails与UserDetailsService" class="headerlink" title="UserDetails与UserDetailsService"></a>UserDetails与UserDetailsService</h3><p>UserDetails 是Spring Security里的一个关键接口，他用来表示一个principal。</p>
<pre><code>public interface UserDetails extends Serializable &#123;/** * 用户的授权信息，可以理解为角色 */Collection&lt;? extends GrantedAuthority&gt; getAuthorities();
/** * 用户密码 * * @return the password */String getPassword();
/** * 用户名  *     */String getUsername();
boolean isAccountNonExpired();
boolean isAccountNonLocked();
boolean isCredentialsNonExpired();
boolean isEnabled();
&#125;
</code></pre>
<p>UserDetails提供了认证所需的必要信息，在实际使用里，可以自己实现UserDetails，并增加额外的信息，比如email、mobile等信息。</p>
<p>在Authentication中的principal通常是用户名，我们可以通过UserDetailsService来通过principal获取UserDetails：</p>
<pre><code>public interface UserDetailsService &#123;UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
&#125;
</code></pre>
<h3 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h3><p>在UserDetails里说了，GrantedAuthority可以理解为角色，例如 <code>ROLE_ADMINISTRATOR</code> or <code>ROLE_HR_SUPERVISOR</code>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><code>SecurityContextHolder</code>, 用来访问 <code>SecurityContext</code>.</li>
<li><code>SecurityContext</code>, 用来存储<code>Authentication</code> .</li>
<li><code>Authentication</code>, 代表凭证.</li>
<li><code>GrantedAuthority</code>, 代表权限.</li>
<li><code>UserDetails</code>, 用户信息.</li>
<li><code>UserDetailsService</code>,获取用户信息.</li>
</ul>
<h2 id="Authentication认证"><a href="#Authentication认证" class="headerlink" title="Authentication认证"></a>Authentication认证</h2><h3 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h3><p>实现认证主要是通过AuthenticationManager接口，它只包含了一个方法：</p>
<pre><code>public interface AuthenticationManager &#123;
  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
&#125;
</code></pre>
<p>authenticate()方法主要做三件事：</p>
<ol>
<li>如果验证通过，返回Authentication（通常带上authenticated=true）。</li>
<li>认证失败抛出<code>AuthenticationException</code></li>
<li>如果无法确定，则返回null</li>
</ol>
<p><code>AuthenticationException</code>是运行时异常,它通常由应用程序按通用方式处理，用户代码通常不用特意被捕获和处理这个异常。</p>
<p><code>AuthenticationManager</code>的默认实现是<code>ProviderManager</code>，它委托一组<code>AuthenticationProvider</code>实例来实现认证。<br><code>AuthenticationProvider</code>和<code>AuthenticationManager</code>类似，都包含<code>authenticate</code>，但它有一个额外的方法<code>supports</code>，以允许查询调用方是否支持给定<code>Authentication</code>类型：</p>
<pre><code>public interface AuthenticationProvider &#123;
Authentication authenticate(Authentication authentication)        throws AuthenticationException;boolean supports(Class&lt;?&gt; authentication);
&#125;
</code></pre>
<p>ProviderManager包含一组<code>AuthenticationProvider</code>，执行authenticate时，遍历Providers，然后调用supports，如果支持，则执行遍历当前provider的authenticate方法，如果一个provider认证成功，则break。</p>
<pre><code>public Authentication authenticate(Authentication authentication)        throws AuthenticationException &#123;    Class&lt;? extends Authentication&gt; toTest = authentication.getClass();    AuthenticationException lastException = null;    Authentication result = null;    boolean debug = logger.isDebugEnabled();
    for (AuthenticationProvider provider : getProviders()) &#123;        if (!provider.supports(toTest)) &#123;            continue;        &#125;
        if (debug) &#123;            logger.debug(&quot;Authentication attempt using &quot;                    + provider.getClass().getName());        &#125;
        try &#123;            result = provider.authenticate(authentication);
            if (result != null) &#123;                copyDetails(authentication, result);                break;            &#125;        &#125;        catch (AccountStatusException e) &#123;            prepareException(e, authentication);            // SEC-546: Avoid polling additional providers if auth failure is due to            // invalid account status            throw e;        &#125;        catch (InternalAuthenticationServiceException e) &#123;            prepareException(e, authentication);            throw e;        &#125;        catch (AuthenticationException e) &#123;            lastException = e;        &#125;    &#125;
    if (result == null &amp;&amp; parent != null) &#123;        // Allow the parent to try.        try &#123;            result = parent.authenticate(authentication);        &#125;        catch (ProviderNotFoundException e) &#123;            // ignore as we will throw below if no other exception occurred prior to            // calling parent and the parent            // may throw ProviderNotFound even though a provider in the child already            // handled the request        &#125;        catch (AuthenticationException e) &#123;            lastException = e;        &#125;    &#125;
    if (result != null) &#123;        if (eraseCredentialsAfterAuthentication                &amp;&amp; (result instanceof CredentialsContainer)) &#123;            // Authentication is complete. Remove credentials and other secret data            // from authentication            ((CredentialsContainer) result).eraseCredentials();        &#125;
        eventPublisher.publishAuthenticationSuccess(result);        return result;    &#125;
    // Parent was null, or didn&#39;t authenticate (or throw an exception).
    if (lastException == null) &#123;        lastException = new ProviderNotFoundException(messages.getMessage(                &quot;ProviderManager.providerNotFound&quot;,                new Object[] &#123; toTest.getName() &#125;,                &quot;No AuthenticationProvider found for &#123;0&#125;&quot;));    &#125;
    prepareException(lastException, authentication);
    throw lastException;&#125;
</code></pre>
<p>从上面的代码可以看出， <code>ProviderManager</code>有一个可选parent，如果parent不为空，则调用<code>parent.authenticate(authentication)</code></p>
<h3 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h3><p><code>AuthenticationProvider</code>有多种实现，大家最关注的通常是<code>DaoAuthenticationProvider</code>，继承于<code>AbstractUserDetailsAuthenticationProvider</code>，核心是通过<code>UserDetails</code>来实现认证,<code>DaoAuthenticationProvider</code>默认会自动加载，不用手动配。</p>
<p>先来看<code>AbstractUserDetailsAuthenticationProvide</code>r，看最核心的<code>authenticate</code>：</p>
<pre><code>public Authentication authenticate(Authentication authentication)        throws AuthenticationException &#123;    // 必须是UsernamePasswordAuthenticationToken    Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,            messages.getMessage(                    &quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;,                    &quot;Only UsernamePasswordAuthenticationToken is supported&quot;));
    //  获取用户名    String username = (authentication.getPrincipal() == null) ? &quot;NONE_PROVIDED&quot;            : authentication.getName();
    boolean cacheWasUsed = true;    // 从缓存获取    UserDetails user = this.userCache.getUserFromCache(username);
    if (user == null) &#123;        cacheWasUsed = false;
        try &#123;           // retrieveUser 抽象方法，获取用户            user = retrieveUser(username,                    (UsernamePasswordAuthenticationToken) authentication);        &#125;        catch (UsernameNotFoundException notFound) &#123;            logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;);
            if (hideUserNotFoundExceptions) &#123;                throw new BadCredentialsException(messages.getMessage(                        &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                        &quot;Bad credentials&quot;));            &#125;            else &#123;                throw notFound;            &#125;        &#125;
          Assert.notNull(user,                &quot;retrieveUser returned null - a violation of the interface contract&quot;);    &#125;
    try &#123;        // 预先检查，DefaultPreAuthenticationChecks，检查用户是否被lock或者账号是否可用        preAuthenticationChecks.check(user);                // 抽象方法，自定义检验        additionalAuthenticationChecks(user,                (UsernamePasswordAuthenticationToken) authentication);    &#125;    catch (AuthenticationException exception) &#123;        if (cacheWasUsed) &#123;            // There was a problem, so try again after checking            // we&#39;re using latest data (i.e. not from the cache)            cacheWasUsed = false;            user = retrieveUser(username,                    (UsernamePasswordAuthenticationToken) authentication);            preAuthenticationChecks.check(user);            additionalAuthenticationChecks(user,                    (UsernamePasswordAuthenticationToken) authentication);        &#125;        else &#123;            throw exception;        &#125;    &#125;
          // 后置检查 DefaultPostAuthenticationChecks，检查isCredentialsNonExpired    postAuthenticationChecks.check(user);
    if (!cacheWasUsed) &#123;        this.userCache.putUserInCache(user);    &#125;
    Object principalToReturn = user;
    if (forcePrincipalAsString) &#123;        principalToReturn = user.getUsername();    &#125;
       return createSuccessAuthentication(principalToReturn, authentication, user);&#125;
</code></pre>
<p>上面的检验主要基于UserDetails实现，其中获取用户和检验逻辑由具体的类去实现，默认实现是DaoAuthenticationProvider，这个类的核心是让开发者提供UserDetailsService来获取UserDetails以及 PasswordEncoder来检验密码是否有效：</p>
<pre><code>private UserDetailsService userDetailsService;
private PasswordEncoder passwordEncoder;
</code></pre>
<p>看具体的实现，<code>retrieveUser</code>,直接调用userDetailsService获取用户：</p>
<pre><code>protected final UserDetails retrieveUser(String username,        UsernamePasswordAuthenticationToken authentication)        throws AuthenticationException &#123;    UserDetails loadedUser;
    try &#123;        loadedUser = this.getUserDetailsService().loadUserByUsername(username);    &#125;    catch (UsernameNotFoundException notFound) &#123;        if (authentication.getCredentials() != null) &#123;            String presentedPassword = authentication.getCredentials().toString();            passwordEncoder.isPasswordValid(userNotFoundEncodedPassword,                    presentedPassword, null);        &#125;        throw notFound;    &#125;    catch (Exception repositoryProblem) &#123;        throw new InternalAuthenticationServiceException(                repositoryProblem.getMessage(), repositoryProblem);    &#125;
    if (loadedUser == null) &#123;        throw new InternalAuthenticationServiceException(                &quot;UserDetailsService returned null, which is an interface contract violation&quot;);    &#125;    return loadedUser;&#125;
</code></pre>
<p>再来看验证：</p>
<pre><code>protected void additionalAuthenticationChecks(UserDetails userDetails,        UsernamePasswordAuthenticationToken authentication)        throws AuthenticationException &#123;    Object salt = null;
    if (this.saltSource != null) &#123;        salt = this.saltSource.getSalt(userDetails);    &#125;
    if (authentication.getCredentials() == null) &#123;        logger.debug(&quot;Authentication failed: no credentials provided&quot;);
        throw new BadCredentialsException(messages.getMessage(                &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                &quot;Bad credentials&quot;));    &#125;
        // 获取用户密码    String presentedPassword = authentication.getCredentials().toString();
        // 比较passwordEncoder后的密码是否和userdetails的密码一致    if (!passwordEncoder.isPasswordValid(userDetails.getPassword(),            presentedPassword, salt)) &#123;        logger.debug(&quot;Authentication failed: password does not match stored value&quot;);
        throw new BadCredentialsException(messages.getMessage(                &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;,                &quot;Bad credentials&quot;));    &#125;&#125;
</code></pre>
<p>小结：要自定义认证，使用DaoAuthenticationProvider，只需要为其提供PasswordEncoder和UserDetailsService就可以了。</p>
<h3 id="定制-Authentication-Managers"><a href="#定制-Authentication-Managers" class="headerlink" title="定制 Authentication Managers"></a>定制 Authentication Managers</h3><p>Spring Security提供了一个Builder类<code>AuthenticationManagerBuilder</code>，借助它可以快速实现自定义认证。</p>
<p>看官方源码说明：</p>
<blockquote>
<p>SecurityBuilder used to create an AuthenticationManager . Allows for easily building in memory authentication, LDAP authentication, JDBC based authentication, adding UserDetailsService , and adding AuthenticationProvider’s.</p>
</blockquote>
<p>AuthenticationManagerBuilder可以用来Build一个AuthenticationManager，可以创建基于内存的认证、LDAP认证、 JDBC认证，以及添加UserDetailsService和AuthenticationProvider。</p>
<p>简单使用：</p>
<pre><code>@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class ApplicationSecurity extends WebSecurityConfigurerAdapter &#123;


  public SecurityConfiguration(AuthenticationManagerBuilder authenticationManagerBuilder, UserDetailsService userDetailsService,TokenProvider tokenProvider,CorsFilter corsFilter, SecurityProblemSupport problemSupport) &#123;
        this.authenticationManagerBuilder = authenticationManagerBuilder;
        this.userDetailsService = userDetailsService;
        this.tokenProvider = tokenProvider;
        this.corsFilter = corsFilter;
        this.problemSupport = problemSupport;
    &#125;

    @PostConstruct
    public void init() &#123;
        try &#123;
            authenticationManagerBuilder
                .userDetailsService(userDetailsService)
                .passwordEncoder(passwordEncoder());
        &#125; catch (Exception e) &#123;
            throw new BeanInitializationException(&quot;Security configuration failed&quot;, e);
        &#125;
    &#125;

   @Override
    protected void configure(HttpSecurity http) throws Exception &#123;
        http
            .addFilterBefore(corsFilter, UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(problemSupport)
            .accessDeniedHandler(problemSupport)
        .and()
            .csrf()
            .disable()
            .headers()
            .frameOptions()
            .disable()
        .and()
            .sessionManagement()
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and()
            .authorizeRequests()
            .antMatchers(&quot;/api/register&quot;).permitAll()
            .antMatchers(&quot;/api/activate&quot;).permitAll()
            .antMatchers(&quot;/api/authenticate&quot;).permitAll()
            .antMatchers(&quot;/api/account/reset-password/init&quot;).permitAll()
            .antMatchers(&quot;/api/account/reset-password/finish&quot;).permitAll()
            .antMatchers(&quot;/api/profile-info&quot;).permitAll()
            .antMatchers(&quot;/api/**&quot;).authenticated()
            .antMatchers(&quot;/management/health&quot;).permitAll()
            .antMatchers(&quot;/management/**&quot;).hasAuthority(AuthoritiesConstants.ADMIN)
            .antMatchers(&quot;/v2/api-docs/**&quot;).permitAll()
            .antMatchers(&quot;/swagger-resources/configuration/ui&quot;).permitAll()
            .antMatchers(&quot;/swagger-ui/index.html&quot;).hasAuthority(AuthoritiesConstants.ADMIN)
        .and()
            .apply(securityConfigurerAdapter());

    &#125;
&#125;
</code></pre>
<h2 id="授权与访问控制"><a href="#授权与访问控制" class="headerlink" title="授权与访问控制"></a>授权与访问控制</h2><p>一旦认证成功，我们可以继续进行授权，授权是通过<code>AccessDecisionManager</code>来实现的。框架有三种实现，默认是AffirmativeBased，通过<code>AccessDecisionVoter</code>决策，有点像<code>ProviderManager</code>委托给<code>AuthenticationProviders</code>来认证。</p>
<pre><code>public void decide(Authentication authentication, Object object,        Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException &#123;    int deny = 0;
        // 遍历DecisionVoter     for (AccessDecisionVoter voter : getDecisionVoters()) &#123;        // 投票        int result = voter.vote(authentication, object, configAttributes);
        if (logger.isDebugEnabled()) &#123;            logger.debug(&quot;Voter: &quot; + voter + &quot;, returned: &quot; + result);        &#125;
        switch (result) &#123;        case AccessDecisionVoter.ACCESS_GRANTED:            return;
        case AccessDecisionVoter.ACCESS_DENIED:            deny++;
            break;
        default:            break;        &#125;    &#125;
           // 一票否决    if (deny &gt; 0) &#123;        throw new AccessDeniedException(messages.getMessage(                &quot;AbstractAccessDecisionManager.accessDenied&quot;, &quot;Access is denied&quot;));    &#125;
    // To get this far, every AccessDecisionVoter abstained    checkAllowIfAllAbstainDecisions();&#125;
</code></pre>
<p>来看AccessDecisionVoter：</p>
<pre><code>boolean supports(ConfigAttribute attribute);

boolean supports(Class&lt;?&gt; clazz);

int vote(Authentication authentication, S object,
        Collection&lt;ConfigAttribute&gt; attributes);
</code></pre>
<p>object是用户要访问的资源，ConfigAttribute则是访问object要满足的条件，通常payload是字符串，比如ROLE_ADMIN 。所以我们来看下RoleVoter的实现，其核心就是从authentication提取出GrantedAuthority，然后和ConfigAttribute比较是否满足条件。</p>
<pre><code>public boolean supports(ConfigAttribute attribute) &#123;    if ((attribute.getAttribute() != null)            &amp;&amp; attribute.getAttribute().startsWith(getRolePrefix())) &#123;        return true;    &#125;    else &#123;        return false;    &#125;&#125;
public boolean supports(Class&lt;?&gt; clazz) &#123;    return true;&#125;


public int vote(Authentication authentication, Object object,        Collection&lt;ConfigAttribute&gt; attributes) &#123;    if(authentication == null) &#123;        return ACCESS_DENIED;    &#125;    int result = ACCESS_ABSTAIN;        // 获取GrantedAuthority信息    Collection&lt;? extends GrantedAuthority&gt; authorities = extractAuthorities(authentication);
    for (ConfigAttribute attribute : attributes) &#123;        if (this.supports(attribute)) &#123;            // 默认拒绝访问            result = ACCESS_DENIED;
            // Attempt to find a matching granted authority            for (GrantedAuthority authority : authorities) &#123;                 // 判断是否有匹配的 authority                if (attribute.getAttribute().equals(authority.getAuthority())) &#123;                    // 可访问                    return ACCESS_GRANTED;                &#125;            &#125;        &#125;    &#125;
    return result;&#125;
</code></pre>
<p>这里要疑问，ConfigAttribute哪来的？其实就是上面ApplicationSecurity的configure里的。</p>
<h3 id="web-security-如何实现"><a href="#web-security-如何实现" class="headerlink" title="web security 如何实现"></a>web security 如何实现</h3><p>Web层中的Spring Security（用于UI和HTTP后端）基于Servlet <code>Filters</code>，下图显示了单个HTTP请求的处理程序的典型分层。</p>
<p><img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/filters.png" alt="过滤链委托给一个Servlet"></p>
<p>Spring Security通过<code>FilterChainProxy</code>作为单一的Filter注册到web层，Proxy内部的Filter。</p>
<p><img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/security-filters.png" alt="Spring安全筛选器"></p>
<p>FilterChainProxy相当于一个filter的容器，通过VirtualFilterChain来依次调用各个内部filter</p>
<pre><code>public void doFilter(ServletRequest request, ServletResponse response,        FilterChain chain) throws IOException, ServletException &#123;    boolean clearContext = request.getAttribute(FILTER_APPLIED) == null;    if (clearContext) &#123;        try &#123;            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);            doFilterInternal(request, response, chain);        &#125;        finally &#123;            SecurityContextHolder.clearContext();            request.removeAttribute(FILTER_APPLIED);        &#125;    &#125;    else &#123;        doFilterInternal(request, response, chain);    &#125;&#125;
private void doFilterInternal(ServletRequest request, ServletResponse response,        FilterChain chain) throws IOException, ServletException &#123;
    FirewalledRequest fwRequest = firewall            .getFirewalledRequest((HttpServletRequest) request);    HttpServletResponse fwResponse = firewall            .getFirewalledResponse((HttpServletResponse) response);
    List&lt;Filter&gt; filters = getFilters(fwRequest);
    if (filters == null || filters.size() == 0) &#123;        if (logger.isDebugEnabled()) &#123;            logger.debug(UrlUtils.buildRequestUrl(fwRequest)                    + (filters == null ? &quot; has no matching filters&quot;                            : &quot; has an empty filter list&quot;));        &#125;
        fwRequest.reset();
        chain.doFilter(fwRequest, fwResponse);
        return;    &#125;
    VirtualFilterChain vfc = new VirtualFilterChain(fwRequest, chain, filters);    vfc.doFilter(fwRequest, fwResponse);&#125;private static class VirtualFilterChain implements FilterChain &#123;    private final FilterChain originalChain;    private final List&lt;Filter&gt; additionalFilters;    private final FirewalledRequest firewalledRequest;    private final int size;    private int currentPosition = 0;
    private VirtualFilterChain(FirewalledRequest firewalledRequest,            FilterChain chain, List&lt;Filter&gt; additionalFilters) &#123;        this.originalChain = chain;        this.additionalFilters = additionalFilters;        this.size = additionalFilters.size();        this.firewalledRequest = firewalledRequest;    &#125;
    public void doFilter(ServletRequest request, ServletResponse response)            throws IOException, ServletException &#123;        if (currentPosition == size) &#123;            if (logger.isDebugEnabled()) &#123;                logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)                        + &quot; reached end of additional filter chain; proceeding with original chain&quot;);            &#125;
            // Deactivate path stripping as we exit the security filter chain            this.firewalledRequest.reset();
            originalChain.doFilter(request, response);        &#125;        else &#123;            currentPosition++;
            Filter nextFilter = additionalFilters.get(currentPosition - 1);
            if (logger.isDebugEnabled()) &#123;                logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)                        + &quot; at position &quot; + currentPosition + &quot; of &quot; + size                        + &quot; in additional filter chain; firing Filter: &#39;&quot;                        + nextFilter.getClass().getSimpleName() + &quot;&#39;&quot;);            &#125;
            nextFilter.doFilter(request, response, this);        &#125;    &#125;&#125;
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://spring.io/guides/topicals/spring-security-architecture/">https://spring.io/guides/topicals/spring-security-architecture/</a></li>
<li><a href="https://docs.spring.io/spring-security/site/docs/5.0.5.RELEASE/reference/htmlsingle/#overall-architecture">https://docs.spring.io/spring-security/site/docs/5.0.5.RELEASE/reference/htmlsingle/#overall-architecture</a></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>开源APM系统skywalking介绍与使用</title>
    <url>/jadepeng/2018/05/28/jqpeng-%E5%BC%80%E6%BA%90APM%E7%B3%BB%E7%BB%9Fskywalking%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/skywalking-usage.html">开源APM系统skywalking介绍与使用</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>SkyWalking</strong> 创建与2015年，提供分布式追踪功能。从5.x开始，项目进化为一个完成功能的<a href="https://en.wikipedia.org/wiki/Application_performance_management">Application Performance Management</a>系统。<br> 他被用于追踪、监控和诊断分布式系统，特别是使用微服务架构，云原生或容积技术。提供以下主要功能：</p>
<ul>
<li>分布式追踪和上下文传输</li>
<li>应用、实例、服务性能指标分析</li>
<li>根源分析</li>
<li>应用拓扑分析</li>
<li>应用和服务依赖分析</li>
<li>慢服务检测</li>
<li>性能优化</li>
</ul>
<h3 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h3><ul>
<li>多语言探针或类库<ul>
<li>Java自动探针，追踪和监控程序时，不需要修改源码。</li>
<li>社区提供的其他多语言探针<ul>
<li><a href="https://github.com/OpenSkywalking/skywalking-netcore">.NET Core</a></li>
<li><a href="https://github.com/OpenSkywalking/skywalking-nodejs">Node.js</a></li>
</ul>
</li>
</ul>
</li>
<li>多种后端存储： ElasticSearch， H2</li>
<li>支持<a href="http://opentracing.io/">OpenTracing</a><ul>
<li>Java自动探针支持和OpenTracing API协同工作</li>
</ul>
</li>
<li>轻量级、完善功能的后端聚合和分析</li>
<li>现代化Web UI</li>
<li>日志集成</li>
<li>应用、实例和服务的告警</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://skywalkingtest.github.io/page-resources/5.0/architecture.png"></p>
<h3 id="在线体验"><a href="#在线体验" class="headerlink" title="在线体验"></a>在线体验</h3><ul>
<li>北京服务器. <a href="http://49.4.12.44:8080/">前往</a></li>
<li>香港服务器. <a href="http://159.138.0.181:8080/">前往</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装es"><a href="#安装es" class="headerlink" title="安装es"></a>安装es</h3><p>新版本的skywalking使用ES作为存储，所以先安装es，注意6.X版本不行，安装5.6.8：</p>
<pre><code>wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.8.tar.gz
tar zxvf elasticsearch-5.6.8.tar.gz
cd elasticsearch-5.6.8/
</code></pre>
<p>修改配置文件，主要修改cluster.name，并增加两行配置，<br> vim config/elasticsearch.yml：</p>
<pre><code>cluster.name: CollectorDBCluster

# ES监听的ip地址
network.host: 0.0.0.0
thread_pool.bulk.queue_size: 1000
</code></pre>
<p>保存，然后启动es：</p>
<pre><code>nohup bin/elasticsearch &amp;
</code></pre>
<h3 id="安装skywalking"><a href="#安装skywalking" class="headerlink" title="安装skywalking"></a>安装skywalking</h3><p>先下载编译好的版本并解压：</p>
<pre><code>wget http://mirrors.hust.edu.cn/apache/incubator/skywalking/5.0.0-beta/apache-skywalking-apm-incubating-5.0.0-beta.tar.gz
tar zxvf apache-skywalking-apm-incubating-5.0.0-beta.tar.gz 
cd apache-skywalking-apm-incubating/
</code></pre>
<p>然后部署，注意skywalking会使用(8080, 10800, 11800, 12800)端口，因此先排除端口占用情况。</p>
<p>然后运行bin/startup.sh，windows用户为.bat文件。</p>
<p>一切正常的话，访问localhost:8080就能看到页面了。</p>
<h4 id="安装过程问题解决"><a href="#安装过程问题解决" class="headerlink" title="安装过程问题解决"></a>安装过程问题解决</h4><ol>
<li>启动bin/startup.sh后，提示success，但是不能访问，ps 查看并无相关进程，经过检查发现是端口被占用</li>
<li>collector 不能正常启动，发现是es问题：<ul>
<li>es需要使用5.x版本</li>
<li>es的集群名称需要和collector的配置文件一致</li>
</ul>
</li>
</ol>
<h3 id="java程序使用skywalking探针"><a href="#java程序使用skywalking探针" class="headerlink" title="java程序使用skywalking探针"></a>java程序使用skywalking探针</h3><p>1.拷贝apache-skywalking-apm-incubating目录下的agent目录到应用程序位置，探针包含整个目录，请不要改变目录结构<br> 2.java程序启动时，增加JVM启动参数，-javaagent:/path/to/agent/skywalking-agent.jar。参数值为skywalking-agent.jar的绝对路径</p>
<p>在IDEA里调试程序怎么办？</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1527477582714.jpg" alt="enter description here" title="IDEA 配置"></p>
<p>增加VM参数即可。</p>
<p>agent探针配置，简单修改下agent.application_code即可</p>
<pre><code># 当前的应用编码，最终会显示在webui上。
# 建议一个应用的多个实例，使用有相同的application_code。请使用英文
agent.application_code=Your_ApplicationName

# 每三秒采样的Trace数量
# 默认为负数，代表在保证不超过内存Buffer区的前提下，采集所有的Trace
# agent.sample_n_per_3_secs=-1

# 设置需要忽略的请求地址
# 默认配置如下
# agent.ignore_suffix=.jpg,.jpeg,.js,.css,.png,.bmp,.gif,.ico,.mp3,.mp4,.html,.svg

# 探针调试开关，如果设置为true，探针会将所有操作字节码的类输出到/debugging目录下
# skywalking团队可能在调试，需要此文件
# agent.is_open_debugging_class = true

# 对应Collector的config/application.yml配置文件中 agent_server/jetty/port 配置内容
# 例如：
# 单节点配置：SERVERS=&quot;127.0.0.1:8080&quot; 
# 集群配置：SERVERS=&quot;10.2.45.126:8080,10.2.45.127:7600&quot; 
collector.servers=127.0.0.1:10800

# 日志文件名称前缀
logging.file_name=skywalking-agent.log

# 日志文件最大大小
# 如果超过此大小，则会生成新文件。
# 默认为300M
logging.max_file_size=314572800

# 日志级别，默认为DEBUG。
logging.level=DEBUG
</code></pre>
<p>一切正常的话，稍后就可以在skywalking ui看到了。</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1527477724637.jpg" alt="enter description here" title="SW UI"></p>
<p>可以看到累出了slow service等信息，更多的细节慢慢挖掘吧。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>apm</tag>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>SkyWalking</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱学习笔记（1）</title>
    <url>/jadepeng/2018/05/04/jqpeng-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/kg-study-part-1.html">知识图谱学习笔记（1）</a></p>
<p>知识图谱学习笔记第一部分，包含RDF介绍，以及Jena RDF API使用</p>
<h2 id="知识图谱的基石：RDF"><a href="#知识图谱的基石：RDF" class="headerlink" title="知识图谱的基石：RDF"></a>知识图谱的基石：RDF</h2><p>RDF(Resource Description Framework)，即资源描述框架，其本质是一个数据模型（Data Model）。它提供了一个统一的标准，用于描述实体/资源。简单来说，就是表示事物的一种方法和手段。<br><img src="https://pic2.zhimg.com/80/v2-e3478e02c36ead3875e598b0668830fd_hd.jpg" alt="enter description here"></p>
<h3 id="RDF序列化方法"><a href="#RDF序列化方法" class="headerlink" title="RDF序列化方法"></a>RDF序列化方法</h3><p>RDF序列化的方式主要有：RDF/XML，N-Triples，Turtle，RDFa，JSON-LD等几种。</p>
<ol>
<li>RDF/XML，顾名思义，就是用XML的格式来表示RDF数据</li>
<li>N-Triples，即用多个三元组来表示RDF数据集，是最直观的表示方法。在文件中，每一行表示一个三元组，方便机器解析和处理。开放领域知识图谱DBpedia通常是用这种格式来发布数据的。</li>
<li>Turtle, [‘tɝtl] 应该是使用得最多的一种RDF序列化方式了。它比RDF/XML紧凑，且可读性比N-Triples好。</li>
<li>RDFa,即“The Resource Description Framework in Attributes”，是HTML5的一个扩展，在不改变任何显示效果的情况下，让网站构建者能够在页面中标记实体，像人物、地点、时间、评论等等</li>
<li>JSON-LD，即“JSON for Linking Data”，用键值对的方式来存储RDF数据</li>
</ol>
<p>Example1 N-Triples:</p>
<pre><code>&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/chineseName&gt; &quot;罗纳尔多·路易斯·纳萨里奥·德·利马&quot;^^string.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/career&gt; &quot;足球运动员&quot;^^string.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/fullName&gt; &quot;Ronaldo Luís Nazário de Lima&quot;^^string.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/birthDate&gt; &quot;1976-09-18&quot;^^date.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/height&gt; &quot;180&quot;^^int.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/weight&gt; &quot;98&quot;^^int.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/nationality&gt; &quot;巴西&quot;^^string.
&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/hasBirthPlace&gt; &lt;http://www.kg.com/place/10086&gt;.
&lt;http://www.kg.com/place/10086&gt; &lt;http://www.kg.com/ontology/address&gt; &quot;里约热内卢&quot;^^string.
&lt;http://www.kg.com/place/10086&gt; &lt;http://www.kg.com/ontology/coordinate&gt; &quot;-22.908333, -43.196389&quot;^^string.
</code></pre>
<p>Example2 Turtle:</p>
<pre><code>@prefix person: &lt;http://www.kg.com/person/&gt; .
@prefix place: &lt;http://www.kg.com/place/&gt; .
@prefix : &lt;http://www.kg.com/ontology/&gt; .

person:1 :chineseName &quot;罗纳尔多·路易斯·纳萨里奥·德·利马&quot;^^string.
person:1 :career &quot;足球运动员&quot;^^string.
person:1 :fullName &quot;Ronaldo Luís Nazário de Lima&quot;^^string.
person:1 :birthDate &quot;1976-09-18&quot;^^date.
person:1 :height &quot;180&quot;^^int. 
person:1 :weight &quot;98&quot;^^int.
person:1 :nationality &quot;巴西&quot;^^string. 
person:1 :hasBirthPlace place:10086.
place:10086 :address &quot;里约热内卢&quot;^^string.
place:10086 :coordinate &quot;-22.908333, -43.196389&quot;^^string.
</code></pre>
<h3 id="RDF的表达能力"><a href="#RDF的表达能力" class="headerlink" title="RDF的表达能力"></a>RDF的表达能力</h3><p>RDF的表达能力有限，无法区分类和对象，也无法定义和描述类的关系/属性。RDF是对具体事物的描述，缺乏抽象能力，无法对同一个类别的事物进行定义和描述。就以罗纳尔多这个知识图为例，RDF能够表达罗纳尔多和里约热内卢这两个实体具有哪些属性，以及它们之间的关系。但如果我们想定义罗纳尔多是人，里约热内卢是地点，并且人具有哪些属性，地点具有哪些属性，人和地点之间存在哪些关系，这个时候RDF就表示无能为力了。</p>
<h2 id="RDFS-OWL"><a href="#RDFS-OWL" class="headerlink" title="RDFS/OWL"></a>RDFS/OWL</h2><p>RDFS/OWL本质上是一些预定义词汇（vocabulary）构成的集合，用于对RDF进行类似的类定义及其属性的定义。</p>
<blockquote>
<p>RDFS/OWL序列化方式和RDF没什么不同，其实在表现形式上，它们就是RDF。其常用的方式主要是RDF/XML，Turtle。另外，通常我们用小写开头的单词或词组来表示属性，大写开头的表示类。数据属性（data property，实体和literal字面量的关系）通常由名词组成，而对象数据（object property，实体和实体之间的关系）通常由动词（has，is之类的）加名词组成。剩下的部分符合驼峰命名法。</p>
</blockquote>
<h3 id="轻量级的模式语言——RDFS"><a href="#轻量级的模式语言——RDFS" class="headerlink" title="轻量级的模式语言——RDFS"></a>轻量级的模式语言——RDFS</h3><p>RDFS，即“Resource Description Framework Schema”，是最基础的模式语言。还是以罗纳尔多知识图为例，我们在概念、抽象层面对RDF数据进行定义。下面的RDFS定义了人和地点这两个类，及每个类包含的属性。</p>
<pre><code>@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix : &lt;http://www.kg.com/ontology/&gt; .

### 这里我们用词汇rdfs:Class定义了“人”和“地点”这两个类。
:Person rdf:type rdfs:Class.
:Place rdf:type rdfs:Class.

### rdfs当中不区分数据属性和对象属性，词汇rdf:Property定义了属性，即RDF的“边”。

:chineseName rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:string .

:career rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:string .

:fullName rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:string .

:birthDate rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:date .

:height rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:int .

:weight rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:int .

:nationality rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range xsd:string .

:hasBirthPlace rdf:type rdf:Property;    rdfs:domain :Person;    rdfs:range :Place .

:address rdf:type rdf:Property;    rdfs:domain :Place;    rdfs:range xsd:string .

:coordinate rdf:type rdf:Property;    rdfs:domain :Place;    rdfs:range xsd:string .
</code></pre>
<p>RDFS几个比较重要，常用的词汇：</p>
<ol>
<li>rdfs:Class. 用于定义类</li>
<li>rdfs:domain. 用于表示该属性属于哪个类别</li>
<li>rdfs:range. 用于描述该属性的取值类型</li>
<li>rdfs:subClassOf. 用于描述该类的父类</li>
<li>rdfs:subProperty. 用于描述该属性的父属性</li>
</ol>
<p><img src="https://pic3.zhimg.com/v2-9950314f9ab6e6c44a2300d03e022bb1_r.jpg" alt="enter description here"></p>
<p>Data层是我们用RDF对罗纳尔多知识图的具体描述，Vocabulary是我们自己定义的一些词汇（类别，属性），RDF(S)则是预定义词汇。从下到上是一个具体到抽象的过程。图中我们用红色圆角矩形表示类，绿色字体表示rdf:type，rdfs:domain，rdfs:range三种预定义词汇，虚线表示rdf:type这种所属关系。</p>
<h3 id="RDFS的扩展——OWL"><a href="#RDFS的扩展——OWL" class="headerlink" title="RDFS的扩展——OWL"></a>RDFS的扩展——OWL</h3><p>RDFS本质上是RDF词汇的一个扩展。后来人们发现RDFS的表达能力还是相当有限，因此提出了OWL。我们也可以把OWL当做是RDFS的一个扩展，其添加了额外的预定义词汇。</p>
<p>OWL，即“Web Ontology Language”，语义网技术栈的核心之一。OWL有两个主要的功能：</p>
<ol>
<li>提供快速、灵活的数据建模能力。</li>
<li>高效的自动推理。</li>
</ol>
<p>用OWL对罗纳尔多知识图进行语义层的描述：</p>
<pre><code>@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix : &lt;http://www.kg.com/ontology/&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .

### 这里我们用词汇owl:Class定义了“人”和“地点”这两个类。
:Person rdf:type owl:Class.
:Place rdf:type owl:Class.

### owl区分数据属性和对象属性（对象属性表示实体和实体之间的关系）。词汇owl:DatatypeProperty定义了数据属性，owl:ObjectProperty定义了对象属性。
:chineseName rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:string .

:career rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:string .

:fullName rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:string .

:birthDate rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:date .

:height rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:int .

:weight rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:int .

:nationality rdf:type owl:DatatypeProperty;    rdfs:domain :Person;    rdfs:range xsd:string .

:hasBirthPlace rdf:type owl:ObjectProperty;    rdfs:domain :Person;    rdfs:range :Place .

:address rdf:type owl:DatatypeProperty;    rdfs:domain :Place;    rdfs:range xsd:string .

:coordinate rdf:type owl:DatatypeProperty;    rdfs:domain :Place;    rdfs:range xsd:string .
</code></pre>
<p>schema层的描述语言换为OWL后，层次图表示为：<br><img src="https://pic2.zhimg.com/v2-ef0de6ba9620d27ca0f2d2f4b0f18f53_r.jpg" alt="enter description here"></p>
<p>owl区分数据属性和对象属性（对象属性表示实体和实体之间的关系）。词汇owl:DatatypeProperty定义了数据属性，owl:ObjectProperty定义了对象属性。</p>
<p>上图中，数据属性用青色表示，对象属性由蓝色表示。</p>
<p>描述属性特征的词汇</p>
<ol>
<li>owl:TransitiveProperty. 表示该属性具有传递性质。例如，我们定义“位于”是具有传递性的属性，若A位于B，B位于C，那么A肯定位于C。</li>
<li>owl:SymmetricProperty. 表示该属性具有对称性。例如，我们定义“认识”是具有对称性的属性，若A认识B，那么B肯定认识A。</li>
<li>owl:FunctionalProperty. 表示该属性取值的唯一性。 例如，我们定义“母亲”是具有唯一性的属性，若A的母亲是B，在其他地方我们得知A的母亲是C，那么B和C指的是同一个人。</li>
<li>owl:inverseOf. 定义某个属性的相反关系。例如，定义“父母”的相反关系是“子女”，若A是B的父母，那么B肯定是A的子女。</li>
</ol>
<p>本体映射词汇（Ontology Mapping）</p>
<ol>
<li>owl:equivalentClass. 表示某个类和另一个类是相同的。</li>
<li>owl:equivalentProperty. 表示某个属性和另一个属性是相同的。</li>
<li>owl:sameAs. 表示两个实体是同一个实体。</li>
</ol>
<h3 id="RDFS-OWL推理的推理机（reasoner）"><a href="#RDFS-OWL推理的推理机（reasoner）" class="headerlink" title="RDFS,OWL推理的推理机（reasoner）"></a>RDFS,OWL推理的推理机（reasoner）</h3><p>RDFS同样支持推理，由于缺乏丰富的表达能力，推理能力也不强。举个例子，我们用RDFS定义人和动物两个类，另外，定义人是动物的一个子类。此时推理机能够推断出一个实体若是人，那么它也是动物。OWL当然支持这种基本的推理，除此之外，凭借其强大的表达能力，我们能进行更有实际意义的推理。想象一个场景，我们有一个庞大数据库存储人物的亲属关系。里面很多关系都是单向的，比如，其只保存了A的父亲（母亲）是B，但B的子女字段里面没有A，可以推理得到B的子女A。</p>
<p>。<img src="https://pic4.zhimg.com/80/v2-b27db971f3fa1cefc83a47be5234dc18_hd.jpg" alt="enter description here"></p>
<h2 id="RDF查询语言SPARQL"><a href="#RDF查询语言SPARQL" class="headerlink" title="RDF查询语言SPARQL"></a>RDF查询语言SPARQL</h2><p>SPARQL即SPARQL Protocol and RDF Query Language的递归缩写，专门用于访问和操作RDF数据，是语义网的核心技术之一。W3C的RDF数据存取小组（RDF Data Access Working Group, RDAWG）对其进行了标准化。在2008年，SPARQL 1.0成为W3C官方所推荐的标准。2013年发布了SPARQL 1.1。相对第一个版本，其支持RDF图的更新，提供更强大的查询，比如：子查询、聚合操作（像我们常用的count）等等。</p>
<p>由两个部分组成：协议和查询语言。</p>
<ol>
<li>查询语言很好理解，就像SQL用于查询关系数据库中的数据，XQuery用于查询XML数据，SPARQL用于查询RDF数据。</li>
<li>协议是指我们可以通过HTTP协议在客户端和SPARQL服务器（SPARQL endpoint）之间传输查询和结果，这也是和其他查询语言最大的区别。</li>
</ol>
<p>一个SPARQL查询本质上是一个带有变量的RDF图，以我们之前提到的罗纳尔多RDF数据为例：</p>
<pre><code>&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/chineseName&gt; &quot;罗纳尔多·路易斯·纳萨里奥·德·利马&quot;^^string.
</code></pre>
<p>查询SPARQL</p>
<pre><code>&lt;http://www.kg.com/person/1&gt; &lt;http://www.kg.com/ontology/chineseName&gt; ?x.
</code></pre>
<p>SPARQL查询是基于图匹配的思想。我们把上述的查询与RDF图进行匹配，找到符合该匹配模式的所有子图，最后得到变量的值。就上面这个例子而言，在RDF图中找到匹配的子图后，将”罗纳尔多·路易斯·纳萨里奥·德·利马”和“?x”绑定，我们就得到最后的结果。简而言之，SPARQL查询分为三个步骤：</p>
<ol>
<li>构建查询图模式，表现形式就是带有变量的RDF。</li>
<li>匹配，匹配到符合指定图模式的子图。</li>
<li>绑定，将结果绑定到查询图模式对应的变量上。</li>
</ol>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>如何查询所有数据</strong></p>
<pre><code>PREFIX : &lt;http://www.kgdemo.com#&gt;
PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX owl: &lt;http://www.w3.org/2002/07/owl#&gt;
PREFIX xsd: &lt;XML Schema&gt;
PREFIX vocab: &lt;http://localhost:2020/resource/vocab/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX map: &lt;http://localhost:2020/resource/#&gt;
PREFIX db: &lt;http://localhost:2020/resource/&gt;

SELECT * WHERE &#123;
  ?s ?p ?o
&#125;
</code></pre>
<p>SPARQL的部分关键词：</p>
<ol>
<li>SELECT， 指定我们要查询的变量。在这里我们查询所有的变量，用*代替。</li>
<li>WHERE，指定我们要查询的图模式。含义上和SQL的WHERE没有区别。</li>
<li>FROM，指定查询的RDF数据集。我们这里只有一个图，因此省去了FROM关键词。 PREFIX，用于IRI的缩写。</li>
</ol>
<p>“周星驰出演了哪些电影”：</p>
<pre><code>PREFIX : &lt;http://www.kgdemo.com#&gt;
PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX owl: &lt;http://www.w3.org/2002/07/owl#&gt;
PREFIX xsd: &lt;XML Schema&gt;
PREFIX vocab: &lt;http://localhost:2020/resource/vocab/&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX map: &lt;http://localhost:2020/resource/#&gt;
PREFIX db: &lt;http://localhost:2020/resource/&gt;

SELECT ?n WHERE &#123;
  ?s rdf:type :Person.
  ?s :personName &#39;周星驰&#39;.
  ?s :hasActedIn ?o.
  ?o :movieTitle ?n
&#125;
</code></pre>
<h2 id="使用Jena-构建知识图谱"><a href="#使用Jena-构建知识图谱" class="headerlink" title="使用Jena 构建知识图谱"></a>使用Jena 构建知识图谱</h2><p>Jena是Apache基金会旗下的开源Java框架，用于构建Semantic Web 和 Linked Data 应用。</p>
<p>下面简要的介绍下API，要使用jena，可以下载jar包或者使用maven（推荐），建议测试时下面的都加上：</p>
<pre><code>    &lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;apache-jena-libs&lt;/artifactId&gt;    &lt;type&gt;pom&lt;/type&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;jena-sdb&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;jena-base&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;jena-fuseki-embedded&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt; &lt;!-- Set the version --&gt;&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/org.apache.jena/jena-arq --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.jena&lt;/groupId&gt;    &lt;artifactId&gt;jena-arq&lt;/artifactId&gt;    &lt;version&gt;3.7.0&lt;/version&gt;&lt;/dependency&gt;
</code></pre>
<h3 id="Jena-RDF-API"><a href="#Jena-RDF-API" class="headerlink" title="Jena RDF API"></a>Jena RDF API</h3><p>首先，三元组（triple）组成的图称之为Model，这个图里的Node可以是resources(实体）、literals（文本）或者blank nodes。</p>
<p>一个三元组，在jena里称之为Statement，一个 statement 包含三部分：:</p>
<ul>
<li>the subject ：实体</li>
<li>the predicate ：属性</li>
<li>the object ： 值</li>
</ul>
<h4 id="创建Model"><a href="#创建Model" class="headerlink" title="创建Model"></a>创建Model</h4><pre><code>// URI 定义
static String personURI    = &quot;http://somewhere/JohnSmith&quot;;
static String fullName     = &quot;John Smith&quot;;

// 创建一个空模型（KG)
Model model = ModelFactory.createDefaultModel();

// 创建一个resource（一个subject)
Resource johnSmith = model.createResource(personURI);

// 添加属性，这里的value是一个literals（文本）
 johnSmith.addProperty(VCARD.FN, fullName);
</code></pre>
<p>当然，你还可以使用链式API,为resource添加多个Property</p>
<pre><code>// create the resource
//   and add the properties cascading style
Resource johnSmith
  = model.createResource(personURI)     .addProperty(VCARD.FN, fullName)     .addProperty(VCARD.N,                  model.createResource()                       .addProperty(VCARD.Given, givenName)                       .addProperty(VCARD.Family, familyName));
</code></pre>
<h4 id="遍历Model"><a href="#遍历Model" class="headerlink" title="遍历Model"></a>遍历Model</h4><p>使用model.listStatements遍历statements，返回一个迭代器，使用hasNext判断是否还有数据，通过getSubject，getPredicate，getObject 获取三元组信息。</p>
<pre><code>// list the statements in the Model
StmtIterator iter = model.listStatements();

// print out the predicate, subject and object of each statement
while (iter.hasNext()) &#123;
    Statement stmt      = iter.nextStatement();  // get next statement
    Resource  subject   = stmt.getSubject();     // get the subject
    Property  predicate = stmt.getPredicate();   // get the predicate
    RDFNode   object    = stmt.getObject();      // get the object
    System.out.print(subject.toString());
    System.out.print(&quot; &quot; + predicate.toString() + &quot; &quot;);
    if (object instanceof Resource) &#123;
       System.out.print(object.toString());
    &#125; else &#123;
        // object is a literal
        System.out.print(&quot; \&quot;&quot; + object.toString() + &quot;\&quot;&quot;);
    &#125;
    System.out.println(&quot; .&quot;);
&#125; 
</code></pre>
<p>运行结果：</p>
<pre><code>http://somewhere/JohnSmith http://www.w3.org/2001/vcard-rdf/3.0#N 80aeb72e-ef9c-4879-807d-62daf3c13b72 .
http://somewhere/JohnSmith http://www.w3.org/2001/vcard-rdf/3.0#FN  &quot;John Smith&quot; .
80aeb72e-ef9c-4879-807d-62daf3c13b72 http://www.w3.org/2001/vcard-rdf/3.0#Family  &quot;Smith&quot; .
80aeb72e-ef9c-4879-807d-62daf3c13b72 http://www.w3.org/2001/vcard-rdf/3.0#Given  &quot;John&quot; .
</code></pre>
<h4 id="保存为-RDF文件"><a href="#保存为-RDF文件" class="headerlink" title="保存为 RDF文件"></a>保存为 RDF文件</h4><p>可以使用model.write方便的把Model保存为rdf文件，write默认保存为XML格式</p>
<pre><code>// now write the model in XML form to a file
model.write(System.out);



&lt;rdf:RDF
  xmlns:rdf=&#39;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#39;
  xmlns:vcard=&#39;http://www.w3.org/2001/vcard-rdf/3.0#&#39;
 &gt;
  &lt;rdf:Description rdf:about=&#39;http://somewhere/JohnSmith&#39;&gt;
    &lt;vcard:FN&gt;John Smith&lt;/vcard:FN&gt;
    &lt;vcard:N rdf:nodeID=&quot;A0&quot;/&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description rdf:nodeID=&quot;A0&quot;&gt;
    &lt;vcard:Given&gt;John&lt;/vcard:Given&gt;
    &lt;vcard:Family&gt;Smith&lt;/vcard:Family&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</code></pre>
<p>write还提供重载版本write( OutputStream out, String lang )，lang可以为”RDF/XML-ABBREV”, “N-TRIPLE”, “TURTLE”, (and “TTL”) and “N3”<br> 我们来保存为常见的TURTLE：</p>
<pre><code>model.write(System.out, &quot;TURTLE&quot;);
</code></pre>
<p>结果：</p>
<pre><code>&lt;http://somewhere/JohnSmith&gt;    &lt;http://www.w3.org/2001/vcard-rdf/3.0#FN&gt;            &quot;John Smith&quot; ;    &lt;http://www.w3.org/2001/vcard-rdf/3.0#N&gt;            [ &lt;http://www.w3.org/2001/vcard-rdf/3.0#Family&gt;                      &quot;Smith&quot; ;              &lt;http://www.w3.org/2001/vcard-rdf/3.0#Given&gt;                      &quot;John&quot;            ] .
</code></pre>
<p>jena还提供prefix功能，我们可以指定prefix来简化turtle,下面的代码将指定prefix，并保存到文件1.rdf里：</p>
<pre><code>    model.setNsPrefix( &quot;vCard&quot;, &quot;http://www.w3.org/2001/vcard-rdf/3.0#&quot; );    model.setNsPrefix( &quot;rdf&quot;, &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot; );    try &#123;        model.write(new FileOutputStream(&quot;1.rdf&quot;),&quot;TURTLE&quot;);    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;
</code></pre>
<p>结果：</p>
<pre><code>@prefix rdf:   &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix vCard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

&lt;http://somewhere/JohnSmith&gt;    vCard:FN  &quot;John Smith&quot; ;    vCard:N   [ vCard:Family  &quot;Smith&quot; ;                vCard:Given   &quot;John&quot;              ] .
</code></pre>
<h4 id="读取rdf"><a href="#读取rdf" class="headerlink" title="读取rdf"></a>读取rdf</h4><p>Mode的read(Reader reader, String base)方法，提供 读取RDF文件的功能：</p>
<pre><code>    static final String inputFileName  = &quot;1.rdf&quot;;
                              
    public static void main (String args[]) &#123;
        // create an empty model
        Model model = ModelFactory.createDefaultModel();

        InputStream in = FileManager.get().open( inputFileName );
        if (in == null) &#123;
            throw new IllegalArgumentException( &quot;File: &quot; + inputFileName + &quot; not found&quot;);
        &#125;
        
        // read the RDF/XML file
        model.read(in, &quot;&quot;,&quot;TURTLE&quot;);
                    
        // write it to standard out
        model.write(System.out);            
    &#125;
</code></pre>
<p>注意，read的时候，默认是读取XML，如果是其他格式，需要指定lang。</p>
<h4 id="从模型读取Resouce"><a href="#从模型读取Resouce" class="headerlink" title="从模型读取Resouce"></a>从模型读取Resouce</h4><p>一个resouce都有一个唯一的URI，我们可以通过URI来获取对应的Resouce：<br> 函数原型：</p>
<pre><code>    /**    Return a Resource instance with the given URI in this model. &lt;i&gt;This method    behaves identically to &lt;code&gt;createResource(String)&lt;/code&gt;&lt;/i&gt; and exists as    legacy: createResource is now capable of, and allowed to, reuse existing objects.&lt;p&gt;    Subsequent operations on the returned object may modify this model.   @return a resource instance   @param uri the URI of the resource*/Resource getResource(String uri) ;
</code></pre>
<p>获取到Resouce后，通过getRequiredProperty获取属性，如果一个属性包含多个值，可以使用listProperties获取。</p>
<pre><code> static final String inputFileName = &quot;1.rdf&quot;;
    static final String johnSmithURI = &quot;http://somewhere/JohnSmith&quot;;
    
    public static void main (String args[]) &#123;
        // create an empty model
        Model model = ModelFactory.createDefaultModel();
       
        // use the FileManager to find the input file
        InputStream in = FileManager.get().open(inputFileName);
        if (in == null) &#123;
            throw new IllegalArgumentException( &quot;File: &quot; + inputFileName + &quot; not found&quot;);
        &#125;
        
        // read the RDF/XML file
        model.read(new InputStreamReader(in), &quot;&quot;);
        
        // retrieve the Adam Smith vcard resource from the model
        Resource vcard = model.getResource(johnSmithURI);

        // retrieve the value of the N property
        Resource name = (Resource) vcard.getRequiredProperty(VCARD.N)
                                        .getObject();
        // retrieve the given name property
        String fullName = vcard.getRequiredProperty(VCARD.FN)
                               .getString();
        // add two nick name properties to vcard
        vcard.addProperty(VCARD.NICKNAME, &quot;Smithy&quot;)
             .addProperty(VCARD.NICKNAME, &quot;Adman&quot;);
        
        // set up the output
        System.out.println(&quot;The nicknames of \&quot;&quot; + fullName + &quot;\&quot; are:&quot;);
        // list the nicknames
        StmtIterator iter = vcard.listProperties(VCARD.NICKNAME);
        while (iter.hasNext()) &#123;
            System.out.println(&quot;    &quot; + iter.nextStatement().getObject()
                                            .toString());
        &#125;

        try &#123;
            model.write(new FileOutputStream(&quot;1.rdf&quot;));
        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<h4 id="查询模型"><a href="#查询模型" class="headerlink" title="查询模型"></a>查询模型</h4><p>可以通过listResourcesWithProperty查询包含Property的数据：</p>
<pre><code>    ResIterator iter = model.listResourcesWithProperty(VCARD.FN);
        if (iter.hasNext()) &#123;
            System.out.println(&quot;The database contains vcards for:&quot;);
            while (iter.hasNext()) &#123;
                System.out.println(&quot;  &quot; + iter.nextResource()
                                              .getRequiredProperty(VCARD.FN)
                                              .getString() );
            &#125;
        &#125; else &#123;
            System.out.println(&quot;No vcards were found in the database&quot;);
        &#125;        
</code></pre>
<p>通过listStatements(SimpleSelector)查询Statement：</p>
<pre><code>        // select all the resources with a VCARD.FN property
        // whose value ends with &quot;Smith&quot;
        StmtIterator iter = model.listStatements(
            new 
                SimpleSelector(null, VCARD.FN, (RDFNode) null) &#123;
                    @Override
                    public boolean selects(Statement s) &#123;
                            return s.getString().endsWith(&quot;Smith&quot;);
                    &#125;
                &#125;);
        if (iter.hasNext()) &#123;
            System.out.println(&quot;The database contains vcards for:&quot;);
            while (iter.hasNext()) &#123;
                System.out.println(&quot;  &quot; + iter.nextStatement()
                                              .getString());
            &#125;
        &#125; else &#123;
            System.out.println(&quot;No Smith&#39;s were found in the database&quot;);
        &#125;     
</code></pre>
<h4 id="模型合并"><a href="#模型合并" class="headerlink" title="模型合并"></a>模型合并</h4><p>可以通过union合并两个模型：</p>
<p><img src="https://jena.apache.org/tutorials/figures/fig4.png" alt="enter description here"><br><img src="https://jena.apache.org/tutorials/figures/fig5.png" alt="enter description here"></p>
<p>合并后：<br><img src="http://oyqmmpkcm.bkt.clouddn.com/1524907704194.jpg" alt="enter description here" title="1524907704194"></p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/32122644">知识图谱基础之RDF，RDFS与OWL</a></li>
<li></li>
</ul>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>知识图谱</tag>
        <tag>Jena</tag>
        <tag>RDF</tag>
      </tags>
  </entry>
  <entry>
    <title>新型前端开发工程师的三个境界 后端开发工程师如何快速转前端</title>
    <url>/jadepeng/2018/04/16/jqpeng-%E6%96%B0%E5%9E%8B%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E4%B8%89%E4%B8%AA%E5%A2%83%E7%95%8C%20%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BD%AC%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/front-dev.html">新型前端开发工程师的三个境界 后端开发工程师如何快速转前端</a></p>
<p>初入软件开发这一行时，当时还没有前后端分离这个概念，所有的开发工程师既能写html，也能写后台服务，随着技术的发展，前后端分离成为趋势，目前团队不少人能熟悉的写java后台服务，却难以hold住前端页面的开发，前端页面开发成为瓶颈。针对这个情况，筹划了一个前端培训专题，让后端的同事可以通过学习快速掌握前端开发技能。</p>
<h2 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h2><ul>
<li>培养全栈工程师，前后端均可以Hold住</li>
</ul>
<h2 id="前端技能梳理"><a href="#前端技能梳理" class="headerlink" title="前端技能梳理"></a>前端技能梳理</h2><p>我们把前端同事做的事情简单的梳理下，大概可以分为：</p>
<h3 id="效果图-gt-HTML还原"><a href="#效果图-gt-HTML还原" class="headerlink" title="效果图 -&gt; HTML还原"></a>效果图 -&gt; HTML还原</h3><p>将UED设计的效果图还原为页面，这个也是以前狭义的UI完成的工作。梳理下这个工作需要的技能：</p>
<ul>
<li>熟悉HTML\CSS、熟悉常见布局，div+css</li>
<li>熟悉浏览器兼容</li>
<li>熟悉PS切图</li>
</ul>
<p>随着前端UI框架的发展，当你使用bootstrap、elements、iview这类框架时，80%的功能开发可以不需要这一步，因此一个小团队有1个这样的工程师就OK了。</p>
<h3 id="HTML-gt-应用"><a href="#HTML-gt-应用" class="headerlink" title="HTML-&gt;应用"></a>HTML-&gt;应用</h3><p>单独的HTML是缺乏灵魂的，还需要绑定数据，这样才是一个完整的页面。在前后端未分离的时代，通常是后端基于前端还原的html来进行开发，通过模板技术绑定数据。而随着ajax的兴起，前端 MVVM框架的流行，前后端分离，数据绑定工作前移到前端，因此前端的职责之一就是调用后端的服务，并显示到页面上。</p>
<p>同样的，梳理下这个工作需要的技能：</p>
<ul>
<li>了解或者熟悉html</li>
<li>熟悉HTTP</li>
<li>基本的javascript应用</li>
<li>熟悉一个js框架的应用，比如jq、vue.js</li>
</ul>
<p>一个合格的后端，在熟悉javascript的情况下，可以很快掌握。</p>
<h3 id="复杂的单页应用"><a href="#复杂的单页应用" class="headerlink" title="复杂的单页应用"></a>复杂的单页应用</h3><p>现在流行一个词“大前端”，前端更大的挑战就是构建复杂的单页应用，比如易企秀的H5编辑器，单个页面里包含了非常多的功能和逻辑，这类页面有个特点：</p>
<ul>
<li>包含复杂的业务逻辑</li>
<li>通常需要上千行的javascript代码</li>
<li>需要良好的设计模式来组织和维护代码，MVC\MVVM等概念在前端运用</li>
</ul>
<p>而随着技术的发展，javascript可以用来开发手机端app（react-native、weex），本质上来说还是开发复杂的单页应用。特别是使用vuex这类状态管理库时，如果懂的后端的数据库概念，可以事半功倍的理解其原理。</p>
<p>总结一下，开发复杂的单页应用，需要具备的技能：</p>
<ul>
<li>熟悉数据结构和算法</li>
<li>熟悉常用的设计模式</li>
<li>OOP思维</li>
<li>模块化开发</li>
<li>db思维</li>
<li>熟悉javascript，熟悉es2015\es2017</li>
</ul>
<p>一句话总结起来，<strong>复杂的前端应用开发所需要的技能，恰恰是后端开发所擅长的</strong>，只是编程语言从java、c#变成了javascript，仅此而已。</p>
<h2 id="新型前后端一体化工程师的三个境界"><a href="#新型前后端一体化工程师的三个境界" class="headerlink" title="新型前后端一体化工程师的三个境界"></a>新型前后端一体化工程师的三个境界</h2><p>怎么来评价一个人的前端能力，简单起见，划分为三个境界：</p>
<ul>
<li><p>第一层（必须具备）</p>
<ul>
<li>依葫芦画瓢</li>
<li>可以根据还原的HTML或者UI框架，实现简单页面的开发和数据绑定</li>
<li>熟悉HTML常见标签、CSS盒子模型、CSS优先级，常见布局</li>
<li>会使用Vue.js/jquery，Iview、Element等工具库</li>
</ul>
</li>
<li><p>第二层（努力可以达到）</p>
<ul>
<li>可以熟练的开发单页应用</li>
<li>javascript了然于心，es2015\2016信手拈来</li>
<li>熟悉Vue、React、angular、知道各自的优缺点，根据需要选择合理的方案</li>
<li>跟踪前端发展趋势、不盲从、独立思考</li>
</ul>
</li>
<li><p>第三层（尽量追求，需要时间和积累）</p>
<ul>
<li>融会贯通，可以改造轮子、造新的轮子提升效率</li>
<li>在公司、业界前端形成影响力</li>
</ul>
</li>
</ul>
<h2 id="培训规划"><a href="#培训规划" class="headerlink" title="培训规划"></a>培训规划</h2><p>最后来定一下培训的规划。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>所有人达到第一层境界</li>
<li>骨干需要达到第二层</li>
</ul>
<h3 id="培训内容"><a href="#培训内容" class="headerlink" title="培训内容"></a>培训内容</h3><h4 id="课时1：HTTP-HTML-CSS基础-常见布局-HTML5-CSS3"><a href="#课时1：HTTP-HTML-CSS基础-常见布局-HTML5-CSS3" class="headerlink" title="课时1：HTTP+HTML+CSS基础+常见布局+HTML5+CSS3"></a>课时1：HTTP+HTML+CSS基础+常见布局+HTML5+CSS3</h4><ul>
<li>HTTP<ul>
<li>HTTP get/post/put/delete</li>
<li>HTTP响应码</li>
<li>chrome F12 network使用</li>
</ul>
</li>
<li>html块元素、内联元素、表单</li>
<li>CSS 与盒子模型</li>
<li>响应式布局</li>
<li>H5语义标签，audio，canvas</li>
<li>CSS3动画</li>
</ul>
<h4 id="课时2：javascript-基础"><a href="#课时2：javascript-基础" class="headerlink" title="课时2：javascript 基础"></a>课时2：javascript 基础</h4><ul>
<li>数据类型，数组、对象，表达式、条件、循环等</li>
<li>javascript常用对象</li>
<li>DOM编程</li>
<li>AJAX、jsonp</li>
<li>正则、表单验证</li>
</ul>
<h4 id="课时3：javascript进阶"><a href="#课时3：javascript进阶" class="headerlink" title="课时3：javascript进阶"></a>课时3：javascript进阶</h4><ul>
<li>深入js<ul>
<li>模块化、AMD，require.js</li>
<li>作用域链</li>
<li>原型链与继承</li>
<li>闭包</li>
<li>OOP</li>
</ul>
</li>
<li>es2015/2017<ul>
<li>箭头函数等新语法糖</li>
</ul>
</li>
<li>TypeScript</li>
</ul>
<h4 id="课时4：项目框架应用-Vue-js-IView使用培训"><a href="#课时4：项目框架应用-Vue-js-IView使用培训" class="headerlink" title="课时4：项目框架应用 Vue.js +IView使用培训"></a>课时4：项目框架应用 Vue.js +IView使用培训</h4><ul>
<li>Vue.js 渐进式理解</li>
<li>Vue.js 模板绑定</li>
<li>Vue.js 组件</li>
<li>Vue.js 单页应用</li>
<li>Vuex 状态管理</li>
<li>Vue Router</li>
<li>IView 组件库介绍</li>
<li>项目案例讲解</li>
</ul>
<h4 id="课时5：基于Nodejs的前端新生态"><a href="#课时5：基于Nodejs的前端新生态" class="headerlink" title="课时5：基于Nodejs的前端新生态"></a>课时5：基于Nodejs的前端新生态</h4><ul>
<li>NodeJs原理、历史、发展</li>
<li>webpack</li>
<li>less</li>
<li>代码质量eslint</li>
</ul>
<h4 id="课时6：-vue-js与手机app、微信小程序开发"><a href="#课时6：-vue-js与手机app、微信小程序开发" class="headerlink" title="课时6： vue.js与手机app、微信小程序开发"></a>课时6： vue.js与手机app、微信小程序开发</h4><ul>
<li>使用vue.js+weex开发手机app</li>
<li>微信小程序开发</li>
</ul>
<p>最后，欢迎大家拍砖和提出建议。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>axios介绍与使用说明 axios中文文档</title>
    <url>/jadepeng/2018/04/14/jqpeng-axios%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%20axios%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/axios.html">axios介绍与使用说明 axios中文文档</a></p>
<p>本周在做一个使用vuejs的前端项目，访问后端服务使用axios库，这里对照官方文档，简单记录下，也方便大家参考。</p>
<p>Axios 是一个基于  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 的 HTTP 库，可以用在浏览器和 node.js 中。github开源地址<a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>在浏览器中创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a></li>
<li>在 node.js 则创建 <a href="http://nodejs.org/api/http.html">http</a> 请求</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</li>
<li>支持拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></li>
</ul>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>支持Chrome、火狐、Edge、IE8+等浏览器</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm安装:</p>
<pre><code>$ npm install axios
</code></pre>
<p>使用 bower:</p>
<pre><code>$ bower install axios
</code></pre>
<p>或者直接使用 cdn:</p>
<pre><code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2><p>执行 <code>GET</code> 请求</p>
<pre><code>// 为给定 ID 的 user 创建请求
axios.get(&#39;/user?ID=12345&#39;)
  .then(function (response) &#123;
    console.log(response);
  &#125;)
  .catch(function (error) &#123;
    console.log(error);
  &#125;);

// GET 参数可以放到params里（推荐）
axios.get(&#39;/user&#39;, &#123;
    params: &#123;
      ID: 12345
    &#125;
  &#125;)
  .then(function (response) &#123;
    console.log(response);
  &#125;)
  .catch(function (error) &#123;
    console.log(error);
  &#125;);

// 还可以使用ECMAScript 2017里的async/await，添加 `async` keyword to your outer function/method.
async function getUser() &#123;
  try &#123;
    const response = await axios.get(&#39;/user?ID=12345&#39;);
    console.log(response);
  &#125; catch (error) &#123;
    console.error(error);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>async/await 是 ECMAScript 2017新提供的功能 ，Internet Explorer 和一些旧的浏览器并不支持</p>
</blockquote>
<p>执行 <code>POST</code> 请求</p>
<pre><code>axios.post(&#39;/user&#39;, &#123;
    firstName: &#39;Fred&#39;,
    lastName: &#39;Flintstone&#39;
  &#125;)
  .then(function (response) &#123;
    console.log(response);
  &#125;)
  .catch(function (error) &#123;
    console.log(error);
  &#125;);
</code></pre>
<p>执行多个并发请求</p>
<pre><code>function getUserAccount() &#123;
  return axios.get(&#39;/user/12345&#39;);
&#125;

function getUserPermissions() &#123;
  return axios.get(&#39;/user/12345/permissions&#39;);
&#125;
axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) &#123;
    // 两个请求现在都执行完成
  &#125;));
</code></pre>
<h2 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h2><p>可以通过向 <code>axios</code> 传递相关配置来创建请求</p>
<h5 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h5><pre><code>// 发送 POST 请求
axios(&#123;
  method: &#39;post&#39;,
  url: &#39;/user/12345&#39;,
  data: &#123;
    firstName: &#39;Fred&#39;,
    lastName: &#39;Flintstone&#39;
  &#125;
&#125;);
//  GET 请求远程图片
axios(&#123;
  method:&#39;get&#39;,
  url:&#39;http://bit.ly/2mTM3nY&#39;,
  responseType:&#39;stream&#39;
&#125;)
  .then(function(response) &#123;
  response.data.pipe(fs.createWriteStream(&#39;ada_lovelace.jpg&#39;))
&#125;);
</code></pre>
<h5 id="axios-url-config"><a href="#axios-url-config" class="headerlink" title="axios(url[, config])"></a>axios(url[, config])</h5><pre><code>// 发送 GET 请求（默认的方法）
axios(&#39;/user/12345&#39;);
</code></pre>
<h3 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h3><p>为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求：</p>
<h5 id="axios-request-config"><a href="#axios-request-config" class="headerlink" title="axios.request(config)"></a>axios.request(config)</h5><h5 id="axios-get-url-config"><a href="#axios-get-url-config" class="headerlink" title="axios.get(url[, config])"></a>axios.get(url[, config])</h5><h5 id="axios-delete-url-config"><a href="#axios-delete-url-config" class="headerlink" title="axios.delete(url[, config])"></a>axios.delete(url[, config])</h5><h5 id="axios-head-url-config"><a href="#axios-head-url-config" class="headerlink" title="axios.head(url[, config])"></a>axios.head(url[, config])</h5><h5 id="axios-post-url-data-config"><a href="#axios-post-url-data-config" class="headerlink" title="axios.post(url[, data[, config]])"></a>axios.post(url[, data[, config]])</h5><h5 id="axios-put-url-data-config"><a href="#axios-put-url-data-config" class="headerlink" title="axios.put(url[, data[, config]])"></a>axios.put(url[, data[, config]])</h5><h5 id="axios-patch-url-data-config"><a href="#axios-patch-url-data-config" class="headerlink" title="axios.patch(url[, data[, config]])"></a>axios.patch(url[, data[, config]])</h5><h6 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h6><p>在使用别名方法时， <code>url</code>、<code>method</code>、<code>data</code> 这些属性都不必在配置中指定。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>处理并发请求的助手函数</p>
<h5 id="axios-all-iterable"><a href="#axios-all-iterable" class="headerlink" title="axios.all(iterable)"></a>axios.all(iterable)</h5><h5 id="axios-spread-callback"><a href="#axios-spread-callback" class="headerlink" title="axios.spread(callback)"></a>axios.spread(callback)</h5><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>可以使用自定义配置新建一个 axios 实例</p>
<h5 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create([config])"></a>axios.create([config])</h5><pre><code>const instance = axios.create(&#123;
  baseURL: &#39;https://some-domain.com/api/&#39;,
  timeout: 1000,
  headers: &#123;&#39;X-Custom-Header&#39;: &#39;foobar&#39;&#125;
&#125;);
</code></pre>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>以下是可用的实例方法。指定的配置将与实例的配置合并</p>
<h5 id="axios-request-config-1"><a href="#axios-request-config-1" class="headerlink" title="axios#request(config)"></a>axios#request(config)</h5><h5 id="axios-get-url-config-1"><a href="#axios-get-url-config-1" class="headerlink" title="axios#get(url[, config])"></a>axios#get(url[, config])</h5><h5 id="axios-delete-url-config-1"><a href="#axios-delete-url-config-1" class="headerlink" title="axios#delete(url[, config])"></a>axios#delete(url[, config])</h5><h5 id="axios-head-url-config-1"><a href="#axios-head-url-config-1" class="headerlink" title="axios#head(url[, config])"></a>axios#head(url[, config])</h5><h5 id="axios-post-url-data-config-1"><a href="#axios-post-url-data-config-1" class="headerlink" title="axios#post(url[, data[, config]])"></a>axios#post(url[, data[, config]])</h5><h5 id="axios-put-url-data-config-1"><a href="#axios-put-url-data-config-1" class="headerlink" title="axios#put(url[, data[, config]])"></a>axios#put(url[, data[, config]])</h5><h5 id="axios-patch-url-data-config-1"><a href="#axios-patch-url-data-config-1" class="headerlink" title="axios#patch(url[, data[, config]])"></a>axios#patch(url[, data[, config]])</h5><h2 id="请求配置项"><a href="#请求配置项" class="headerlink" title="请求配置项"></a>请求配置项</h2><p>下面是创建请求时可用的配置选项，注意只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>get</code> 方法。</p>
<pre><code>&#123;
  // `url` 是用于请求的服务器 URL
  url: &quot;/user&quot;,

  // `method` 是创建请求时使用的方法
  method: &quot;get&quot;, // 默认是 get

  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。
  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL
  baseURL: &quot;https://some-domain.com/api/&quot;,

  // `transformRequest` 允许在向服务器发送前，修改请求数据
  // 只能用在 &quot;PUT&quot;, &quot;POST&quot; 和 &quot;PATCH&quot; 这几个请求方法
  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream
  transformRequest: [function (data) &#123;
    // 对 data 进行任意转换处理

    return data;
  &#125;],

  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据
  transformResponse: [function (data) &#123;
    // 对 data 进行任意转换处理

    return data;
  &#125;],

  // `headers` 是即将被发送的自定义请求头
  headers: &#123;&quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;&#125;,

  // `params` 是即将与请求一起发送的 URL 参数
  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象
  params: &#123;
    ID: 12345
  &#125;,

  // `paramsSerializer` 是一个负责 `params` 序列化的函数
  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
  paramsSerializer: function(params) &#123;
    return Qs.stringify(params, &#123;arrayFormat: &quot;brackets&quot;&#125;)
  &#125;,

  // `data` 是作为请求主体被发送的数据
  // 只适用于这些请求方法 &quot;PUT&quot;, &quot;POST&quot;, 和 &quot;PATCH&quot;
  // 在没有设置 `transformRequest` 时，必须是以下类型之一：
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - 浏览器专属：FormData, File, Blob
  // - Node 专属： Stream
  data: &#123;
    firstName: &quot;Fred&quot;
  &#125;,

  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)
  // 如果请求话费了超过 `timeout` 的时间，请求将被中断
  timeout: 1000,

  // `withCredentials` 表示跨域请求时是否需要使用凭证
  withCredentials: false, // 默认的

  // `adapter` 允许自定义处理请求，以使测试更轻松
  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).
  adapter: function (config) &#123;
    /* ... */
  &#125;,

  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据
  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头
  auth: &#123;
    username: &quot;janedoe&quot;,
    password: &quot;s00pers3cret&quot;
  &#125;,

  // `responseType` 表示服务器响应的数据类型，可以是 &quot;arraybuffer&quot;, &quot;blob&quot;, &quot;document&quot;, &quot;json&quot;, &quot;text&quot;, &quot;stream&quot;
  responseType: &quot;json&quot;, // 默认的

  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称
  xsrfCookieName: &quot;XSRF-TOKEN&quot;, // default

  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称
  xsrfHeaderName: &quot;X-XSRF-TOKEN&quot;, // 默认的

  // `onUploadProgress` 允许为上传处理进度事件
  onUploadProgress: function (progressEvent) &#123;
    // 对原生进度事件的处理
  &#125;,

  // `onDownloadProgress` 允许为下载处理进度事件
  onDownloadProgress: function (progressEvent) &#123;
    // 对原生进度事件的处理
  &#125;,

  // `maxContentLength` 定义允许的响应内容的最大尺寸
  maxContentLength: 2000,

  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte
  validateStatus: function (status) &#123;
    return status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300; // 默认的
  &#125;,

  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目
  // 如果设置为0，将不会 follow 任何重定向
  maxRedirects: 5, // 默认的

  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：
  // `keepAlive` 默认没有启用
  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),
  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),

  // &quot;proxy&quot; 定义代理服务器的主机名称和端口
  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据
  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。
  proxy: &#123;
    host: &quot;127.0.0.1&quot;,
    port: 9000,
    auth: : &#123;
      username: &quot;mikeymike&quot;,
      password: &quot;rapunz3l&quot;
    &#125;
  &#125;,

  // `cancelToken` 指定用于取消请求的 cancel token
  // （查看后面的 Cancellation 这节了解更多）
  cancelToken: new CancelToken(function (cancel) &#123;
  &#125;)
&#125;
</code></pre>
<h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><p>axios请求的响应包含以下信息：</p>
<pre><code>&#123;
  // `data` 由服务器提供的响应
  data: &#123;&#125;,

  // `status`  HTTP 状态码
  status: 200,

  // `statusText` 来自服务器响应的 HTTP 状态信息
  statusText: &quot;OK&quot;,

  // `headers` 服务器响应的头
  headers: &#123;&#125;,

  // `config` 是为请求提供的配置信息
  config: &#123;&#125;
&#125;
</code></pre>
<p>使用 <code>then</code> 时，会接收下面这样的响应：</p>
<pre><code>axios.get(&quot;/user/12345&quot;)
  .then(function(response) &#123;
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  &#125;);
</code></pre>
<p>在使用 <code>catch</code> 时，或传递 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">rejection callback</a> 作为 <code>then</code> 的第二个参数时，响应可以通过 <code>error</code> 对象可被使用，正如在错误处理这一节所讲。</p>
<h2 id="配置的默认值-defaults"><a href="#配置的默认值-defaults" class="headerlink" title="配置的默认值/defaults"></a>配置的默认值/defaults</h2><p>你可以指定将被用在各个请求的配置默认值</p>
<h3 id="全局的-axios-默认值"><a href="#全局的-axios-默认值" class="headerlink" title="全局的 axios 默认值"></a>全局的 axios 默认值</h3><pre><code>axios.defaults.baseURL = &quot;https://api.example.com&quot;;
axios.defaults.headers.common[&quot;Authorization&quot;] = AUTH_TOKEN;
axios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;;
</code></pre>
<h3 id="自定义实例默认值"><a href="#自定义实例默认值" class="headerlink" title="自定义实例默认值"></a>自定义实例默认值</h3><pre><code>// 创建实例时设置配置的默认值
var instance = axios.create(&#123;
  baseURL: &quot;https://api.example.com&quot;
&#125;);

// 在实例已创建后修改默认值
instance.defaults.headers.common[&quot;Authorization&quot;] = AUTH_TOKEN;
</code></pre>
<h3 id="配置的优先级"><a href="#配置的优先级" class="headerlink" title="配置的优先级"></a>配置的优先级</h3><p>配置会以一个优先顺序进行合并。</p>
<p>请求的config &gt; 实例的 <code>defaults</code> 属性 &gt; 库默认值：</p>
<pre><code>// 使用由库提供的配置的默认值来创建实例
// 此时超时配置的默认值是 `0`
var instance = axios.create();

// 覆写库的超时默认值
// 现在，在超时前，所有请求都会等待 2.5 秒
instance.defaults.timeout = 2500;

// 为已知需要花费很长时间的请求覆写超时设置
instance.get(&quot;/longRequest&quot;, &#123;
  timeout: 5000
&#125;);
</code></pre>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>可以自定义拦截器，在在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p>
<pre><code>// 添加请求拦截器
axios.interceptors.request.use(function (config) &#123;
    // 在发送请求之前做些什么
    return config;
  &#125;, function (error) &#123;
    // 对请求错误做些什么
    return Promise.reject(error);
  &#125;);

// 添加响应拦截器
axios.interceptors.response.use(function (response) &#123;
    // 对响应数据做点什么
    return response;
  &#125;, function (error) &#123;
    // 对响应错误做点什么
    return Promise.reject(error);
  &#125;);
</code></pre>
<p>如果你想在稍后移除拦截器，可以这样：</p>
<pre><code>var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);
axios.interceptors.request.eject(myInterceptor);
</code></pre>
<p>可以为自定义 axios 实例添加拦截器</p>
<pre><code>var instance = axios.create();
instance.interceptors.request.use(function () &#123;/*...*/&#125;);
</code></pre>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><pre><code>axios.get(&quot;/user/12345&quot;)
  .catch(function (error) &#123;
    if (error.response) &#123;
      // 请求已发出，但服务器响应的状态码不在 2xx 范围内
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
    &#125; else &#123;
      // Something happened in setting up the request that triggered an Error
      console.log(&quot;Error&quot;, error.message);
    &#125;
    console.log(error.config);
  &#125;);
</code></pre>
<p>可以使用 <code>validateStatus</code> 配置选项定义一个自定义 HTTP 状态码的错误范围。</p>
<pre><code>axios.get(&quot;/user/12345&quot;, &#123;
  validateStatus: function (status) &#123;
    return status &lt; 500; // 状态码在大于或等于500时才会 reject
  &#125;
&#125;)
</code></pre>
<h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p>使用 <em>cancel token</em> 取消请求</p>
<blockquote>
<p>Axios 的 cancel token API 基于<a href="https://github.com/tc39/proposal-cancelable-promises">cancelable promises proposal</a></p>
</blockquote>
<p>可以使用 <code>CancelToken.source</code> 工厂方法创建 cancel token，像这样：</p>
<pre><code>const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get(&#39;/user/12345&#39;, &#123;
  cancelToken: source.token
&#125;).catch(function(thrown) &#123;
  if (axios.isCancel(thrown)) &#123;
    console.log(&#39;Request canceled&#39;, thrown.message);
  &#125; else &#123;
    // handle error
  &#125;
&#125;);

axios.post(&#39;/user/12345&#39;, &#123;
  name: &#39;new name&#39;
&#125;, &#123;
  cancelToken: source.token
&#125;)

// cancel the request (the message parameter is optional)
source.cancel(&#39;Operation canceled by the user.&#39;);
</code></pre>
<p>还可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token：</p>
<pre><code>var CancelToken = axios.CancelToken;
var cancel;

axios.get(&quot;/user/12345&quot;, &#123;
  cancelToken: new CancelToken(function executor(c) &#123;
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  &#125;)
&#125;);

// 取消请求
cancel();
</code></pre>
<p>Note : 可以使用同一个 cancel token 取消多个请求</p>
<h2 id="请求时使用-application-x-www-form-urlencoded"><a href="#请求时使用-application-x-www-form-urlencoded" class="headerlink" title="请求时使用 application/x-www-form-urlencoded"></a>请求时使用 application/x-www-form-urlencoded</h2><p>axios会默认序列化  JavaScript 对象为 JSON. 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置.</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>在浏览器环境，你可以使用  URLSearchParams API ：:</p>
<pre><code>const params = new URLSearchParams();
params.append(&#39;param1&#39;, &#39;value1&#39;);
params.append(&#39;param2&#39;, &#39;value2&#39;);
axios.post(&#39;/foo&#39;, params);
</code></pre>
<blockquote>
<p>URLSearchParams不是所有的浏览器均支持</p>
</blockquote>
<p>除此之外，你可以使用qs库来编码数据:</p>
<pre><code>const qs = require(&#39;qs&#39;);
axios.post(&#39;/foo&#39;, qs.stringify(&#123; &#39;bar&#39;: 123 &#125;));

// Or in another way (ES6),

import qs from &#39;qs&#39;;
const data = &#123; &#39;bar&#39;: 123 &#125;;
const options = &#123;
  method: &#39;POST&#39;,
  headers: &#123; &#39;content-type&#39;: &#39;application/x-www-form-urlencoded&#39; &#125;,
  data: qs.stringify(data),
  url,
&#125;;
axios(options);
</code></pre>
<h3 id="Node-js环境"><a href="#Node-js环境" class="headerlink" title="Node.js环境"></a>Node.js环境</h3><p>在 node.js里, 可以使用 querystring module:</p>
<pre><code>const querystring = require(&#39;querystring&#39;);
axios.post(&#39;http://something.com/&#39;, querystring.stringify(&#123; foo: &#39;bar&#39; &#125;));
</code></pre>
<p>当然，同浏览器一样，你还可以使用 qs library.</p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>axios 依赖原生的 ES6 Promise 实现而<a href="http://caniuse.com/promises">被支持</a>.<br> 如果你的环境不支持 ES6 Promise，你可以使用 <a href="https://github.com/jakearchibald/es6-promise">polyfill</a>.</p>
<h2 id="TypeScript支持"><a href="#TypeScript支持" class="headerlink" title="TypeScript支持"></a>TypeScript支持</h2><p>axios 包含 <a href="http://typescriptlang.org/">TypeScript</a> definitions.</p>
<pre><code>import axios from &quot;axios&quot;;
axios.get(&quot;/user?ID=12345&quot;);
</code></pre>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul>
<li><a href="https://github.com/mzabriskie/axios/blob/master/CHANGELOG.md">变更记录</a></li>
<li><a href="https://github.com/mzabriskie/axios/blob/master/UPGRADE_GUIDE.md">升级指南</a></li>
<li><a href="https://github.com/mzabriskie/axios/blob/master/ECOSYSTEM.md">生态</a></li>
<li><a href="https://github.com/mzabriskie/axios/blob/master/CONTRIBUTING.md">贡献引导</a></li>
<li><a href="https://github.com/mzabriskie/axios/blob/master/CODE_OF_CONDUCT.md">Code of Conduct</a></li>
</ul>
<h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><p>axios 受<a href="https://angularjs.org/">Angular</a>.提供的<a href="https://docs.angularjs.org/api/ng/service/$http">$http service</a> 启发而创建， 致力于以提供一个脱离于ng的 <code>$http</code>模块。</p>
<h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p>采用MIT</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>JavaScript</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot web程序static资源放在jar外部</title>
    <url>/jadepeng/2018/04/04/jqpeng-Spring%20boot%20web%E7%A8%8B%E5%BA%8Fstatic%E8%B5%84%E6%BA%90%E6%94%BE%E5%9C%A8jar%E5%A4%96%E9%83%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/8715860.html">Spring boot web程序static资源放在jar外部</a></p>
<p>spring boot程序的static目录默认在resources/static目录， 打包为jar的时候，会把static目录打包进去，这样会存在一些问题：</p>
<ul>
<li>static文件过多，造成jar包体积过大</li>
<li>临时修改不方便</li>
</ul>
<p>查看官方文档，可以发现，static其实是可以外置的。</p>
<h2 id="方法1-直接修改配置文件"><a href="#方法1-直接修改配置文件" class="headerlink" title="方法1 直接修改配置文件"></a>方法1 直接修改配置文件</h2><pre><code>spring.resources.static-locations=file:///E://resources/static
</code></pre>
<h2 id="自定义Configuration方法"><a href="#自定义Configuration方法" class="headerlink" title="自定义Configuration方法"></a>自定义Configuration方法</h2><pre><code>@Configuration
public class StaticResourceConfiguration extends WebMvcConfigurerAdapter &#123;
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
        registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;file:/path/to/my/dropbox/&quot;);
    &#125;
&#125;
</code></pre>
<p>推荐使用方法1，安全无害</p>
<p>相关阅读：<a href="http://www.cnblogs.com/xiaoqi/p/6955288.html">Spring Boot配置文件放在jar外部</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>易企秀前端压缩源码分析与还原</title>
    <url>/jadepeng/2018/03/08/jqpeng-%E6%98%93%E4%BC%81%E7%A7%80%E5%89%8D%E7%AB%AF%E5%8E%8B%E7%BC%A9%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E8%BF%98%E5%8E%9F/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/8529899.html">易企秀前端压缩源码分析与还原</a></p>
<p>你是否想知道易企秀炫酷的H5是如何实现的，原理是什么，本文会为你揭秘并还原压缩过的源代码。</p>
<p>易企秀是一款h5页面制作工具，因方便易用成为业界标杆。后续一个项目会用到类似易企秀这样的自定义H5的功能，因此首先分析下易企秀的前端代码，看看他们是怎么实现的，再取其精华去其糟粕。<br> 由于代码较多，且是压缩处理过的，阅读和还原起来较为困难，不过可以先大概分析下原理，然后有针对性的看主要代码，并借助VS Code等工具对变量、函数进行重命名，稍微耐心一点就能大概还原源代码。</p>
<h2 id="分析数据模型"><a href="#分析数据模型" class="headerlink" title="分析数据模型"></a>分析数据模型</h2><p>前端分析第一步，看看易企秀的数据模型：</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1520492536143.jpg" alt="数据模型" title="1520492536143"></p>
<p>dataList是页面配置信息，elemengts是页面元素的配置信息，obj是H5的配置信息，</p>
<h2 id="加载流程分析"><a href="#加载流程分析" class="headerlink" title="加载流程分析"></a>加载流程分析</h2><p>查看H5源代码，发现入口函数是：</p>
<pre><code> eqShow.bootstrap();
</code></pre>
<p>顺藤摸瓜，大概分析下，主要流程如下：</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1520493739334.jpg" alt="加载主要流程" title="1520493739334"></p>
<p>主要的功能函数在eqxiu和window对象下面，其中的重点是parsePage、renderPage和app,下面一一来分析。</p>
<h2 id="parsePage"><a href="#parsePage" class="headerlink" title="parsePage"></a>parsePage</h2><p>先看主要代码（重命名后的），主要功能是为每一页生成一个section并appendTo(“.nr”)，另外如果页面有特效，加载相关js库并执行，最后再renderPage。</p>
<pre><code>function parsePage(dataList, response) &#123;

        for (var pageIndex = 1; pageIndex &lt;= dataList.length; pageIndex++) &#123;
            // 分页容器
            $(&#39;&lt;section class=&quot;main-page&quot;&gt;&lt;div class=&quot;m-img&quot; id=&quot;page&#39; + pageIndex + &#39;&quot;&gt;&lt;/div&gt;&lt;/section&gt;&#39;).appendTo(&quot;.nr&quot;);

            if (10 == pageMode) &#123;
                $(&quot;#page&quot; + pageIndex).parent(&quot;.main-page&quot;).wrap(&#39;&lt;div class=&quot;flip-mask&quot; id=&quot;flip&#39; + pageIndex + &#39;&quot;&gt;&lt;/div&gt;&#39;),
                    $(&quot;.main-page&quot;).css(&#123;
                        width: $(&quot;.nr&quot;).width() + &quot;px&quot;,
                        height: $(&quot;.nr&quot;).height() + &quot;px&quot;
                    &#125;);
            &#125;

            if (dataList.length &gt; 1 &amp;&amp; 14 != pageMode &amp;&amp; !response.obj.property.forbidHandFlip) &#123;
                if (0 == pageMode || 1 == pageMode || 2 == pageMode || 6 == pageMode || 7 == pageMode ||
                    8 == pageMode || 11 == pageMode || 12 == pageMode || 13 == pageMode || 14 == pageMode) &#123;
                    $(&#39;&lt;section class=&quot;u-arrow-bottom&quot;&gt;&lt;div class=&quot;pre-wrap&quot;&gt;&lt;div class=&quot;pre-box1&quot;&gt;&lt;div class=&quot;pre1&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;pre-box2&quot;&gt;&lt;div class=&quot;pre2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&#39;)
                        .appendTo(&quot;#page&quot; + pageIndex)
                &#125; else if (3 == pageMode || 4 == pageMode || 5 == pageMode || 9 == pageMode || 10 == pageMode) &#123;
                    $(&#39;&lt;section class=&quot;u-arrow-right&quot;&gt;&lt;div class=&quot;pre-wrap-right&quot;&gt;&lt;div class=&quot;pre-box3&quot;&gt;&lt;div class=&quot;pre3&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;pre-box4&quot;&gt;&lt;div class=&quot;pre4&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&#39;)
                        .appendTo(&quot;#page&quot; + pageIndex);
                &#125;
            &#125;

              ....
           renderPage(eqShow, pageIndex, dataList);

                // 最后一页
                if (pageIndex == dataList.length) &#123;
                    eqxiu.app($(&quot;.nr&quot;), response.obj.pageMode, dataList, response);
                    addEnabledClassToPageCtrl(response);
                &#125;
            &#125;

        &#125;

        hasSymbols || addReportToLastPage(dataList, response);
    &#125;
</code></pre>
<h2 id="渲染页面和组件"><a href="#渲染页面和组件" class="headerlink" title="渲染页面和组件"></a>渲染页面和组件</h2><p>parsePage搭建了页面框架，renderPage实现页面渲染。</p>
<p>rendepage里，核心代码是：</p>
<pre><code>eqShow.templateParser(&quot;jsonParser&quot;).parse(&#123;
    def: dataList[pageIndex - 1],
    appendTo: &quot;#page&quot; + pageIndex,
    mode: &quot;view&quot;,
    disEvent: disEvent
&#125;);
</code></pre>
<p>templateParser负责将页面上的elements还原为组件，因此这里核心是要了解下templateParser，大致还原的代码如下：</p>
<pre><code>            var jsonTemplateParser = eqShow.templateParser(&quot;jsonParser&quot;, function () &#123;

                function createContainerFunction(container) &#123;
                    return function (key, value) &#123;
                        container[key] = value
                    &#125;
                &#125;

                function wrapComp(element, mode) &#123;
                    try &#123;
                        var comp = components[(&quot;&quot; + element.type).charAt(0)](element, mode)
                    &#125; catch (e) &#123;
                        return
                    &#125;
                    if (comp) &#123;
                        var elementContainer = $(&#39;&lt;li comp-drag comp-rotate class=&quot;comp-resize comp-rotate inside&quot; id=&quot;inside_&#39; + element.id + &#39;&quot; num=&quot;&#39; +
                                element.num + &#39;&quot; ctype=&quot;&#39; + element.type + &#39;&quot;&gt;&lt;/li&gt;&#39;),
                            elementType = (&quot;&quot; + element.type).charAt(0);

                        if (&quot;3&quot; !== elementType &amp;&amp; &quot;1&quot; !== elementType) &#123;
                            elementContainer.attr(&quot;comp-resize&quot;, &quot;&quot;)
                        &#125;

                        // 组件类型
                        /**
                         *  2 文本
                         *  3 背景
                         *  9 音乐
                         *  v video
                         *  4 图片
                         *  h shape形状
                         *  p 图集
                         *  5 输入框
                         *  r radio
                         *  c checkbox
                         *  z 多选按钮
                         *  a 评分组件
                         *  b 留言板
                         *  6 提交按钮
                         */
                        switch (elementType) &#123;
                            case &quot;p&quot;:
                                elementContainer.removeAttr(&quot;comp-rotate&quot;);
                                break;
                            case &quot;1&quot;:
                                elementContainer.removeAttr(&quot;comp-drag&quot;);
                                break;
                            case &quot;2&quot;: // 文本
                                elementContainer.addClass(&quot;wsite-text&quot;);
                                break;
                            case &quot;3&quot;:
                                // 背景
                                break;
                            case &quot;x&quot;:
                                elementContainer.addClass(&quot;show-text&quot;);
                                break;
                            case &quot;4&quot;:
                                // image
                                element.properties.imgStyle &amp;&amp; $(comp).css(element.properties.imgStyle), elementContainer.addClass(&quot;wsite-image&quot;);
                                break;
                            case &quot;n&quot;:
                                elementContainer.addClass(&quot;wsite-image&quot;);
                                break;
                            case &quot;h&quot;:
                                elementContainer.addClass(&quot;wsite-shape&quot;)
                                break;
                            case &quot;5&quot;:
                                elementContainer.removeAttr(&quot;comp-input&quot;);
                                break;
                            case &quot;6&quot;:
                            case &quot;8&quot;:
                                elementContainer.removeAttr(&quot;comp-button&quot;);
                                break;
                            case &quot;v&quot;:
                                elementContainer.removeAttr(&quot;comp-video&quot;);
                                elementContainer.addClass(&quot;wsite-video&quot;);
                                if (element.properties &amp;&amp; element.properties.lock) &#123;
                                    elementContainer.addClass(&quot;alock&quot;)
                                &#125;
                                break;
                            case &quot;b&quot;:
                                elementContainer.removeAttr(&quot;comp-boards&quot;);
                                elementContainer.attr(&quot;min-h&quot;, 60),
                                    elementContainer.attr(&quot;min-w&quot;, 230);
                                break;
                            default:
                                break;
                        &#125;

                        elementContainer.mouseenter(function () &#123;
                                $(this).addClass(&quot;inside-hover&quot;)
                            &#125;),
                            elementContainer.mouseleave(function () &#123;
                                $(this).removeClass(&quot;inside-hover&quot;)
                            &#125;);

                        // edit或者非文本type，再套一层
                        if (&quot;edit&quot; === jsonTemplateParser.mode || &quot;x&quot; !== (&quot;&quot; + element.type).charAt(0)) &#123;
                            var elementBoxContent = $(&#39;&lt;div class=&quot;element-box-contents&quot;&gt;&#39;),
                                elementBox = $(&#39;&lt;div class=&quot;element-box&quot;&gt;&#39;).append(elementBoxContent.append(comp));
                            elementContainer.append(elementBox),
                                &quot;5&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp; &quot;6&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp; &quot;r&quot; !== element.type &amp;&amp; &quot;c&quot; !== element.type &amp;&amp; &quot;a&quot; !== element.type &amp;&amp; &quot;8&quot; !== element.type &amp;&amp; &quot;l&quot; !== element.type &amp;&amp; &quot;s&quot; !== element.type &amp;&amp; &quot;i&quot; !== element.type &amp;&amp; &quot;h&quot; !== element.type &amp;&amp; &quot;z&quot; !== element.type || &quot;edit&quot; !== mode || $(comp).before($(&#39;&lt;div class=&quot;element&quot; style=&quot;position: absolute; height: 100%; width: 100%;z-index: 1;&quot;&gt;&#39;))
                        &#125;

                        // 文本类型，处理font
                        var k, eleFonts = element.fonts || element.css.fontFamily || element.fontFamily;
                        if (&quot;2&quot; === elementType || &quot;x&quot; === elementType) &#123;
                            for (var content = element.content, font_pattern = /font-family:(.*?);/g, matchResults = [], fonts = []; null !== (matchResults = font_pattern.exec(content));)
                                fonts.push(matchResults[1].trim());
                            if (1 !== fonts.length || &quot;defaultFont&quot; !== fonts[0] &amp;&amp; &quot;moren&quot; !== fonts[0] || (eleFonts = null),
                                eleFonts) &#123;
                                if (&quot;view&quot; === jsonTemplateParser.mode &amp;&amp; element.css.fontFamily &amp;&amp; window.scene &amp;&amp; (window.scene.publishTime || !mobilecheck() &amp;&amp; !tabletCheck() || (k = &quot;@font-face&#123;font-family:&quot; + element.css.fontFamily + &#39;;src: url(&quot;&#39; + element.properties.localFontPath + &#39;&quot;) format(&quot;truetype&quot;);&#125;&#39;,
                                        b(k))),
                                    &quot;object&quot; == typeof eleFonts &amp;&amp; eleFonts.constructor === Object) &#123;
                                    if (!jQuery.isEmptyObject(eleFonts))
                                        for (var q in eleFonts)
                                            u[q] || (&quot;edit&quot; === jsonTemplateParser.mode ? k = &quot;@font-face&#123;font-family:&quot; + q + &quot;;src: url(&quot; + PREFIX_FILE_HOST + eleFonts[q] + &quot;) format(woff);&#125;&quot; : window.scene &amp;&amp; window.scene.publishTime &amp;&amp; (k = &quot;@font-face&#123;font-family:&quot; + q + &#39;;src: url(&quot;&#39; + PREFIX_S2_URL + &quot;fc/&quot; + q + &quot;_&quot; + element.sceneId + &quot;_&quot; + scene.publishTime + &#39;.woff&quot;) format(&quot;woff&quot;);&#125;&#39;),
                                                b(k),
                                                u[q] = !0)
                                &#125; else
                                    u[eleFonts] || (&quot;edit&quot; === jsonTemplateParser.mode ? k = &quot;@font-face&#123;font-family:&quot; + eleFonts + &quot;;src: url(&quot; + PREFIX_FILE_HOST + element.preWoffPath + &quot;) format(woff);&#125;&quot; : window.scene &amp;&amp; window.scene.publishTime &amp;&amp; (k = &quot;@font-face&#123;font-family:&quot; + eleFonts + &#39;;src: url(&quot;&#39; + PREFIX_S2_URL + &quot;fc/&quot; + eleFonts + &quot;_&quot; + element.sceneId + &quot;_&quot; + scene.publishTime + &#39;.woff&quot;) format(&quot;woff&quot;);&#125;&#39;),
                                        b(k),
                                        u[eleFonts] = !0);
                                &quot;edit&quot; === jsonTemplateParser.mode &amp;&amp; localStorage.setItem(&quot;shoppingFontFamily&quot;, JSON.stringify(u))
                            &#125;
                        &#125;

                        // 处理css
                        if (element.css) &#123;
                            var elementWidth = 320 - parseInt(element.css.left, 10);
                            elementContainer.css(&#123;
                                width: elementWidth
                            &#125;);
                            elementContainer.css(&#123;
                                width: element.css.width,
                                height: element.css.height,
                                left: element.css.left,
                                top: element.css.top,
                                zIndex: element.css.zIndex,
                                bottom: element.css.bottom,
                                transform: element.css.transform
                            &#125;);
                            if (0 === element.css.boxShadowSize || &quot;&quot; + element.css.boxShadowSize == &quot;0&quot;) &#123;
                                element.css.boxShadow = &quot;0px 0px 0px rgba(0,0,0,0.5)&quot;;
                                if (&quot;edit&quot; !== jsonTemplateParser.mode &amp;&amp; &quot;x&quot; === (&quot;&quot; + element.type).charAt(0)) &#123;
                                    return elementContainer.append(comp),
                                        elementContainer.find(&quot;.element-box&quot;).css(&#123;
                                            borderStyle: element.css.borderStyle,
                                            borderWidth: element.css.borderWidth,
                                            borderColor: element.css.borderColor,
                                            borderTopLeftRadius: element.css.borderTopLeftRadius,
                                            borderTopRightRadius: element.css.borderTopRightRadius,
                                            borderBottomRightRadius: element.css.borderBottomRightRadius,
                                            borderBottomLeftRadius: element.css.borderBottomLeftRadius,
                                            boxShadow: element.css.boxShadow,
                                            backgroundColor: element.css.backgroundColor,
                                            opacity: element.css.opacity,
                                            width: &quot;100%&quot;,
                                            height: &quot;100%&quot;,
                                            overflow: &quot;hidden&quot;
                                        &#125;),
                                        elementContainer.find(&quot;img&quot;).css(&#123;
                                            width: &quot;100%&quot;
                                        &#125;),
                                        elementContainer;
                                &#125;
                            &#125;

                            // Android 微信，图片，设置borderColor
                            isAndroid() &amp;&amp;
                                isWeixin() &amp;&amp;
                                &quot;&quot; + element.type == &quot;4&quot; &amp;&amp;
                                &quot;0px&quot; !== element.css.borderRadius &amp;&amp;
                                0 === element.css.borderWidth &amp;&amp;
                                element.properties.anim &amp;&amp; (element.css.borderWidth = 1, element.css.borderColor = &quot;rgba(0,0,0,0)&quot;);

                            var elementCss = $.extend(!0, &#123;&#125;, element.css);
                            delete elementCss.fontFamily,
                                elementBox.css(elementCss).css(&#123;
                                    width: &quot;100%&quot;,
                                    height: &quot;100%&quot;,
                                    transform: &quot;none&quot;
                                &#125;),
                                elementBox.children(&quot;.element-box-contents&quot;).css(&#123;
                                    width: &quot;100%&quot;,
                                    height: &quot;100%&quot;
                                &#125;),
                                // 设置宽高
                                &quot;4&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                &quot;n&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                &quot;p&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                &quot;h&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp; &quot;t&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                &quot;z&quot; !== (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                $(comp).css(&#123;
                                    width: element.css.width,
                                    height: element.css.height
                                &#125;),
                                // w01 w02 设置lineHeight
                                (&quot;w01&quot; === element.type || &quot;w02&quot; === element.type) &amp;&amp;
                                $(comp).css(&#123;
                                    lineHeight: element.css.height + &quot;px&quot;
                                &#125;),
                                // shape 类型
                                &quot;h&quot; === (&quot;&quot; + element.type).charAt(0) &amp;&amp;
                                ($(comp).find(&quot;g&quot;).length ?
                                    $(comp).find(&quot;g&quot;).attr(&quot;fill&quot;, element.css.color) :
                                    $(comp).children().attr(&quot;fill&quot;, element.css.color),
                                    elementBox.children(&quot;.element-box-contents&quot;).css(&quot;position&quot;, &quot;relative&quot;))
                        &#125;
                        return elementContainer
                    &#125;
                &#125;

                /**
                 * 将element按zindex排序
                 */
                function sortElementsByZindex(elements) &#123;
                    for (var i = 0; i &lt; elements.length - 1; i++)
                        for (var j = i + 1; j &lt; elements.length; j++)
                            if (parseInt(elements[i].css.zIndex, 10) &gt; parseInt(elements[j].css.zIndex, 10)) &#123;
                                var element = elements[i];
                                elements[i] = elements[j],
                                    elements[j] = element
                            &#125;
                    for (var e = 0; e &lt; elements.length; e++)
                        elements[e].css.zIndex = e + 1 + &quot;&quot;;
                    return elements
                &#125;

                function parseElements(pageDef, $edit_wrapper, mode) &#123;
                    $edit_wrapper = $edit_wrapper.find(&quot;.edit_area&quot;);
                    var i, elements = pageDef.elements;
                    if (elements)
                        for (elements = sortElementsByZindex(elements),
                            i = 0; i &lt; elements.length; i++)
                            if (elements[i].sceneId = pageDef.sceneId,
                                &quot;&quot; + elements[i].type == &quot;3&quot;) &#123;
                                // type == 3 
                                var component = components[(&quot;&quot; + elements[i].type).charAt(0)](elements[i], $edit_wrapper);

                                // if is edit mode, dispatch edit event
                                &quot;edit&quot; === mode
                                    &amp;&amp;
                                    editEvents[(&quot;&quot; + elements[i].type).charAt(0)] &amp;&amp;
                                    editEvents[(&quot;&quot; + elements[i].type).charAt(0)](component, elements[i])
                            &#125; else &#123;
                                var comp = wrapComp(elements[i], mode);
                                if (!comp)
                                    continue;
                                $edit_wrapper.append(comp);

                                // invoke interceptors
                                for (var n = 0; n &lt; interceptors.length; n++)
                                    interceptors[n](comp, elements[i], mode);

                                afterRenderEvents[(&quot;&quot; + elements[i].type).charAt(0)] &amp;&amp;
                                    (
                                        afterRenderEvents[(&quot;&quot; + elements[i].type).charAt(0)](comp, elements[i]),
                                        &quot;edit&quot; !== mode &amp;&amp; (
                                            parseElementTrigger(comp, elements[i]),
                                            r(comp, elements[i])
                                        )
                                    ),

                                    &quot;edit&quot; === mode &amp;&amp;
                                    editEvents[(&quot;&quot; + elements[i].type).charAt(0)] &amp;&amp;
                                    editEvents[(&quot;&quot; + elements[i].type).charAt(0)](comp, elements[i])
                            &#125;
                &#125;

                function getEventHandlers() &#123;
                    return editEvents
                &#125;

                function getComponents() &#123;
                    return components
                &#125;

                function addInterceptor(interceptor) &#123;
                    interceptors.push(interceptor)
                &#125;

                function getInterceptors() &#123;
                    return interceptors
                &#125;
                var components = &#123;&#125;,
                    editEvents = &#123;&#125;,
                    afterRenderEvents = &#123;&#125;,
                    interceptors = [],
                    _width = containerWidth = 320,
                    _height = containerHeight = 486,
                    p = 1,
                    s = 1,
                    parser = &#123;
                        getComponents: getComponents,
                        getEventHandlers: getEventHandlers,
                        addComponent: createContainerFunction(components),
                        bindEditEvent: createContainerFunction(editEvents),
                        bindAfterRenderEvent: createContainerFunction(afterRenderEvents),
                        addInterceptor: addInterceptor,
                        getInterceptors: getInterceptors,
                        wrapComp: wrapComp,
                        disEvent: !1,
                        mode: &quot;view&quot;,
                        parse: function (parseInfo) &#123;
                            var edit_wrapper = $(&#39;&lt;div class=&quot;edit_wrapper&quot; data-scene-id=&quot;&#39; + parseInfo.def.sceneId + &#39;&quot;&gt;&lt;ul eqx-edit-destroy id=&quot;edit_area&#39; + parseInfo.def.id + &#39;&quot; paste-element class=&quot;edit_area weebly-content-area weebly-area-active&quot;&gt;&lt;/div&gt;&#39;),
                                mode = this.mode = parseInfo.mode;
                            // page 定义
                            this.def = parseInfo.def,
                                parseInfo.disEvent &amp;&amp; (this.disEvent = !0),
                                &quot;view&quot; === mode &amp;&amp; tplCount++;
                            // 页面容器
                            var pageContainer = $(parseInfo.appendTo);
                            return containerWidth = pageContainer.width(),
                                containerHeight = pageContainer.height(),
                                p = _width / containerWidth,
                                s = _height / containerHeight,
                                parseElements(parseInfo.def, edit_wrapper.appendTo($(parseInfo.appendTo)), mode)
                        &#125;
                    &#125;;
                return parser
            &#125;);
</code></pre>
<p>上面的重点是parseElements，先把elements按zindex排序，然后逐个渲染。<br> 注意，渲染是根据elementType,从components找到对应的组件，然后创建一个实例，因此这里要单独说下组件是如何定义的。</p>
<p>先看下一个组件的配置信息大概是这样，有id，css，type和动画等配置信息：</p>
<pre><code>    &#123;
    &quot;id&quot;: 29,
    &quot;css&quot;: &#123;
        &quot;top&quot;: 124.93546211843,
        &quot;left&quot;: 62.967731059217,
        &quot;color&quot;: &quot;#676767&quot;,
        &quot;width&quot;: 195,
        &quot;height&quot;: 195,
        &quot;zIndex&quot;: &quot;1&quot;,
        &quot;opacity&quot;: 1,
        &quot;boxShadow&quot;: &quot;0px 0px 0px rgba(0,0,0,0.5)&quot;,
        &quot;transform&quot;: &quot;rotateZ(45deg)&quot;,
        &quot;lineHeight&quot;: 1,
        &quot;paddingTop&quot;: 0,
        &quot;borderColor&quot;: &quot;rgba(255,255,255,1)&quot;,
        &quot;borderStyle&quot;: &quot;double&quot;,
        &quot;borderWidth&quot;: 4,
        &quot;borderRadius&quot;: &quot;0px&quot;,
        &quot;boxShadowSize&quot;: 0,
        &quot;paddingBottom&quot;: 0,
        &quot;backgroundColor&quot;: &quot;rgba(252,230,238,0.16)&quot;,
        &quot;borderRadiusPerc&quot;: 0,
        &quot;boxShadowDirection&quot;: 0,
        &quot;textAlign&quot;: &quot;left&quot;,
        &quot;borderBottomRightRadius&quot;: &quot;0px&quot;,
        &quot;borderBottomLeftRadius&quot;: &quot;0px&quot;,
        &quot;borderTopRightRadius&quot;: &quot;0px&quot;,
        &quot;borderTopLeftRadius&quot;: &quot;0px&quot;
    &#125;,
    &quot;type&quot;: &quot;2&quot;,
    &quot;pageId&quot;: &quot;24642&quot;,
    &quot;content&quot;: &quot;&lt;div style=\&quot;text-align: center;\&quot;&gt;&lt;br&gt;&lt;/div&gt;&quot;,
    &quot;sceneId&quot;: 8831293,
    &quot;properties&quot;: &#123;
        &quot;anim&quot;: &#123;
            &quot;type&quot;: 4,
            &quot;delay&quot;: 0.6,
            &quot;countNum&quot;: 1,
            &quot;duration&quot;: 1,
            &quot;direction&quot;: 0
        &#125;,
        &quot;width&quot;: 195,
        &quot;height&quot;: 195
    &#125;
&#125;
</code></pre>
<p>jsonParser里用一个components对象存储组件，通过addComponent添加组件，key就是组件的type：</p>
<pre><code>addComponent: createContainerFunction(components)
function createContainerFunction(container) &#123;
                return function (key, value) &#123;
                    container[key] = value
                &#125;
            &#125;
</code></pre>
<p>添加组件时，type 作为key，value为创建组件的函数：</p>
<pre><code>// 添加组件1jsonTemplateParser.addComponent(&quot;1&quot;, function (element, mode) &#123;    var comp = document.createElement(&quot;div&quot;);    if (comp.id = element.id,        comp.setAttribute(&quot;class&quot;, &quot;element comp_title&quot;),        // 设置组件content        element.content &amp;&amp; (comp.textContent = element.content),        element.css) &#123;        var item, elementCss = element.css;        for (item in elementCss)            comp.style[item] = elementCss[item]    &#125;    if (element.properties.labels)        for (var labels = element.properties.labels, f = 0; f &lt; labels.length; f++)            $(&#39;&lt;a class = &quot;label_content&quot; style = &quot;display: inline-block;&quot;&gt;&#39;)            .appendTo($(comp))            .html(labels[f].title)            .css(labels[f].color)            .css(&quot;width&quot;, 100 / labels.length + &quot;%&quot;);    return comp&#125;);
</code></pre>
<p>这样渲染组件时，根据element的类型就能找到createCompFunction，从而创建组件。</p>
<h2 id="组件动画播放"><a href="#组件动画播放" class="headerlink" title="组件动画播放"></a>组件动画播放</h2><p>H5之所以炫酷，很大一部分因为每个组件都有定制好的CSS3动画，我们这里来看看这些动画是如何执行的。</p>
<p>代码还是上一部分的代码，我们注意到组件渲染后，有一段代码;</p>
<pre><code>  // invoke interceptorsfor (var n = 0; n &lt; interceptors.length; n++)    interceptors[n](comp, elements[i], mode);
</code></pre>
<p>执行interceptors，这个interceptors可以通过addInterceptor注册拦截器，在组件渲染完成后会调用定义的拦截器，组件的动画就是这样来调用的。</p>
<pre><code>        // 添加拦截器执行动画
        jsonTemplateParser.addInterceptor(function (comp, element, mode) &#123;
            eqxCommon.animation(comp, element, mode, jsonTemplateParser.def.properties)
        &#125;);
</code></pre>
<p>我们发现，eqxiu通过addInterceptor注册了一个拦截器，该拦截器调用eqxCommon.animation执行组件动画，因此分析eqxCommon.animation就可以了解动画是如何实现的。</p>
<p>还是先看element里的定义：</p>
<pre><code>     &quot;properties&quot;: &#123;        &quot;anim&quot;: &#123;            &quot;type&quot;: 4,            &quot;delay&quot;: 0.6,            &quot;countNum&quot;: 1,            &quot;duration&quot;: 1,            &quot;direction&quot;: 0        &#125;,
</code></pre>
<p>我们看到，anim里定义了type，delay，duration等配置信息，可以设想播放动画无非就是解析这个配置，然后执行，其中type应该是对应的各种动画类型，分析代码吧，下面给出破解后的代码：</p>
<pre><code>        // 动画播放序号
        var animIndex = 0;

        // 处理动画属性
        if (element.properties &amp;&amp; element.properties.anim) &#123;
            var anim = [];
            element.properties.anim.length ? anim = element.properties.anim : anim.push(element.properties.anim);
            var elementBox = $(&quot;.element-box&quot;, comp);
            elementBox.attr(&quot;element-anim&quot;, &quot;&quot;);

            // 找出animations
            for (var animType, animTypes = [], anims = [], index = 0, animLength = anim.length; animLength &gt; index; index++)
                if (null != anim[index].type &amp;&amp;
                    -1 != anim[index].type) &#123;
                    animType = eqxCommon.convertType(anim[index]),
                        animTypes.push(animType),
                        anims.push(anim[index]);
                &#125;

            if (properties &amp;&amp; properties.scale)
                return;

            // 动画播放类型
            element.properties.anim.trigger ?
                comp.click(function () &#123;
                    // 点击播放
                    playAnimation(elementBox, animType, element.properties.anim)
                &#125;) :
                properties &amp;&amp; properties.longPage ?
                playAnimation(elementBox, animTypes, anims, !0, element.css) // longpage
                :
                playAnimation(elementBox, animTypes, anims)
        &#125;
</code></pre>
<p>上面的逻辑是先从element里找到anim，放入数组，然后再playAnimation。这里使用了convertType函数将数字type转换为真实的动画类型：</p>
<pre><code>var convertType = function (a) &#123;
        var animType, c, d = a.type;
        return &quot;typer&quot; === d &amp;&amp; (animType = &quot;typer&quot;),
            0 === d &amp;&amp; (animType = &quot;fadeIn&quot;),
            1 === d &amp;&amp; (c = a.direction,
                0 === c &amp;&amp; (animType = &quot;fadeInLeft&quot;),
                1 === c &amp;&amp; (animType = &quot;fadeInDown&quot;),
                2 === c &amp;&amp; (animType = &quot;fadeInRight&quot;),
                3 === c &amp;&amp; (animType = &quot;fadeInUp&quot;)),
            6 === d &amp;&amp; (animType = &quot;wobble&quot;),
            5 === d &amp;&amp; (animType = &quot;rubberBand&quot;),
            7 === d &amp;&amp; (animType = &quot;rotateIn&quot;),
            8 === d &amp;&amp; (animType = &quot;flip&quot;),
            9 === d &amp;&amp; (animType = &quot;swing&quot;),
            2 === d &amp;&amp; (c = a.direction,
                0 === c &amp;&amp; (animType = &quot;bounceInLeft&quot;),
                1 === c &amp;&amp; (animType = &quot;bounceInDown&quot;),
                2 === c &amp;&amp; (animType = &quot;bounceInRight&quot;),
                3 === c &amp;&amp; (animType = &quot;bounceInUp&quot;)),
            3 === d &amp;&amp; (animType = &quot;bounceIn&quot;),
            4 === d &amp;&amp; (animType = &quot;zoomIn&quot;),
            10 === d &amp;&amp; (animType = &quot;fadeOut&quot;),
            11 === d &amp;&amp; (animType = &quot;flipOutY&quot;),
            12 === d &amp;&amp; (animType = &quot;rollIn&quot;),
            13 === d &amp;&amp; (animType = &quot;lightSpeedIn&quot;),
            14 === d &amp;&amp; (animType = &quot;bounceOut&quot;),
            15 === d &amp;&amp; (animType = &quot;rollOut&quot;),
            16 === d &amp;&amp; (animType = &quot;lightSpeedOut&quot;),
            17 === d &amp;&amp; (c = a.direction,
                0 === c &amp;&amp; (animType = &quot;fadeOutRight&quot;),
                1 === c &amp;&amp; (animType = &quot;fadeOutDown&quot;),
                2 === c &amp;&amp; (animType = &quot;fadeOutLeft&quot;),
                3 === c &amp;&amp; (animType = &quot;fadeOutUp&quot;)),
            18 === d &amp;&amp; (animType = &quot;zoomOut&quot;),
            19 === d &amp;&amp; (c = a.direction,
                0 === c &amp;&amp; (animType = &quot;bounceOutRight&quot;),
                1 === c &amp;&amp; (animType = &quot;bounceOutDown&quot;),
                2 === c &amp;&amp; (animType = &quot;bounceOutLeft&quot;),
                3 === c &amp;&amp; (animType = &quot;bounceOutUp&quot;)),
            20 === d &amp;&amp; (animType = &quot;flipInY&quot;),
            21 === d &amp;&amp; (animType = &quot;tada&quot;),
            22 === d &amp;&amp; (animType = &quot;jello&quot;),
            23 === d &amp;&amp; (animType = &quot;flash&quot;),
            26 === d &amp;&amp; (animType = &quot;twisterInDown&quot;),
            27 === d &amp;&amp; (animType = &quot;puffIn&quot;),
            28 === d &amp;&amp; (animType = &quot;puffOut&quot;),
            29 === d &amp;&amp; (animType = &quot;slideDown&quot;),
            30 === d &amp;&amp; (animType = &quot;slideUp&quot;),
            24 === d &amp;&amp; (animType = &quot;flipInX&quot;),
            25 === d &amp;&amp; (animType = &quot;flipOutX&quot;),
            31 === d &amp;&amp; (animType = &quot;twisterInUp&quot;),
            32 == d &amp;&amp; (animType = &quot;vanishOut&quot;),
            33 == d &amp;&amp; (animType = &quot;vanishIn&quot;),
            animType
    &#125;;
</code></pre>
<p>播放动画函数在playAnimation里：</p>
<ul>
<li>大概是先判断类型是否是typer，typer的话是打字机特效，调用相关代码</li>
<li>设置element的的css animation属性，本质上是CSS3的animation动画,可以参见（<a href="http://www.w3school.com.cn/css3/css3_animation.asp%EF%BC%89">http://www.w3school.com.cn/css3/css3_animation.asp）</a></li>
</ul>
<pre><code> elementBox.css(&quot;animation&quot;, &quot;&quot;);
                elementBox.css(&quot;animation&quot;, animTypes[animIndex] + &quot; &quot; + anims[animIndex].duration + &quot;s ease &quot; + anims[animIndex].delay + &quot;s &quot; +
                    (anims[animIndex].countNum ? anims[animIndex].countNum : &quot;&quot;));                 anims[animIndex].count &amp;&amp; animIndex == anims.length - 1 &amp;&amp; elementBox.css(&quot;animation-iteration-count&quot;, &quot;infinite&quot;);
                    elementBox.css(&quot;animation-fill-mode&quot;, &quot;both&quot;);
</code></pre>
<p>最后，如果有多个动画，在播放完成后继续播放下一个：</p>
<pre><code>// 动画播放结束，播放下一个动画（一个组件可能有多个动画）
                elementBox.one(&quot;webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend&quot;, function () &#123;
                    animIndex++;
                    playAnimation(elementBox, animTypes, anims);
                &#125;)
</code></pre>
<h2 id="页面切换"><a href="#页面切换" class="headerlink" title="页面切换"></a>页面切换</h2><p>由于是多页应用，因此涉及到页面切换，并且页面切换时还需要有对应的切换动画，改工作是由一个eqxiu对象来管理和实现的。</p>
<p>老套路，先看这块的配置吧，页面的配置在obj下面,其中pageMode定义了翻页效果：</p>
<pre><code>&quot;obj&quot;: &#123;
    &quot;id&quot;: 8831293,
    &quot;name&quot;: &quot;房产广告&quot;,
    &quot;createUser&quot;: &quot;1&quot;,
    &quot;type&quot;: 103,
    &quot;pageMode&quot;: 4,
    &quot;image&quot;: &#123;&#125;,
    &quot;property&quot;: &quot;&#123;\&quot;triggerLoop\&quot;:true,\&quot;slideNumber\&quot;:true,\&quot;autoFlipTime\&quot;:4,\&quot;shareDes\&quot;:\&quot;\&quot;,\&quot;eqAdType\&quot;:1,\&quot;hideEqAd\&quot;:false,\&quot;autoFlip\&quot;:true,\&quot;lastPageId\&quot;:604964&#125;&quot;,
    &quot;timeout&quot;: &quot;&quot;,
    &quot;timeout_url&quot;: &quot;&quot;,
    &quot;accessCode&quot;: null,
    &quot;cover&quot;: &quot;syspic/pageimg/yq0KA1UrbkOAV_yiAAFuhyGx9LE397.jpg&quot;,
    &quot;bgAudio&quot;: &quot;&#123;\&quot;url\&quot;:\&quot;syspic/mp3/yq0KA1RHT3iAMXYOAAgPq1MjV9M930.mp3\&quot;,\&quot;type\&quot;:\&quot;3\&quot;&#125;&quot;,
    &quot;isTpl&quot;: 0,
    &quot;isPromotion&quot;: 0,
    &quot;status&quot;: 1,
    &quot;openLimit&quot;: 0,
    &quot;startDate&quot;: null,
    &quot;endDate&quot;: null,
    &quot;updateTime&quot;: 1426045746000,
    &quot;createTime&quot;: 1426572693000,
    &quot;publishTime&quot;: 1426572693000,
    &quot;applyTemplate&quot;: 0,
    &quot;applyPromotion&quot;: 0,
    &quot;sourceId&quot;: null,
    &quot;code&quot;: &quot;U903078B74Q5&quot;,
    &quot;description&quot;: &quot;房产广告&quot;,
    &quot;sort&quot;: 0,
    &quot;pageCount&quot;: 0,
    &quot;dataCount&quot;: 0,
    &quot;showCount&quot;: 44,
    &quot;eqcode&quot;: &quot;&quot;,
    &quot;userLoginName&quot;: null,
    &quot;userName&quot;: null
&#125;,
</code></pre>
<p>pagemode是这样定义的：</p>
<pre><code>pagemodes = [&#123;        id: 0,        name: &quot;上下翻页&quot;    &#125;, &#123;        id: 4,        name: &quot;左右翻页&quot;    &#125;, &#123;        id: 1,        name: &quot;上下惯性翻页&quot;    &#125;, &#123;        id: 3,        name: &quot;左右惯性翻页&quot;    &#125;, &#123;        id: 11,        name: &quot;上下连续翻页&quot;    &#125;, &#123;        id: 5,        name: &quot;左右连续翻页&quot;    &#125;, &#123;        id: 6,        name: &quot;立体翻页&quot;    &#125;, &#123;        id: 7,        name: &quot;卡片翻页&quot;    &#125;, &#123;        id: 8,        name: &quot;放大翻页&quot;    &#125;, &#123;        id: 9,        name: &quot;交换翻页&quot;    &#125;, &#123;        id: 10,        name: &quot;翻书翻页&quot;    &#125;, &#123;        id: 12,        name: &quot;掉落翻页&quot;    &#125;, &#123;        id: 13,        name: &quot;淡入翻页&quot;    &#125;];
</code></pre>
<p>在renderpage结束后，调用eqxiu.app：</p>
<pre><code>                  // 最后一页
                if (pageIndex == dataList.length) &#123;
                    eqxiu.app($(&quot;.nr&quot;), response.obj.pageMode, dataList, response);
                    addEnabledClassToPageCtrl(response);
                &#125;
</code></pre>
<p>来分析eqxiu.app代码，通过pagemode，我们可以看出翻页打开分为上下翻页、左右翻页两个大类：</p>
<pre><code>if (&quot;8&quot; == pageMode || &quot;9&quot; == pageMode) &#123;
            transformTime = 0.7;
            timeoutDelay = 800;
        &#125;
        // 上下翻页  上下惯性翻页 立体翻页 卡片翻页 放大翻页 上下连续翻页 上下连续翻页
        if (0 == pageMode || (1 == pageMode || (2 == pageMode || (6 == pageMode || (7 == pageMode || (8 == pageMode || (11 == pageMode || 12 == pageMode))))))) &#123;
            /** @type &#123;boolean&#125; */
            upDownMode = true;
        &#125; else &#123;
            // 左右惯性翻页 左右翻页 左右连续翻页  翻书翻页
            if (3 == pageMode || (4 == pageMode || (5 == pageMode || 10 == pageMode))) &#123;
                /** @type &#123;boolean&#125; */
                leftRightMode = true;
            &#125;
        &#125;
</code></pre>
<p>然后配置里有一个autoFlip，代表是否自动翻页,通过setInterval设置定时翻页任务：</p>
<pre><code>        // 自动翻页
        if (response.obj.property.autoFlip) &#123;
            // 自动翻页时间
            autoFlipTimeMS = 1000 * response.obj.property.autoFlipTime;
            setAndStartAutoFlip(autoFlipTimeMS);
        &#125;    
    /**
     * 设置翻页时间间隔并启动翻页
     * @param &#123;number&#125; textStatus
     * @return &#123;undefined&#125;
     */
    function setAndStartAutoFlip(autoFlipTime) &#123;
        autoFlipTime = autoFlipTime;
        pauseAutoFlip();
        startAutoFlip();
    &#125;           /**
     * 启动自动翻页
     * @return &#123;undefined&#125;
     */
    function startAutoFlip() &#123;
        // 通过setInterval
        autoFlipIntervalId = setInterval(function () &#123;
            if (!(10 === self._scrollMode)) &#123;
                if (!isTouching) &#123;
                    nextPage();
                &#125;
            &#125;
        &#125;, autoFlipTimeMS);
    &#125;
</code></pre>
<p>默认情况下H5是支持touch滑动翻页的，这种滑动操作一般是监听相关事件，开始滑动、滑动中和滑动结束，为了同时支持移动端和PC端，还需要加上鼠标点击事件：</p>
<pre><code>        var isTouch = false;
        self._$app.on(&quot;mousedown touchstart&quot;, function (e) &#123;
            if (!self._isforbidHandFlip) &#123;
                onTouchStart(e);
                isTouch = true;
            &#125;
        &#125;).on(&quot;mousemove touchmove&quot;, function (e) &#123;
            if (!self._isforbidHandFlip) &#123;
                if (isTouch) &#123;
                    onTouchMove(e);
                &#125;
            &#125;
        &#125;).on(&quot;mouseup touchend mouseleave&quot;, function (events) &#123;
            if (!self._isforbidHandFlip) &#123;
                onTouchEnd(events);
                /** @type &#123;boolean&#125; */
                isTouch = false;
            &#125;
        &#125;);
</code></pre>
<p>翻页的核心无非就是判断位移是否超过特定的值，比如左右翻页X位移是否大于Y位移并且X的偏移量大于20。因此onTouchStart开始时，记录初始位置，onTouchMove时计算offset变化，按照pageMode执行对应的动画，onTouchEnd时判断位移是否足够，足够就切换页面，否则复位。</p>
<pre><code>/**
         * 开始滑动
         * @param &#123;Object&#125; e
         * @return &#123;undefined&#125;
         */
        onTouchStart = function (e) &#123;
            /** @type &#123;boolean&#125; */
            fa = false;
            if (isMobile) &#123;
                if (e) &#123;
                    e = event;
                &#125;
            &#125;
            if (!self._isDisableFlipPage) &#123;
                self.$currentPage = self._$pages.filter(&quot;.z-current&quot;).get(0);
                if (!C) &#123;
                    /** @type &#123;null&#125; */
                    self.$activePage = null;
                &#125;
                if (self.$currentPage) &#123;
                    if (completeEffect($(self.$currentPage))) &#123;
                        isTouching = true;
                        isCursorAtEnd = false;
                        ignoreEvent = true;
                        offsetX = 0;
                        offsetY = 0;
                        if (e &amp;&amp; &quot;mousedown&quot; == e.type) &#123;
                            currentPageX = e.pageX;
                            currentPageY = e.pageY;
                        &#125; else if (e &amp;&amp; &quot;touchstart&quot; == e.type) &#123;
                            currentPageX = e.touches ? e.touches[0].pageX : e.originalEvent.touches[0].pageX;
                            currentPageY = e.touches ? e.touches[0].pageY : e.originalEvent.touches[0].pageY;
                        &#125;
                        self.$currentPage.classList.add(&quot;z-move&quot;);
                        setAttribute(self.$currentPage.style, &quot;Transition&quot;, &quot;none&quot;);
                        if (&quot;12&quot; == self._scrollMode) &#123;
                            /** @type &#123;number&#125; */
                            self.$currentPage.style.zIndex = 3;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;;

        /**
         * 滑动处理
         * @param &#123;Object&#125; e
         * @return &#123;undefined&#125;
         */
        onTouchMove = function (e) &#123;
            if (isMobile) &#123;
                if (e) &#123;
                    e = event;
                &#125;
            &#125;
            if (isTouching) &#123;
                if (self._$pages.length &gt; 1) &#123;
                    if (e &amp;&amp; &quot;mousemove&quot; == e.type) &#123;
                        offsetX = e.pageX - currentPageX;
                        offsetY = e.pageY - currentPageY;
                    &#125; else &#123;
                        if (e) &#123;
                            if (&quot;touchmove&quot; == e.type) &#123;
                                offsetX = (e.touches ? e.touches[0].pageX : e.originalEvent.touches[0].pageX) - currentPageX;
                                offsetY = (e.touches ? e.touches[0].pageY : e.originalEvent.touches[0].pageY) - currentPageY;
                            &#125;
                        &#125;
                    &#125;
                    if (!fa) &#123;
                        if (Math.abs(offsetX) &gt; 20 || Math.abs(offsetY) &gt; 20) &#123;
                            /** @type &#123;boolean&#125; */
                            fa = true;
                        &#125;
                    &#125;

                    switch (self._scrollMode + &quot;&quot;) &#123;
                        case &quot;0&quot;:
                        case &quot;1&quot;:
                        case &quot;2&quot;:
                        case &quot;15&quot;:
                            //上下翻页
                            upDownFlip();
                            break;
                        case &quot;3&quot;:
                        case &quot;4&quot;:
                            // 左右翻页
                            leftRightFlip();
                            break;
                        case &quot;5&quot;:
                            // 左右连续翻页
                            leftRightLoopFlip();
                            break;
                        case &quot;7&quot;:
                            cardFlip();
                            break;
                        case &quot;8&quot;:
                            scaleUpFlip();
                            break;
                        case &quot;9&quot;:
                            switchFlip();
                            break;
                        case &quot;11&quot;:
                            //上下连续翻页
                            upDownContinuousFlip();
                            break;
                        case &quot;12&quot;:
                            //掉落翻页
                            dropFlip();
                            break;
                        case &quot;13&quot;:
                        case &quot;14&quot;:
                            //淡入翻页
                            fadeFlip();
                            break;
                        default:
                            break;
                    &#125;
                &#125;
            &#125;
        &#125;;


        /**
         *  滑动结束
         * @param &#123;?&#125; e
         * @return &#123;undefined&#125;
         */
        onTouchEnd = function (e) &#123;
            if (isTouching &amp;&amp; completeEffect($(self.$currentPage))) &#123;
                isTouching = false;
                if (self.$activePage) &#123;
                    self._isDisableFlipPage = true;
                    var ease;
                    ease = &quot;6&quot; == self._scrollMode || &quot;7&quot; == self._scrollMode ? &quot;cubic-bezier(0,0,0.99,1)&quot; : &quot;12&quot; == self._scrollMode ? &quot;cubic-bezier(.17,.67,.87,.13)&quot; : &quot;linear&quot;;
                    self.$currentPage.style.webkitTransition = &quot;-webkit-transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$activePage.style.webkitTransition = &quot;-webkit-transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$currentPage.style.mozTransition = &quot;-moz-transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$activePage.style.mozTransition = &quot;-moz-transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$currentPage.style.transition = &quot;transform &quot; + transformTime + &quot;s &quot; + ease;
                    self.$activePage.style.transition = &quot;transform &quot; + transformTime + &quot;s &quot; + ease;

                    // 完成翻页
                    if (&quot;0&quot; == self._scrollMode || (&quot;2&quot; == self._scrollMode || (&quot;1&quot; == self._scrollMode || &quot;15&quot; == self._scrollMode))) &#123;
                        endUpDownFlip();
                    &#125; else if (&quot;4&quot; == self._scrollMode || &quot;3&quot; == self._scrollMode) &#123;
                        // 左右翻页
                        endLeftRightFlip();
                    &#125; else if (&quot;5&quot; == self._scrollMode) &#123;
                        //左右连续翻页
                        endLeftRightContinueFlip();
                    &#125; else if (&quot;6&quot; == self._scrollMode) &#123;
                        //立体翻页
                        endCubeFlip();
                    &#125; else if (&quot;7&quot; == self._scrollMode) &#123;
                        //卡片翻页
                        endCardFlip();
                    &#125; else if (&quot;8&quot; == self._scrollMode) &#123;
                        //放大翻页
                        endScaleUpFlip();
                    &#125; else if (&quot;9&quot; == self._scrollMode) &#123;
                        //交换翻页
                        endSwitchFlip();
                    &#125; else if (&quot;11&quot; == self._scrollMode) &#123;
                        //上下连续翻页
                        endUpDownContinueFlip();
                    &#125; else if (&quot;12&quot; == self._scrollMode) &#123;
                        //掉落翻页
                        endDropFlip();
                    &#125; else if (&quot;13&quot; == self._scrollMode || &quot;14&quot; == self._scrollMode) &#123;
                        //淡入翻页
                        endFadeFlip();
                    &#125; 

                    /** @type &#123;number&#125; */
                    var pageIndex = $(self.$activePage).find(&quot;.m-img&quot;).attr(&quot;id&quot;).replace(&quot;page&quot;, &quot;&quot;) - 1;
                    if (self._pageData[pageIndex].properties) &#123;
                        if (self._pageData[pageIndex].properties.longPage) &#123;
                            $(document).trigger(&quot;clearTouchPos&quot;);
                        &#125;
                    &#125;
                    $(self.$activePage).find(&quot;li.comp-resize&quot;).each(function (dataAndEvents) &#123;
                        /** @type &#123;number&#125; */
                        var i = 0;
                        for (; i &lt; self._pageData[pageIndex].elements.length; i++) &#123;
                            if (self._pageData[pageIndex].elements[i].id == parseInt($(this).attr(&quot;id&quot;).substring(7), 10)) &#123;
                                eqxCommon.animation($(this), self._pageData[pageIndex].elements[i], &quot;view&quot;, self._pageData[pageIndex].properties);
                                var r20 = getComp(self._pageData[pageIndex].elements[i].id);
                                eqxCommon.bindTrigger(r20, self._pageData[pageIndex].elements[i]);
                            &#125;
                        &#125;
                    &#125;);
                    /** @type &#123;number&#125; */
                    var i = 0;
                    for (; i &lt; self._pageData.length; i++) &#123;
                        if (self._pageData[i].effObj) &#123;
                            /** @type &#123;boolean&#125; */
                            self._pageData[i].effObj.pause = true;
                        &#125;
                    &#125;
                    if (self._pageData[pageIndex].effObj) &#123;
                        self._pageData[pageIndex].effObj.startPlay();
                    &#125;
                    eqShow.setPageHis(self._pageData[pageIndex].id);
                &#125; else &#123;
                    self.$currentPage.classList.remove(&quot;z-move&quot;);
                &#125;
            &#125;
            C = false;
        &#125;;
</code></pre>
<p>然后再来看自动翻页nextPage</p>
<pre><code>  /**
     * 启动自动翻页
     * @return &#123;undefined&#125;
     */
    function startAutoFlip() &#123;
        // 通过setInterval
        autoFlipIntervalId = setInterval(function () &#123;
            if (!(10 === self._scrollMode)) &#123;
                if (!isTouching) &#123;
                    nextPage();
                &#125;
            &#125;
        &#125;, autoFlipTimeMS);
    &#125;
</code></pre>
<p>自动翻页比较简单，模拟滑动操作，当位移足够时就可以自动翻页了：</p>
<pre><code>/**
     *  上一页
     * @param &#123;number&#125; direction
     * @return &#123;undefined&#125;
     */
    function prePage(direction) &#123;
        if (!(leftRightMode &amp;&amp; 2 == direction || upDownMode &amp;&amp; 1 == direction)) &#123;
            if (&quot;10&quot; != self._scrollMode) &#123;
                var offset = 0;
                // 开启滑动
                onTouchStart();
                // 定时器，增加offset,模拟滑动
                var poll = setInterval(function () &#123;
                    offset += 2;
                    if (&quot;0&quot; == self._scrollMode || (&quot;1&quot; == self._scrollMode || (&quot;2&quot; == self._scrollMode || (&quot;6&quot; == self._scrollMode || (&quot;7&quot; == self._scrollMode || (&quot;8&quot; == self._scrollMode || (&quot;11&quot; == self._scrollMode || (&quot;12&quot; == self._scrollMode || (&quot;13&quot; == self._scrollMode || (&quot;14&quot; == self._scrollMode || &quot;15&quot; == self._scrollMode)))))))))) &#123;
                        // 纵向翻页，增加y
                        offsetY = offset;
                    &#125; else &#123;
                        if (&quot;3&quot; == self._scrollMode || (&quot;4&quot; == self._scrollMode || (&quot;5&quot; == self._scrollMode || &quot;9&quot; == self._scrollMode))) &#123;
                            // 横向翻页，增加x
                            offsetX = offset;
                        &#125;
                    &#125;
                    // 触发move操作，模拟滑动
                    onTouchMove();
                    if (offset &gt;= 21) &#123;
                        // 位移超过20，
                        clearInterval(poll);
                        // 停止滑动,完成翻页
                        onTouchEnd();
                    &#125;
                &#125;, 1);
            &#125; else &#123;
                // 翻书
                $(document).trigger(&quot;bookFlipPre&quot;);
            &#125;
        &#125;
    &#125;

    /**
     * 下一页，逻辑和prePage类似
     * @param &#123;number&#125; direction
     * @return &#123;undefined&#125;
     */
    function nextPage(direction) &#123;
        if (!(leftRightMode &amp;&amp; 2 == direction || upDownMode &amp;&amp; 1 == direction)) &#123;
            if (&quot;10&quot; != self._scrollMode) &#123;
                u = false;
                var offset = 0;
                if (&quot;block&quot; == $(&quot;body .boards-panel&quot;).css(&quot;display&quot;)) &#123;
                    $(&quot;body .boards-panel&quot;).hide();
                    $(&quot;body .z-current&quot;).show();
                &#125;
                onTouchStart();
                var poll = setInterval(function () &#123;
                    offset -= 2;
                    if (&quot;0&quot; == self._scrollMode || (&quot;1&quot; == self._scrollMode || (&quot;2&quot; == self._scrollMode || (&quot;6&quot; == self._scrollMode || (&quot;7&quot; == self._scrollMode || (&quot;8&quot; == self._scrollMode || (&quot;11&quot; == self._scrollMode || (&quot;12&quot; == self._scrollMode || (&quot;13&quot; == self._scrollMode || (&quot;14&quot; == self._scrollMode || &quot;15&quot; == self._scrollMode)))))))))) &#123;
                        offsetY = offset;
                    &#125; else &#123;
                        if (&quot;3&quot; == self._scrollMode || (&quot;4&quot; == self._scrollMode || (&quot;5&quot; == self._scrollMode || &quot;9&quot; == self._scrollMode))) &#123;
                            offsetX = offset;
                        &#125;
                    &#125;
                    onTouchMove();
                    if (-21 &gt;= offset) &#123;
                        clearInterval(poll);
                        onTouchEnd();
                        if (!triggerLoop) &#123;
                            if (!self.$activePage) &#123;
                                clearInterval(autoFlipIntervalId);
                            &#125;
                        &#125;
                    &#125;
                &#125;, 1);
            &#125; else &#123;
                $(document).trigger(&quot;bookFlipNext&quot;);
            &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面是花了大概一天多的时间阅读代码的成果，总结经验就是阅读代码先分析大的流程，再层层递进分析一些细节，就能一步一步接近真相。</p>
<p>另外，阅读压缩过的代码，可以借助VS Code，善用F2重命名，修改的越多，越接近本来的代码：）</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring boot自定义启动字符画（banner）</title>
    <url>/jadepeng/2018/02/28/jqpeng-Spring%20boot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E5%AD%97%E7%AC%A6%E7%94%BB%EF%BC%88banner%EF%BC%89/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/springboot-banner.html">Spring boot自定义启动字符画（banner）</a></p>
<p>spring boot项目启动时会打印spring boot的ANSI字符画，可以进行自定义。</p>
<h2 id="如何自定义"><a href="#如何自定义" class="headerlink" title="如何自定义"></a>如何自定义</h2><p>实现方式非常简单，我们只需要在Spring Boot工程的/src/main/resources目录下创建一个banner.txt文件，然后将ASCII字符画复制进去，就能替换默认的banner了。</p>
<pre><code>█████████████████████████████████████████████████████████████████████████████████████████████████████

 █████╗ ██╗██╗   ██╗██╗    ███████╗ █████╗  █████╗ ███████╗
██╔══██╗██║██║   ██║██║    ██╔════╝██╔══██╗██╔══██╗██╔════╝
███████║██║██║   ██║██║    ███████╗███████║███████║███████╗
██╔══██║██║██║   ██║██║    ╚════██║██╔══██║██╔══██║╚════██║
██║  ██║██║╚██████╔╝██║    ███████║██║  ██║██║  ██║███████║
╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═╝    ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝

█████████████████████████████████████████████████████████████████████████████████████████████████████
</code></pre>
<h2 id="如何生成字符画"><a href="#如何生成字符画" class="headerlink" title="如何生成字符画"></a>如何生成字符画</h2><p>如果让我们手工的来编辑这些字符画，显然是一件非常困难的差事。</p>
<p>正好刚接触jhipster，发现有一个 <a href="https://github.com/PierreBesson/generator-jhipster-banner">generator-jhipster-banner插件</a>，可以生成banner.</p>
<p>首先安装：</p>
<pre><code>npm install -g generator-jhipster-banner
</code></pre>
<p>使用：</p>
<pre><code>yo jhipster-banner.
</code></pre>
<p>没有安装yo的，先安装：</p>
<pre><code>npm install -g yo
</code></pre>
<p>按提示输入文本和选择颜色即可。</p>
<p>其他方法：</p>
<p><a href="http://patorjk.com/software/taag">http://patorjk.com/software/taag</a><br><a href="http://www.network-science.de/ascii/">http://www.network-science.de/ascii/</a><br><a href="http://www.degraeve.com/img2txt.php">http://www.degraeve.com/img2txt.php</a></p>
<h2 id="彩蛋：永不宕机佛祖"><a href="#彩蛋：永不宕机佛祖" class="headerlink" title="彩蛋：永不宕机佛祖"></a>彩蛋：永不宕机佛祖</h2><pre><code>$&#123;AnsiColor.BRIGHT_YELLOW&#125;
////////////////////////////////////////////////////////////////////
//                          _ooOoo_                               //
//                         o8888888o                              //
//                         88&quot; . &quot;88                              //
//                         (| ^_^ |)                              //
//                         O\  =  /O                              //
//                      ____/`---&#39;\____                           //
//                    .&#39;  \\|     |//  `.                         //
//                   /  \\|||  :  |||//  \                        //
//                  /  _||||| -:- |||||-  \                       //
//                  |   | \\\  -  /// |   |                       //
//                  | \_|  &#39;&#39;\---/&#39;&#39;  |   |                       //
//                  \  .-\__  `-`  ___/-. /                       //
//                ___`. .&#39;  /--.--\  `. . ___                     //
//              .&quot;&quot; &#39;&lt;  `.___\_&lt;|&gt;_/___.&#39;  &gt;&#39;&quot;&quot;.                  //
//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //
//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //
//      ========`-.____`-.___\_____/___.-`____.-&#39;========         //
//                           `=---=&#39;                              //
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //
//            佛祖保佑       永不宕机     永无BUG                  //
////////////////////////////////////////////////////////////////////
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>gitbook安装与使用，并使用docker部署</title>
    <url>/jadepeng/2018/01/04/jqpeng-gitbook%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/gitbook-setup-and-usage-publish-with-docker.html">gitbook安装与使用，并使用docker部署</a></p>
<p>本文简单介绍如何安装并使用gitbook，最后如何使用docker构建书籍镜像。</p>
<h1 id="1-前置条件"><a href="#1-前置条件" class="headerlink" title="1. 前置条件"></a>1. 前置条件</h1><p>需要Nodejs环境，安装npm，国内用户再安装cnpm</p>
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<h1 id="2-安装gitbook"><a href="#2-安装gitbook" class="headerlink" title="2. 安装gitbook"></a>2. 安装gitbook</h1><pre><code>cnpm install -g gitbook-cli
gitbook -V 
CLI version: 2.3.2
Installing GitBook 3.2.3
gitbook@3.2.3 ..\AppData\Local\Temp\tmp-20544doJtj1hfVp40\node_modules\gitbook
├── escape-string-regexp@1.0.5
├── escape-html@1.0.3
 。。。。
GitBook version: 3.2.3
</code></pre>
<h1 id="3-gitbook使用"><a href="#3-gitbook使用" class="headerlink" title="3. gitbook使用"></a>3. gitbook使用</h1><h2 id="3-1-生成目录和图书结构"><a href="#3-1-生成目录和图书结构" class="headerlink" title="3.1 生成目录和图书结构"></a>3.1 生成目录和图书结构</h2><pre><code>mkdir docker-start
gitbook init
warn: no summary file in this book
info: create README.md
info: create SUMMARY.md
info: initialization is finished
</code></pre>
<p>编辑SUMMARY.md，输入：</p>
<pre><code>* [简介](README.md)
* [1.Docker入门](chapter1/README.md)
 - [1.1 什么是Docker](chapter1/section1.md)
 - [1.2 Docker基本概念](chapter1/section2.md)
 - [1.3 安装Docker](chapter1/section3.md)
 - [1.4 使用Docker镜像](chapter1/section4.md)
 - [1.5 操作容器](chapter1/section5.md)
 - [1.6 访问仓库](chapter1/section6.md)
 - [1.6 数据管理](chapter1/section7.md)
* [2.使用Docker部署web应用](chapter2/README.md)
 - [2.1 编写DockerFile](chapter2/section1.md)
 - [2.2 编写web应用](chapter2/section2.md)
 - [2.3 构建镜像](chapter2/section3.md)
 - [2.4 运行web应用](chapter2/section4.md)
 - [2.5 分享镜像](chapter2/section5.md)
* [结束](end/README.md)
</code></pre>
<p>再次执行：</p>
<pre><code>gitbook init
info: create chapter1/README.md
info: create chapter1/section1.md
info: create chapter1/section2.md
info: create chapter1/section3.md
info: create chapter1/section4.md
info: create chapter1/section5.md
info: create chapter1/section6.md
info: create chapter1/section7.md
info: create chapter2/README.md
info: create chapter2/section1.md
info: create chapter2/section2.md
info: create chapter2/section3.md
info: create chapter2/section4.md
info: create chapter2/section5.md
info: create end/README.md
info: create SUMMARY.md
info: initialization is finished
</code></pre>
<h2 id="3-2-生成图书"><a href="#3-2-生成图书" class="headerlink" title="3.2 生成图书"></a>3.2 生成图书</h2><p>使用：</p>
<pre><code>gitbook serve .
Live reload server started on port: 35729
Press CTRL+C to quit ...

info: 7 plugins are installed
info: loading plugin &quot;livereload&quot;... OK
info: loading plugin &quot;highlight&quot;... OK
info: loading plugin &quot;search&quot;... OK
info: loading plugin &quot;lunr&quot;... OK
info: loading plugin &quot;sharing&quot;... OK
info: loading plugin &quot;fontsettings&quot;... OK
info: loading plugin &quot;theme-default&quot;... OK
info: found 16 pages
info: found 15 asset files
info: &gt;&gt; generation finished with success in 4.0s !

Starting server ...
Serving book on http://localhost:4000
</code></pre>
<p>访问 <a href="http://localhost:4000/">http://localhost:4000</a> ，就可以看到图书了</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1515048112496.jpg" alt="enter description here" title="1515048112496"></p>
<p>编辑生成的md，gitbook会自动Restart，</p>
<p><img src="http://oyqmmpkcm.bkt.clouddn.com/1515048702182.jpg" alt="enter description here" title="1515048702182"></p>
<p>在当前目录下，会生成一个_book目录 ，里面是生成的静态html，可以发布到服务器直接使用。</p>
<h1 id="4-使用docker发布gitbook书籍"><a href="#4-使用docker发布gitbook书籍" class="headerlink" title="4. 使用docker发布gitbook书籍"></a>4. 使用docker发布gitbook书籍</h1><p>首先 将_book目录里的内容拷贝到一个新目录。</p>
<p>然后编写Dockerfile</p>
<pre><code>FROM nginx
WORKDIR /usr/share/nginx/html
ADD . /usr/share/nginx/html
EXPOSE 80
</code></pre>
<p>build：</p>
<pre><code>docker build -t docker-start-web .
Sending build context to Docker daemon  4.766MB
Step 1/4 : FROM nginx
 ---&gt; 3f8a4339aadd
Step 2/4 : WORKDIR /usr/share/nginx/html
Removing intermediate container a4232f4b6b62
 ---&gt; 91a66299ecad
Step 3/4 : ADD . /usr/share/nginx/html
 ---&gt; 9a9fef80da3b
Step 4/4 : EXPOSE 80
 ---&gt; Running in 59f2b829aba6
Removing intermediate container 59f2b829aba6
 ---&gt; b92c92688046
Successfully built b92c92688046
Successfully tagged docker-start-web:latest
</code></pre>
<p>执行：</p>
<pre><code>docker run -p 4000:80 --name docker-start-web -d docker-start-web
f91cf4446b3746c665476b3dd214446a941d838fa9a3ad47680190bb08c9aa48
</code></pre>
<p>访问服务器ip:4000就可以查看到了。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>docker</tag>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Spring访问Mongodb的方法大全——Spring Data MongoDB查询指南</title>
    <url>/jadepeng/2017/12/26/jqpeng-%E4%BD%BF%E7%94%A8Spring%E8%AE%BF%E9%97%AEMongodb%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%E2%80%94%E2%80%94Spring%20Data%20MongoDB%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/queries-in-spring-data-mongodb.html">使用Spring访问Mongodb的方法大全——Spring Data MongoDB查询指南</a></p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>Spring Data MongoDB 是Spring框架访问mongodb的神器，借助它可以非常方便的读写mongo库。本文介绍使用Spring Data MongoDB来访问mongodb数据库的几种方法：</p>
<ul>
<li>使用Query和Criteria类</li>
<li>JPA自动生成的查询方法</li>
<li>使用@Query 注解基于JSON查询</li>
</ul>
<p>在开始前，首先需要引入maven依赖</p>
<h2 id="1-1-添加Maven的依赖"><a href="#1-1-添加Maven的依赖" class="headerlink" title="1.1 添加Maven的依赖"></a>1.1 添加Maven的依赖</h2><p>如果您想使用Spring Data MongoDB，则需要将以下条目添加到您的pom.xml文件中：</p>
<pre><code>&lt;dependency&gt;&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;&lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt;&lt;version&gt;1.9.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>版本根据需要选择。</p>
<h1 id="2-文档查询"><a href="#2-文档查询" class="headerlink" title="2.文档查询"></a>2.文档查询</h1><p>使用Spring Data来查询MongoDB的最常用方法之一是使用Query和Criteria类 ， 它们非常接近本地操作符。</p>
<h2 id="2-1-is查询"><a href="#2-1-is查询" class="headerlink" title="2.1 is查询"></a>2.1 is查询</h2><p>在以下示例中 - 我们正在寻找名为Eric的用户。</p>
<p>我们来看看我们的数据库：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 55&#125;
&#125;]
</code></pre>
<p>让我们看看查询代码：</p>
<pre><code>Query query = new Query();
query.addCriteria(Criteria.where(&quot;name&quot;).is(&quot;Eric&quot;));
List&lt;User&gt; users = mongoTemplate.find(query, User.class);
</code></pre>
<p>如预期的那样，这个逻辑返回：</p>
<pre><code>&#123;&quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),&quot;_class&quot; : &quot;org.baeldung.model.User&quot;,&quot;name&quot; : &quot;Eric&quot;,&quot;age&quot; : 45
&#125;
</code></pre>
<h2 id="2-2-正则查询"><a href="#2-2-正则查询" class="headerlink" title="2.2 正则查询"></a>2.2 正则查询</h2><p>正则表达式是一个更灵活和强大的查询类型。这使用了一个使用MongoDB $ regex的标准，该标准返回适用于这个字段的这个正则表达式的所有记录。</p>
<p>它的作用类似于startingWith，endingWith操作 - 让我们来看一个例子。</p>
<p>寻找名称以A开头的所有用户，这是数据库的状态：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<p>我们来创建查询：</p>
<pre><code>Query query = new Query();
query.addCriteria(Criteria.where(&quot;name&quot;).regex(&quot;^A&quot;));
List&lt;User&gt; users = mongoTemplate.find(query,User.class);
</code></pre>
<p>这运行并返回2条记录：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<p>下面是另一个简单的例子，这次查找名称以c结尾的所有用户：</p>
<pre><code>Query query = new Query();
query.addCriteria(Criteria.where(&quot;name&quot;).regex(&quot;c$&quot;));
List&lt;User&gt; users = mongoTemplate.find(query, User.class);
</code></pre>
<p>所以结果是：</p>
<pre><code>&#123;&quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),&quot;_class&quot; : &quot;org.baeldung.model.User&quot;,&quot;name&quot; : &quot;Eric&quot;,&quot;age&quot; : 45
&#125;
</code></pre>
<h2 id="2-3-LT和GT"><a href="#2-3-LT和GT" class="headerlink" title="2.3 LT和GT"></a>2.3 LT和GT</h2><p>$ lt（小于）运算符和$ gt（大于）。</p>
<p>让我们快速看一个例子 - 我们正在寻找年龄在20岁到50岁之间的所有用户。</p>
<p>数据库是：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 55&#125;
&#125;
</code></pre>
<p>构造查询：</p>
<pre><code>Query query = new Query();
query.addCriteria(Criteria.where(&quot;age&quot;).lt(50).gt(20));
List&lt;User&gt; users = mongoTemplate.find(query,User.class);
</code></pre>
<p>结果 - 年龄大于20且小于50的所有用户：</p>
<pre><code>&#123;&quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),&quot;_class&quot; : &quot;org.baeldung.model.User&quot;,&quot;name&quot; : &quot;Eric&quot;,&quot;age&quot; : 45
&#125;
</code></pre>
<h2 id="2-4-结果排序"><a href="#2-4-结果排序" class="headerlink" title="2.4 结果排序"></a>2.4 结果排序</h2><p>Sort用于指定结果的排序顺序。</p>
<p>首先 - 这里是现有的数据：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<p>执行排序后：</p>
<pre><code>Query query = new Query();
query.with(new Sort(Sort.Direction.ASC, &quot;age&quot;));
List&lt;User&gt; users = mongoTemplate.find(query,User.class);
</code></pre>
<p>这是查询的结果 - 很好地按年龄排序：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;
]
</code></pre>
<h2 id="2-5-分页"><a href="#2-5-分页" class="headerlink" title="2.5 分页"></a>2.5 分页</h2><p>我们来看一个使用分页的简单例子。</p>
<p>这是数据库的状态：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<p>现在，查询逻辑，只需要一个大小为2的页面：</p>
<pre><code>final Pageable pageableRequest = new PageRequest(0, 2);
Query query = new Query();
query.with(pageableRequest);
</code></pre>
<p>结果 ：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581907&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Eric&quot;,    &quot;age&quot; : 45&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;
]
</code></pre>
<p>为了探索这个API的全部细节，这里是Query和Criteria类的文档。</p>
<h2 id="3-生成的查询方法（Generated-Query-Methods）"><a href="#3-生成的查询方法（Generated-Query-Methods）" class="headerlink" title="3.生成的查询方法（Generated Query Methods）"></a>3.生成的查询方法（Generated Query Methods）</h2><p>生成查询方法是JPA的一个特性，在Spring Data Mongodb里也可以使用。</p>
<p>要做到2里功能，只需要在接口上声明方法即可，</p>
<pre><code>public interface UserRepository 
  extends MongoRepository&lt;User, String&gt;, QueryDslPredicateExecutor&lt;User&gt; &#123;...
&#125;
</code></pre>
<h2 id="3-1-FindByX"><a href="#3-1-FindByX" class="headerlink" title="3.1 FindByX"></a>3.1 FindByX</h2><p>我们将通过探索findBy类型的查询来简单地开始 - 在这种情况下，通过名称查找：</p>
<pre><code>List&lt;User&gt; findByName(String name);
</code></pre>
<p>与上一节相同 2.1 - 查询将具有相同的结果，查找具有给定名称的所有用户：</p>
<pre><code>List&lt;User&gt; users = userRepository.findByName(&quot;Eric&quot;);
</code></pre>
<h2 id="3-2-StartingWith-and-endingWith"><a href="#3-2-StartingWith-and-endingWith" class="headerlink" title="3.2  StartingWith and endingWith."></a>3.2  StartingWith and endingWith.</h2><p>下面是操作过程的一个简单例子：</p>
<pre><code>List&lt;User&gt; findByNameStartingWith(String regexp);

List&lt;User&gt; findByNameEndingWith(String regexp);
</code></pre>
<p>实际使用这个例子当然会非常简单：</p>
<pre><code>List&lt;User&gt; users = userRepository.findByNameStartingWith(&quot;A&quot;);
List&lt;User&gt; users = userRepository.findByNameEndingWith(&quot;c&quot;);
</code></pre>
<p>结果是完全一样的。</p>
<h2 id="3-3-Between"><a href="#3-3-Between" class="headerlink" title="3.3 Between"></a>3.3 Between</h2><p>类似于2.3，这将返回年龄在ageGT和ageLT之间的所有用户：</p>
<pre><code>List&lt;User&gt; findByAgeBetween(int ageGT, int ageLT);
List&lt;User&gt; users = userRepository.findByAgeBetween(20, 50);
</code></pre>
<h2 id="3-4-Like和OrderBy"><a href="#3-4-Like和OrderBy" class="headerlink" title="3.4 Like和OrderBy"></a>3.4 Like和OrderBy</h2><p>让我们来看看这个更高级的示例 - 为生成的查询组合两种类型的修饰符。</p>
<p>我们将要查找名称中包含字母A的所有用户，我们也将按年龄顺序排列结果：</p>
<pre><code>List&lt;User&gt; users = userRepository.findByNameLikeOrderByAgeAsc(&quot;A&quot;);
</code></pre>
<p>结果：</p>
<pre><code>[&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581908&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Antony&quot;,    &quot;age&quot; : 33&#125;,&#123;    &quot;_id&quot; : ObjectId(&quot;55c0e5e5511f0a164a581909&quot;),    &quot;_class&quot; : &quot;org.baeldung.model.User&quot;,    &quot;name&quot; : &quot;Alice&quot;,    &quot;age&quot; : 35&#125;
]
</code></pre>
<h1 id="4-JSON查询方法"><a href="#4-JSON查询方法" class="headerlink" title="4. JSON查询方法"></a>4. JSON查询方法</h1><p>如果我们无法用方法名称或条件来表示查询，那么我们可以做更低层次的事情 - 使用@Query注解。</p>
<p>通过这个注解，我们可以指定一个原始查询 - 作为一个Mongo JSON查询字符串。</p>
<h2 id="4-1-FindBy"><a href="#4-1-FindBy" class="headerlink" title="4.1 FindBy"></a>4.1 FindBy</h2><p>让我们先从简单的，看看我们是如何将是一个通过查找类型的方法第一：</p>
<pre><code>@Query(&quot;&#123; &#39;name&#39; : ?0 &#125;&quot;)
List&lt;User&gt; findUsersByName(String name);
</code></pre>
<p>这个方法应该按名称返回用户 - 占位符?0引用方法的第一个参数。</p>
<h2 id="4-2-regex"><a href="#4-2-regex" class="headerlink" title="4.2 $regex"></a>4.2 $regex</h2><p>让我们来看一个正则表达式驱动的查询 - 这当然会产生与2.2和3.2相同的结果：</p>
<pre><code>@Query(&quot;&#123; &#39;name&#39; : &#123; $regex: ?0 &#125; &#125;&quot;)
List&lt;User&gt; findUsersByRegexpName(String regexp);
</code></pre>
<p>用法也完全一样：</p>
<pre><code>List&lt;User&gt; users = userRepository.findUsersByRegexpName(&quot;^A&quot;);
List&lt;User&gt; users = userRepository.findUsersByRegexpName(&quot;c$&quot;);
</code></pre>
<h2 id="4-3-lt和-gt"><a href="#4-3-lt和-gt" class="headerlink" title="4.3. $ lt和$ gt"></a>4.3. $ lt和$ gt</h2><p>现在我们来实现lt和gt查询：</p>
<pre><code>@Query(&quot;&#123; &#39;age&#39; : &#123; $gt: ?0, $lt: ?1 &#125; &#125;&quot;)
List&lt;User&gt; findUsersByAgeBetween(int ageGT, int ageLT);
</code></pre>
<h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h1><p>在本文中，我们探讨了使用Spring Data MongoDB进行查询的常用方法。</p>
<p>本文示例可以从 <a href="https://github.com/eugenp/tutorials/tree/master/spring-data-mongodb">spring-data-mongodb</a>这里下载。</p>
<p>本文参考<a href="http://www.baeldung.com/queries-in-spring-data-mongodb">A Guide to Queries in Spring Data MongoDB</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>MongoDB</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>kgtemp文件转mp3工具</title>
    <url>/jadepeng/2017/12/22/jqpeng-kgtemp%E6%96%87%E4%BB%B6%E8%BD%ACmp3%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/8085563.html">kgtemp文件转mp3工具</a></p>
<p>kgtemp文件是酷我音乐软件的缓存文件，本文从技术层面探讨如何解密该文件为mp3文件，并通过读取ID3信息来重命名。</p>
<p>备注：针对老版本的酷我音乐生效，新版本不支持！！！</p>
<h2 id="kgtemp解密"><a href="#kgtemp解密" class="headerlink" title="kgtemp解密"></a>kgtemp解密</h2><p>kgtemp文件前1024个字节是固定的包头信息，解密方案详细可以参见(<a href="http://www.cnblogs.com/KMBlog/p/6877752.html">http://www.cnblogs.com/KMBlog/p/6877752.html</a>)：</p>
<pre><code>class Program&#123;    static void Main(string[] args)    &#123;
        byte[] key=&#123;0xAC,0xEC,0xDF,0x57&#125;;        using (var input = new FileStream(@&quot;E:\KuGou\Temp\236909b6016c6e98365e5225f488dd7a.kgtemp&quot;, FileMode.Open, FileAccess.Read))        &#123;            var output = File.OpenWrite(@&quot;d:\test.mp3&quot;);//输出文件            input.Seek(1024, SeekOrigin.Begin);//跳过1024字节的包头            byte[] buffer = new byte[key.Length];            int length;            while((length=input.Read(buffer,0,buffer.Length))&gt;0)            &#123;                for(int i=0;i&lt;length;i++)                &#123;                    var k = key[i];                    var kh = k &gt;&gt; 4;                    var kl = k &amp; 0xf;                    var b = buffer[i];                    var low = b &amp; 0xf ^ kl;//解密后的低4位                    var high = (b &gt;&gt; 4) ^ kh ^ low &amp; 0xf;//解密后的高4位                    buffer[i] = (byte)(high &lt;&lt; 4 | low);                &#125;                output.Write(buffer, 0, length);            &#125;            output.Close();        &#125;        Console.WriteLine(&quot;按任意键退出...&quot;);        Console.ReadKey();    &#125;&#125;
</code></pre>
<p>这样解密出来就是mp3文件了</p>
<h2 id="读取ID3信息"><a href="#读取ID3信息" class="headerlink" title="读取ID3信息"></a>读取ID3信息</h2><p>解密出来的文件还需要手动命名，不是很方便，可以读取ID3V1信息重命名文件。<br> ID3V1比较简单，它是存放在MP3文件的末尾，用16进制的编辑器打开一个MP3文件，查看其末尾的128个顺序存放字节，数据结构定义如下：<br> char Header<a href="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1513919861693.jpg" title="1513919861693">3</a>;    /<em>标签头必须是”TAG”否则认为没有标签</em>/<br> char Title[30];    /<em>标题</em>/<br> char Artist[30];   /<em>作者</em>/<br> char Album[30];    /<em>专集</em>/<br> char Year<a href="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1513920067729.jpg" title="1513920067729">4</a>;    /<em>出品年代</em>/<br> char Comment[30];   /<em>备注</em>/<br> char Genre;    /<em>类型，流派</em>/</p>
<p>解析代码比较简单，注意中文歌曲用GBK编码就可以了：</p>
<pre><code>  private static Mp3Info FormatMp3Info(byte[] Info, System.Text.Encoding Encoding)    &#123;        Mp3Info myMp3Info = new Mp3Info();        string str = null;        int i;        int position = 0主要代码jia，; //循环的起始值        int currentIndex = 0; //Info的当前索引值
        //获取TAG标识        for (i = currentIndex; i &lt; currentIndex + 3; i++)        &#123;            str = str + (char)Info[i];            position++;        &#125;        currentIndex = position;        myMp3Info.identify = str;
        //获取歌名        str = null;        byte[] bytTitle = new byte[30]; //将歌名部分读到一个单独的数组中        int j = 0;        for (i = currentIndex; i &lt; currentIndex + 30; i++)        &#123;            bytTitle[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Title = ByteToString(bytTitle, Encoding);
        //获取歌手名        str = null;        j = 0;        byte[] bytArtist = new byte[30]; //将歌手名部分读到一个单独的数组中        for (i = currentIndex; i &lt; currentIndex + 30; i++)        &#123;            bytArtist[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Artist = ByteToString(bytArtist, Encoding);
        //获取唱片名        str = null;        j = 0;        byte[] bytAlbum = new byte[30]; //将唱片名部分读到一个单独的数组中        for (i = currentIndex; i &lt; currentIndex + 30; i++)        &#123;            bytAlbum[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Album = ByteToString(bytAlbum, Encoding);
        //获取年        str = null;        j = 0;        byte[] bytYear = new byte[4]; //将年部分读到一个单独的数组中        for (i = currentIndex; i &lt; currentIndex + 4; i++)        &#123;            bytYear[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Year = ByteToString(bytYear, Encoding);
        //获取注释        str = null;        j = 0;        byte[] bytComment = new byte[28]; //将注释部分读到一个单独的数组中        for (i = currentIndex; i &lt; currentIndex + 25; i++)        &#123;            bytComment[j] = Info[i];            position++;            j++;        &#125;        currentIndex = position;        myMp3Info.Comment = ByteToString(bytComment, Encoding);
        //以下获取保留位        myMp3Info.reserved1 = (char)Info[++position];        myMp3Info.reserved2 = (char)Info[++position];        myMp3Info.reserved3 = (char)Info[++position];
        //        return myMp3Info;    &#125;
</code></pre>
<h2 id="转换小工具"><a href="#转换小工具" class="headerlink" title="转换小工具"></a>转换小工具</h2><p>写了一个小工具，来进行转换</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1513919861693.jpg" alt="装换工具" title="1513919861693"></p>
<p>下载地址：<a href="https://pan.baidu.com/s/1o7FIsPk">https://pan.baidu.com/s/1o7FIsPk</a></p>
<p>PS:上面只读取了IDV1，部分歌曲可能不存在<br> 可以下载@缤纷 提供的程序，增加了ID3V2的支持：<br><a href="https://files.cnblogs.com/files/gxlxzys/kgtemp%E6%96%87%E4%BB%B6%E8%BD%ACmp3%E5%B7%A5%E5%85%B7.zip">https://files.cnblogs.com/files/gxlxzys/kgtemp文件转mp3工具.zip</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>kgtemp</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SpringBoot开发REST服务</title>
    <url>/jadepeng/2017/12/08/jqpeng-%E4%BD%BF%E7%94%A8SpringBoot%E5%BC%80%E5%8F%91REST%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/SpringBootRest.html">使用SpringBoot开发REST服务</a></p>
<p>本文介绍如何基于Spring Boot搭建一个简易的REST服务框架，以及如何通过自定义注解实现Rest服务鉴权</p>
<h1 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>首先，引入相关依赖，数据库使用mongodb，同时使用redis做缓存</p>
<pre><code>注意，这里没有使用tomcat，而是使用undertow



    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;
    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;
    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;    &lt;/dependency&gt;
    &lt;!--redis支持--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;
    &lt;!--mongodb支持--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;    &lt;/dependency&gt;
</code></pre>
<ul>
<li>引入spring-boot-starter-web支持web服务</li>
<li>引入spring-boot-starter-data-redis 和spring-boot-starter-data-mongodb就可以方便的使用mongodb和redis了</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="profiles功能"><a href="#profiles功能" class="headerlink" title="profiles功能"></a>profiles功能</h3><p>为了方便 区分开发环境和线上环境，可以使用profiles功能，在application.properties里增加<br> spring.profiles.active=dev</p>
<p>然后增加application-dev.properties作为dev配置文件。</p>
<h3 id="mondb配置"><a href="#mondb配置" class="headerlink" title="mondb配置"></a>mondb配置</h3><p>配置数据库地址即可</p>
<pre><code>spring.data.mongodb.uri=mongodb://ip:port/database?readPreference=primaryPreferred
</code></pre>
<h3 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h3><pre><code>spring.redis.database=0  
# Redis服务器地址
spring.redis.host=ip
# Redis服务器连接端口
spring.redis.port=6379  
# Redis服务器连接密码（默认为空）
spring.redis.password=
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.pool.max-active=8  
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.pool.max-wait=-1  
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8  
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0  
# 连接超时时间（毫秒）
spring.redis.timeout=0  
</code></pre>
<h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><h3 id="mongdb"><a href="#mongdb" class="headerlink" title="mongdb"></a>mongdb</h3><p>mongdb访问很简单，直接定义接口extends MongoRepository即可，另外可以支持JPA语法，例如：</p>
<pre><code>@Component
public interface UserRepository extends MongoRepository&lt;User, Integer&gt; &#123;
public User findByUserName(String userName);
&#125;
</code></pre>
<p>使用时，加上@Autowired注解即可。</p>
<pre><code>@Component
public class AuthService extends BaseService &#123;
@AutowiredUserRepository userRepository;&#125;
</code></pre>
<h3 id="Redis访问"><a href="#Redis访问" class="headerlink" title="Redis访问"></a>Redis访问</h3><p>使用StringRedisTemplate即可直接访问Redis</p>
<pre><code>@Component
public class BaseService &#123;@Autowiredprotected MongoTemplate mongoTemplate;
@Autowiredprotected StringRedisTemplate stringRedisTemplate;
&#125;
</code></pre>
<p>储存数据：</p>
<pre><code>.stringRedisTemplate.opsForValue().set(token_key, user.getId()+&quot;&quot;,token_max_age, TimeUnit.SECONDS);
</code></pre>
<p>删除数据：</p>
<pre><code>stringRedisTemplate.delete(getFormatToken(accessToken,platform));
</code></pre>
<h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><p>定义一个Controller类，加上RestController即可，使用RequestMapping用来设置url route</p>
<pre><code>@RestController
public class AuthController extends BaseController &#123;
@RequestMapping(value = &#123;&quot;/&quot;&#125;, produces = &quot;application/json;charset=utf-8&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)@ResponseBodypublic String main() &#123;    return &quot;hello world！&quot;;&#125;

&#125;
</code></pre>
<p>现在启动，应该就能看到hello world！了</p>
<h1 id="服务鉴权"><a href="#服务鉴权" class="headerlink" title="服务鉴权"></a>服务鉴权</h1><h2 id="简易accessToken机制"><a href="#简易accessToken机制" class="headerlink" title="简易accessToken机制"></a>简易accessToken机制</h2><p>提供登录接口，认证成功后，生成一个accessToken，以后访问接口时，带上accessToken，服务端通过accessToken来判断是否是合法用户。</p>
<p>为了方便，可以将accessToken存入redis，设定有效期。</p>
<pre><code>        String token = EncryptionUtils.sha256Hex(String.format(&quot;%s%s&quot;, user.getUserName(), System.currentTimeMillis()));    String token_key = getFormatToken(token, platform);    this.stringRedisTemplate.opsForValue().set(token_key, user.getId()+&quot;&quot;,token_max_age, TimeUnit.SECONDS);
</code></pre>
<h2 id="拦截器身份认证"><a href="#拦截器身份认证" class="headerlink" title="拦截器身份认证"></a>拦截器身份认证</h2><p>为了方便做统一的身份认证，可以基于Spring的拦截器机制，创建一个拦截器来做统一认证。</p>
<pre><code>public class AuthCheckInterceptor implements HandlerInterceptor &#123;
&#125;
</code></pre>
<p>要使拦截器生效，还需要一步，增加配置：</p>
<pre><code>@Configuration
public class SessionConfiguration extends WebMvcConfigurerAdapter &#123;
@AutowiredAuthCheckInterceptor authCheckInterceptor;
@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    super.addInterceptors(registry);    // 添加拦截器    registry.addInterceptor(authCheckInterceptor).addPathPatterns(&quot;/**&quot;);&#125;
&#125;
</code></pre>
<h2 id="自定义认证注解"><a href="#自定义认证注解" class="headerlink" title="自定义认证注解"></a>自定义认证注解</h2><p>为了精细化权限认证，比如有的接口只能具有特定权限的人才能访问，可以通过自定义注解轻松解决。在自定义的注解里，加上roles即可。</p>
<pre><code>/**
 *  权限检验注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface AuthCheck &#123;
/** *  角色列表 * @return */String[] roles() default &#123;&#125;;
&#125;
</code></pre>
<p>检验逻辑：</p>
<ul>
<li>只要接口加上了AuthCheck注解，就必须是登陆用户</li>
<li>如果指定了roles，则除了登录外，用户还应该具备相应的角色。</li>
</ul>
<pre><code>    String[] ignoreUrls = new String[]&#123;
            &quot;/user/.*&quot;,
            &quot;/cat/.*&quot;,
            &quot;/app/.*&quot;,
            &quot;/error&quot;
    &#125;;
 public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler) throws Exception &#123;

        // 0 检验公共参数
        if(!checkParams(&quot;platform&quot;,httpServletRequest,httpServletResponse))&#123;
            return  false;
        &#125;

        // 1、忽略验证的URL
        String url = httpServletRequest.getRequestURI().toString();
        for(String ignoreUrl :ignoreUrls)&#123;
            if(url.matches(ignoreUrl))&#123;
                return true;
            &#125;
        &#125;

        // 2、查询验证注解
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        // 查询注解
        AuthCheck authCheck = method.getAnnotation(AuthCheck.class);
        if (authCheck == null) &#123;
            // 无注解，不需要
            return true;
        &#125;

        // 3、有注解，先检查accessToken
        if(!checkParams(&quot;accessToken&quot;,httpServletRequest,httpServletResponse))&#123;
            return  false;
        &#125;
        // 检验token是否过期
        Integer userId = authService.getUserIdFromToken(httpServletRequest.getParameter(&quot;accessToken&quot;),
                httpServletRequest.getParameter(&quot;platform&quot;));
        if(userId==null)&#123;
            logger.debug(&quot;accessToken timeout&quot;);
            output(ResponseResult.Builder.error(&quot;accessToken已过期&quot;).build(),httpServletResponse);
            return false;
        &#125;

        // 4、再检验是否包含必要的角色
        if(authCheck.roles()!=null&amp;&amp;authCheck.roles().length&gt;0)&#123;
            User user = authService.getUser(userId);
            boolean isMatch = false;
            for(String role : authCheck.roles())&#123;
                if(user.getRole().getName().equals(role))&#123;
                    isMatch =  true;
                    break;
                &#125;
            &#125;
            // 角色未匹配，验证失败
            if(!isMatch)&#123;
                return false;
            &#125;
        &#125;

        return true;
    &#125;
</code></pre>
<h1 id="服务响应结果封装"><a href="#服务响应结果封装" class="headerlink" title="服务响应结果封装"></a>服务响应结果封装</h1><p>增加一个Builder，方便生成最终结果</p>
<pre><code>public class ResponseResult &#123;

    public static class Builder&#123;
        ResponseResult responseResult;

        Map&lt;String,Object&gt; dataMap = Maps.newHashMap();

        public Builder()&#123;
            this.responseResult = new ResponseResult();
        &#125;

        public Builder(String state)&#123;
            this.responseResult = new ResponseResult(state);
        &#125;


        public static Builder newBuilder()&#123;
           return new Builder();
        &#125;

        public static Builder success()&#123;
            return new Builder(&quot;success&quot;);
        &#125;

        public static Builder error(String message)&#123;
            Builder builder =  new Builder(&quot;error&quot;);
            builder.responseResult.setError(message);
            return builder;
        &#125;

        public  Builder append(String key,Object data)&#123;
            this.dataMap.put(key,data);
            return this;
        &#125;

        /**
         *  设置列表数据
         * @param datas 数据
         * @return
         */
        public  Builder setListData(List&lt;?&gt; datas)&#123;
            this.dataMap.put(&quot;result&quot;,datas);
            this.dataMap.put(&quot;total&quot;,datas.size());
            return this;
        &#125;

        public  Builder setData(Object data)&#123;
            this.dataMap.clear();
            this.responseResult.setData(data);
            return this;
        &#125;

        boolean wrapData = false;

        /**
         * 将数据包裹在data中
         * @param wrapData
         * @return
         */
        public  Builder wrap(boolean wrapData)&#123;
            this.wrapData = wrapData;
            return this;
        &#125;

        public String build()&#123;

            JSONObject jsonObject = new JSONObject();
            jsonObject.put(&quot;state&quot;,this.responseResult.getState());
            if(this.responseResult.getState().equals(&quot;error&quot;))&#123;
                jsonObject.put(&quot;error&quot;,this.responseResult.getError());
            &#125;
            if(this.responseResult.getData()!=null)&#123;
                jsonObject.put(&quot;data&quot;, JSON.toJSON(this.responseResult.getData()));
            &#125;else  if(dataMap.size()&gt;0)&#123;
                if(wrapData) &#123;
                    JSONObject data = new JSONObject();
                    dataMap.forEach((key, value) -&gt; &#123;
                        data.put(key, value);
                    &#125;);
                    jsonObject.put(&quot;data&quot;, data);
                &#125;else&#123;
                    dataMap.forEach((key, value) -&gt; &#123;
                        jsonObject.put(key, value);
                    &#125;);
                &#125;
            &#125;
            return jsonObject.toJSONString();
        &#125;

    &#125;

    private String state;
    private Object data;
    private String error;


    public String getError() &#123;
        return error;
    &#125;

    public void setError(String error) &#123;
        this.error = error;
    &#125;

    public ResponseResult()&#123;&#125;

    public ResponseResult(String rc)&#123;
        this.state = rc;
    &#125;

    /**
     * 成功时返回
     * @param rc
     * @param result
     */
    public ResponseResult(String rc, Object result)&#123;
        this.state = rc;
        this.data = result;
    &#125;

    public String getState() &#123;
        return state;
    &#125;

    public void setState(String state) &#123;
        this.state = state;
    &#125;

    public Object getData() &#123;
        return data;
    &#125;

    public void setData(Object data) &#123;
        this.data = data;
    &#125;

&#125;
</code></pre>
<p>调用时可以优雅一点</p>
<pre><code>    @RequestMapping(value = &#123;&quot;/user/login&quot;,&quot;/pc/user/login&quot;&#125;, produces = &quot;application/json;charset=utf-8&quot;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)
    @ResponseBody
    public String login(String userName,String password,Integer platform) &#123;
        User user = this.authService.login(userName,password);
        if(user!=null)&#123;
            //  登陆
            String token = authService.updateToken(user,platform);
            return ResponseResult.Builder                 .success()
                    .append(&quot;accessToken&quot;,token)
                    .append(&quot;userId&quot;,user.getId())
                    .build();
        &#125;
        return ResponseResult.Builder.error(&quot;用户不存在或密码错误&quot;).build();
    &#125;
    protected String error(String message)&#123;
        return  ResponseResult.Builder.error(message).build();
    &#125;

    protected String success()&#123;
        return  ResponseResult.Builder
                .success()
                .build();
    &#125;

    protected String successDataList(List&lt;?&gt; data)&#123;
        return ResponseResult.Builder
                .success()
                .wrap(true) // data包裹
                .setListData(data)
                .build();
    &#125;
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Spring Boot</tag>
        <tag>REST服务</tag>
      </tags>
  </entry>
  <entry>
    <title>一起读源码之zookeeper(1) -- 启动分析</title>
    <url>/jadepeng/2017/12/01/jqpeng-%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81%E4%B9%8Bzookeeper(1)%20--%20%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/7942234.html">一起读源码之zookeeper(1) – 启动分析</a></p>
<p>从本文开始，不定期分析一个开源项目源代码，起篇从大名鼎鼎的zookeeper开始。<br> 为什么是zk，因为用到zk的场景实在太多了，大部分耳熟能详的分布式系统都有zookeeper的影子，比如hbase，storm，dubbo，kafka等等，另外前面提到的<a href="http://www.cnblogs.com/xiaoqi/p/java-rpc.html">RPC框架原理与实现</a>也用到了zookeeper。</p>
<p>目录</p>
<ul>
<li>1 环境准备<ul>
<li>1.1 导入代码</li>
<li>1.2 设置配置文件</li>
<li>1.3 调试配置</li>
</ul>
</li>
<li>2 启动分析<ul>
<li>2.1 QuorumPeerMain</li>
<li>2.2 ZooKeeperServerMain</li>
<li>2.3 ServerCnxnFactory</li>
<li>2.4 ZooKeeperServer</li>
<li>2.5 服务启动<ul>
<li>2.5.1 配置cnxnFactory</li>
<li>2.5.2 启动cnxnFactory<ul>
<li>socket处理线程</li>
<li>socket网络请求处理</li>
<li>读取连接请求</li>
<li>创建session</li>
</ul>
</li>
<li>2.5.3 zk服务器启动<ul>
<li>SessionTracker</li>
</ul>
</li>
<li>2.5.4  ZooKeeperServer请求处理器链介绍<ul>
<li>RequestProcessor</li>
<li>PrepRequestProcessor</li>
<li>SyncRequestProcessor</li>
<li>FinalRequestProcessor</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1 环境准备"></a>1 环境准备</h2><p>首先，下载zk的新版本，最新的稳定版是3.4.10，由于已下载3.4.9.先直接使用。</p>
<h3 id="1-1-导入代码"><a href="#1-1-导入代码" class="headerlink" title="1.1 导入代码"></a>1.1 导入代码</h3><p>IDEA直接打开zk目录：<br><img src="https://ooo.0o0.ooo/2017/04/27/590166a796fb3.jpg" alt="enter description here" title="1493264040459"></p>
<p>项目设置为jdk1.7<br> 然后，将src/java下面的main和generated设置为源码目录，同时将lib目录添加为liabary。</p>
<h3 id="1-2-设置配置文件"><a href="#1-2-设置配置文件" class="headerlink" title="1.2 设置配置文件"></a>1.2 设置配置文件</h3><p>在conf目录，新建zoo.cfg，拷贝sample.cfg即可</p>
<p><img src="https://ooo.0o0.ooo/2017/04/27/5901674b5600d.jpg" alt="enter description here" title="1493264204261"></p>
<h3 id="1-3-调试配置"><a href="#1-3-调试配置" class="headerlink" title="1.3 调试配置"></a>1.3 调试配置</h3><p>查看bin/zkServer</p>
<pre><code>set ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain
....
endlocal
</code></pre>
<p>调用的是org.apache.zookeeper.server.quorum.QuorumPeerMain，因此QuorumPeerMain，配置调试程序，arguments设置conf/zoo.cfg</p>
<p><img src="https://ooo.0o0.ooo/2017/04/27/5901838aed112.jpg" alt="enter description here" title="1493271435981"></p>
<p>这样，就可以愉快的Debug代码了-😃</p>
<h2 id="2-启动分析"><a href="#2-启动分析" class="headerlink" title="2 启动分析"></a>2 启动分析</h2><h3 id="2-1-QuorumPeerMain"><a href="#2-1-QuorumPeerMain" class="headerlink" title="2.1 QuorumPeerMain"></a>2.1 QuorumPeerMain</h3><p>QuorumPeerMain的main里，调用initializeAndRun</p>
<pre><code>    protected void initializeAndRun(String[] args)
        throws ConfigException, IOException
    &#123;
        QuorumPeerConfig config = new QuorumPeerConfig();
        if (args.length == 1) &#123;
            config.parse(args[0]);
        &#125;

        // Start and schedule the the purge task 清理任务
        DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config
                .getDataDir(), config.getDataLogDir(), config
                .getSnapRetainCount(), config.getPurgeInterval());
        purgeMgr.start();

        // 集群模式
        if (args.length == 1 &amp;&amp; config.servers.size() &gt; 0) &#123;
            runFromConfig(config);
        &#125; else &#123;
            LOG.warn(&quot;Either no config or no quorum defined in config, running &quot;
                    + &quot; in standalone mode&quot;);
            // there is only server in the quorum -- run as standalone
            // 单机模式
            ZooKeeperServerMain.main(args);
        &#125;
    &#125;
</code></pre>
<p>主要执行了：</p>
<ul>
<li>加载解析配置文件到QuorumPeerConfig</li>
<li>执行清理任务</li>
<li>判断是集群模式还是单机模式，我们的配置文件未配置server，所以是单机模式，执行 ZooKeeperServerMain.main</li>
</ul>
<blockquote>
<p>本文重点分析单机模式下的zk，集群模式暂时不解读</p>
</blockquote>
<h3 id="2-2-ZooKeeperServerMain"><a href="#2-2-ZooKeeperServerMain" class="headerlink" title="2.2 ZooKeeperServerMain"></a>2.2 ZooKeeperServerMain</h3><p>ZooKeeperServerMain.main调用initializeAndRun</p>
<pre><code> protected void initializeAndRun(String[] args)
        throws ConfigException, IOException
    &#123;
        try &#123;
            ManagedUtil.registerLog4jMBeans();
        &#125; catch (JMException e) &#123;
            LOG.warn(&quot;Unable to register log4j JMX control&quot;, e);
        &#125;

        ServerConfig config = new ServerConfig();
        if (args.length == 1) &#123;
            config.parse(args[0]);
        &#125; else &#123;
            config.parse(args);
        &#125;

        runFromConfig(config);
    &#125;```

读取配置，然后runFromConfig：

``` java
 public void runFromConfig(ServerConfig config) throws IOException &#123;
        LOG.info(&quot;Starting server&quot;);
        FileTxnSnapLog txnLog = null;
        try &#123;
            // Note that this thread isn&#39;t going to be doing anything else,
            // so rather than spawning another thread, we will just call
            // run() in this thread.
            // create a file logger url from the command line args
            final ZooKeeperServer zkServer = new ZooKeeperServer();
            // Registers shutdown handler which will be used to know the
            // server error or shutdown state changes.
            final CountDownLatch shutdownLatch = new CountDownLatch(1);
            zkServer.registerServerShutdownHandler(
                    new ZooKeeperServerShutdownHandler(shutdownLatch));

            // 快照
            txnLog = new FileTxnSnapLog(new File(config.dataLogDir), new File(
                    config.dataDir));
            zkServer.setTxnLogFactory(txnLog);
            zkServer.setTickTime(config.tickTime);
            zkServer.setMinSessionTimeout(config.minSessionTimeout);
            zkServer.setMaxSessionTimeout(config.maxSessionTimeout);
            // socket工厂
            cnxnFactory = ServerCnxnFactory.createFactory();
            cnxnFactory.configure(config.getClientPortAddress(),
                    config.getMaxClientCnxns());
            cnxnFactory.startup(zkServer);

            // Watch status of ZooKeeper server. It will do a graceful shutdown
            // if the server is not running or hits an internal error.
            shutdownLatch.await();
            shutdown();

            cnxnFactory.join();
            if (zkServer.canShutdown()) &#123;
                zkServer.shutdown();
            &#125;
        &#125; catch (InterruptedException e) &#123;
            // warn, but generally this is ok
            LOG.warn(&quot;Server interrupted&quot;, e);
        &#125; finally &#123;
            if (txnLog != null) &#123;
                txnLog.close();
            &#125;
        &#125;
    &#125;
</code></pre>
<p>几件事情：</p>
<ul>
<li>创建zkServer，对ZooKeeperServer设置一些配置参数，如tickTime、minSessionTimeout、maxSessionTimeout</li>
<li>创建CountDownLatch，注释里写了，用来watch zk的状态，当zk关闭或者出现内部错误的时候<strong>优雅</strong>的关闭服务</li>
<li>根据配置参数dataLogDir和dataDir创建FileTxnSnapLog，用来存储zk数据和日志快照</li>
<li>创建cnxnFactory，zk的 socket工厂，负责处理网络请求，zk里有netty和NIO两种实现</li>
<li>cnxnFactory.startup(zkServer)，启动zk服务器</li>
</ul>
<h3 id="2-3-ServerCnxnFactory"><a href="#2-3-ServerCnxnFactory" class="headerlink" title="2.3 ServerCnxnFactory"></a>2.3 ServerCnxnFactory</h3><p>cnxnFactory负责zk的网络请求，createFactory中，从系统配置中读取ZOOKEEPER_SERVER_CNXN_FACTORY，默认是没有这个配置的，因此默认是使用NIOServerCnxnFactory，基于java的NIO实现，</p>
<pre><code>    static public ServerCnxnFactory createFactory() throws IOException &#123;
        String serverCnxnFactoryName =
            System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);
        if (serverCnxnFactoryName == null) &#123;
            serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();
        &#125;
        try &#123;
            return (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)
                                                .newInstance();
        &#125; catch (Exception e) &#123;
            IOException ioe = new IOException(&quot;Couldn&#39;t instantiate &quot;
                    + serverCnxnFactoryName);
            ioe.initCause(e);
            throw ioe;
        &#125;
    &#125;
</code></pre>
<p>当然，我们可以很容易发现：<br><img src="https://ooo.0o0.ooo/2017/04/27/59018f04f17b9.jpg" alt="enter description here" title="1493274374075"></p>
<p>ServerCnxnFactory还有个NettyServerCnxnFactory实现，基于Netty实现NIO。ServerCnxnFactory里具体负责什么，后面再来看。</p>
<h3 id="2-4-ZooKeeperServer"><a href="#2-4-ZooKeeperServer" class="headerlink" title="2.4 ZooKeeperServer"></a>2.4 ZooKeeperServer</h3><p>现在，主角登场，我们来看ZooKeeperServer内部有什么玄妙。<br><img src="https://ooo.0o0.ooo/2017/04/27/59018cc60446f.jpg" alt="enter description here" title="1493273799033"></p>
<p>ZooKeeperServer是单机模式使用的类，在集群模式下使用的是它的子类。<br> 我们先来看ZooKeeperServer包含哪些内容：</p>
<pre><code>    public static final int DEFAULT_TICK_TIME = 3000;
    protected int tickTime = DEFAULT_TICK_TIME;
    /** value of -1 indicates unset, use default */
    protected int minSessionTimeout = -1;
    /** value of -1 indicates unset, use default */
    protected int maxSessionTimeout = -1;
    protected SessionTracker sessionTracker; //创建和管理session
    private FileTxnSnapLog txnLogFactory = null; //文件快照
    private ZKDatabase zkDb; // ZooKeeper树形数据的模型
    private final AtomicLong hzxid = new AtomicLong(0); //原子增长Long，用于分配事务编号
    public final static Exception ok = new Exception(&quot;No prob&quot;);
    protected RequestProcessor firstProcessor; // ZooKeeperServer请求处理器链中的第一个处理器
    protected volatile State state = State.INITIAL;

    protected enum State &#123;
        INITIAL, RUNNING, SHUTDOWN, ERROR;
    &#125;

    /**
     * This is the secret that we use to generate passwords, for the moment it
     * is more of a sanity check.
     */
    static final private long superSecret = 0XB3415C00L;

    private final AtomicInteger requestsInProcess = new AtomicInteger(0);
    final List&lt;ChangeRecord&gt; outstandingChanges = new ArrayList&lt;ChangeRecord&gt;();
    // this data structure must be accessed under the outstandingChanges lock
    final HashMap&lt;String, ChangeRecord&gt; outstandingChangesForPath =
        new HashMap&lt;String, ChangeRecord&gt;();
    
    private ServerCnxnFactory serverCnxnFactory; //ServerSocket工厂，接受客户端的socket连接

    private final ServerStats serverStats; //server的运行状态统计
    private final ZooKeeperServerListener listener; // ZK运行状态监听
    private ZooKeeperServerShutdownHandler zkShutdownHandler;
</code></pre>
<h3 id="2-5-服务启动"><a href="#2-5-服务启动" class="headerlink" title="2.5 服务启动"></a>2.5 服务启动</h3><p>前面有点跑偏，继续回归启动过程:</p>
<pre><code>            cnxnFactory = ServerCnxnFactory.createFactory();
            cnxnFactory.configure(config.getClientPortAddress(),
                    config.getMaxClientCnxns());
            cnxnFactory.startup(zkServer);
</code></pre>
<h4 id="2-5-1-配置cnxnFactory"><a href="#2-5-1-配置cnxnFactory" class="headerlink" title="2.5.1 配置cnxnFactory"></a>2.5.1 配置cnxnFactory</h4><p>进入configure：</p>
<pre><code>    @Override
    public void configure(InetSocketAddress addr, int maxcc) throws IOException &#123;
        configureSaslLogin();

        // ZK网络请求主线程
        thread = new ZooKeeperThread(this, &quot;NIOServerCxn.Factory:&quot; + addr);
        thread.setDaemon(true);

        maxClientCnxns = maxcc;
        this.ss = ServerSocketChannel.open();
        ss.socket().setReuseAddress(true);
        LOG.info(&quot;binding to port &quot; + addr);
        ss.socket().bind(addr);
        ss.configureBlocking(false);
        ss.register(selector, SelectionKey.OP_ACCEPT);
    &#125;
</code></pre>
<p>几件事情：</p>
<ul>
<li>configureSaslLogin，具体不细看，应该是处理鉴权</li>
<li>初始化ZooKeeperThread，这个ZooKeeperThread的作用是负责处理未处理异常：</li>
</ul>
<pre><code>public class ZooKeeperThread extends Thread &#123;

    private static final Logger LOG = LoggerFactory
            .getLogger(ZooKeeperThread.class);

    private UncaughtExceptionHandler uncaughtExceptionalHandler = new UncaughtExceptionHandler() &#123;

        @Override
        public void uncaughtException(Thread t, Throwable e) &#123;
            handleException(t.getName(), e);
        &#125;
    &#125;;

    public ZooKeeperThread(Runnable thread, String threadName) &#123;
        super(thread, threadName);
        setUncaughtExceptionHandler(uncaughtExceptionalHandler);
    &#125;

    protected void handleException(String thName, Throwable e) &#123;
        LOG.warn(&quot;Exception occured from thread &#123;&#125;&quot;, thName, e);
    &#125;
&#125;
</code></pre>
<ul>
<li>启动ServerSocketChannel，并绑定配置的addr，并且注册selector（可以搜索NIO了解细节）</li>
</ul>
<h4 id="2-5-2-启动cnxnFactory"><a href="#2-5-2-启动cnxnFactory" class="headerlink" title="2.5.2 启动cnxnFactory"></a>2.5.2 启动cnxnFactory</h4><p>继续分析，进入cnxnFactory.startup(zkServer)</p>
<pre><code>    @Override
    public void startup(ZooKeeperServer zks) throws IOException,
            InterruptedException &#123;
        start();
        setZooKeeperServer(zks);
        zks.startdata();
        zks.startup();
    &#125;
</code></pre>
<p>首先，start，判断线程状态，如果未启动则启动线程，注意只会启动一次。</p>
<pre><code>    @Override
    public void start() &#123;
        // ensure thread is started once and only once
        if (thread.getState() == Thread.State.NEW) &#123;
            thread.start();
        &#125;
    &#125;
</code></pre>
<h5 id="socket处理线程"><a href="#socket处理线程" class="headerlink" title="socket处理线程"></a>socket处理线程</h5><p>启动后，就会执行cnxnFactory.run</p>
<pre><code>    public void run() &#123;
        while (!ss.socket().isClosed()) &#123;
            try &#123;
                selector.select(1000);
                Set&lt;SelectionKey&gt; selected;
                synchronized (this) &#123;
                    selected = selector.selectedKeys();
                &#125;
                ArrayList&lt;SelectionKey&gt; selectedList = new ArrayList&lt;SelectionKey&gt;(
                        selected);
                Collections.shuffle(selectedList);
                for (SelectionKey k : selectedList) &#123;
                    if ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != 0) &#123;
                        SocketChannel sc = ((ServerSocketChannel) k
                                .channel()).accept();
                        InetAddress ia = sc.socket().getInetAddress();
                        int cnxncount = getClientCnxnCount(ia);
                        if (maxClientCnxns &gt; 0 &amp;&amp; cnxncount &gt;= maxClientCnxns)&#123;
                            LOG.warn(&quot;Too many connections from &quot; + ia
                                     + &quot; - max is &quot; + maxClientCnxns );
                            sc.close();
                        &#125; else &#123;
                            LOG.info(&quot;Accepted socket connection from &quot;
                                     + sc.socket().getRemoteSocketAddress());
                            sc.configureBlocking(false);
                            SelectionKey sk = sc.register(selector,
                                    SelectionKey.OP_READ);
                            NIOServerCnxn cnxn = createConnection(sc, sk);
                            sk.attach(cnxn);
                            addCnxn(cnxn);
                        &#125;
                    &#125; else if ((k.readyOps() &amp; (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) &#123;
                        NIOServerCnxn c = (NIOServerCnxn) k.attachment();
                        c.doIO(k);
                    &#125; else &#123;
                        if (LOG.isDebugEnabled()) &#123;
                            LOG.debug(&quot;Unexpected ops in select &quot;
                                      + k.readyOps());
                        &#125;
                    &#125;
                &#125;
                selected.clear();
            &#125; catch (RuntimeException e) &#123;
                LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);
            &#125; catch (Exception e) &#123;
                LOG.warn(&quot;Ignoring exception&quot;, e);
            &#125;
        &#125;
        closeAll();
        LOG.info(&quot;NIOServerCnxn factory exited run method&quot;);
    &#125;
</code></pre>
<p>这里相当于一个独立线程来处理网络连接，通过selector.select(1000)来获取网络请求，一旦有连接就绪，则开始处理：</p>
<ul>
<li>首先打乱 Collections.shuffle(selectedList);</li>
<li>for循环处理<ul>
<li>如果SelectionKey.OP_ACCEPT，代表一个新连接请求，创建SocketChannel，创建NIOServerCnxn，然后addCnxn</li>
<li>如果可读写，则 NIOServerCnxn.doIO(k)，执行IO操作</li>
</ul>
</li>
</ul>
<h5 id="socket网络请求处理"><a href="#socket网络请求处理" class="headerlink" title="socket网络请求处理"></a>socket网络请求处理</h5><p>这里简单分析下doIO,摘录部分代码：</p>
<pre><code>void doIO(SelectionKey k) throws InterruptedException &#123;
        try &#123;
            if (isSocketOpen() == false) &#123;
                LOG.warn(&quot;trying to do i/o on a null socket for session:0x&quot;
                         + Long.toHexString(sessionId));

                return;
            &#125;
            if (k.isReadable()) &#123;
                // 读取4个字节
                int rc = sock.read(incomingBuffer);
                if (rc &lt; 0) &#123;
                    throw new EndOfStreamException(
                            &quot;Unable to read additional data from client sessionid 0x&quot;
                            + Long.toHexString(sessionId)
                            + &quot;, likely client has closed socket&quot;);
                &#125;
                // 读满了
                if (incomingBuffer.remaining() == 0) &#123;
                    boolean isPayload;
                    if (incomingBuffer == lenBuffer) &#123; // start of next request
                        incomingBuffer.flip(); // 复位
                        isPayload = readLength(k); // 读取载荷长度
                        incomingBuffer.clear();
                    &#125; else &#123;
                        // continuation
                        isPayload = true;
                    &#125;
                    if (isPayload) &#123; // not the case for 4letterword
                        readPayload();
                    &#125;
                    else &#123;
                        // four letter words take care
                        // need not do anything else
                        return;
                    &#125;
                &#125;
            &#125;
</code></pre>
<p>读取4个字节，获取到数据长度，然后读取载荷，也就是请求</p>
<pre><code>    private void readPayload() throws IOException, InterruptedException &#123;
        if (incomingBuffer.remaining() != 0) &#123; // have we read length bytes?
            int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok
            if (rc &lt; 0) &#123;
                throw new EndOfStreamException(
                        &quot;Unable to read additional data from client sessionid 0x&quot;
                        + Long.toHexString(sessionId)
                        + &quot;, likely client has closed socket&quot;);
            &#125;
        &#125;

        if (incomingBuffer.remaining() == 0) &#123; // have we read length bytes?
            packetReceived();
            incomingBuffer.flip(); // 复位
            if (!initialized) &#123;
                readConnectRequest(); // 读取连接请求
            &#125; else &#123;
                readRequest();
            &#125;
            lenBuffer.clear();
            incomingBuffer = lenBuffer;
        &#125;
    &#125;
</code></pre>
<p>先是读取数据，然后再读取请求，这里关注readConnectRequest</p>
<h5 id="读取连接请求"><a href="#读取连接请求" class="headerlink" title="读取连接请求"></a>读取连接请求</h5><pre><code>    private void readConnectRequest() throws IOException, InterruptedException &#123;
        if (zkServer == null) &#123;
            throw new IOException(&quot;ZooKeeperServer not running&quot;);
        &#125;
        zkServer.processConnectRequest(this, incomingBuffer);
        initialized = true;
    &#125;
</code></pre>
<p>继续，下面是处理连接请求：</p>
<pre><code>     public void processConnectRequest(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException &#123;
        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));
        ConnectRequest connReq = new ConnectRequest();
        connReq.deserialize(bia, &quot;connect&quot;); // 反序列化请求
        ....
        // 客户端设置的超时时间
        int sessionTimeout = connReq.getTimeOut();
        byte passwd[] = connReq.getPasswd();
        int minSessionTimeout = getMinSessionTimeout();
        if (sessionTimeout &lt; minSessionTimeout) &#123;
            sessionTimeout = minSessionTimeout;
        &#125;
        // 服务端设置的最大超时时间
        int maxSessionTimeout = getMaxSessionTimeout();
        if (sessionTimeout &gt; maxSessionTimeout) &#123;
            sessionTimeout = maxSessionTimeout;
        &#125;
        cnxn.setSessionTimeout(sessionTimeout);
        // We don&#39;t want to receive any packets until we are sure that the
        // session is setup
        cnxn.disableRecv();
        // 请求是否带上sessionid
        long sessionId = connReq.getSessionId();
        if (sessionId != 0) &#123;
            // 请求带了sessionid
            long clientSessionId = connReq.getSessionId();
            LOG.info(&quot;Client attempting to renew session 0x&quot;
                    + Long.toHexString(clientSessionId)
                    + &quot; at &quot; + cnxn.getRemoteSocketAddress());
            // 关闭请求
            serverCnxnFactory.closeSession(sessionId);
            cnxn.setSessionId(sessionId);
            // 重新打开请求
            reopenSession(cnxn, sessionId, passwd, sessionTimeout);
        &#125; else &#123;
            LOG.info(&quot;Client attempting to establish new session at &quot;
                    + cnxn.getRemoteSocketAddress());
            // 创建新sesssion
            createSession(cnxn, passwd, sessionTimeout);
        &#125;
    &#125;
</code></pre>
<p>以上完成：</p>
<ul>
<li>将读取出来的incomingBuffer反序列化为ConnectRequest对象</li>
<li>然后设置超时时间，ServerCnxn接收到该申请后，根据客户端传递过来的sessionTimeout时间以及ZooKeeperServer本身的minSessionTimeout、maxSessionTimeout参数，确定最终的sessionTimeout时间</li>
<li>判断客户端的请求是否已经含有sessionId<ul>
<li>如果含有，则执行sessionId的是否过期、密码是否正确等检查</li>
<li>如果没有sessionId，则创建一个session</li>
</ul>
</li>
</ul>
<h5 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h5><p>所以，我们需要再看一下如何创建session：</p>
<pre><code>    long createSession(ServerCnxn cnxn, byte passwd[], int timeout) &#123;
        long sessionId = sessionTracker.createSession(timeout);
        Random r = new Random(sessionId ^ superSecret);
        r.nextBytes(passwd);
        ByteBuffer to = ByteBuffer.allocate(4);
        to.putInt(timeout);
        cnxn.setSessionId(sessionId);
        submitRequest(cnxn, sessionId, OpCode.createSession, 0, to, null);
        return sessionId;
    &#125;
</code></pre>
<ul>
<li>使用sessionTracker生成一个sessionId</li>
<li>submitRequest构建一个Request请求，请求的类型为OpCode.createSession</li>
</ul>
<pre><code>    private void submitRequest(ServerCnxn cnxn, long sessionId, int type,
            int xid, ByteBuffer bb, List&lt;Id&gt; authInfo) &#123;
        Request si = new Request(cnxn, sessionId, xid, type, bb, authInfo);
        submitRequest(si);
    &#125;
    
    public void submitRequest(Request si) &#123;
        if (firstProcessor == null) &#123;
            synchronized (this) &#123;
                try &#123;
                    // Since all requests are passed to the request
                    // processor it should wait for setting up the request
                    // processor chain. The state will be updated to RUNNING
                    // after the setup.
                    while (state == State.INITIAL) &#123;
                        wait(1000);
                    &#125;
                &#125; catch (InterruptedException e) &#123;
                    LOG.warn(&quot;Unexpected interruption&quot;, e);
                &#125;
                if (firstProcessor == null || state != State.RUNNING) &#123;
                    throw new RuntimeException(&quot;Not started&quot;);
                &#125;
            &#125;
        &#125;
        try &#123;
            touch(si.cnxn);
            boolean validpacket = Request.isValid(si.type);
            if (validpacket) &#123;
                firstProcessor.processRequest(si);
                if (si.cnxn != null) &#123;
                    incInProcess();
                &#125;
            &#125; else &#123;
                LOG.warn(&quot;Received packet at server of unknown type &quot; + si.type);
                new UnimplementedRequestProcessor().processRequest(si);
            &#125;
        &#125; catch (MissingSessionException e) &#123;
            if (LOG.isDebugEnabled()) &#123;
                LOG.debug(&quot;Dropping request: &quot; + e.getMessage());
            &#125;
        &#125; catch (RequestProcessorException e) &#123;
            LOG.error(&quot;Unable to process request:&quot; + e.getMessage(), e);
        &#125;
    &#125;
</code></pre>
<p>上面的代码：</p>
<ul>
<li>创建一个Request</li>
<li>等待firstProcessor创建完成，然后调用firstProcessor.processRequest</li>
</ul>
<blockquote>
<p>firstProcessor是什么东东，下面再揭晓</p>
</blockquote>
<h4 id="2-5-3-zk服务器启动"><a href="#2-5-3-zk服务器启动" class="headerlink" title="2.5.3 zk服务器启动"></a>2.5.3 zk服务器启动</h4><p>再次回到startup，  setZooKeeperServer(zks)，代码很简单</p>
<pre><code> final public void setZooKeeperServer(ZooKeeperServer zk) &#123;
        this.zkServer = zk;
        if (zk != null) &#123;
            zk.setServerCnxnFactory(this);
        &#125;
    &#125;
</code></pre>
<p>然后是zk服务器的startdata:</p>
<pre><code>    public void startdata() 
    throws IOException, InterruptedException &#123;
        //check to see if zkDb is not null
        if (zkDb == null) &#123;
            zkDb = new ZKDatabase(this.txnLogFactory);
        &#125;  
        if (!zkDb.isInitialized()) &#123;
            loadData();
        &#125;
    &#125;
</code></pre>
<p>初始化ZKDatabase，从txnLogFactory里读取快照数据。</p>
<p>最后是zk服务器的startup：</p>
<pre><code>    public synchronized void startup() &#123;
        if (sessionTracker == null) &#123;
            createSessionTracker();
        &#125;
        startSessionTracker();
        setupRequestProcessors();

        registerJMX();

        setState(State.RUNNING);
        notifyAll();
    &#125;
</code></pre>
<p>几件事情：</p>
<ul>
<li>createSessionTracker创建sessionTracker</li>
<li>startSessionTracker启动SessionTracker</li>
<li>setupRequestProcessors 创建请求处理器链</li>
<li>registerJMX 注册JMX</li>
<li>setState(State.RUNNING) 设置状态为运行中</li>
</ul>
<h5 id="SessionTracker"><a href="#SessionTracker" class="headerlink" title="SessionTracker"></a>SessionTracker</h5><p>看SessionTracker的注释：</p>
<blockquote>
<p>This is the basic interface that ZooKeeperServer uses to track sessions.<br> 负责追踪Session的</p>
</blockquote>
<p>在zk里的实现是SessionTrackerImpl：</p>
<pre><code>    protected void createSessionTracker() &#123;
        sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),
                tickTime, 1, getZooKeeperServerListener());
    &#125;
    
    protected void startSessionTracker() &#123;
        ((SessionTrackerImpl)sessionTracker).start();
    &#125;
</code></pre>
<p>SessionTrackerImpl后面再详细分析。</p>
<h4 id="2-5-4-ZooKeeperServer请求处理器链介绍"><a href="#2-5-4-ZooKeeperServer请求处理器链介绍" class="headerlink" title="2.5.4  ZooKeeperServer请求处理器链介绍"></a>2.5.4  ZooKeeperServer请求处理器链介绍</h4><p>这里是zk的核心部分之一，zk接收到的请求最终在这里进行处理。</p>
<pre><code> protected void setupRequestProcessors() &#123;
        RequestProcessor finalProcessor = new FinalRequestProcessor(this);
        RequestProcessor syncProcessor = new SyncRequestProcessor(this,
                finalProcessor);
        ((SyncRequestProcessor)syncProcessor).start();
        firstProcessor = new PrepRequestProcessor(this, syncProcessor);
        ((PrepRequestProcessor)firstProcessor).start();
    &#125;
</code></pre>
<p>请求处理链介绍</p>
<ul>
<li>首先是PrepRequestProcessor</li>
<li>然后是SyncRequestProcessor</li>
<li>最后是finalProcessor</li>
</ul>
<p>下面依次解读：</p>
<h5 id="RequestProcessor"><a href="#RequestProcessor" class="headerlink" title="RequestProcessor"></a>RequestProcessor</h5><blockquote>
<p>RequestProcessors are chained together to process transactions.<br> RequestProcessors都是链在一起的事务处理链</p>
</blockquote>
<pre><code>public interface RequestProcessor &#123;
    @SuppressWarnings(&quot;serial&quot;)
    public static class RequestProcessorException extends Exception &#123;
        public RequestProcessorException(String msg, Throwable t) &#123;
            super(msg, t);
        &#125;
    &#125;

    void processRequest(Request request) throws RequestProcessorException;

    void shutdown();
&#125;
</code></pre>
<p>包含下面这些实现：<br><img src="https://ooo.0o0.ooo/2017/04/27/5901abdf8ffaa.jpg" alt="enter description here" title="1493281760211"><br> 我们重点来看下面几个：</p>
<h5 id="PrepRequestProcessor"><a href="#PrepRequestProcessor" class="headerlink" title="PrepRequestProcessor"></a>PrepRequestProcessor</h5><p>为什么成为请求处理链，看下PrepRequestProcessor代码就知道了：</p>
<pre><code>    RequestProcessor nextProcessor;

    ZooKeeperServer zks;

    public PrepRequestProcessor(ZooKeeperServer zks,
            RequestProcessor nextProcessor) &#123;
        super(&quot;ProcessThread(sid:&quot; + zks.getServerId() + &quot; cport:&quot;
                + zks.getClientPort() + &quot;):&quot;, zks.getZooKeeperServerListener());
        this.nextProcessor = nextProcessor;
        this.zks = zks;
    &#125;protected void pRequest(Request request) throws RequestProcessorException &#123;
        ……
        nextProcessor.processRequest(request);
    &#125;
</code></pre>
<p>构造函数里包含nextProcessor，在pRequest完成后，执行nextProcessor.processRequest，相当于链式执行。</p>
<p>接着分析，再来看类的定义：</p>
<pre><code>public class PrepRequestProcessor extends ZooKeeperCriticalThread implements
            RequestProcessor &#123;

        LinkedBlockingQueue&lt;Request&gt; submittedRequests = new LinkedBlockingQueue&lt;Request&gt;();

        RequestProcessor nextProcessor;    
&#125;
</code></pre>
<p>几个要点</p>
<ul>
<li>继承自ZooKeeperCriticalThread，是一个Thread</li>
<li>重要属性submittedRequests 是一个LinkedBlockingQueue，LinkedBlockingQueue实现是线程安全的，实现了先进先出特性，是作为生产者消费者的首选。</li>
</ul>
<p>PrepRequestProcessor作为处理链的源头，对外提供processRequest方法收集请求，由于是单线程，所以需要将请求放入submittedRequests队列。</p>
<pre><code>    public void processRequest(Request request) &#123;
        // request.addRQRec(&quot;&gt;prep=&quot;+zks.outstandingChanges.size());
        submittedRequests.add(request);
    &#125;
</code></pre>
<p>放入队列后，PrepRequestProcessor本身就是一个Thread，所以start后执行run，在run方法中又会将用户提交的请求取出来进行处理：</p>
<pre><code>    public void run() &#123;
            while (true) &#123;
                // 取出一个请求
                Request request = submittedRequests.take();
                if (Request.requestOfDeath == request) &#123;
                    break;
                &#125;
                // 处理请求
                pRequest(request);
            &#125;
        &#125;
</code></pre>
<p>再来看pRequest：<br><img src="https://ooo.0o0.ooo/2017/04/27/5901af5b683c8.jpg" alt="enter description here" title="1493282652397"></p>
<p>根据request的type，构造对应的请求，对于增删改等影响数据状态的操作都被认为是事务（txn:transaction) ，需要创建出事务请求头(hdr)，调用pRequest2Txn，其他操作则不属于事务操作，需要验证下sessionId是否合法。</p>
<pre><code> //create/close session don&#39;t require request record
            case OpCode.createSession:
            case OpCode.closeSession:
                pRequest2Txn(request.type, zks.getNextZxid(), request, null, true);
                break;
 
            //All the rest don&#39;t need to create a Txn - just verify session
            case OpCode.sync:
            case OpCode.exists:
            case OpCode.getData:
            case OpCode.getACL:
            case OpCode.getChildren:
            case OpCode.getChildren2:
            case OpCode.ping:
            case OpCode.setWatches:
                zks.sessionTracker.checkSession(request.sessionId,
                        request.getOwner());
                break;
</code></pre>
<p>来看pRequest2Txn，以create为例</p>
<pre><code>  pRequest2Txn(request.type, zks.getNextZxid(), request, createRequest, true);
 
   protected void pRequest2Txn(int type, long zxid, Request request, Record record, boolean deserialize)
        throws KeeperException, IOException, RequestProcessorException
    &#123;
        request.hdr = new TxnHeader(request.sessionId, request.cxid, zxid,
                                    zks.getTime(), type);

        switch (type) &#123;
            case OpCode.create:                
                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());
                CreateRequest createRequest = (CreateRequest)record;   
                if(deserialize)
                    ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);
                String path = createRequest.getPath();
                int lastSlash = path.lastIndexOf(&#39;/&#39;);
                if (lastSlash == -1 || path.indexOf(&#39;\0&#39;) != -1 || failCreate) &#123;
                    LOG.info(&quot;Invalid path &quot; + path + &quot; with session 0x&quot; +
                            Long.toHexString(request.sessionId));
                    throw new KeeperException.BadArgumentsException(path);
                &#125;
                List&lt;ACL&gt; listACL = removeDuplicates(createRequest.getAcl());
                if (!fixupACL(request.authInfo, listACL)) &#123;
                    throw new KeeperException.InvalidACLException(path);
                &#125;
                String parentPath = path.substring(0, lastSlash);
                ChangeRecord parentRecord = getRecordForPath(parentPath);

                checkACL(zks, parentRecord.acl, ZooDefs.Perms.CREATE,
                        request.authInfo);
                int parentCVersion = parentRecord.stat.getCversion();
                CreateMode createMode =
                    CreateMode.fromFlag(createRequest.getFlags());
                if (createMode.isSequential()) &#123;
                    path = path + String.format(Locale.ENGLISH, &quot;%010d&quot;, parentCVersion);
                &#125;
                validatePath(path, request.sessionId);
                try &#123;
                    if (getRecordForPath(path) != null) &#123;
                        throw new KeeperException.NodeExistsException(path);
                    &#125;
                &#125; catch (KeeperException.NoNodeException e) &#123;
                    // ignore this one
                &#125;
                boolean ephemeralParent = parentRecord.stat.getEphemeralOwner() != 0;
                if (ephemeralParent) &#123;
                    throw new KeeperException.NoChildrenForEphemeralsException(path);
                &#125;
                int newCversion = parentRecord.stat.getCversion()+1;
                request.txn = new CreateTxn(path, createRequest.getData(),
                        listACL,
                        createMode.isEphemeral(), newCversion);
                StatPersisted s = new StatPersisted();
                if (createMode.isEphemeral()) &#123;
                    s.setEphemeralOwner(request.sessionId);
                &#125;
                parentRecord = parentRecord.duplicate(request.hdr.getZxid());
                parentRecord.childCount++;
                parentRecord.stat.setCversion(newCversion);
                addChangeRecord(parentRecord);
                addChangeRecord(new ChangeRecord(request.hdr.getZxid(), path, s,
                        0, listACL));
                break;
</code></pre>
<ul>
<li>首先是 zks.getNextZxid()创建一个事务id，AtomicLong hzxid是自增长id，初始化为0，每次加一</li>
<li>在pRequest2Txn内部，先给request创建一个TxnHeader，这个header包含事务id</li>
<li>然后判断请求类型</li>
<li>zks.sessionTracker.checkSession(request.sessionId, request.getOwner()) 检查session</li>
<li>反序列化为CreateRequest</li>
</ul>
<h5 id="SyncRequestProcessor"><a href="#SyncRequestProcessor" class="headerlink" title="SyncRequestProcessor"></a>SyncRequestProcessor</h5><h5 id="FinalRequestProcessor"><a href="#FinalRequestProcessor" class="headerlink" title="FinalRequestProcessor"></a>FinalRequestProcessor</h5><p>未完待续</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>从编辑距离、BK树到文本纠错</title>
    <url>/jadepeng/2017/11/21/jqpeng-%E4%BB%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E3%80%81BK%E6%A0%91%E5%88%B0%E6%96%87%E6%9C%AC%E7%BA%A0%E9%94%99/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/BK-Tree.html">从编辑距离、BK树到文本纠错</a></p>
<p>搜索引擎里有一个很重要的话题，就是文本纠错，主要有两种做法，一是从词典纠错，一是分析用户搜索日志，今天我们探讨使用基于词典的方式纠错，核心思想就是基于编辑距离，使用BK树。下面我们来逐一探讨：</p>
<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>1965年，俄国科学家Vladimir<br> Levenshtein给字符串相似度做出了一个明确的定义叫做Levenshtein距离，我们通常叫它“编辑距离”。</p>
<p>字符串A到B的编辑距离是指，只用插入、删除和替换三种操作，最少需要多少步可以把A变成B。例如，从FAME到GATE需要两步（两次替换），从GAME到ACM则需要三步（删除G和E再添加C）。Levenshtein给出了编辑距离的一般求法，就是大家都非常熟悉的经典动态规划问题。</p>
<pre><code> class LevenshteinDistanceFunction &#123;

        private final boolean isCaseSensitive;

        public LevenshteinDistanceFunction(boolean isCaseSensitive) &#123;
            this.isCaseSensitive = isCaseSensitive;
        &#125;

        public int distance(CharSequence left, CharSequence right) &#123;
            int leftLength = left.length(), rightLength = right.length();

            // special cases.
            if (leftLength == 0)
                return rightLength;
            if (rightLength == 0)
                return leftLength;

            // Use the iterative matrix method.
            int[] currentRow = new int[rightLength + 1];
            int[] nextRow    = new int[rightLength + 1];

            // Fill first row with all edit counts.
            for (int i = 0; i &lt;= rightLength; i++)
                currentRow[i] = i;

            for (int i = 1; i &lt;= leftLength; i++) &#123;
                nextRow[0] = i;

                for(int j = 1; j &lt;= rightLength; j++) &#123;
                    int subDistance = currentRow[j - 1]; // Distance without insertions or deletions.
                    if (!charEquals(left.charAt(i - 1), right.charAt(j - 1), isCaseSensitive))
                            subDistance++; // Add one edit if letters are different.
                    nextRow[j] = Math.min(Math.min(nextRow[j - 1], currentRow[j]) + 1, subDistance);
                &#125;

                // Swap rows, use last row for next row.
                int[] t = currentRow;
                currentRow = nextRow;
                nextRow = t;
            &#125;

            return currentRow[rightLength];
        &#125;

    &#125;
</code></pre>
<h1 id="BK树"><a href="#BK树" class="headerlink" title="BK树"></a>BK树</h1><p>编辑距离的经典应用就是用于拼写检错，如果用户输入的词语不在词典中，自动从词典中找出编辑距离小于某个数n的单词，让用户选择正确的那一个，n通常取到2或者3。</p>
<p>这个问题的难点在于，怎样才能快速在字典里找出最相近的单词？可以像 <a href="http://www.cnblogs.com/xiaoqi/archive/2012/08/10/2633025.html">使用贝叶斯做英文拼写检查（c#)</a> 里是那样，通过单词自动修改一个单词，检查是否在词典里，这样有暴力破解的嫌疑，是否有更优雅的方案呢？</p>
<p>1973年，Burkhard和Keller提出的BK树有效地解决了这个问题。BK树的核心思想是：</p>
<pre><code>令d(x,y)表示字符串x到y的Levenshtein距离，那么显然：
d(x,y) = 0 当且仅当 x=y （Levenshtein距离为0 &lt;==&gt; 字符串相等）
d(x,y) = d(y,x) （从x变到y的最少步数就是从y变到x的最少步数）
d(x,y) + d(y,z) &gt;= d(x,z) （从x变到z所需的步数不会超过x先变成y再变成z的步数）
</code></pre>
<p>最后这一个性质叫做三角形不等式。就好像一个三角形一样，两边之和必然大于第三边。</p>
<h2 id="BK建树"><a href="#BK建树" class="headerlink" title="BK建树"></a>BK建树</h2><p>首先我们随便找一个单词作为根（比如GAME）。以后插入一个单词时首先计算单词与根的Levenshtein距离：如果这个距离值是该节点处头一次出现，建立一个新的儿子节点；否则沿着对应的边递归下去。例如，我们插入单词FAME，它与GAME的距离为1，于是新建一个儿子，连一条标号为1的边；下一次插入GAIN，算得它与GAME的距离为2，于是放在编号为2的边下。再下次我们插入GATE，它与GAME距离为1，于是沿着那条编号为1的边下去，递归地插入到FAME所在子树；GATE与FAME的距离为2，于是把GATE放在FAME节点下，边的编号为2。</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1511232052823.jpg" alt="enter description here" title="BK树"></p>
<h2 id="BK查询"><a href="#BK查询" class="headerlink" title="BK查询"></a>BK查询</h2><p>如果我们需要返回与错误单词距离不超过n的单词，这个错误单词与树根所对应的单词距离为d，那么接下来我们只需要递归地考虑编号在d-n到d+n范围内的边所连接的子树。由于n通常很小，因此每次与某个节点进行比较时都可以<strong>排除很多子树</strong>。</p>
<p>可以通过下图（来自 <a href="http://blog.csdn.net/tradymeky/article/details/40581547">超酷算法（1）：BK树 （及个人理解）</a>）理解：</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1511229083171.jpg" alt="enter description here" title="1511229083171"></p>
<h2 id="BK-实现"><a href="#BK-实现" class="headerlink" title="BK 实现"></a>BK 实现</h2><p>知道了原理实现就简单了，这里从<a href="https://github.com/sk-scd91/BKTree">github</a>找一段代码</p>
<p>建树：</p>
<pre><code>public boolean add(T t) &#123;
        if (t == null)
            throw new NullPointerException();

        if (rootNode == null) &#123;
            rootNode = new Node&lt;&gt;(t);
            length = 1;
            modCount++; // Modified tree by adding root.
            return true;
        &#125;

        Node&lt;T&gt; parentNode = rootNode;
        Integer distance;
        while ((distance = distanceFunction.distance(parentNode.item, t)) != 0
                || !t.equals(parentNode.item)) &#123;
            Node&lt;T&gt; childNode = parentNode.children.get(distance);
            if (childNode == null) &#123;
                parentNode.children.put(distance, new Node&lt;&gt;(t));
                length++;
                modCount++; // Modified tree by adding a child.
                return true;
            &#125;
            parentNode = childNode;
        &#125;

        return false;
    &#125;
</code></pre>
<p>查找：</p>
<pre><code> public List&lt;SearchResult&lt;T&gt;&gt; search(T t, int radius) &#123;
        if (t == null)
            return Collections.emptyList();
        ArrayList&lt;SearchResult&lt;T&gt;&gt; searchResults = new ArrayList&lt;&gt;();
        ArrayDeque&lt;Node&lt;T&gt;&gt; nextNodes = new ArrayDeque&lt;&gt;();
        if (rootNode != null)
            nextNodes.add(rootNode);

        while(!nextNodes.isEmpty()) &#123;
            Node&lt;T&gt; nextNode = nextNodes.poll();
            int distance = distanceFunction.distance(nextNode.item, t);
            if (distance &lt;= radius)
                searchResults.add(new SearchResult&lt;&gt;(distance, nextNode.item));
            int lowBound = Math.max(0, distance - radius), highBound = distance + radius;
            for (Integer i = lowBound; i &lt;= highBound; i++) &#123;
                if (nextNode.children.containsKey(i))
                    nextNodes.add(nextNode.children.get(i));
            &#125;
        &#125;

        searchResults.trimToSize();
        Collections.sort(searchResults);
        return Collections.unmodifiableList(searchResults);
    &#125;
</code></pre>
<h1 id="使用BK树做文本纠错"><a href="#使用BK树做文本纠错" class="headerlink" title="使用BK树做文本纠错"></a>使用BK树做文本纠错</h1><p>准备词典，18万的影视名称：<br><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1511231191970.jpg" alt="enter description here" title="1511231191970"></p>
<p>测试代码：</p>
<pre><code>  static void outputSearchResult( List&lt;SearchResult&lt;CharSequence&gt;&gt; results)&#123;
        for(SearchResult&lt;CharSequence&gt; item : results)&#123;
            System.out.println(item.item);
        &#125;
    &#125;

    static void test(BKTree&lt;CharSequence&gt; tree,String word)&#123;
        System.out.println(word+&quot;的最相近结果：&quot;);
        outputSearchResult(tree.search(word,Math.max(1,word.length()/4)));
    &#125;

    public static void main(String[] args) &#123;

        BKTree&lt;CharSequence&gt; tree = new BKTree(DistanceFunctions.levenshteinDistance());
        List&lt;String&gt; testStrings = FileUtil.readLine(&quot;./src/main/resources/act/name.txt&quot;);
        System.out.println(&quot;词典条数：&quot;+testStrings.size());
        long startTime = System.currentTimeMillis();
        for(String testStr: testStrings)&#123;
            tree.add(testStr.replace(&quot;.&quot;,&quot;&quot;));
        &#125;
        System.out.println(&quot;建树耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;);
        startTime = System.currentTimeMillis();
        String[] testWords = new String[]&#123;
                &quot;湄公河凶案&quot;,
                &quot;葫芦丝兄弟&quot;,
                &quot;少林足球&quot;
        &#125;;

        for (String testWord: testWords)&#123;
            test(tree,testWord);
        &#125;
        System.out.println(&quot;测试耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;);
    &#125;
</code></pre>
<p>结果：</p>
<pre><code>词典条数：18513
建树耗时：421ms
湄公河凶案的最相近结果：
湄公河大案
葫芦丝兄弟的最相近结果：
葫芦兄弟
少林足球的最相近结果：
少林足球
笑林足球
测试耗时：20ms
</code></pre>
<p>参考：<br><a href="http://blog.csdn.net/tradymeky/article/details/40581547">http://blog.csdn.net/tradymeky/article/details/40581547</a><br><a href="https://github.com/sk-scd91/BKTree">https://github.com/sk-scd91/BKTree</a><br><a href="https://www.cnblogs.com/data2value/p/5707973.html">https://www.cnblogs.com/data2value/p/5707973.html</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>BK树</tag>
        <tag>文本纠错</tag>
      </tags>
  </entry>
  <entry>
    <title>从Trie树到双数组Trie树</title>
    <url>/jadepeng/2017/11/13/jqpeng-%E4%BB%8ETrie%E6%A0%91%E5%88%B0%E5%8F%8C%E6%95%B0%E7%BB%84Trie%E6%A0%91/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/Trie.html">从Trie树到双数组Trie树</a></p>
<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，能在常数时间O(len)内实现插入和查询操作，是一种以空间换取时间的数据结构，广泛用于词频统计和输入统计领域。</p>
<p>来看看Trie树长什么样，我们从百度找一张图片：</p>
<p><img src="https://raw.githubusercontent.com/jadepeng/blogpic/master/pic/2018/1509691910484.jpg" alt="enter description here" title="1509691910484"></p>
<p>字典树在查找时，先看第一个字是否在字典树里，如果在继续往下，如果不在，则字典里不存在，因此，对于一个长度为len的字符串，可以在O（len)时间内完成查询。</p>
<h2 id="实现trie树"><a href="#实现trie树" class="headerlink" title="实现trie树"></a>实现trie树</h2><p>怎么实现trie树呢，trie树的关键是一个节点要在O（1）时间跳转到下一级节点，因此链表方式不可取，最好用数组来存储下一级节点。问题就来了，如果是纯英文字母，长度26的数组就可以搞定，N个节点的数，就需要N个长度为26的数组。但是，如果包含中文等字符呢，就需要N个65535的数组，特别占用存储空间。当然，可以考虑使用map来存储下级节点。</p>
<p>定义一个Node，包含节点的Character word，以及下级节点nexts和节点可能附件的值values：</p>
<pre><code>public static class Node&lt;T&gt; &#123;
        Character word;

        List&lt;T&gt; values;

        Map&lt;Character, Node&gt; nexts = new HashMap&lt;&gt;(24);

        public Node() &#123;
        &#125;

        public Node(Character word) &#123;
            this.word = word;
        &#125;

        public Character getWord() &#123;
            return word;
        &#125;

        public void setWord(Character word) &#123;
            this.word = word;
        &#125;

        public void addValue(T value)&#123;
            if(values == null)&#123;
                values = new ArrayList&lt;&gt;();
            &#125;
            values.add(value);
        &#125;

        public List&lt;T&gt; getValues() &#123;
            return values;
        &#125;

        public Map&lt;Character, Node&gt; getNexts() &#123;
            return nexts;
        &#125;

        /**
         * @param node
         */
        public void addNext(Node node) &#123;
            this.nexts.put(node.getWord(), node);
        &#125;

        public Node getNext(Character word) &#123;
            return this.nexts.get(word);
        &#125;
    &#125;
</code></pre>
<p>来看如何构建字典树，首先定义一棵树，包含根节点即可</p>
<pre><code>    public static class Trie&lt;T&gt; &#123;
        Node&lt;T&gt; rootNode;

        public Trie() &#123;
            this.rootNode = new Node&lt;T&gt;();
        &#125;

        public Node&lt;T&gt; getRootNode() &#123;
            return rootNode;
        &#125;

    &#125;
</code></pre>
<p>构建树，拆分成单字，然后逐级构建树。</p>
<pre><code> public static class TrieBuilder &#123;
        public static  Trie&lt;String&gt; buildTrie(String... values)&#123;
            Trie&lt;String&gt; trie = new Trie&lt;String&gt;();
            for(String sentence : values)&#123;
                // 根节点
                Node&lt;String&gt; currentNode = trie.getRootNode();
                for (int i = 0; i &lt; sentence.length(); i++) &#123;
                    Character character = sentence.charAt(i);
                    // 寻找首个节点
                    Node&lt;String&gt; node = currentNode.getNext(character);
                    if(node == null)&#123;
                        // 不存在，创建节点
                        node = new Node&lt;String&gt;(character);
                        currentNode.addNext(node);
                    &#125;
                    currentNode = node;
                &#125;

                // 添加数据
                currentNode.addValue(sentence);
            &#125;

            return trie;
        &#125;
</code></pre>
<h2 id="Trie树应用"><a href="#Trie树应用" class="headerlink" title="Trie树应用"></a>Trie树应用</h2><p>比如判断一个词是否在字典树里，非常简单，逐级匹配，末了判断最后的节点是否包含数据：</p>
<pre><code>   public boolean isContains(String word) &#123;
            if (word == null || word.length() == 0) &#123;
                return false;
            &#125;
            Node&lt;T&gt; currentState = rootNode;
            for (int i = 0; i &lt; word.length(); i++) &#123;
                currentState = currentState.getNext(word.charAt(i));
                if (currentState == null) &#123;
                    return false;
                &#125;
            &#125;
            return currentState.getValues()!=null;
        &#125;
</code></pre>
<p>测试代码:</p>
<pre><code>        public static void main(String[] args) &#123;

            Trie trie = TrieBuilder.buildTrie(&quot;刘德华&quot;,&quot;刘三姐&quot;,&quot;刘德刚&quot;,&quot;江姐&quot;);
            System.out.println(trie.isContains(&quot;刘德华&quot;));
            System.out.println(trie.isContains(&quot;刘德&quot;));
            System.out.println(trie.isContains(&quot;刘大大&quot;));
        &#125;
</code></pre>
<p>结果：</p>
<pre><code>true
false
false
</code></pre>
<h1 id="双数组Trie树"><a href="#双数组Trie树" class="headerlink" title="双数组Trie树"></a>双数组Trie树</h1><p>在Trie数实现过程中，我们发现了每个节点均需要 一个数组来存储next节点，非常占用存储空间，空间复杂度大，双数组Trie树正是解决这个问题的。双数组Trie树(DoubleArrayTrie)是一种空间复杂度低的Trie树，应用于字符区间大的语言（如中文、日文等）分词领域。</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>双数组的原理是，将原来需要多个数组才能表示的Trie树，使用两个数据就可以存储下来，可以极大的减小空间复杂度。具体来说：</p>
<p>使用两个数组base和check来维护Trie树，base负责记录状态，check负责检查各个字符串是否是从同一个状态转移而来，当check[i]为负值时，表示此状态为字符串的结束。</p>
<p>上面的有点抽象，举个例子，假定两个单词ta,tb,base和check的值会满足下面的条件：<br> base[t] + a.code = base[ta]<br> base[t] + b.code = base[tb]<br> check[ta] = check[tb]</p>
<p>在每个节点插入的过程中会修改这两个数组，具体说来：</p>
<p>1、初始化root节点base[0] = 1; check[0] = 0;</p>
<p>2、对于每一群兄弟节点，寻找一个begin值使得check[begin + a1…an]  == 0，也就是找到了n个空闲空间,a1…an是siblings中的n个节点对应的code。</p>
<p>3、然后将这群兄弟节点的check设为check[begin + a1…an] = begin</p>
<p>4、接着对每个兄弟节点，如果它没有孩子，令其base为负值；否则为该节点的子节点的插入位置（也就是begin值），同时插入子节点（迭代跳转到步骤2）。</p>
<pre><code>码表：
   胶    名    动    知    下    成    举    一    能    天    万    
33014 21517 21160 30693 19979 25104 20030 19968 33021 22825 19975 

DoubleArrayTrie&#123;
char =      ×    一    万     ×    举     ×    动     ×     下    名    ×    知      ×     ×    能    一    天    成    胶
i    =      0 19970 19977 20032 20033 21162 21164 21519 21520 21522 30695 30699 33023 33024 33028 40001 44345 45137 66038
base =      1     2     6    -1 20032    -2 21162    -3     5 21519    -4 30695    -5    -6 33023     3  1540     4 33024
check=      0     1     1 20032     2 21162     3 21519  1540     4 30695     5 33023 33024     6 20032 21519 20032 33023
size=66039, allocSize=2097152, key=[一举, 一举一动, 一举成名, 一举成名天下知, 万能, 万能胶], keySize=6, progress=6, nextCheckPos=33024, error_=0&#125;
</code></pre>
<p>首层:一[19968],万[ 19975]<br> base[一] = base[0]+19968-19968 = 1<br> base[万] = base[0]+19975-19968 =</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参考 <a href="http://www.hankcs.com/program/java/%E5%8F%8C%E6%95%B0%E7%BB%84trie%E6%A0%91doublearraytriejava%E5%AE%9E%E7%8E%B0.html">双数组Trie树(DoubleArrayTrie)Java实现</a><br> 开源项目：<a href="https://github.com/komiya-atsushi/darts-java">https://github.com/komiya-atsushi/darts-java</a></p>
<h1 id="双数组Trie-AC自动机"><a href="#双数组Trie-AC自动机" class="headerlink" title="双数组Trie+AC自动机"></a>双数组Trie+AC自动机</h1><p>参见：<a href="http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html">http://www.hankcs.com/program/algorithm/aho-corasick-double-array-trie.html</a></p>
<p>结合了AC自动机+双数组Trie树：<br> AC自动机能高速完成多模式匹配，然而具体实现聪明与否决定最终性能高低。大部分实现都是一个Map&lt;Character, State&gt;了事，无论是TreeMap的对数复杂度，还是HashMap的巨额空间复杂度与哈希函数的性能消耗，都会降低整体性能。</p>
<p>双数组Trie树能高速O(n)完成单串匹配，并且内存消耗可控，然而软肋在于多模式匹配，如果要匹配多个模式串，必须先实现前缀查询，然后频繁截取文本后缀才可多匹配，这样一份文本要回退扫描多遍，性能极低。</p>
<p>如果能用双数组Trie树表达AC自动机，就能集合两者的优点，得到一种近乎完美的数据结构。在我的Java实现中，我称其为AhoCorasickDoubleArrayTrie，支持泛型和持久化，自己非常喜爱。</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Trie树</tag>
        <tag>双数组Trie树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>使用websocket-sharp来创建c#版本的websocket服务</title>
    <url>/jadepeng/2017/06/22/jqpeng-%E4%BD%BF%E7%94%A8websocket-sharp%E6%9D%A5%E5%88%9B%E5%BB%BAc#%E7%89%88%E6%9C%AC%E7%9A%84websocket%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/websocket-sharp.html">使用websocket-sharp来创建c#版本的websocket服务</a></p>
<p>当前有一个需求，需要网页端调用扫描仪，javascript不具备调用能力，因此需要在机器上提供一个ws服务给前端网页调用扫描仪。而扫描仪有一个c#版本的API，因此需要寻找一个c#的websocket库。</p>
<p>java里有大名鼎鼎的netty，通过搜索，c#可以选择<a href="https://github.com/sta/websocket-sharp">websocket-sharp</a>来实现websocket Server。</p>
<h3 id="使用websocket-sharp创建websocket-server"><a href="#使用websocket-sharp创建websocket-server" class="headerlink" title="使用websocket-sharp创建websocket server###"></a>使用websocket-sharp创建websocket server###</h3><pre><code>using System;
using WebSocketSharp;
using WebSocketSharp.Server;

namespace Example
&#123;
  public class Laputa : WebSocketBehavior
  &#123;
    protected override void OnMessage (MessageEventArgs e)
    &#123;
      var msg = e.Data == &quot;BALUS&quot;
                ? &quot;I&#39;ve been balused already...&quot;
                : &quot;I&#39;m not available now.&quot;;

      Send (msg);
    &#125;
  &#125;

  public class Program
  &#123;
    public static void Main (string[] args)
    &#123;
      var wssv = new WebSocketServer (&quot;ws://dragonsnest.far&quot;);
      wssv.AddWebSocketService&lt;Laputa&gt; (&quot;/Laputa&quot;);
      wssv.Start ();
      Console.ReadKey (true);
      wssv.Stop ();
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h4><p>Required namespace.</p>
<pre><code>using WebSocketSharp.Server;
</code></pre>
<p>The <code>WebSocketBehavior</code> and <code>WebSocketServer</code> 两个类需要引用 <code>WebSocketSharp.Server</code> namespace.</p>
<h4 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h4><p>编写处理类，需要继承 <code>WebSocketBehavior</code> class.</p>
<p>例如，如果你要创建一个echo Service,</p>
<pre><code>using System;
using WebSocketSharp;
using WebSocketSharp.Server;

public class Echo : WebSocketBehavior
&#123;
  protected override void OnMessage (MessageEventArgs e)
  &#123;
    Send (e.Data);
  &#125;
&#125;
</code></pre>
<p>再提供一个 chat service,</p>
<pre><code>using System;
using WebSocketSharp;
using WebSocketSharp.Server;

public class Chat : WebSocketBehavior
&#123;
  private string _suffix;

  public Chat ()
    : this (null)
  &#123;
  &#125;

  public Chat (string suffix)
  &#123;
    _suffix = suffix ?? String.Empty;
  &#125;

  protected override void OnMessage (MessageEventArgs e)
  &#123;
    Sessions.Broadcast (e.Data + _suffix);
  &#125;
&#125;
</code></pre>
<p>可以通过继承<code>WebSocketBehavior</code>类来自定义Service.</p>
<p>通过重载 <code>WebSocketBehavior.OnMessage (MessageEventArgs)</code> 方法, 来处理消息</p>
<p>同时你也可以重载 <code>WebSocketBehavior.OnOpen ()</code>, <code>WebSocketBehavior.OnError (ErrorEventArgs)</code>, 和 <code>WebSocketBehavior.OnClose (CloseEventArgs)</code> 方法,来处理websocket连接事件。</p>
<p>通过<code>WebSocketBehavior.Send</code> 方法来给客户端发送消息。</p>
<p>If you would like to get the sessions in the service, you should access the <code>WebSocketBehavior.Sessions</code> property (returns a <code>WebSocketSharp.Server.WebSocketSessionManager</code>).</p>
<p>The <code>WebSocketBehavior.Sessions.Broadcast</code> method can send data to every client in the service.</p>
<h4 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h4><p>创建 <code>WebSocketServer</code> 对象.</p>
<pre><code>var wssv = new WebSocketServer (4649);
wssv.AddWebSocketService&lt;Echo&gt; (&quot;/Echo&quot;);
wssv.AddWebSocketService&lt;Chat&gt; (&quot;/Chat&quot;);
wssv.AddWebSocketService&lt;Chat&gt; (&quot;/ChatWithNyan&quot;, () =&gt; new Chat (&quot; Nyan!&quot;));
</code></pre>
<h4 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h4><p>启动 WebSocket server.</p>
<pre><code>wssv.Start ();
</code></pre>
<h4 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h4><p>停止 WebSocket server.</p>
<pre><code>wssv.Stop (code, reason);
</code></pre>
<h3 id="测试Demo"><a href="#测试Demo" class="headerlink" title="测试Demo"></a>测试Demo</h3><p><code>目的</code>：对外提供一个websocket服务，让网页端的js可以调用扫描仪</p>
<h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><pre><code> class Program
    &#123;
        static void Main(string[] args)
        &#123;
            var wssv = new WebSocketServer(10086);
            wssv.AddWebSocketService&lt;ScannerHandler&gt;(&quot;/scan&quot;);
            wssv.Start();
            if (wssv.IsListening)
            &#123;
                Console.WriteLine(&quot;Listening on port &#123;0&#125;, and providing WebSocket services:&quot;, wssv.Port);
                foreach (var path in wssv.WebSocketServices.Paths)
                    Console.WriteLine(&quot;- &#123;0&#125;&quot;, path);
            &#125;

            Console.WriteLine(&quot;\nPress Enter key to stop the server...&quot;);
            Console.ReadLine();

            wssv.Stop();
        &#125;
    &#125;

    public class ScannerHandler : WebSocketBehavior
    &#123;
        protected override void OnMessage(MessageEventArgs e)
        &#123;
            if(e.Data == &quot;scan&quot;)
            &#123;
                ScanResult result = ScanerHelper.Scan(&quot;D:\\test.jpg&quot;);
                if (result.Success)
                &#123;
                    Console.WriteLine(&quot;scan success&quot;);
                    Send(&quot;scan success&quot;);
                &#125;
                else
                &#123;
                    Send(&quot;scan eror&quot;);
                &#125;
            &#125;
           
        &#125;
    &#125;
</code></pre>
<h4 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h4><p>javascript代码</p>
<pre><code>     var ws;
    function initWS() &#123;
        ws = new WebSocket(&quot;ws://127.0.0.1:10086/scan&quot;);
        ws.onopen = function () &#123;
            console.log(&quot;Openened connection to websocket&quot;);

        &#125;;
        ws.onclose = function () &#123;
            console.log(&quot;Close connection to websocket&quot;);
            // 断线重连
            initWS();
        &#125;

        ws.onmessage = function (e) &#123;
            alert(e.data)
        &#125;
    &#125;
    initWS();
    function scan() &#123;
        ws &amp;&amp; ws.send(&#39;scan&#39;);
    &#125;
</code></pre>
<p>html代码</p>
<pre><code>&lt;button onclick=&quot;scan()&quot;&gt;扫描&lt;/button&gt;
</code></pre>
<ul>
<li>initWS创建连接，支持断线重连</li>
<li>可以调用scan函数，发送scan指令</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>c#</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA+PHP+XDebug调试配置</title>
    <url>/jadepeng/2017/06/19/jqpeng-IDEA+PHP+XDebug%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/xdbug.html">IDEA+PHP+XDebug调试配置</a></p>
<h2 id="XDebug调试配置"><a href="#XDebug调试配置" class="headerlink" title="XDebug调试配置"></a>XDebug调试配置</h2><p>临时需要调试服务器上的PHP web程序，因此安装xdebug，下面简单记录</p>
<h3 id="安装xdebug"><a href="#安装xdebug" class="headerlink" title="安装xdebug"></a>安装xdebug</h3><h4 id="下载最新并解压"><a href="#下载最新并解压" class="headerlink" title="下载最新并解压"></a>下载最新并解压</h4><pre><code>wget https://xdebug.org/files/xdebug-2.5.4.tgz
tar zxvf xdebug-2.5.4.tgz 
cd xdebug-2.5.4/
</code></pre>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>按照README里的步骤安装</p>
<pre><code>./configure --enable-xdebug
···

报错
&gt;checking Check for supported PHP versions... configure: error: not supported. Need a PHP version &gt;= 5.5.0 and &lt; 7.2.0 (found 5.3.10-1ubuntu3.21)


原来服务器上的php版本比较低：
&gt;PHP 5.3.10-1ubuntu3.26 with Suhosin-Patch (cli) (built: Feb 13 2017 20:37:53) 
Copyright (c) 1997-2012 The PHP Group
Zend Engine v2.3.0, Copyright (c) 1998-2012 Zend Technologies

最稳妥起见，下载老版本的xdebug，下载2.2.2版本

``` bash
wget https://xdebug.org/files/xdebug-2.2.2.tgz
tar zxvf xdebug-2.2.2.tgz 
cd xdebug-2.2.2/
./configure --enable-xdebug
make
</code></pre>
<p>make完成后，modules下面就有了编译好的xdebug.so:</p>
<pre><code>root@nginx01:/opt/research/xdebug-2.2.2# ll modules/
total 808
drwxr-xr-x 2 root root   4096 Jun 19 14:17 ./
drwxr-xr-x 9 root root   4096 Jun 19 13:10 ../
-rw-r--r-- 1 root root    939 Jun 19 13:09 xdebug.la
-rwxr-xr-x 1 root root 814809 Jun 19 13:09 xdebug.so*
</code></pre>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>修改php.ini，服务器使用的php5-fpm，配置文件在/etc/php5/fpm/php.ini</p>
<p>修改，增加xdebug配置信息</p>
<pre><code>zend_extension=&quot;/opt/research/xdebug-2.2.2/modules/xdebug.so&quot;
xdebug.remote_enable = On
xdebug.remote_handler = dbgp
xdebug.remote_port = 9001 #端口9001
xdebug.remote_connect_back = 1 
#xdebug.remote_host= 192.168.xxx.xxx
xdebug.idekey = PHPSTORM
xdebug.remote_log = /opt/research/xdebug-2.2.2/xdebug.log
</code></pre>
<h3 id="IDEA-配置"><a href="#IDEA-配置" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h3><h4 id="配置xdebug端口为9001"><a href="#配置xdebug端口为9001" class="headerlink" title="配置xdebug端口为9001"></a>配置xdebug端口为9001</h4><p>在设置里搜索XDEBUG，配置端口9001<br><img src="https://ooo.0o0.ooo/2017/06/19/5947709e37cf4.jpg" alt="enter description here" title="1497854105384"></p>
<h4 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h4><p>在RUN-Edit Configuratins里，新增PHP Web Application<br><img src="https://ooo.0o0.ooo/2017/06/19/5947707361211.jpg" alt="enter description here" title="1497854062372"></p>
<p>Server新增服务器地址，Debugger设置为Xdebug，将服务器上的绝对地址，映射到本地</p>
<p><img src="https://ooo.0o0.ooo/2017/06/19/59477034b6e7f.jpg" alt="XDEBUG配置" title="1497853999274"></p>
<p>然后就可以启动调试了</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5录音控件</title>
    <url>/jadepeng/2017/06/12/jqpeng-HTML5%E5%BD%95%E9%9F%B3%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/6993912.html">HTML5录音控件</a></p>
<p>最近的项目又需要用到录音，年前有过调研，再次翻出来使用，这里做一个记录。</p>
<p>HTML5提供了录音支持，因此可以方便使用HTML5来录音，来实现录音、语音识别等功能，语音开发必备。但是ES标准提供的API并不人性化，不方便使用，并且不提供保存为wav的功能，开发起来费劲啊！！</p>
<p>github寻找轮子，发现<a href="https://github.com/mattdiamond/Recorderjs">Recorder.js</a>，基本上可以满足需求了，良好的封装，支持导出wav，但是存在：</p>
<ul>
<li>wav采样率不可调整</li>
<li>recorder创建麻烦，需要自己初始化getUserMedia</li>
<li>无实时数据回调，不方便绘制波形</li>
<li>。。。</li>
</ul>
<h2 id="改造轮子"><a href="#改造轮子" class="headerlink" title="改造轮子"></a>改造轮子</h2><h3 id="创建recorder工具方法"><a href="#创建recorder工具方法" class="headerlink" title="创建recorder工具方法"></a>创建recorder工具方法</h3><p>提供创建recorder工具函数，封装audio接口：</p>
<pre><code>static createRecorder(callback,config)&#123;
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        window.URL = window.URL || window.webkitURL;
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
        
        if (navigator.getUserMedia) &#123;
            navigator.getUserMedia(
                &#123; audio: true &#125; //只启用音频
                , function (stream) &#123;
                    var audio_context = new AudioContext;
                    var input = audio_context.createMediaStreamSource(stream);
                    var rec = new Recorder(input, config);
                    callback(rec);
                &#125;
                , function (error) &#123;
                    switch (error.code || error.name) &#123;
                        case &#39;PERMISSION_DENIED&#39;:
                        case &#39;PermissionDeniedError&#39;:
                            throwError(&#39;用户拒绝提供信息。&#39;);
                            break;
                        case &#39;NOT_SUPPORTED_ERROR&#39;:
                        case &#39;NotSupportedError&#39;:
                            throwError(&#39;浏览器不支持硬件设备。&#39;);
                            break;
                        case &#39;MANDATORY_UNSATISFIED_ERROR&#39;:
                        case &#39;MandatoryUnsatisfiedError&#39;:
                            throwError(&#39;无法发现指定的硬件设备。&#39;);
                            break;
                        default:
                            throwError(&#39;无法打开麦克风。异常信息:&#39; + (error.code || error.name));
                            break;
                    &#125;
                &#125;);
        &#125; else &#123;
            throwError(&#39;当前浏览器不支持录音功能。&#39;); return;
        &#125;
    &#125;
</code></pre>
<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>H5录制的默认是44k的，文件大，不方便传输，因此需要进行重新采样，一般采用插值取点方法：</p>
<p>以下代码主要来自stackoverflow：</p>
<pre><code>             /**
             * 转换采样率
             * @param data
             * @param newSampleRate 目标采样率
             * @param oldSampleRate 原始数据采样率
             * @returns &#123;any[]|Array&#125;
             */
            function interpolateArray(data, newSampleRate, oldSampleRate) &#123;
                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));
                var newData = new Array();
                var springFactor = new Number((data.length - 1) / (fitCount - 1));
                newData[0] = data[0]; // for new allocation
                for (var i = 1; i &lt; fitCount - 1; i++) &#123;
                    var tmp = i * springFactor;
                    var before = new Number(Math.floor(tmp)).toFixed();
                    var after = new Number(Math.ceil(tmp)).toFixed();
                    var atPoint = tmp - before;
                    newData[i] = this.linearInterpolate(data[before], data[after], atPoint);
                &#125;
                newData[fitCount - 1] = data[data.length - 1]; // for new allocation
                return newData;
            &#125;

            function linearInterpolate(before, after, atPoint) &#123;
                return before + (after - before) * atPoint;
            &#125;
</code></pre>
<p>修改导出wav函数exportWAV，增加采样率选项：</p>
<pre><code>            /**
             * 导出wav
             * @param type
             * @param desiredSamplingRate 期望的采样率
             */
            function exportWAV(type,desiredSamplingRate) &#123;
                // 默认为16k
                desiredSamplingRate = desiredSamplingRate || 16000;
                var buffers = [];
                for (var channel = 0; channel &lt; numChannels; channel++) &#123;
                    var buffer = mergeBuffers(recBuffers[channel], recLength);
                    // 需要转换采样率
                    if (desiredSamplingRate!=sampleRate) &#123;
                        // 插值去点
                        buffer = interpolateArray(buffer, desiredSamplingRate, sampleRate);
                    &#125;
                    buffers.push(buffer);
                &#125;
                var interleaved = numChannels === 2 ? interleave(buffers[0], buffers[1]) : buffers[0];
                var dataview = encodeWAV(interleaved,desiredSamplingRate);
                var audioBlob = new Blob([dataview], &#123; type: type &#125;);
                self.postMessage(&#123; command: &#39;exportWAV&#39;, data: audioBlob &#125;);
            &#125;
</code></pre>
<h3 id="实时录音数据回调"><a href="#实时录音数据回调" class="headerlink" title="实时录音数据回调"></a>实时录音数据回调</h3><p>为了方便绘制音量、波形图，需要获取到实时数据：</p>
<p>config新增一个回调函数onaudioprocess：</p>
<pre><code>  config = &#123;
        bufferLen: 4096,
        numChannels: 1, // 默认单声道
        mimeType: &#39;audio/wav&#39;,
        onaudioprocess:null
    &#125;;
</code></pre>
<p>修改录音数据处理函数：</p>
<pre><code>        this.node.onaudioprocess = (e) =&gt; &#123;
            if (!this.recording) return;
            var buffer = [];

            for (var channel = 0; channel &lt; this.config.numChannels; channel++) &#123;
                buffer.push(e.inputBuffer.getChannelData(channel));
            &#125;

            // 发送给worker
            this.worker.postMessage(&#123;
                command: &#39;record&#39;,
                buffer: buffer
            &#125;);

            // 数据回调
            if(this.config.onaudioprocess)&#123;
                this.config.onaudioprocess(buffer[0]);
            &#125;
        &#125;;
</code></pre>
<p>这样，在创建recorder时，配置onaudioprocess就可以获取到实时数据了</p>
<h3 id="实时数据编码"><a href="#实时数据编码" class="headerlink" title="实时数据编码"></a>实时数据编码</h3><p>编码计算耗时，需要放到worker执行：</p>
<p>接口函数新增encode，发送消息给worker，让worker执行：</p>
<pre><code>    encode(cb,buffer,sampleRate) &#123;
        cb = cb || this.config.callback;
        if (!cb) throw new Error(&#39;Callback not set&#39;);
        this.callbacks.encode.push(cb);
        this.worker.postMessage(&#123; command: &#39;encode&#39;,buffer:buffer,sampleRate:sampleRate&#125;);
    &#125;
</code></pre>
<p>worker里新增encode函数，处理encode请求，完成后执行回调</p>
<pre><code> self.onmessage = function (e) &#123;
                switch (e.data.command) &#123;

                    case &#39;encode&#39;:
                        encode(e.data.buffer,e.data.sampleRate);
                        break;

                &#125;
            &#125;;        
    encode(cb,buffer,sampleRate) &#123;
        cb = cb || this.config.callback;
        if (!cb) throw new Error(&#39;Callback not set&#39;);
        this.callbacks.encode.push(cb);
        this.worker.postMessage(&#123; command: &#39;encode&#39;,buffer:buffer,sampleRate:sampleRate&#125;);
    &#125;
</code></pre>
<h3 id="wav上传"><a href="#wav上传" class="headerlink" title="wav上传"></a>wav上传</h3><p>增加一个上传函数：</p>
<pre><code>     exportWAVAndUpload(url, callback) &#123;
        var _url = url;
        exportWAV(function(blob)&#123;
            var fd = new FormData();
            fd.append(&quot;audioData&quot;, blob);
            var xhr = new XMLHttpRequest();
            if (callback) &#123;
                xhr.upload.addEventListener(&quot;progress&quot;, function (e) &#123;
                    callback(&#39;uploading&#39;, e);
                &#125;, false);
                xhr.addEventListener(&quot;load&quot;, function (e) &#123;
                    callback(&#39;ok&#39;, e);
                &#125;, false);
                xhr.addEventListener(&quot;error&quot;, function (e) &#123;
                    callback(&#39;error&#39;, e);
                &#125;, false);
                xhr.addEventListener(&quot;abort&quot;, function (e) &#123;
                    callback(&#39;cancel&#39;, e);
                &#125;, false);
            &#125;
            xhr.open(&quot;POST&quot;, url);
            xhr.send(fd);
        &#125;)     
    &#125;
</code></pre>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>=<a href="http://files.cnblogs.com/files/xiaoqi/recorder.js">点击下载</a></p>
<h2 id="发现新轮子"><a href="#发现新轮子" class="headerlink" title="发现新轮子"></a>发现新轮子</h2><p>今天再次看这个项目，发现这个项目已经不维护了，</p>
<blockquote>
<p>Note: This repository is not being actively maintained due to lack of time and interest. If you maintain or know of a good fork, please let me know so I can direct future visitors to it. In the meantime, if this library isn’t working, you can find a list of popular forks here: <a href="http://forked.yannick.io/mattdiamond/recorderjs">http://forked.yannick.io/mattdiamond/recorderjs</a>.</p>
</blockquote>
<p>作者推荐<a href="https://github.com/chris-rudmin/Recorderjs">https://github.com/chris-rudmin/Recorderjs</a>，提供更多的功能：</p>
<ul>
<li><strong>bitRate</strong> (<em>optional</em>) Specifies the target bitrate in bits/sec. The encoder selects an application-specific default when this is not specified.</li>
<li><strong>bufferLength</strong> - (<em>optional</em>) The length of the buffer that the internal JavaScriptNode uses to capture the audio. Can be tweaked if experiencing performance issues. Defaults to <code>4096</code>.</li>
<li><strong>encoderApplication</strong> - (<em>optional</em>) Specifies the encoder application. Supported values are <code>2048</code> - Voice, <code>2049</code> - Full Band Audio, <code>2051</code> - Restricted Low Delay. Defaults to <code>2049</code>.</li>
<li><strong>encoderComplexity</strong> - (<em>optional</em>) Value between 0 and 10 which determines latency and processing for resampling. <code>0</code> is fastest with lowest complexity. <code>10</code> is slowest with highest complexity. The encoder selects a default when this is not specified.</li>
<li><strong>encoderFrameSize</strong> (<em>optional</em>) Specifies the frame size in ms used for encoding. Defaults to <code>20</code>.</li>
<li><strong>encoderPath</strong> - (<em>optional</em>) Path to encoderWorker.min.js worker script. Defaults to <code>encoderWorker.min.js</code></li>
<li><strong>encoderSampleRate</strong> - (<em>optional</em>) Specifies the sample rate to encode at. Defaults to <code>48000</code>. Supported values are <code>8000</code>, <code>12000</code>, <code>16000</code>, <code>24000</code> or <code>48000</code>.</li>
<li><strong>leaveStreamOpen</strong> - (<em>optional</em>) Keep the stream around when trying to <code>stop</code> recording, so you can re-<code>start</code> without re-<code>initStream</code>. Defaults to <code>false</code>.</li>
<li><strong>maxBuffersPerPage</strong> - (<em>optional</em>) Specifies the maximum number of buffers to use before generating an Ogg page. This can be used to lower the streaming latency. The lower the value the more overhead the ogg stream will incur. Defaults to <code>40</code>.</li>
<li><strong>monitorGain</strong> - (<em>optional</em>) Sets the gain of the monitoring output. Gain is an a-weighted value between <code>0</code> and <code>1</code>. Defaults to <code>0</code></li>
<li><strong>numberOfChannels</strong> - (<em>optional</em>) The number of channels to record. <code>1</code> = mono, <code>2</code> = stereo. Defaults to <code>1</code>. Maximum <code>2</code> channels are supported.</li>
<li><strong>originalSampleRateOverride</strong> - (<em>optional</em>) Override the ogg opus ‘input sample rate’ field. Google Speech API requires this field to be <code>16000</code>.</li>
<li><strong>resampleQuality</strong> - (<em>optional</em>) Value between 0 and 10 which determines latency and processing for resampling. <code>0</code> is fastest with lowest quality. <code>10</code> is slowest with highest quality. Defaults to <code>3</code>.</li>
<li><strong>streamPages</strong> - (<em>optional</em>) <code>dataAvailable</code> event will fire after each encoded page. Defaults to <code>false</code>.</li>
</ul>
<p>推荐使用</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot配置文件放在jar外部</title>
    <url>/jadepeng/2017/06/07/jqpeng-Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8jar%E5%A4%96%E9%83%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/6955288.html">Spring Boot配置文件放在jar外部</a></p>
<p>Spring Boot程序默认从application.properties或者application.yaml读取配置，如何将配置信息外置，方便配置呢？</p>
<p>查询官网，可以得到下面的几种方案:</p>
<h2 id="通过命令行指定"><a href="#通过命令行指定" class="headerlink" title="通过命令行指定"></a>通过命令行指定</h2><p>SpringApplication会默认将命令行选项参数转换为配置信息<br> 例如，启动时命令参数指定：</p>
<pre><code>java -jar myproject.jar --server.port = 9000
</code></pre>
<p>从命令行指定配置项的优先级最高，不过你可以通过setAddCommandLineProperties来禁用</p>
<pre><code>SpringApplication.setAddCommandLineProperties(false).
</code></pre>
<h2 id="外置配置文件"><a href="#外置配置文件" class="headerlink" title="外置配置文件"></a>外置配置文件</h2><p>Spring程序会按优先级从下面这些路径来加载application.properties配置文件</p>
<ul>
<li>当前目录下的/config目录</li>
<li>当前目录</li>
<li>classpath里的/config目录</li>
<li>classpath 跟目录</li>
</ul>
<p>因此，要外置配置文件就很简单了，在jar所在目录新建config文件夹，然后放入配置文件，或者直接放在配置文件在jar目录</p>
<h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p>如果你不想使用application.properties作为配置文件，怎么办？完全没问题</p>
<pre><code>java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties
</code></pre>
<p>或者</p>
<pre><code>java -jar -Dspring.config.location=D:\config\config.properties springbootrestdemo-0.0.1-SNAPSHOT.jar 
</code></pre>
<p>当然，还能在代码里指定</p>
<pre><code>@SpringBootApplication
@PropertySource(value=&#123;&quot;file:config.properties&quot;&#125;)
public class SpringbootrestdemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(SpringbootrestdemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<h2 id="按Profile不同环境读取不同配置"><a href="#按Profile不同环境读取不同配置" class="headerlink" title="按Profile不同环境读取不同配置"></a>按Profile不同环境读取不同配置</h2><p>不同环境的配置设置一个配置文件，例如：</p>
<ul>
<li>dev环境下的配置配置在application-dev.properties中；</li>
<li>prod环境下的配置配置在application-prod.properties中。</li>
</ul>
<p>在application.properties中指定使用哪一个文件</p>
<pre><code>spring.profiles.active = dev
</code></pre>
<p>当然，你也可以在运行的时候手动指定：</p>
<pre><code>java -jar myproject.jar --spring.profiles.active = prod
</code></pre>
<p>参考：<br> 1    参见<a href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">Externalized Configuration</a></p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty断线重连</title>
    <url>/jadepeng/2017/06/01/jqpeng-Netty%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/6927387.html">Netty断线重连</a></p>
<h1 id="Netty断线重连"><a href="#Netty断线重连" class="headerlink" title="Netty断线重连"></a>Netty断线重连</h1><p>最近使用Netty开发一个中转服务，需要一直保持与Server端的连接，网络中断后需要可以自动重连，查询官网资料，实现方案很简单，核心思想是在channelUnregistered钩子函数里执行重连。</p>
<h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><p>需要把configureBootstrap重构为一个函数，方便后续复用</p>
<ol>
<li>EventLoopGroup group = new NioEventLoopGroup(); </li>
</ol>
<hr>
<ol start="2">
<li>private volatile Bootstrap bootstrap; </li>
</ol>
<hr>
<ol start="3">
<li><hr>
</li>
<li>public void init(String host, int port) throws RobotException { </li>
</ol>
<hr>
<ol start="5">
<li>this.serverIp = host; </li>
</ol>
<hr>
<ol start="6">
<li>this.serverPort = port; </li>
</ol>
<hr>
<ol start="7">
<li>try { </li>
</ol>
<hr>
<ol start="8">
<li>// 创建并初始化 Netty 客户端 Bootstrap 对象 </li>
</ol>
<hr>
<ol start="9">
<li>bootstrap = configureBootstrap(new Bootstrap(),group); </li>
</ol>
<hr>
<ol start="10">
<li>bootstrap.option(ChannelOption.TCP_NODELAY, true); </li>
</ol>
<hr>
<ol start="11">
<li>doConnect(bootstrap); </li>
</ol>
<hr>
<ol start="12">
<li>} </li>
</ol>
<hr>
<ol start="13">
<li>catch(Exception ex){ </li>
</ol>
<hr>
<ol start="14">
<li>ex.printStackTrace(); </li>
</ol>
<hr>
<ol start="15">
<li>throw new RobotException(“connect remote control server error!”,ex.getCause()); </li>
</ol>
<hr>
<ol start="16">
<li>} </li>
</ol>
<hr>
<ol start="17">
<li>} </li>
</ol>
<hr>
<ol start="18">
<li><hr>
</li>
<li>Bootstrap configureBootstrap(Bootstrap b, EventLoopGroup g) { </li>
</ol>
<hr>
<ol start="20">
<li>b.group(g).channel(NioSocketChannel.class) </li>
</ol>
<hr>
<ol start="21">
<li>.remoteAddress(serverIp, serverPort) </li>
</ol>
<hr>
<ol start="22">
<li>.handler(new ChannelInitializer&lt;SocketChannel&gt;() { </li>
</ol>
<hr>
<ol start="23">
<li>@Override </li>
</ol>
<hr>
<ol start="24">
<li>public void initChannel(SocketChannel channel) throws Exception { </li>
</ol>
<hr>
<ol start="25">
<li>ChannelPipeline pipeline = channel.pipeline(); </li>
</ol>
<hr>
<ol start="26">
<li>// 编解码器 </li>
</ol>
<hr>
<ol start="27">
<li>pipeline.addLast(protoCodec); </li>
</ol>
<hr>
<ol start="28">
<li>// 请求处理 </li>
</ol>
<hr>
<ol start="29">
<li>pipeline.addLast(RobotClient.this); </li>
</ol>
<hr>
<ol start="30">
<li>} </li>
</ol>
<hr>
<ol start="31">
<li>}); </li>
</ol>
<hr>
<ol start="32">
<li><hr>
</li>
<li>return b; </li>
</ol>
<hr>
<ol start="34">
<li>} </li>
</ol>
<hr>
<ol start="35">
<li><hr>
</li>
<li>void doConnect(Bootstrap b) { </li>
</ol>
<hr>
<ol start="37">
<li>try { </li>
</ol>
<hr>
<ol start="38">
<li><hr>
</li>
<li>ChannelFuture future = b.connect(); </li>
</ol>
<hr>
<ol start="40">
<li>future.addListener(new ChannelFutureListener() { </li>
</ol>
<hr>
<ol start="41">
<li>@Override </li>
</ol>
<hr>
<ol start="42">
<li>public void operationComplete(ChannelFuture future) throws Exception { </li>
</ol>
<hr>
<ol start="43">
<li>if (future.isSuccess()) { </li>
</ol>
<hr>
<ol start="44">
<li>System.out.println(“Started Tcp Client: “ + serverIp); </li>
</ol>
<hr>
<ol start="45">
<li>} else { </li>
</ol>
<hr>
<ol start="46">
<li>System.out.println(“Started Tcp Client Failed: “); </li>
</ol>
<hr>
<ol start="47">
<li>} </li>
</ol>
<hr>
<ol start="48">
<li>if (future.cause() != null) { </li>
</ol>
<hr>
<ol start="49">
<li>future.cause().printStackTrace(); </li>
</ol>
<hr>
<ol start="50">
<li>} </li>
</ol>
<hr>
<ol start="51">
<li><hr>
</li>
<li>} </li>
</ol>
<hr>
<ol start="53">
<li>}); </li>
</ol>
<hr>
<ol start="54">
<li>} catch (Exception e) { </li>
</ol>
<hr>
<ol start="55">
<li>e.printStackTrace(); </li>
</ol>
<hr>
<ol start="56">
<li>} </li>
</ol>
<hr>
<ol start="57">
<li>} </li>
</ol>
<hr>
<h2 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h2><p>来看断线重连的关键代码：</p>
<ol>
<li>@ChannelHandler.Sharable </li>
</ol>
<hr>
<ol start="2">
<li>public class RobotClient extends SimpleChannelInboundHandler&lt;RobotProto&gt; { </li>
</ol>
<hr>
<ol start="3">
<li>@Override </li>
</ol>
<hr>
<ol start="4">
<li>public void channelUnregistered(ChannelHandlerContext ctx) throws Exception { </li>
</ol>
<hr>
<ol start="5">
<li>// 状态重置 </li>
</ol>
<hr>
<ol start="6">
<li>isConnected = false; </li>
</ol>
<hr>
<ol start="7">
<li>this.serverStatus = -1; </li>
</ol>
<hr>
<ol start="8">
<li><hr>
</li>
<li>final EventLoop loop = ctx.channel().eventLoop(); </li>
</ol>
<hr>
<ol start="10">
<li>loop.schedule(new Runnable() { </li>
</ol>
<hr>
<ol start="11">
<li>@Override </li>
</ol>
<hr>
<ol start="12">
<li>public void run() { </li>
</ol>
<hr>
<ol start="13">
<li>doConnect(configureBootstrap(new Bootstrap(), loop)); </li>
</ol>
<hr>
<ol start="14">
<li>} </li>
</ol>
<hr>
<ol start="15">
<li>}, 1, TimeUnit.SECONDS); </li>
</ol>
<hr>
<ol start="16">
<li>} </li>
</ol>
<hr>
<ol start="17">
<li>} </li>
</ol>
<hr>
<p>需要注意，Client类需要添加@ChannelHandler.Sharable注解，否则重连时会报错</p>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>高效沟通技巧</title>
    <url>/jadepeng/2017/04/26/jqpeng-%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/effective-commnunication.html">高效沟通技巧</a></p>
<p>高效沟通是工作中的必备技巧，本文为学习总结。</p>
<h2 id="什么是沟通"><a href="#什么是沟通" class="headerlink" title="什么是沟通?"></a>什么是沟通?</h2><ul>
<li>沟通是达成共识，理解一致</li>
<li>沟通 VS. 表达 ： 沟通是双向交流，而表达是单向</li>
<li>沟通关键在于<strong>通</strong>，需要抓住时机<strong>及时沟通到位</strong>，并不是讲过了就通了</li>
</ul>
<h2 id="沟通技巧"><a href="#沟通技巧" class="headerlink" title="沟通技巧"></a>沟通技巧</h2><h3 id="沟通障碍在于认知偏差"><a href="#沟通障碍在于认知偏差" class="headerlink" title="沟通障碍在于认知偏差"></a>沟通障碍在于认知偏差</h3><p>每个人的背景、价值观并不尽相同，对同一个事物的认识会产生较多的偏差，因此这个认知偏差会导致沟通出现障碍。</p>
<p>克服认知偏差小技巧：</p>
<ul>
<li>刚开始不要说定性的结论</li>
<li>及时沟通到位，一次不行，多次沟通</li>
<li>要有为能做好事情<strong>找方法</strong>，而不是为不能做<strong>找理由</strong>!</li>
</ul>
<p>认知偏差通常会由这些原因导致：</p>
<ul>
<li>听不到位</li>
<li>缺乏参与</li>
<li>无效表达</li>
</ul>
<h3 id="聆听技巧"><a href="#聆听技巧" class="headerlink" title="聆听技巧"></a>聆听技巧</h3><p>关注下听的繁体字：<strong>聽</strong></p>
<ul>
<li>十目</li>
<li>一心</li>
<li>一耳</li>
<li>一王</li>
</ul>
<h4 id="聆听小秘诀"><a href="#聆听小秘诀" class="headerlink" title="聆听小秘诀"></a>聆听小秘诀</h4><ul>
<li>理解确认<ul>
<li>用自己的语言<strong>复述</strong>对方所表达的意思</li>
<li>在复述后通过<strong>澄清</strong>与对方确认理解，确认对话说话的目的</li>
</ul>
</li>
<li>回应情绪<ul>
<li>同理心</li>
<li>表示理解</li>
<li>让对方释放情绪</li>
<li>不要一上来就将应该怎么做</li>
</ul>
</li>
</ul>
<p>沟通重在通，是双向的，因此需要提升参与度</p>
<h3 id="提升参与"><a href="#提升参与" class="headerlink" title="提升参与"></a>提升参与</h3><h4 id="沟通三技巧"><a href="#沟通三技巧" class="headerlink" title="沟通三技巧"></a>沟通三技巧</h4><ul>
<li>收集信息、了解真相</li>
<li>澄清疑虑、核对想法</li>
<li>拓展思维，鼓励参与</li>
</ul>
<h4 id="用开放式问题，激发思考"><a href="#用开放式问题，激发思考" class="headerlink" title="用开放式问题，激发思考"></a>用开放式问题，激发思考</h4><ul>
<li>WHAT<ul>
<li>你的建议是什么</li>
<li>有什么困难挑战障碍</li>
</ul>
</li>
<li>WHEN<ul>
<li>你认为什么时候可以完成</li>
</ul>
</li>
<li>WHY<ul>
<li>这样的理由是？</li>
<li>你认为可能是什么原因</li>
</ul>
</li>
<li>WHO<ul>
<li>谁可以帮忙</li>
<li>可以从谁那里获取帮助</li>
</ul>
</li>
<li>HOW<ul>
<li>你打算如何开始</li>
<li>要怎么做才可以</li>
</ul>
</li>
<li>WHERE</li>
</ul>
<h4 id="提问技巧"><a href="#提问技巧" class="headerlink" title="提问技巧"></a>提问技巧</h4><ul>
<li>一次一个问题</li>
<li>保持开放</li>
<li>由广泛到具体</li>
<li>尊重隐私</li>
<li>不带威胁</li>
</ul>
<h2 id="沟通互动流程"><a href="#沟通互动流程" class="headerlink" title="沟通互动流程"></a>沟通互动流程</h2><p>但凡沟通，可以按这个秘籍（套路）来做：</p>
<ol>
<li>定方向<ul>
<li>确定沟通的目的——今天主要是。。。</li>
<li>然后再将讲重要性  ——  有什么重要性</li>
</ul>
</li>
<li>理情况<ul>
<li>摆事实、看数据</li>
<li>问题、疑虑</li>
</ul>
</li>
<li>想方案<ul>
<li>方向</li>
<li>资源</li>
<li>支持</li>
</ul>
</li>
<li>明做法<ul>
<li>行动计划</li>
<li>追踪、应变</li>
</ul>
</li>
<li>做总结<ul>
<li>要点</li>
<li>信心</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex 公式在线可视化编辑器</title>
    <url>/jadepeng/2017/04/21/jqpeng-Latex%20%E5%85%AC%E5%BC%8F%E5%9C%A8%E7%BA%BF%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/latex-editor.html">Latex 公式在线可视化编辑器</a></p>
<h2 id="寻觅"><a href="#寻觅" class="headerlink" title="寻觅"></a>寻觅</h2><p>最近的一个demo需要用到Latex公式在线编辑器，从搜索引擎一般会得到类似<a href="http://latex.codecogs.com/eqneditor/editor.php">http://latex.codecogs.com/eqneditor/editor.php</a>的结果，这个编辑器的问题在于使用成本高，并且界面不美观。<br><img src="https://ooo.0o0.ooo/2017/04/20/58f847b5b0998.jpg" alt="codecogs" title="codecogs"></p>
<p>继续探寻，发现了<a href="http://www.wiris.com/editor/demo/en/examples">wiris Editor</a>：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f8474b37a60.jpg" alt="wiris Editor" title="wiris"></p>
<p>支持mathml和latex：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f847990789b.jpg" alt="wiris Editor" title="mathml和latex"></p>
<p>那么就它了！</p>
<h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>首先，我们不会直接使用这个编辑器，只是在编辑公式的时候才使用，所以要选择合适的版本。<br><img src="https://ooo.0o0.ooo/2017/04/20/58f849cd99f29.jpg" alt="wiris Editor" title="1492666829731"><br> 以前用过CKEditor，所以就这它了！选用<a href="http://www.wiris.com/en/downloads/files/1376/011ckeditor/java-demo_ckeditor_wiris4-4.2.0.1365.zip">java版本</a><br> 我们的数据已经是latex的，在wiris 编辑器显示需要注意latex需要用两个$$包括起来<br> 例如:</p>
<pre><code>The history of $$\sqrt(2)$$.
</code></pre>
<p>但是CK版本的wiris对latex的支持是非可视化支持，在编辑器里输入latex还是显示为latex：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f8490c90a9e.jpg" alt="enter description here" title="1492666637204"></p>
<p>将焦点移动到$$内部，再点击按钮出现wiris的公式编辑器：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/20/58f84a34a07e2.jpg" alt="enter description here" title="1492666933326"><br> 这种设计适合对latex熟悉的人员，可以裸写latex，同时对不熟悉的人来说，可以使用公式编辑器。但是，这样不直观啊！你让不会latex的看到的就一堆符号！</p>
<h2 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h2><p>简单试用可以发现，如果直接使用公式编辑器插入公式，是直观显示的：<br><img src="https://ooo.0o0.ooo/2017/04/20/58f84c7433958.jpg" alt="enter description here" title="1492667508804"></p>
<p>可以看到保存的时候，mathml是：</p>
<pre><code>&lt;math class=&quot;wrs_chemistry&quot; xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msqrt&gt;    &lt;mn&gt;2&lt;/mn&gt;&lt;/msqrt&gt;
&lt;/math&gt;
</code></pre>
<p>那么在latex输入情况下呢：</p>
<pre><code>&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;    &lt;mrow&gt;        &lt;msqrt&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;/msqrt&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;    &lt;/mrow&gt;    &lt;annotation encoding=&quot;LaTeX&quot;&gt;\sqrt(2)&lt;/annotation&gt;&lt;/semantics&gt;
&lt;/math&gt;
</code></pre>
<p>原来问题在这里，正是mathML的区别导致处理的区别。也就是说一开始就生成不带LaTeX的mathML，然后再放入编辑器。简单查看代码，可以知道先调用wrs_endParse，再wrs_initParse就可以了。</p>
<pre><code>CKEDITOR.on(&quot;instanceReady&quot;, function(event)&#123;    CKEDITOR.instances.example.focus();    var mathxml = wrs_endParse(&quot;已知向量$$\\vec&#123;a&#125;=(\\sqrt&#123;3&#125;,2)$$,$$\\vec&#123;b&#125;=(0,-2)$$,向量$$\\vec&#123;c&#125;=(k,\\sqrt&#123;2&#125;)$$.$$\\vec&#123;a&#125;-1\\vec&#123;b&#125;$$与$$\\vec&#123;d&#125;$$共线,$$k=$$__.&quot;);    CKEDITOR.instances.example.setData(wrs_initParse(mathxml));    // 等待完成    window.setTimeout(updateFunction,0);&#125;);
</code></pre>
<p><img src="https://ooo.0o0.ooo/2017/04/21/58f954fc81b80.jpg" alt="Latex" title="Latex可视化"></p>
<p>直观显示没问题了，但是mathml如何再转换成Latex呢？core.js里的wrs_parseMathmlToLatex函数是直接从mathml里将<annotation encoding="LaTeX">。。。</annotation>里的内容提取出来：</p>
<pre><code>function wrs_parseMathmlToLatex(content, characters)&#123;
    ....
    var openTarget = characters.tagOpener + &#39;annotation encoding=&#39; + characters.doubleQuote + &#39;LaTeX&#39; + characters.doubleQuote + characters.tagCloser;
 
        mathml = content.substring(start, end);

        startAnnotation = mathml.indexOf(openTarget);    // 包含 encoding=latex，保留latex
        if (startAnnotation != -1)&#123;
            startAnnotation += openTarget.length;
            closeAnnotation = mathml.indexOf(closeTarget);
            var latex = mathml.substring(startAnnotation, closeAnnotation);
            if (characters == _wrs_safeXmlCharacters) &#123;
                latex = wrs_mathmlDecode(latex);
            &#125;
            output += &#39;$$&#39; + latex + &#39;$$&#39;;
            // Populate latex into cache.
            wrs_populateLatexCache(latex, mathml);
        &#125;else&#123;
            output += mathml;
        &#125;
   ......
&#125;
</code></pre>
<p>但是现在的mathml不包含这个信息，如何处理？查看官方文档，发现有一个mathml2latex的服务，查看官方给的java demo里servlet并不包含这个服务，但是jar包里存在代码，于是自己封装一个servlet即可：</p>
<pre><code>public class ServiceServlet extends com.wiris.plugin.dispatchers.MainServlet &#123;

    @Override
    public void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)
            throws ServletException, IOException &#123;
        PluginBuilder pb = newPluginBuilder(request);
        String origin = request.getHeader(&quot;origin&quot;);
        HttpResponse res = new HttpResponse(response);
        pb.addCorsHeaders(res, origin);
        String pathInfo = request.getServletPath();
        if (pathInfo.equals(&quot;/mathml2latex&quot;)) &#123;
            response.setContentType(&quot;text/plain; charset=utf-8&quot;);
            ParamsProvider provider = pb.getCustomParamsProvider();
            String mml = provider.getParameter(&quot;mml&quot;, (String)null);
            String r = pb.newTextService().mathml2latex(mml);
            PrintWriter out = response.getWriter();
            out.print(r);
            out.close();
        &#125;
</code></pre>
<p>js里，调用这个服务：</p>
<pre><code>var _wrs_mathmlCache = &#123;&#125;;
function wrs_getLatexFromMathML(mml) &#123;
    if (_wrs_mathmlCache.hasOwnProperty(mml)) &#123;
        return _wrs_mathmlCache[mml];
    &#125;
    var data = &#123;
        &#39;service&#39;: &#39;mathml2latex&#39;,
        &#39;mml&#39;: mml
    &#125;;

    var latex = wrs_getContent(_wrs_conf_servicePath, data);
    // Populate LatexCache.
    if (!_wrs_mathmlCache.hasOwnProperty(mml)) &#123;
        _wrs_mathmlCache[mml] = latex;
    &#125;
    return latex.split(&quot;\r&quot;).join(&#39;&#39;).split(&quot;\n&quot;).join(&#39; &#39;);
&#125;
</code></pre>
<p>wrs_getLatexFromMathML只能将一个mathml转换为latex，对于编辑器里的内容来说，需要将mathML抽取出来逐一转换：</p>
<pre><code>function wrs_parseRawMathmlToLatex(content, characters)&#123;
    var output = &#39;&#39;;
    var mathTagBegin = characters.tagOpener + &#39;math&#39;;
    var mathTagEnd = characters.tagOpener + &#39;/math&#39; + characters.tagCloser;
    var start = content.indexOf(mathTagBegin);
    var end = 0;
    var mathml, startAnnotation, closeAnnotation;

    while (start != -1) &#123;
        output += content.substring(end, start);
        end = content.indexOf(mathTagEnd, start);

        if (end == -1) &#123;
            end = content.length - 1;
        &#125;
        else &#123;
            end += mathTagEnd.length;
        &#125;

        mathml = content.substring(start, end);

        output += wrs_getLatexFromMathML(mathml);

        start = content.indexOf(mathTagBegin, end);
    &#125;

    output += content.substring(end, content.length);
    return output;
&#125;
function wrs_getLatex(code) &#123;
    return wrs_parseRawMathmlToLatex(code, _wrs_xmlCharacters);
&#125;
</code></pre>
<p>末了，为了方便获取，可以将latex放到_current_latex变量里：</p>
<pre><code>    // 获取数据editor.on(&#39;getData&#39;, function (e) &#123;    e.data.dataValue = wrs_endParse(e.data.dataValue || &quot;&quot;);    _current_latex = wrs_getLatex(e.data.dataValue || &quot;&quot;);&#125;);
</code></pre>
<p>再简单修改下网页，显示latex：<br><img src="https://ooo.0o0.ooo/2017/04/21/58f9588ca5b8f.jpg" alt="enter description here" title="获取Latex"></p>
<p>收官!</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC框架原理与实现</title>
    <url>/jadepeng/2017/04/13/jqpeng-RPC%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/java-rpc.html">RPC框架原理与实现</a></p>
<p>RPC，全称 Remote Procedure Call（远程过程调用），即调用远程计算机上的服务，就像调用本地服务一样。那么RPC的原理是什么呢？了解一个技术最好的思路就是寻找一个该类型麻雀虽小五脏俱全的开源项目，不负所期，找到一个<a href="http://git.oschina.net/huangyong/rpc">轻量级分布式 RPC 框架</a>，本文从这个项目入手来解读RPC的原理及其实现。</p>
<p>其实说到RPC，大家应该不会陌生才是，以往流行的Web Service就是一种RPC，一般来说RPC 可基于 HTTP 或 TCP 协议，因为Web Service 基于HTTP，所以具有良好的跨平台性，但由于HTTP是应用层协议，相比TCP性能有所损耗。</p>
<p>与本地调用不一样，远程调用需要通过网络层传输，因此涉及到的一个问题就是序列化，不同的序列化方式影响调用性能，流行的序列化包括Protobuf、Kryo、Hessian、Jackson、Thrift。</p>
<p>下面，让我们来一关如何从零开始实现分布式RPC框架。</p>
<h2 id="RPC框架组件"><a href="#RPC框架组件" class="headerlink" title="RPC框架组件"></a>RPC框架组件</h2><p>建设一个框架，一个系统，首先要做的就是分析需要哪些组件，他们的关系是什么？</p>
<p>简单分析下，一个RPC框架需要包括：</p>
<ul>
<li>APP ：应用端，调用服务</li>
<li>Server 服务容器，对外提供服务</li>
<li>Service Registry 服务注册表</li>
</ul>
<blockquote>
<p>我们需要将服务部署在分布式环境下的不同节点上，通过服务注册的方式，让客户端来自动发现当前可用的服务，并调用这些服务。这需要一种服务注册表（Service Registry）的组件，让它来注册分布式环境下所有的服务地址（包括：主机名与端口号）。</p>
</blockquote>
<p><img src="https://ooo.0o0.ooo/2017/04/13/58ef302271951.jpg" alt="RPC框架图" title="RPC"><br> 每台 Server 上可发布多个 Service，这些 Service 共用一个 host 与 port，在分布式环境下会提供 Server 共同对外提供 Service。此外，为防止 Service Registry 出现单点故障，因此需要将其搭建为集群环境。</p>
<h2 id="RPC框架实现"><a href="#RPC框架实现" class="headerlink" title="RPC框架实现"></a>RPC框架实现</h2><h3 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h3><p>首先定义服务接口，接口可以单独放在一个jar包中</p>
<pre><code>public interface HelloService &#123;
String hello(String name);
String hello(Person person);
&#125;
</code></pre>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>然后，增加一种实现</p>
<pre><code>@RpcService(HelloService.class)
public class HelloServiceImpl implements HelloService &#123;

    @Override
    public String hello(String name) &#123;
        return &quot;Hello! &quot; + name;
    &#125;

    @Override
    public String hello(Person person) &#123;
        return &quot;Hello! &quot; + person.getFirstName() + &quot; &quot; + person.getLastName();
    &#125;
&#125;
</code></pre>
<p>这里的RpcService注解，定义在服务接口的实现类上，可以让框架通过这个注解找到服务实现类。</p>
<p>更进一步，如果哪天服务版本升级了，但是历史服务还有人在使用，怎么办？解决方案就是服务需要分版本，按版本调用。</p>
<pre><code>@RpcService(value = HelloService.class, version = &quot;sample.hello2&quot;)
public class HelloServiceImpl2 implements HelloService &#123;

    @Override
    public String hello(String name) &#123;
        return &quot;你好! &quot; + name;
    &#125;

    @Override
    public String hello(Person person) &#123;
        return &quot;你好! &quot; + person.getFirstName() + &quot; &quot; + person.getLastName();
    &#125;
&#125;
</code></pre>
<p>再来看下 RPC 服务注解</p>
<pre><code>/**
 * RPC 服务注解（标注在服务实现类上）
 */
@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface RpcService &#123;

    /**
     * 服务接口类
     */
    Class&lt;?&gt; value();

    /**
     * 服务版本号
     */
    String version() default &quot;&quot;;
&#125;
</code></pre>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><p>Server端主要基于Netty（一个NIO框架）+Spring</p>
<p>回到开头讲的，RPC关键点之一就是传输序列化，简单来说就是客户端调用service时，需要构建一个请求，然后将这个请求序列化传输到服务端，服务端完成调用后，再将结果 序列化后返回，简单画一下：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/13/58ef300978eca.jpg" alt="RPC请求" title="RPC"></p>
<h4 id="定义Request"><a href="#定义Request" class="headerlink" title="定义Request"></a>定义Request</h4><pre><code>public class RpcRequest &#123;

    private String requestId;
    private String interfaceName;
    private String serviceVersion;
    private String methodName;
    private Class&lt;?&gt;[] parameterTypes;
    private Object[] parameters;

&#125;
</code></pre>
<h4 id="定义RpcResponse"><a href="#定义RpcResponse" class="headerlink" title="定义RpcResponse"></a>定义RpcResponse</h4><pre><code>public class RpcResponse &#123;

    private String requestId;
    private Exception exception;
    private Object result;

&#125;
</code></pre>
<h4 id="Encoder与Decoder"><a href="#Encoder与Decoder" class="headerlink" title="Encoder与Decoder"></a>Encoder与Decoder</h4><p>因为项目基于Netty，所以按Netty那一套搞就行，核心是SerializationUtil，这个根据需要可以采用不同的序列化框架，比如pb。</p>
<pre><code>public class RpcEncoder extends MessageToByteEncoder &#123;

    private Class&lt;?&gt; genericClass;

    public RpcEncoder(Class&lt;?&gt; genericClass) &#123;
        this.genericClass = genericClass;
    &#125;

    @Override
    public void encode(ChannelHandlerContext ctx, Object in, ByteBuf out) throws Exception &#123;
        if (genericClass.isInstance(in)) &#123;
            byte[] data = SerializationUtil.serialize(in);
            out.writeInt(data.length);
            out.writeBytes(data);
        &#125;
    &#125;
&#125;



public class RpcDecoder extends ByteToMessageDecoder &#123;

    private Class&lt;?&gt; genericClass;

    public RpcDecoder(Class&lt;?&gt; genericClass) &#123;
        this.genericClass = genericClass;
    &#125;

    @Override
    public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;
        if (in.readableBytes() &lt; 4) &#123;
            return;
        &#125;
        in.markReaderIndex();
        int dataLength = in.readInt();
        if (in.readableBytes() &lt; dataLength) &#123;
            in.resetReaderIndex();
            return;
        &#125;
        byte[] data = new byte[dataLength];
        in.readBytes(data);
        out.add(SerializationUtil.deserialize(data, genericClass));
    &#125;
&#125;
</code></pre>
<h4 id="扫描服务"><a href="#扫描服务" class="headerlink" title="扫描服务"></a>扫描服务</h4><p>服务端采用Spring，并且服务加了RpcService注解，所以服务器启动的时候扫描一下带RpcService的就行</p>
<p>下面的代码实现了将服务找出来，并放到handlerMap里，这样，调用服务的时候就可以根据服务名称从Map里找到服务对象，知道了服务对象和服务方法，就能直接调用了。</p>
<pre><code>    private Map&lt;String, Object&gt; handlerMap = new HashMap&lt;&gt;();

    public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123;
        // 扫描带有 RpcService 注解的类并初始化 handlerMap 对象
        Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(RpcService.class);
        if (MapUtils.isNotEmpty(serviceBeanMap)) &#123;
            for (Object serviceBean : serviceBeanMap.values()) &#123;
                RpcService rpcService = serviceBean.getClass().getAnnotation(RpcService.class);
                String serviceName = rpcService.value().getName();
                String serviceVersion = rpcService.version();
                if (StringUtil.isNotEmpty(serviceVersion)) &#123;
                    serviceName += &quot;-&quot; + serviceVersion;
                &#125;
                handlerMap.put(serviceName, serviceBean);
            &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h4><p>按照Netty服务器标准代码，启动服务，注意Encoder和Decoder</p>
<pre><code> @Override
    public void afterPropertiesSet() throws Exception &#123;
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try &#123;
            // 创建并初始化 Netty 服务端 Bootstrap 对象
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup);
            bootstrap.channel(NioServerSocketChannel.class);
            bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                public void initChannel(SocketChannel channel) throws Exception &#123;
                    ChannelPipeline pipeline = channel.pipeline();
                    pipeline.addLast(new RpcDecoder(RpcRequest.class)); // 解码 RPC 请求
                    pipeline.addLast(new RpcEncoder(RpcResponse.class)); // 编码 RPC 响应
                    pipeline.addLast(new RpcServerHandler(handlerMap)); // 处理 RPC 请求
                &#125;
            &#125;);
            bootstrap.option(ChannelOption.SO_BACKLOG, 1024);
            bootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);
            // 获取 RPC 服务器的 IP 地址与端口号
            String[] addressArray = StringUtil.split(serviceAddress, &quot;:&quot;);
            String ip = addressArray[0];
            int port = Integer.parseInt(addressArray[1]);
            // 启动 RPC 服务器
            ChannelFuture future = bootstrap.bind(ip, port).sync();
            // 注册 RPC 服务地址
            if (serviceRegistry != null) &#123;
                for (String interfaceName : handlerMap.keySet()) &#123;
                    serviceRegistry.register(interfaceName, serviceAddress);
                    LOGGER.debug(&quot;register service: &#123;&#125; =&gt; &#123;&#125;&quot;, interfaceName, serviceAddress);
                &#125;
            &#125;
            LOGGER.debug(&quot;server started on port &#123;&#125;&quot;, port);
            // 关闭 RPC 服务器
            future.channel().closeFuture().sync();
        &#125; finally &#123;
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        &#125;
    &#125;
</code></pre>
<h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>RpcServerHandler负责处理请求，熟悉Netty的应该知道，继承SimpleChannelInboundHandler，在channelRead0函数里处理即可，注意，因为pipline里前面已经解码为RpcRequest对象了，所以在这里可以直接使用。</p>
<pre><code>    public class RpcServerHandler extends SimpleChannelInboundHandler&lt;RpcRequest&gt; &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcServerHandler.class);

    private final Map&lt;String, Object&gt; handlerMap;

    public RpcServerHandler(Map&lt;String, Object&gt; handlerMap) &#123;
        this.handlerMap = handlerMap;
    &#125;

    @Override
    public void channelRead0(final ChannelHandlerContext ctx, RpcRequest request) throws Exception &#123;
        // 创建并初始化 RPC 响应对象
        RpcResponse response = new RpcResponse();
        response.setRequestId(request.getRequestId());
        try &#123;
            Object result = handle(request);
            response.setResult(result);
        &#125; catch (Exception e) &#123;
            LOGGER.error(&quot;handle result failure&quot;, e);
            response.setException(e);
        &#125;
        // 写入 RPC 响应对象并自动关闭连接
        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
    &#125;
&#125;
</code></pre>
<p>框架没什么说的，核心是怎么handle，无非就是从Reques里获取到服务名称和版本号，然后从handlerMap里寻找服务对象，然后调用方法。</p>
<blockquote>
<p>已知方法名和Class，可以通过反射进行调用，但是反射性能较低，可以使用cglib里的FastClass来执行invoke，详情参见<a href="http://blog.jobbole.com/105423/">说说 cglib 动态代理</a></p>
</blockquote>
<pre><code>    private Object handle(RpcRequest request) throws Exception &#123;
        // 获取服务对象
        String serviceName = request.getInterfaceName();
        String serviceVersion = request.getServiceVersion();
        if (StringUtil.isNotEmpty(serviceVersion)) &#123;
            serviceName += &quot;-&quot; + serviceVersion;
        &#125;
        Object serviceBean = handlerMap.get(serviceName);
        if (serviceBean == null) &#123;
            throw new RuntimeException(String.format(&quot;can not find service bean by key: %s&quot;, serviceName));
        &#125;
        // 获取反射调用所需的参数
        Class&lt;?&gt; serviceClass = serviceBean.getClass();
        String methodName = request.getMethodName();
        Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();
        Object[] parameters = request.getParameters();
        // 执行反射调用
//        Method method = serviceClass.getMethod(methodName, parameterTypes);
//        method.setAccessible(true);
//        return method.invoke(serviceBean, parameters);
        // 使用 CGLib 执行反射调用
        FastClass serviceFastClass = FastClass.create(serviceClass);
        FastMethod serviceFastMethod = serviceFastClass.getMethod(methodName, parameterTypes);
        return serviceFastMethod.invoke(serviceBean, parameters);
    &#125;
</code></pre>
<h4 id="服务发现与注册"><a href="#服务发现与注册" class="headerlink" title="服务发现与注册"></a>服务发现与注册</h4><p>在分布式系统里，服务的自动发现与注册是标配功能，一般来说都是使用集中配置中心，开源届有Zookeeper、etcd等实现。这里，使用zk作为配置中心。</p>
<p>服务发现与注册的核心是，服务启动时，将服务名称和服务地址写入到配置中心，客户端调用的时候，先从集中配置中心读取所要调用服务的服务器地址，如果有多个，随机挑选一个（当然随机的话会存在负载不均衡问题），连接服务器并调用。</p>
<blockquote>
<p>个人认为较好的实现方式是，服务层面加一个HA层，客户端直接调用HA，HA负责负载Service。</p>
</blockquote>
<p>回到代码解读，这里使用的zookeeper，我们来看怎么实现。</p>
<p>先是定义接口：</p>
<pre><code>public interface ServiceRegistry &#123;

    /**
     * 注册服务名称与服务地址
     *
     * @param serviceName    服务名称
     * @param serviceAddress 服务地址
     */
    void register(String serviceName, String serviceAddress);
&#125;

public interface ServiceDiscovery &#123;

    /**
     * 根据服务名称查找服务地址
     *
     * @param serviceName 服务名称
     * @return 服务地址
     */
    String discover(String serviceName);
&#125;
</code></pre>
<p>再看谈实现，zk有两种类型的节点，永久节点和临时节点，这种特性非常适合做服务发现与注册。<br> 试想：</p>
<ul>
<li>新启动一台Server，自动注册到ZK，写一个临时节点，客户端调用的时候就能读取到这个节点</li>
<li>一台Server挂了，临时节点失效，客户端调用的时候就读取不到这个节点，自然不会调用</li>
<li>当服务调用量太大，可以新启动服务，服务小的时候再停掉</li>
</ul>
<p>不再赘述，看代码：</p>
<pre><code>public class ZooKeeperServiceRegistry implements ServiceRegistry &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(ZooKeeperServiceRegistry.class);

    private final ZkClient zkClient;

    public ZooKeeperServiceRegistry(String zkAddress) &#123;
        // 创建 ZooKeeper 客户端
        zkClient = new ZkClient(zkAddress, Constant.ZK_SESSION_TIMEOUT, Constant.ZK_CONNECTION_TIMEOUT);
        LOGGER.debug(&quot;connect zookeeper&quot;);
    &#125;

    @Override
    public void register(String serviceName, String serviceAddress) &#123;
        // 创建 registry 节点（持久）
        String registryPath = Constant.ZK_REGISTRY_PATH;
        if (!zkClient.exists(registryPath)) &#123;
            zkClient.createPersistent(registryPath);
            LOGGER.debug(&quot;create registry node: &#123;&#125;&quot;, registryPath);
        &#125;
        // 创建 service 节点（持久）
        String servicePath = registryPath + &quot;/&quot; + serviceName;
        if (!zkClient.exists(servicePath)) &#123;
            zkClient.createPersistent(servicePath);
            LOGGER.debug(&quot;create service node: &#123;&#125;&quot;, servicePath);
        &#125;
        // 创建 address 节点（临时）
        String addressPath = servicePath + &quot;/address-&quot;;
        String addressNode = zkClient.createEphemeralSequential(addressPath, serviceAddress);
        LOGGER.debug(&quot;create address node: &#123;&#125;&quot;, addressNode);
    &#125;
&#125;
</code></pre>
<p>原理就是创建了一个临时节点存储服务地址</p>
<p>再来看服务发现：</p>
<pre><code>public class ZooKeeperServiceDiscovery implements ServiceDiscovery &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(ZooKeeperServiceDiscovery.class);

    private String zkAddress;

    public ZooKeeperServiceDiscovery(String zkAddress) &#123;
        this.zkAddress = zkAddress;
    &#125;

    @Override
    public String discover(String name) &#123;
        // 创建 ZooKeeper 客户端
        ZkClient zkClient = new ZkClient(zkAddress, Constant.ZK_SESSION_TIMEOUT, Constant.ZK_CONNECTION_TIMEOUT);
        LOGGER.debug(&quot;connect zookeeper&quot;);
        try &#123;
            // 获取 service 节点
            String servicePath = Constant.ZK_REGISTRY_PATH + &quot;/&quot; + name;
            if (!zkClient.exists(servicePath)) &#123;
                throw new RuntimeException(String.format(&quot;can not find any service node on path: %s&quot;, servicePath));
            &#125;
            List&lt;String&gt; addressList = zkClient.getChildren(servicePath);
            if (CollectionUtil.isEmpty(addressList)) &#123;
                throw new RuntimeException(String.format(&quot;can not find any address node on path: %s&quot;, servicePath));
            &#125;
            // 获取 address 节点
            String address;
            int size = addressList.size();
            if (size == 1) &#123;
                // 若只有一个地址，则获取该地址
                address = addressList.get(0);
                LOGGER.debug(&quot;get only address node: &#123;&#125;&quot;, address);
            &#125; else &#123;
                // 若存在多个地址，则随机获取一个地址
                address = addressList.get(ThreadLocalRandom.current().nextInt(size));
                LOGGER.debug(&quot;get random address node: &#123;&#125;&quot;, address);
            &#125;
            // 获取 address 节点的值
            String addressPath = servicePath + &quot;/&quot; + address;
            return zkClient.readData(addressPath);
        &#125; finally &#123;
            zkClient.close();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><h4 id="服务代理"><a href="#服务代理" class="headerlink" title="服务代理"></a>服务代理</h4><p>可以先查看(<a href="http://www.cnblogs.com/xiaoqi/p/java-proxy.html">http://www.cnblogs.com/xiaoqi/p/java-proxy.html</a>)了解java的动态代理。</p>
<p>使用 Java 提供的动态代理技术实现 RPC 代理（当然也可以使用 CGLib 来实现），具体代码如下：</p>
<pre><code>public class RpcProxy &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcProxy.class);

    private String serviceAddress;

    private ServiceDiscovery serviceDiscovery;

    public RpcProxy(String serviceAddress) &#123;
        this.serviceAddress = serviceAddress;
    &#125;

    public RpcProxy(ServiceDiscovery serviceDiscovery) &#123;
        this.serviceDiscovery = serviceDiscovery;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T create(final Class&lt;?&gt; interfaceClass) &#123;
        return create(interfaceClass, &quot;&quot;);
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T create(final Class&lt;?&gt; interfaceClass, final String serviceVersion) &#123;
        // 创建动态代理对象
        return (T) Proxy.newProxyInstance(
                interfaceClass.getClassLoader(),
                new Class&lt;?&gt;[]&#123;interfaceClass&#125;,
                new InvocationHandler() &#123;
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
                        // 创建 RPC 请求对象并设置请求属性
                        RpcRequest request = new RpcRequest();
                        request.setRequestId(UUID.randomUUID().toString());
                        request.setInterfaceName(method.getDeclaringClass().getName());
                        request.setServiceVersion(serviceVersion);
                        request.setMethodName(method.getName());
                        request.setParameterTypes(method.getParameterTypes());
                        request.setParameters(args);
                        // 获取 RPC 服务地址
                        if (serviceDiscovery != null) &#123;
                            String serviceName = interfaceClass.getName();
                            if (StringUtil.isNotEmpty(serviceVersion)) &#123;
                                serviceName += &quot;-&quot; + serviceVersion;
                            &#125;
                            serviceAddress = serviceDiscovery.discover(serviceName);
                            LOGGER.debug(&quot;discover service: &#123;&#125; =&gt; &#123;&#125;&quot;, serviceName, serviceAddress);
                        &#125;
                        if (StringUtil.isEmpty(serviceAddress)) &#123;
                            throw new RuntimeException(&quot;server address is empty&quot;);
                        &#125;
                        // 从 RPC 服务地址中解析主机名与端口号
                        String[] array = StringUtil.split(serviceAddress, &quot;:&quot;);
                        String host = array[0];
                        int port = Integer.parseInt(array[1]);
                        // 创建 RPC 客户端对象并发送 RPC 请求
                        RpcClient client = new RpcClient(host, port);
                        long time = System.currentTimeMillis();
                        RpcResponse response = client.send(request);
                        LOGGER.debug(&quot;time: &#123;&#125;ms&quot;, System.currentTimeMillis() - time);
                        if (response == null) &#123;
                            throw new RuntimeException(&quot;response is null&quot;);
                        &#125;
                        // 返回 RPC 响应结果
                        if (response.hasException()) &#123;
                            throw response.getException();
                        &#125; else &#123;
                            return response.getResult();
                        &#125;
                    &#125;
                &#125;
        );
    &#125;
&#125;
</code></pre>
<h4 id="RPC客户端"><a href="#RPC客户端" class="headerlink" title="RPC客户端"></a>RPC客户端</h4><p>使用RpcClient类实现 RPC 客户端，只需扩展 Netty 提供的SimpleChannelInboundHandler抽象类即可，代码如下：</p>
<pre><code>public class RpcClient extends SimpleChannelInboundHandler&lt;RpcResponse&gt; &#123;

    private static final Logger LOGGER = LoggerFactory.getLogger(RpcClient.class);

    private final String host;
    private final int port;

    private RpcResponse response;

    public RpcClient(String host, int port) &#123;
        this.host = host;
        this.port = port;
    &#125;

    @Override
    public void channelRead0(ChannelHandlerContext ctx, RpcResponse response) throws Exception &#123;
        this.response = response;
    &#125;

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        LOGGER.error(&quot;api caught exception&quot;, cause);
        ctx.close();
    &#125;

    public RpcResponse send(RpcRequest request) throws Exception &#123;
        EventLoopGroup group = new NioEventLoopGroup();
        try &#123;
            // 创建并初始化 Netty 客户端 Bootstrap 对象
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(group);
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                public void initChannel(SocketChannel channel) throws Exception &#123;
                    ChannelPipeline pipeline = channel.pipeline();
                    pipeline.addLast(new RpcEncoder(RpcRequest.class)); // 编码 RPC 请求
                    pipeline.addLast(new RpcDecoder(RpcResponse.class)); // 解码 RPC 响应
                    pipeline.addLast(RpcClient.this); // 处理 RPC 响应
                &#125;
            &#125;);
            bootstrap.option(ChannelOption.TCP_NODELAY, true);
            // 连接 RPC 服务器
            ChannelFuture future = bootstrap.connect(host, port).sync();
            // 写入 RPC 请求数据并关闭连接
            Channel channel = future.channel();
            channel.writeAndFlush(request).sync();
            channel.closeFuture().sync();
            // 返回 RPC 响应对象
            return response;
        &#125; finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="服务测试"><a href="#服务测试" class="headerlink" title="服务测试"></a>服务测试</h4><pre><code>public class HelloClient &#123;

    public static void main(String[] args) throws Exception &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
        RpcProxy rpcProxy = context.getBean(RpcProxy.class);

        HelloService helloService = rpcProxy.create(HelloService.class);
        String result = helloService.hello(&quot;World&quot;);
        System.out.println(result);

        HelloService helloService2 = rpcProxy.create(HelloService.class, &quot;sample.hello2&quot;);
        String result2 = helloService2.hello(&quot;世界&quot;);
        System.out.println(result2);

        System.exit(0);
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<pre><code>connect zookeeper
get only address node: address-0000000001
discover service: com.xxx.rpc.sample.api.HelloService =&gt; 127.0.0.1:8000
time: 569ms
Hello! World
connect zookeeper
get only address node: address-0000000001
discover service: com.xxx.rpc.sample.api.HelloService-sample.hello2 =&gt; 127.0.0.1:8000
time: 36ms
你好! 世界
</code></pre>
<hr>
<blockquote>
<p>作者：Jadepeng<br> 出处：jqpeng的技术记事本–<a href="http://www.cnblogs.com/xiaoqi">http://www.cnblogs.com/xiaoqi</a><br> 您的支持是对博主最大的鼓励，感谢您的认真阅读。<br> 本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>java</tag>
        <tag>netty</tag>
        <tag>rpc框架</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员主管之路（1）</title>
    <url>/jadepeng/2017/03/22/jqpeng-%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%BB%E7%AE%A1%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/6599956.html">程序员主管之路（1）</a></p>
<p>作为码农，技术出生，随着能力的被认可，会逐步承担管理角色，但是在担任主管尝尝会遇到不少挑战，如何快速从一名个人贡献者转变为一名合格的团队领导，完成职责的华丽转身。</p>
<p>目录</p>
<ul>
<li>领导转型<ul>
<li>工作理念</li>
<li>时间管理</li>
<li>目标分解</li>
<li>团队成果仪表盘</li>
</ul>
</li>
<li>成功领导三要素<ul>
<li>1、言行一致</li>
<li>2、启导他人</li>
<li>3、拥抱反馈</li>
</ul>
</li>
<li>规划团队行事历</li>
</ul>
<h2 id="领导转型"><a href="#领导转型" class="headerlink" title="领导转型"></a>领导转型</h2><p>个人贡献者与领导者有什么不同呢？</p>
<h3 id="工作理念"><a href="#工作理念" class="headerlink" title="工作理念"></a>工作理念</h3><p>一人吃饱 VS 全家温暖<br> 需要树立起对团队负责的思想，关注团队的目标、绩效，关心员工的诉求，为员工争取利益，承担对应的风险与责任，当然你的收获也更多。</p>
<h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>转岗团队领导后，你不仅需要承担原有的技术攻关工作，还需要承担团队的管理工作，有没有手忙脚乱，忙了一天也没有一个重点？试着列出自己每天的所有工作，看看时间都花在哪儿了？</p>
<blockquote>
<p>列出目前工作中最重要的三项目标或者任务，这就是你目前的<strong>重中之重</strong>，你需要花费足够多的时间在重点工作上面，以确保目标达成。如果你每天的工作大部分都不在重点工作上面，那么你需要及时调整你的工作日程！</p>
</blockquote>
<h3 id="目标分解"><a href="#目标分解" class="headerlink" title="目标分解"></a>目标分解</h3><p>有了重点工作计划，需要尝试把工作目标进行分解，根据工作内容，可以有不同的分解方法：</p>
<ul>
<li><p><strong>线性分解法</strong>，例如</p>
<ul>
<li>1季度完成营业额XX万</li>
<li>2季度完成营业额XX万</li>
</ul>
</li>
<li><p><strong>里程碑</strong></p>
<ul>
<li>04/30 提出新产品组合</li>
<li>07/31 完成试销</li>
</ul>
</li>
<li><p><strong>关键要素法</strong></p>
<ul>
<li>04/30 完成XXX</li>
</ul>
</li>
</ul>
<h3 id="团队成果仪表盘"><a href="#团队成果仪表盘" class="headerlink" title="团队成果仪表盘"></a>团队成果仪表盘</h3><p>有了目标，并进行了合适的分解，可以接着使用<strong>团队成果仪表盘</strong>来进行跟踪：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>达标率</th>
<th>目标</th>
<th>关键里程碑</th>
<th>灯号</th>
<th>进度/状况说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>50%</td>
<td>完成丁克玉组的解题demo开发</td>
<td>3月23日完成demo</td>
<td>:—–:</td>
<td>————:</td>
</tr>
</tbody></table>
<p>使用<strong>团队成果仪表盘</strong>，有什么好处呢？</p>
<ul>
<li>判断重点任务，调整工作优先级</li>
<li>自我加压，追求卓越</li>
</ul>
<h2 id="成功领导三要素"><a href="#成功领导三要素" class="headerlink" title="成功领导三要素"></a>成功领导三要素</h2><p>好的团队领导需要与团队建立起信任，而建立信任有三个关键要素：</p>
<h3 id="1、言行一致"><a href="#1、言行一致" class="headerlink" title="1、言行一致"></a>1、言行一致</h3><p>言行一致的表现：</p>
<ul>
<li>表里如一</li>
<li>所言即所行</li>
<li>不会人前一套人后一套</li>
</ul>
<p>为什么需要言行一致？</p>
<ul>
<li>能促进人与人之间的互信</li>
<li>树立良好个人品牌</li>
</ul>
<h3 id="2、启导他人"><a href="#2、启导他人" class="headerlink" title="2、启导他人"></a>2、启导他人</h3><p>启导他人就是培养团队成员，提升他们的技能，因此，需要了解团队每个人的知识能力、经验、人格特质，我们可以通过<strong>团队成员能力评估表</strong>来对成员进行评估</p>
<table>
<thead>
<tr>
<th>能力</th>
<th>员工1</th>
<th>员工2</th>
</tr>
</thead>
<tbody><tr>
<td>专业能力</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>沟通协调</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>团队合作</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>决策能力</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>计划组织</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>质量导向</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>客户导向</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>持续学习</td>
<td>4</td>
<td>4</td>
</tr>
</tbody></table>
<p>评估后选择员工的薄弱环节，有针对性的进行辅导。</p>
<h3 id="3、拥抱反馈"><a href="#3、拥抱反馈" class="headerlink" title="3、拥抱反馈"></a>3、拥抱反馈</h3><p>为什么需要收集反馈？——了解员工心目中真实的自己，做更好的领导</p>
<p>如何拥抱反馈？</p>
<ul>
<li>表现谦虚的态度</li>
<li>主动寻求他人反馈</li>
<li>接纳改善反馈</li>
<li>感谢反馈</li>
</ul>
<h2 id="规划团队行事历"><a href="#规划团队行事历" class="headerlink" title="规划团队行事历"></a>规划团队行事历</h2><p>何为行事历？就是按周、月把需要例行的事情，规划的里程碑等放在日历里，这样月度、年度重点工作一目了然，便于团队拥有共同的目标。</p>
<p>为什么需要建立行事历</p>
<ul>
<li>了解重要的例行事情，做好事先规划</li>
<li>工作了然于胸，避免重要事情遗漏</li>
<li>考核督促团队，达成目标</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown 常用语法教程</title>
    <url>/jadepeng/2017/03/18/jqpeng-MarkDown%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/6576517.html">MarkDown 常用语法教程</a></p>
<h1 id="MarkDown-语法说明"><a href="#MarkDown-语法说明" class="headerlink" title="MarkDown 语法说明"></a>MarkDown 语法说明</h1><p>目录</p>
<ul>
<li>MarkDown 语法说明<ul>
<li>标题</li>
<li>列表<ul>
<li>无序列表</li>
<li>有序列表</li>
</ul>
</li>
<li>引用</li>
<li>图片与链接</li>
<li>粗体与斜体</li>
<li>表格</li>
<li>插入代码</li>
<li>分割线</li>
</ul>
</li>
</ul>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code>标题1
======

标题2
-----

## 大标题
### 小标题 
#### 小标题 
</code></pre>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code>+ 列表文本前使用 [减号+空格]
* 列表文本前使用 [加号+空格]
- 列表文本前使用 [星号+空格]
</code></pre>
<ul>
<li>列表文本前使用 [减号+空格]</li>
</ul>
<ul>
<li>列表文本前使用 [加号+空格]</li>
</ul>
<ul>
<li>列表文本前使用 [星号+空格]</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code>1. 列表前使用 [数字+空格]
2. 我们会自动帮你添加数字
7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3
</code></pre>
<ol>
<li>列表前使用 [数字+空格]</li>
<li>我们会自动帮你添加数字</li>
<li>不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><pre><code>&gt; 引用文本前使用 [大于号+空格]
&gt; 折行可以不加，新起一行都要加上哦
</code></pre>
<blockquote>
<p>引用文本前使用 [大于号+空格]</p>
</blockquote>
<h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><p>插入链接与插入图片的语法很像，区别在一个 !号</p>
<pre><code>图片为：![]()
链接为：[]()
</code></pre>
<p>插入链接：</p>
<p><a href="http://baidu.com/">Baidu</a></p>
<p>图片：<br><img src="http://ww2.sinaimg.cn/large/6aee7dbbgw1efffa67voyj20ix0ctq3n.jpg" alt="图片提示"></p>
<h2 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h2><pre><code>**两个为粗体**
</code></pre>
<p><strong>两个为粗体</strong></p>
<pre><code>*单个为斜体*
</code></pre>
<p><em>单个为斜体</em></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用html</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>markdown语法</p>
<pre><code>name | age
---- | ---
LearnShare    | 12
Mike |  32
</code></pre>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>LearnShare</td>
<td>12</td>
</tr>
<tr>
<td>Mike</td>
<td>32</td>
</tr>
</tbody></table>
<p>对齐：</p>
<pre><code>| Tables        |      Are      |  Cool |
|:--------------|:-------------:|------:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      |   centered    |   $12 |
| zebra stripes |   are neat    |    $1 |
</code></pre>
<table>
<thead>
<tr>
<th>Tables</th>
<th>Are</th>
<th>Cool</th>
</tr>
</thead>
<tbody><tr>
<td>col 3 is</td>
<td>right-aligned</td>
<td>$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td>centered</td>
<td>$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td>are neat</td>
<td>$1</td>
</tr>
</tbody></table>
<h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p>用两个 ``` 包裹一段代码，并指定一种语言</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



$(document).ready(function () &#123;
    alert(&#39;hello world&#39;);
&#125;);
</code></pre>
<p>支持常用的语言，下面试下go语言</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
    &quot;runtime&quot;
)

func sqrt(x float64) string &#123;
    if x &lt; 0 &#123;
        return sqrt(-x) + &quot;i&quot;
    &#125;
    return fmt.Sprint(math.Sqrt(x))
&#125; 
</code></pre>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>分割线的语法只需要三个 * 号，</p>
<pre><code>***
</code></pre>
<hr>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr vs. Elasticsearch谁是开源搜索引擎王者</title>
    <url>/jadepeng/2017/03/13/jqpeng-Solr%20vs.%20Elasticsearch%E8%B0%81%E6%98%AF%E5%BC%80%E6%BA%90%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%8E%8B%E8%80%85/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/solr-vs-elasticsearch.html">Solr vs. Elasticsearch谁是开源搜索引擎王者</a></p>
<p>当前是云计算和数据快速增长的时代,今天的应用程序正以PB级和ZB级的速度生产数据，但人们依然在不停的追求更高更快的性能需求。随着数据的堆积，如何快速有效的搜索这些数据，成为对后端服务的挑战。本文，我们将比较业界两个最流行的开源搜索引擎，Solr和ElasticSearch。两者都建立在Apache Lucene开源平台之上，它们的主要功能非常相似，但是在部署的易用性，可扩展性和其他功能方面也存在巨大差异。</p>
<h1 id="关于Apache-Solr"><a href="#关于Apache-Solr" class="headerlink" title="关于Apache Solr"></a>关于Apache Solr</h1><p>Apache Solr基于业界大名鼎鼎的java开源搜索引擎Lucene，Lucene更多的是一个软件包，还不能称之为搜索引擎，而solr则完成对lucene的封装，是一个真正意义上的搜索引擎框架。在过去的十年里，solr发展壮大，拥有广泛的用户群体。solr提供分布式索引、分片、副本集、负载均衡和自动故障转移和恢复功能。如果正确部署，良好管理，solr就能够成为一个高可靠、可扩展和高容错的搜索引擎。不少互联网巨头，如Netflix，eBay，Instagram和Amazon（CloudSearch）均使用Solr。</p>
<p>solr的主要特点：</p>
<ul>
<li>全文索引</li>
<li>高亮</li>
<li>分面搜索</li>
<li>实时索引</li>
<li>动态聚类</li>
<li>数据库集成</li>
<li>NoSQL特性和丰富的文档处理（例如Word和PDF文件）</li>
</ul>
<h1 id="关于Elasticsearch"><a href="#关于Elasticsearch" class="headerlink" title="关于Elasticsearch"></a>关于Elasticsearch</h1><p>与solr一样，Elasticsearch构建在Apache Lucene库之上，同是开源搜索引擎。Elasticsearch在Solr推出几年后才面世的，通过REST和schema-free（<strong>不需要预先定义 Schema，solr是需要预先定义的</strong>）的JSON文档提供分布式、多租户全文搜索引擎。并且官方提供Java，Groovy，PHP，Ruby，Perl，Python，.NET和Javascript客户端。</p>
<p>分布式搜索引擎包含可以华为为分片（shard）的索引，每一个分片可以有多个副本（replicas）。每个Elasticsearch节点可以有一个或多个分片，其引擎既同时作为协调器（coordinator ），将操作转发给正确的分片。</p>
<p>Elasticsearch可扩展为准实时搜索引擎。其中一个关键特性是多租户功能，可根据不同的用途分索引，可以同时操作多个索引。</p>
<p>Elasticsearch主要特性：</p>
<ul>
<li>分布式搜索</li>
<li>多租户</li>
<li>查询统计分析</li>
<li>分组和聚合</li>
</ul>
<p>热度对比</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170313220045088-284441280.png"></p>
<p>在开始比较前，我们可以查看两者在google中的<a href="https://trends.google.com/trends/explore?date=all&amp;q=apache%20solr,elasticsearch">搜索热度</a>，可以看出在2013年后，Elasticsearch与Solr相比具有很大的吸引力，但这并不意味着Apache Solr已经死了。虽然不少人不认可，但Solr仍然是最流行的搜索引擎之一，具有强大的开源社区支持。</p>
<p>安装与配置</p>
<p>相对来说，Elasticsearch更易于安装，与Solr相比非常轻量级。 Solr的分发软件包大小的当前版本（<a href="http://mirrors.hust.edu.cn/apache/lucene/solr/6.4.2/">6.4.2</a>）大约为150 MB，而Elasticsearch分发软件包大小的当前版本（<a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.2.2.tar.gz">5.2.2</a>）仅为32.2MB。</p>
<p>但是，如果Elasticsearch管理不好，这种易于部署和使用可能会成为一个问题。基于JSON的配置很容易，但如果你想为文件中的每个配置指定注释，那么它不适合你。Solr也提供了Rest API，可以通过集合API创建自定义分片集合，记录聚类算法和执行自定义分片。</p>
<p>总的来说，如果你的应用程序使用JSON，那么Elasticsearch是一个更好的选择。否则，使用Solr，因为它的schema.xml和solrconfig.xml有很好的文档。</p>
<p>索引和搜索</p>
<p>数据源</p>
<p>Solr接受来自不同来源的数据，包括XML文件，逗号分隔符（CSV）文件和从数据库中的表提取的数据以及常见的文件格式（如Microsoft Word和PDF）。</p>
<p>Elasticsearch还支持其他来源的数据，例如ActiveMQ，AWS SQS，DynamoDB（Amazon NoSQL），FileSystem，Git，JDBC，JMS，Kafka，LDAP，MongoDB，neo4j，RabbitMQ，Redis，Solr和Twitter。还有各种插件可用。</p>
<p>搜索</p>
<p><strong>Solr专注于文本搜索，而Elasticsearch则常用于查询、过滤和分组****分析统计</strong>，Elasticsearch背后的团队也努力让这些查询更为高效。因此当比较两者时，对那些不仅需要文本搜索，同时还需要复杂的时间序列搜索和聚合的应用程序而言，毫无疑问Elasticsearch是最佳选择。</p>
<p>索引</p>
<p>两者都支持使用停用词和同义词来匹配文档。</p>
<p>在Solr中，索引间进行join必须是单个分片和其他节点上的副本集进行关联来搜索文档间关系（例如SQL连接）。而Elasticsearch提供更高效的has_children和top_children查询来检索这样的相关文档。</p>
<p>可扩展性和分布式</p>
<p>搜索引擎需要处理数以百万级的文档，基于此搜索引擎应该是可复制的，模块化的和可扩展的，支持集群和分布式架构。</p>
<p>专为云而设计</p>
<p>Elasticsearch非常易于扩展，拥有足够多的需要大集群的使用案例。</p>
<p>Solr 基于Apache ZooKeeper也实现了类似ES的分布式部署模式。ZooKeeper是成熟和广泛使用的独立应用程序。</p>
<p>相对比，Elasticsearch有一个内置的类似ZooKeeper的名为Zen的组件，通过内部的协调机制来维护集群状态。</p>
<p>可以说Elasticsearch是转为云而设计，是分布式首选。</p>
<p>分片拆分和再平衡</p>
<p>shards是luence索引的分区单元，solr和elasticsearch均使用。你可以通过在集群中的不同计算机上运行shard来分发索引。随着SolrCloud的引入，Solr开始支持shard拆分，这允许您通过拆分现有shard来添加更多shard。相比之下，ElasticSearch仍然不支持这一点，事实上，实际上阻止了这种做法。ES通过向设置中添加更多计算机，可以使用自动碎片平衡功能。相比之下，Solr允许添加分片（使用隐式路由时）或分割（使用复合ID时），但不能删除分片。它允许您增加副本。在Elasticsearch中，默认情况下每个索引具有五个分片。它不允许您更改主分片的数量，但它允许您增加副本的数量。分片再平衡对于水平扩容非常有用。当添加新机器时，它将自动重新平衡不同机器中可用的分片。</p>
<p>社区</p>
<p>Solr有一个广泛的开源社区。任何人都可以贡献给Solr，新的Solr开发人员或代码提交者只能根据功能选择。 Elasticsearch在技术上是开源的，但不完全。所有贡献者都可以访问源代码，用户可以进行更改并提供。但最终的变化由Elastic（运行Elasticsearch和其他软件的公司）的员工确认和完成。因此，Elasticsearch更多地由单个公司驱动，而不是整个社区。</p>
<p>Solr贡献者和提交者跨越多个组织，而Elasticsearch提交者仅来自Elastic。还有人指出，Solr的强大社区有一个健康的项目管道和许多知名公司参与。这些成员还通过在整个开发和工程过程中做出贡献来投资该平台。</p>
<p>两者都有很好的用户群和丰富的开发人员社区，但ElasticSearch相较于Solr更新。 Solr已经存在了更长的时间，所以它的生态系统是发达的，拥有更大的用户群。</p>
<p>文档</p>
<p>Solr在这里得分很高。它是一个非常有据可查的产品，具有清晰的示例和API用例场景。 Elasticsearch的文档组织良好，但它缺乏好的示例和清晰的配置说明。</p>
<p>选Solr 还是 Elasticsearch?</p>
<p>通过上面的对比，很难确定谁是最终赢家。其实，无论选择Solr还是Elasticsearch，你首先需要了解您的用户场景和未来的需求。我们来总结一下：</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170313220046213-1161805781.png"></p>
<p>请记住：</p>
<ul>
<li>Elasticsearch由于其易用性而在较新的开发人员中更受欢迎</li>
<li>但是如果你已经在使用solr了，请继续使用它，因为迁移到Elasticsearch并不会带来具体的优势</li>
<li>如果您需要它来处理分析查询以及搜索文本，Elasticsearch是更好的选择，特别是收集日志，做分析处理（参考前面发的ELK 安装使用<a href="http://www.cnblogs.com/xiaoqi/p/elk-part1.html%EF%BC%89">http://www.cnblogs.com/xiaoqi/p/elk-part1.html）</a></li>
</ul>
<p>总之，两者都是功能丰富的搜索引擎，并且或多或少地给出相同的性能，只要它们被设计和实施得很好。</p>
<p>本文主要内容为翻译<a href="http://logz.io/solr-vs-elasticsearch/%EF%BC%8C%E6%84%9F%E8%B0%A2%E4%BD%9C%E8%80%85%EF%BC%8C%E6%84%9F%E8%B0%A2%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91%EF%BC%81">http://logz.io/solr-vs-elasticsearch/，感谢作者，感谢谷歌翻译！</a></p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>elasticsearch</tag>
        <tag>java</tag>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK日志套件安装与使用</title>
    <url>/jadepeng/2017/03/09/jqpeng-ELK%E6%97%A5%E5%BF%97%E5%A5%97%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/elk-part1.html">ELK日志套件安装与使用</a></p>
<p>1、ELK介绍</p>
<p>ELK不是一款软件，而是elasticsearch+Logstash+kibana三款开源软件组合而成的日志收集处理套件，堪称神器。其中Logstash负责日志收集，elasticsearch负责日志的搜索、统计，而kibana则是ES的展示神器，前端炫丽，点几下鼠标简单配置，就可以完成搜索、聚合功能，生成华丽的报表。</p>
<p>目前我们的日志方案：</p>
<ul>
<li>flume负责收集，服务写日志到文件，flume收集日志文件</li>
<li>flume汇总到数据通道kafka，供其他服务消费</li>
<li>日志搜索：从kafka读取日志写入到solr cloud提供搜索</li>
<li>日志统计：将kafka的日志写到hdfs，使用spark、hive来做统计</li>
<li>日志展示：开发的java-web，读取数据库生成统计报表</li>
</ul>
<p>当前日志方案问题分析：</p>
<ul>
<li>需要预先编程才能使用，开发工作量大</li>
<li>不够灵活，新需求需要改代码</li>
<li>离线统计，实时性不高</li>
<li>未提供基于搜索结果的统计功能</li>
<li>系统方案较为复杂，需要了解多项技术，学习维护成本高</li>
<li>……</li>
<li>新增需求都是泪，开发出来后变动很少</li>
</ul>
<p>通过调研ELK，发现真是解救目前问题的一个神器，大部分问题都可以迎刃而解。</p>
<p>2、ELK安装</p>
<p>默认需要先安装jdk1.8，自行安装即可</p>
<p>2.1、安装ES</p>
<p>2.1.1 下载ES</p>
<p>下载地址：<a href="https://www.elastic.co/downloads/elasticsearch">https://www.elastic.co/downloads/elasticsearch</a></p>
<p>最新版本是2.28发布的5.2.2版本</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132521281-1050921717.png"></p>
<p>windows选择ZIP，linux选择tar，ubuntu选择DEB</p>
<p>测试服务器是ubuntu，直接下载deb包，然后安装即可</p>
<p>wget <a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.2.2.deb">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.2.2.deb</a></p>
<p>sudo dpkg -i elasticsearch-5.2.2.deb</p>
<p>2.1.2 配置</p>
<p>如果使用deb包安装的，配置文件路径如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>默认路经</th>
<th>Setting</th>
</tr>
</thead>
<tbody><tr>
<td>home</td>
<td>Elasticsearch home directory or $ES_HOME</td>
<td>/usr/share/elasticsearch</td>
<td></td>
</tr>
<tr>
<td>bin</td>
<td>Binary scripts including elasticsearch to start a node and elasticsearch-plugin to install plugins</td>
<td>/usr/share/elasticsearch/bin</td>
<td></td>
</tr>
<tr>
<td>conf</td>
<td>Configuration files including elasticsearch.yml</td>
<td>/etc/elasticsearch</td>
<td>path.conf</td>
</tr>
<tr>
<td>conf</td>
<td>Environment variables including heap size, file descriptors.</td>
<td>/etc/default/elasticsearch</td>
<td></td>
</tr>
<tr>
<td>data</td>
<td>The location of the data files of each index / shard allocated on the node. Can hold multiple locations.</td>
<td>/var/lib/elasticsearch</td>
<td>path.data</td>
</tr>
<tr>
<td>logs</td>
<td>Log files location.</td>
<td>/var/log/elasticsearch</td>
<td>path.logs</td>
</tr>
<tr>
<td>plugins</td>
<td>Plugin files location. Each plugin will be contained in a subdirectory.</td>
<td>/usr/share/elasticsearch/plugins</td>
<td></td>
</tr>
<tr>
<td>repo</td>
<td>Shared file system repository locations. Can hold multiple locations. A file system repository can be placed in to any subdirectory of any directory specified here.</td>
<td>Not configured</td>
<td>path.repo</td>
</tr>
<tr>
<td>script</td>
<td>Location of script files.</td>
<td>/etc/elasticsearch/scripts</td>
<td>path.scripts</td>
</tr>
</tbody></table>
<p>修改/etc/elasticsearch/elasticsearch.yml即可</p>
<p>测试使用，主要设置网络：</p>
<pre><code>network.host: 192.168.86.108

http.port: 9200
</code></pre>
<p>ES的集群配置比较方便，设置cluster.name就可以：</p>
<pre><code>cluster.name: es-log
</code></pre>
<p>2.1.3 启动ES</p>
<p>由于我们使用的deb安装的，因此可以用服务方式启动：</p>
<p>service elasticsearch start</p>
<p>如果使用的压缩包，执行 bin/elasticsearch (or bin\elasticsearch.bat on Windows)即可</p>
<p>然后，打开 curl <a href="http://192.168.86.108:9200/">http://192.168.86.108:9200/</a> 测试（ip换成配置的ip）</p>
<p>2.2 安装 Logstash</p>
<p>现在收集处理框架非常多，像 facebook 出品的scribe ，apache 基金会的亲儿子flume，Logstash也是一个非常出名的日志框架，使用jruby开发，可以运行在jvm之上实现跨平台，具体的介绍可以到官网<a href="http://logstash.net查看./">http://logstash.net查看。</a></p>
<p>Logstash安装比较简单，下载压缩包、解压、配置，启动即可。</p>
<p>2.2.1 下载安装</p>
<pre><code>wget https://artifacts.elastic.co/downloads/logstash/logstash-5.2.2.tar.gz

tar zxvf logstash-5.2.2.tar.gz

ln -s logstash-5.2.2 logstash
</code></pre>
<p>2.2.2 配置</p>
<p>Logstash 和flume比较类似，有input和output的概念。不过logstash社区通常习惯用 shipper，broker 和 indexer 来描述数据流中不同进程各自的角色。</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132521734-923307871.jpg"></p>
<p>我们来看怎么配置logstash。</p>
<p>创建一个配置文件nginxlog2es.conf，读取nginx日志,输出到elasticsearch 。具体的配置格式参见官方文档。</p>
<pre><code>input &#123;
    file &#123;
        path =&gt; &quot;/var/log/nginx/access.log_json&quot;
        codec =&gt; &quot;json&quot;
    &#125;
&#125;
filter &#123;
    mutate &#123;
        split =&gt; [ &quot;upstreamtime&quot;, &quot;,&quot; ]
    &#125;
    mutate &#123;
        convert =&gt; [ &quot;upstreamtime&quot;, &quot;float&quot; ]
    &#125;
&#125;
output &#123;
  stdout &#123; codec =&gt; rubydebug &#125;
  elasticsearch &#123;
        hosts =&gt; [&quot;192.168.86.108:9200&quot;]
        index =&gt; &quot;logstash-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;
        document_type =&gt; &quot;%&#123;type&#125;&quot;
        flush_size =&gt; 20000
        idle_flush_time =&gt; 10
        sniffing =&gt; true
        template_overwrite =&gt; true
    &#125;
&#125;
</code></pre>
<p>这里简单说明下，input是file类型，/var/log/nginx/access.log_json每行是一个json数据，codec =&gt; “json”指定按json解析。</p>
<p>output 配置了两个，stdout 是控制台输出，elasticsearch 则是输出到前面配置的es服务器，index 索引名称为logstash-nginx-日期，这样每天为一个索引。</p>
<p>Nginx 直接生成json日志可以通过指定logformat，拼接为json：</p>
<p>配置logformat：</p>
<pre><code>log_format json &#39;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&#39;

&#39;&quot;host&quot;:&quot;$server_addr&quot;,&#39;

&#39;&quot;clientip&quot;:&quot;$remote_addr&quot;,&#39;

&#39;&quot;size&quot;:$body_bytes_sent,&#39;

&#39;&quot;responsetime&quot;:$request_time,&#39;

&#39;&quot;upstreamtime&quot;:&quot;$upstream_response_time&quot;,&#39;

&#39;&quot;upstreamhost&quot;:&quot;$upstream_addr&quot;,&#39;

&#39;&quot;http_host&quot;:&quot;$host&quot;,&#39;

&#39;&quot;url&quot;:&quot;$uri&quot;,&#39;

&#39;&quot;xff&quot;:&quot;$http_x_forwarded_for&quot;,&#39;

&#39;&quot;referer&quot;:&quot;$http_referer&quot;,&#39;

&#39;&quot;agent&quot;:&quot;$http_user_agent&quot;,&#39;

&#39;&quot;status&quot;:&quot;$status&quot;&#125;&#39;;
</code></pre>
<p>然后使用：</p>
<p>access_log /var/log/nginx/access.log_json json;</p>
<p>这样nginx的日志就变为：</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132522188-1514690908.png"></p>
<p>2.2.3 启动logstash</p>
<p>使用-f指定配置文件</p>
<p>bin/logstash -f nginxlog2es.conf</p>
<p>启动成功后就能看到收集到的日志：</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132522875-360437388.png"></p>
<p>2.3 kibana</p>
<p>2.3.1 安装</p>
<p>kibana安装也比较简单，下载，解压，配置即可</p>
<p>wget <a href="https://artifacts.elastic.co/downloads/kibana/kibana-5.2.2-linux-x86_64.tar.gz">https://artifacts.elastic.co/downloads/kibana/kibana-5.2.2-linux-x86_64.tar.gz</a></p>
<p>解压后建立软连接</p>
<p>ln -s kibana-5.2.2-linux-x86_64 kibana</p>
<p>cd kibana</p>
<p>修改配置文件</p>
<p>vim config/kibana.yml</p>
<p>修改</p>
<p>server.host: “192.168.86.108”</p>
<p>elasticsearch.url: “<a href="http://192.168.86.108:9200/">http://192.168.86.108:9200</a>“</p>
<p>然后启动：</p>
<p>bin/kibana</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132523531-706059809.png"></p>
<p>2.3.2 配置报表</p>
<p>启动后打开<a href="http://192.168.86.108:5601，就能看到日志了，在输入框里还可以输入关键词进行搜索，并且自带流量统计。">http://192.168.86.108:5601，就能看到日志了，在输入框里还可以输入关键词进行搜索，并且自带流量统计。</a></p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132524219-2011756617.png"></p>
<p>下面来看如何生成报表，比如搞个响应时间折线图，进入visualize，选择折线图</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132524828-237029731.png"></p>
<p>分别配置X和y轴，Y为平均响应时间，X为时间，最后保存即可。</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132525281-2069886424.png"></p>
<p>再来配置一个表格报表，通产各个url的访问量</p>
<p>Metrics 配置使用count作为聚合函数</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132526047-1007293145.png"></p>
<p>buckets增加rows，字段选url</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132526438-1898740306.png"></p>
<p>再增加一个状态码：</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132526953-1261870375.png"></p>
<p>这样就完成了一个漂亮的表格</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132527406-1971021303.png"></p>
<p>2.3.3 将报表添加到dashboard</p>
<p>在dashboard点add，将两个报表加入即可</p>
<p><img src="https://images2015.cnblogs.com/38465/201703/38465-20170309132527781-1974262713.png"></p>
<p>3、总结</p>
<p>简单的介绍就到这里为止了，更多的功能后面继续挖掘。</p>
<p>总结下，借助ELK可以快速搭建日志收集、日志搜索和统计分析平台，可以不写一行代码完成漂亮的统计报表，简直是开发和运维的福音，是不是心动了？如果是，快行动起来吧！</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>ELK</tag>
        <tag>elasticsearch</tag>
        <tag>Logstash</tag>
        <tag>kibana</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter notebook安装与使用</title>
    <url>/jadepeng/2017/02/13/jqpeng-Jupyter%20notebook%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/6393677.html">Jupyter notebook安装与使用</a></p>
<ul>
<li><p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。</p>
</li>
<li><p>安装</p>
<ul>
<li>安装python 3</li>
<li>pip安装<br>  pip3 install –upgrade pip<br>  pip3 install jupyter</li>
</ul>
</li>
<li><p>运行 </p>
<ul>
<li>jupyter notebook 启动，会默认打开<a href="http://localhost:8888/%EF%BC%8C%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E7%9B%AE%E5%BD%95">http://localhost:8888/，访问用户目录</a><br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144027332-1540737258.png">  如何自定义端口？<br>  <em>jupyter notebook –port 9999</em></li>
<li>Nootbook dashboard<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144027957-1866895760.png"></li>
</ul>
</li>
<li><p>笔记操作</p>
<ul>
<li>打开已有笔记<br>  例如，打开网友分享的CS231课程笔记，<a href="https://github.com/zlotus/cs231n">https://github.com/zlotus/cs231n</a><br>  下载zip包，解压到用户目录，刷新dashboard就能看到了<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144028613-1675066940.png"><br>  .ipynb就是保存的笔记，单击打开，enjoy it！<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144029379-1230425518.png"></li>
<li>运行实例管理<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144030004-1079356774.png"><br>  在running里可以查看正在运行的实例，可以shutdown</li>
<li>新建笔记<br>  点击new菜单里的Python 3就可以创建一个笔记了<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144030425-1666909010.png"></li>
<li>插入代码<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144032285-207623686.png"></li>
<li>运行代码<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144032785-1190858195.png">  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144033207-856058105.png"></li>
<li>增加文本段<br>  点击新增（+），选择类型为markdown<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144033863-833209297.png"></li>
<li>保存<br>  CTRL+S 或点击save按钮保存<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144034285-1049238861.png"></li>
<li>命名<br>  点击标题，会弹出rename框<br>  <img src="https://images2015.cnblogs.com/38465/201702/38465-20170213144034769-1640688543.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>java内嵌jetty服务器</title>
    <url>/jadepeng/2017/01/17/jqpeng-java%E5%86%85%E5%B5%8Cjetty%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/6293422.html">java内嵌jetty服务器</a></p>
<p>有的时候需要将一个简单的功能封装为服务，相比python使用flask、web.py的简洁，使用java-web显得太重量级，幸好，我们可以直接在java项目中使用jetty来搭建简易服务</p>
<p>1、pom.xml加入jetty依赖</p>
<pre><code>&lt;dependency&gt;
&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
&lt;artifactId&gt;jetty-server&lt;/artifactId&gt;
&lt;version&gt;9.4.0.v20161208&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
&lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;
&lt;version&gt;9.4.0.v20161208&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
&lt;artifactId&gt;jetty-continuation&lt;/artifactId&gt;
&lt;version&gt;9.4.0.v20161208&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
&lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
&lt;artifactId&gt;jetty-jsp&lt;/artifactId&gt;
&lt;version&gt;9.1.4.v20140401&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、增加Server</p>
<pre><code>Serverserver=newServer(12580);
</code></pre>
<p>3、设置ServletContextHandler</p>
<pre><code>ServletContextHandlercontext=newServletContextHandler(server,&quot;/&quot;);
server.setHandler(context);
</code></pre>
<p>4、Context增加Servlet <br>4.1 创建Servlet 继承HttpServlet，重载doGet，doPost即可</p>
<pre><code>public class XXXHandler extends HttpServlet &#123;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        JSONObject ret =  new JSONObject();
        try &#123;
            String ttsTxt = req.getParameter(&quot;text&quot;);

            String outFile = System.nanoTime() + &quot;.mp4&quot;;
            String url = xx.xxx(ttsTxt,...);
            ret.put(&quot;ret&quot;,&quot;0&quot;);
            ret.put(&quot;url&quot;,url);
        &#125;catch (Exception ex)&#123;
            ret.put(&quot;ret&quot;,&quot;-1&quot;);
            ret.put(&quot;error&quot;,ex.getMessage());
        &#125;
        if(req.getParameter(&quot;callback&quot;)!=null) &#123;
            resp.getWriter().write(req.getParameter(&quot;callback&quot;)+&quot;(&quot;+ret.toString()+&quot;)&quot;);
        &#125;else &#123;
            resp.getWriter().write(ret.toString());
        &#125;
    &#125;

&#125;
</code></pre>
<p>4.2 将Servlet 加入Context</p>
<pre><code>context.addServlet(xxxHandler.class,&quot;/xxx&quot;);
context.addServlet(Image2VideoHandler.class,&quot;/*&quot;);
</code></pre>
<p>5、启动server</p>
<pre><code>server.start();
server.join();
</code></pre>
<p>6、在浏览器访问<a href="http://localhost:12580/XXX">http://localhost:12580/XXX</a> 即可</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>jetty</tag>
      </tags>
  </entry>
  <entry>
    <title>x 开头编码的数据解码成中文</title>
    <url>/jadepeng/2016/01/05/jqpeng-x%20%E5%BC%80%E5%A4%B4%E7%BC%96%E7%A0%81%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A7%A3%E7%A0%81%E6%88%90%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<p>文章作者:jqpeng<br>原文链接: <a href="https://www.cnblogs.com/xiaoqi/p/5101795.html">x 开头编码的数据解码成中文</a></p>
<h2 id="Python-解码"><a href="#Python-解码" class="headerlink" title="Python 解码"></a>Python 解码</h2><p>在python里，直接decode(‘utf-8’)即可</p>
<pre><code>&gt;&gt;&gt; &quot;\xE5\x85\x84\xE5\xBC\x9F\xE9\x9A\xBE\xE5\xBD\x93 \xE6\x9D\x9C\xE6\xAD\x8C&quot;.decode(&#39;utf-8&#39;)
u&#39;\u5144\u5f1f\u96be\u5f53 \u675c\u6b4c&#39;
&gt;&gt;&gt; print &quot;\xE5\x85\x84\xE5\xBC\x9F\xE9\x9A\xBE\xE5\xBD\x93 \xE6\x9D\x9C\xE6\xAD\x8C&quot;.decode(&#39;utf-8&#39;)
兄弟难当 杜歌
&gt;&gt;&gt;
</code></pre>
<h2 id="Java-解码"><a href="#Java-解码" class="headerlink" title="Java 解码"></a>Java 解码</h2><pre><code> public static void main(String[] args) throws UnsupportedEncodingException &#123;
        String utf8String = &quot;\\xE5\\x85\\x84\\xE5\\xBC\\x9F\\xE9\\x9A\\xBE\\xE5\\xBD\\x93 \\xE6\\x9D\\x9C\\xE6\\xAD\\x8C&quot;;
        System.out.println(decodeUTF8Str(utf8String));
    &#125;

    public static String decodeUTF8Str(String xStr) throws UnsupportedEncodingException &#123;
        return URLDecoder.decode(xStr.replaceAll(&quot;\\\\x&quot;, &quot;%&quot;), &quot;utf-8&quot;);
    &#125;
</code></pre>
<p>以上代码输出:</p>
<pre><code>兄弟难当 杜歌

Process finished with exit code 0
</code></pre>
<h2 id="深入理解："><a href="#深入理解：" class="headerlink" title="深入理解："></a>深入理解：</h2><p>要了解原理，推荐阅读<a href="http://www.ruanyifeng.com/2007/10/ascii/_unicode/_and/_utf-8.html">http://www.ruanyifeng.com/2007/10/ascii\_unicode\_and\_utf-8.html</a></p>
<p>UTF-8是unicode编码的一种落地方案：</p>
<p>Unicode符号范围 | UTF-8编码方式<br>(十六进制) | （二进制）<br>——————–+———————————————<br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>\x对应的是UTF-8编码的数据，通过转化规则可以转换为Unicode编码，就能得到对应的汉字，转换规则很简单，先将\x去掉，转换为数字，然后进行对应的位移操作即可，需要注意的是先要判断utf-8的位数.</p>
<p>可以通过下面的scala代码深入了解：</p>
<pre><code> val pattern = &quot;&quot;&quot;(\d+\.\d+\.\d+\.\d+) \- (\S+) (\S+) \[([^\]]+)\] \&quot;(\w+) (\S+) \S+\&quot; (\S+) (\S+) \&quot;([^\&quot;]+)\&quot; \&quot;([^\&quot;]+)\&quot; \&quot;([^\&quot;]+)\&quot; \&quot;([^\&quot;]+)&quot;&quot;&quot;.r
  val decodeDataPattern = &quot;&quot;&quot;(\\x([0-9A-Z])&#123;2&#125;)+&quot;&quot;&quot;.r
  def decodeUtf8(utf8Str:String):String=&#123;
    var data =   decodeDataPattern.replaceAllIn(utf8Str, m=&gt;&#123;
        var item = decodeXdata(m.toString())
        item
     &#125;) 
     return data
   &#125;
     
   def decodeXdata(utf8Str:String):String=&#123;
     var arr = utf8Str.split(&quot;\\\\x&quot;)
     var result = new StringBuilder()
     var isMatchEnd = true
     var matchIndex = 0
     var currentWordLength = 0
     var current = 0
     var e0=0xe0;
     
     for(item &lt;-arr)&#123;
        var str = item.trim
        if(str.length()&gt;0)&#123;
           var currentCode =  Integer.parseInt(str, 16);
           if(isMatchEnd)&#123;
             isMatchEnd = false
             var and = currentCode &amp; e0;
             if(and == 0xe0)&#123;
                matchIndex = 1;
                currentWordLength = 3;
                current =  (currentCode &amp; 0x1f) &lt;&lt;12  // 3位编码的
             &#125;else if(and==96)&#123;
                matchIndex = 1;
                currentWordLength = 2;
                current =  (currentCode &amp; 0x1f) &lt;&lt;6 // 2位编码的
             &#125;else&#123;
               current = currentCode  // 1位编码的
             &#125;
          &#125;else&#123;
            matchIndex = matchIndex+1;
            if(matchIndex == 2)
            &#123;
              current+=(currentCode &amp; 0x3f) &lt;&lt;6
            &#125;else&#123;
               current+=(currentCode &amp; 0x3f) 
            &#125;
          &#125;
           if(matchIndex==currentWordLength)&#123;
               var hex = Integer.toHexString(current)
               hex = if(hex.length()&lt;4) &quot;\\u00&quot;+hex else &quot;\\u&quot;+hex  //补0
               result.append(new String(StringEscapeUtils.unescapeJava(hex).getBytes,&quot;utf-8&quot;)) 
               current = 0
               matchIndex=0
               isMatchEnd = true
           &#125;
        &#125;
     &#125;
     
     return result.toString()
   &#125;
</code></pre>
<p>Javascript解码：</p>
<h1 id="Javascript-x-反斜杠x-16进制-编解码"><a href="#Javascript-x-反斜杠x-16进制-编解码" class="headerlink" title="Javascript \x 反斜杠x 16进制 编解码"></a><a href="https://www.cnblogs.com/xiaoqi/p/js-x-encode-decode.html">Javascript \x 反斜杠x 16进制 编解码</a></h1>]]></content>
      <categories>
        <category>博客</category>
        <category>jqpeng</category>
      </categories>
      <tags>
        <tag>jqpeng</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
